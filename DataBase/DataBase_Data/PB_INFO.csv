PB_IDX,LI_IDX,EX_IDX,PB_NUM,PB_QUES,PB_DETAIL,PB_CHOI1,PB_CHOI2,PB_CHOI3,PB_CHOI4,PB_ANS,PB_SOLU,PB_CR,TOPIC_IDX
1,1,1,1,검토회의 전에 요구사항 명세서를 미리 배포하여 사전 검토한 후 짧은 검토 회의를 통해 오류를 조기에 검출하는데 목적을 두는 요구 사항 검토 방법은?,,빌드 검증,동료 검토,워크 스루,개발자 검토,3,"이 문제는 요구사항 검토 방법 중에서 검토회의 *전*에 미리 자료를 배포하고 사전 검토를 거친 후, 짧은 회의를 통해 오류를 조기에 발견하는 방법을 묻고 있습니다.  이는 효율적인 검토를 위해 사전 준비를 강조하는 방식입니다.  여러 요구사항 검토 방법 중에서,  회의 전에 자료를 미리 배포하여 참석자들이 충분히 검토할 시간을 갖도록 하고, 회의 자체는 짧게 진행하여 효율성을 높이는 방법은 바로 '워크스루'입니다.  워크스루는 참석자들이 미리 검토 자료를 숙지하고 회의에 참여하기 때문에, 회의 시간을 단축하고 효과적으로 오류를 발견할 수 있습니다.  다른 방법들은 이러한 사전 준비 과정과 짧은 회의 시간을 강조하지 않거나,  검토의 초점이 다릅니다. 따라서 요구사항 명세서를 미리 배포하여 사전 검토 후 짧은 검토 회의를 통해 오류를 조기에 발견하는 목적에 가장 부합하는 방법은 워크스루입니다.  마치 중요한 회의 전에 참석자들에게 자료를 미리 보내주고, 회의에서는 간략하게 질문과 답변을 통해 의견을 모으는 것과 같은 원리입니다.",82,2
2,1,1,2,코드 설계에서 일정한 일련번호를 부여하는 방식의 코드는?,,연상 코드,블록 코드,순차 코드,표의 숫자 코드,3,"코드 설계에서 일정한 일련번호를 부여하는 방식은 순차 코드입니다.  예를 들어, 상품에 1, 2, 3…과 같이 번호를 매기는 것을 생각해 보세요.  이처럼 순서대로 숫자를 부여하여 코드를 만드는 것이 순차 코드의 핵심입니다.  다른 코드 방식들은 각각 다른 특징을 가지고 있습니다. 연상 코드는 코드 자체가 의미를 가지도록 설계하는 방식이고, 블록 코드는 특정 범위의 숫자를 특정 의미를 가진 블록으로 묶어 사용하는 방식이며, 표의 숫자 코드는 표를 이용하여 코드를 부여하는 방식입니다.  하지만 문제에서 요구하는 '일정한 일련번호'라는 조건에 가장 잘 맞는 것은 순차적으로 숫자를 부여하는 순차 코드입니다.  따라서 정답은 순차 코드입니다.",85,6
3,1,1,3,객체지향 프로그램에서 데이터를 추상화하는 단위는?,,메소드,클래스,상속성,메시지,2,"객체지향 프로그래밍(OOP)에서 데이터를 추상화하는 기본 단위는 클래스입니다.  클래스는  데이터(멤버 변수, 속성)와 그 데이터를 처리하는 함수(메소드, 행위)를 하나의 묶음으로 정의한 것입니다.  예를 들어 ""강아지""라는 객체를 생각해봅시다. 강아지는 이름, 털 색깔, 나이와 같은 데이터(속성)를 가지고 있으며, 짖기, 뛰어놀기, 잠자기와 같은 행위(메소드)를 합니다.  객체지향 프로그래밍에서는 이러한 데이터와 행위를 하나의 클래스로 묶어서 관리합니다.  따라서 ""강아지"" 클래스는 강아지의 데이터와 행위를 모두 포함하는 추상화된 단위가 되는 것입니다.  메소드는 클래스 내부의 함수이고, 상속성은 클래스 간의 관계를 나타내는 개념이며, 메시지는 객체 간의 상호작용 방식을 나타내는 개념이므로 데이터 자체를 추상화하는 단위는 아닙니다.  클래스는 데이터와 기능을 하나로 묶어서 코드의 재사용성과 관리 효율성을 높여주는 핵심 개념입니다.  정보처리기사 공식 교재에서도 클래스가 객체지향 프로그래밍의 기본 구성 요소이자 데이터 추상화의 핵심 단위로 설명하고 있을 것입니다.",83,7
4,1,1,4,데이터 흐름도(DFD)의 구성요소에 포함되지 않는 것은?,,process,data flow,data store,data dictionary,4,"데이터 흐름도(DFD)는 시스템의 데이터 흐름을 그림으로 나타내는 기법입니다.  마치 물이 파이프를 통해 흐르는 것처럼, 데이터가 시스템 안에서 어떻게 이동하고 처리되는지를 시각적으로 보여주는 것이죠.  그 구성요소는 크게 세 가지로,  데이터가 처리되는 '프로세스(Process)', 데이터가 이동하는 '데이터 흐름(Data Flow)', 그리고 데이터가 저장되는 '데이터 저장소(Data Store)'가 있습니다.  반면 '데이터 사전(Data Dictionary)'은 DFD를 구성하는 요소가 아니고, DFD에 사용되는 데이터 요소들에 대한 상세한 설명(이름, 자료형, 의미 등)을 정의한 표와 같은 것입니다.  데이터 흐름도 자체를 구성하는 요소는 아니지만, DFD를 이해하고 해석하는 데 필수적인 보조적인 자료라고 할 수 있습니다.  따라서 DFD의 구성요소가 아닌 것은 데이터 사전입니다.  쉽게 말해, DFD는 시스템의 '데이터 흐름'을 보여주는 '지도'이고, 데이터 사전은 그 '지도'를 이해하는 데 필요한 '설명서'와 같은 역할을 합니다.",83,3
5,1,1,5,소프트웨어 설계시 구축된 플랫폼의 성능특성 분석에 사용되는 측정 항목이 아닌 것은?,,응답시간(Response Time),가용성(Availability),사용률(Utilization),서버 튜닝(Server Tuning),4,"소프트웨어 설계 시 구축된 플랫폼의 성능 특성을 분석하려면, 시스템의 반응 속도,  얼마나 자주 사용 가능한지, 그리고 시스템 자원의 사용 정도를 측정해야 합니다.  '응답시간'은 사용자가 요청을 보낸 후 시스템이 응답하는 데 걸리는 시간을 나타내고, '가용성'은 시스템이 얼마나 오랫동안 정상적으로 작동하는지를 나타내며, '사용률'은 CPU, 메모리, 네트워크 등 시스템 자원의 사용 정도를 나타냅니다.  반면 '서버 튜닝'은 시스템 성능을 향상시키기 위한 최적화 작업을 의미합니다.  즉, 서버 튜닝 자체는 성능 특성을 *측정*하는 항목이 아니라, 성능을 *개선*하기 위한 활동이기 때문에 플랫폼 성능 특성 분석에 사용되는 측정 항목이라고 할 수 없습니다.  플랫폼의 성능을 분석하기 위해서는 먼저 응답시간, 가용성, 사용률 등을 측정하고 그 결과를 바탕으로 서버 튜닝과 같은 최적화 작업을 진행하는 것이죠. 따라서 서버 튜닝은 성능 분석의 결과로 나오는 활동이지, 분석에 사용되는 측정 항목이 아닙니다.",90,1
6,1,1,6,UML 확장 모델에서 스테레오 타입 객체를 표현할 때 사용하는 기호로 맞는 것은?,,《 》,(( )),{{ }},[[ ]],1,"UML(Unified Modeling Language)은 소프트웨어 시스템을 시각적으로 표현하는 표준 모델링 언어입니다.  UML은 다양한 다이어그램을 제공하는데, 클래스 다이어그램에서 객체를 표현할 때는 일반적으로 사각형을 사용합니다.  하지만 UML은 확장 가능하도록 설계되어 있어, 기존 요소에 추가적인 정보를 덧붙일 수 있습니다. 이때 사용하는 것이 바로 '스테레오타입'입니다. 스테레오타입은 객체의 특별한 속성이나 역할을 나타내는 일종의 태그와 같은 역할을 합니다.  문제에서 묻고 있는 것은 UML 확장 모델에서 이러한 스테레오타입 객체를 표현하는 기호입니다.  스테레오타입은 일반적으로 꺾쇠괄호(`<< >>`)를 사용하여 표현합니다.  예를 들어, 특정 객체가 인터페이스 역할을 한다면 `<<interface>>` 와 같이 표현하는 것이죠.  따라서 꺾쇠괄호를 사용하는 것이 UML 확장 모델에서 스테레오타입 객체를 표현하는 표준적인 방법입니다.",82,2
7,1,1,7,GoF(Gang of Four)의 디자인 패턴에서 행위 패턴에 속하는 것은?,,Builder,Visitor,Prototype,Bridge,2,"GoF 디자인 패턴은 객체지향 설계에서 자주 발생하는 문제들을 해결하기 위한 디자인 패턴들을 모아놓은 책 ""Design Patterns: Elements of Reusable Object-Oriented Software""에서 제시된 23가지의 디자인 패턴들을 말합니다.  이 패턴들은 크게 생성 패턴, 구조 패턴, 행위 패턴으로 나뉘는데,  문제에서 묻고 있는 것은 행위 패턴에 속하는 패턴입니다.  행위 패턴은 객체나 클래스 사이의 알고리즘과 책임 분담을 다루는 패턴입니다.  제시된 선택지 중에서 Visitor 패턴은 객체 구조를 순회하며 각 객체에 대해 특정 작업을 수행하는 행위 패턴입니다.  즉, 객체 구조를 변경하지 않고도 새로운 동작을 추가할 수 있도록 해줍니다.  반면, 다른 선택지들은 객체 생성(Builder, Prototype)이나 클래스 구조(Bridge)에 초점을 맞춘 패턴들이기 때문에 행위 패턴에 속하지 않습니다. 따라서 Visitor 패턴이 정답입니다.  쉽게 말해, Visitor 패턴은 여러 종류의 객체들을 일관된 방식으로 처리해야 할 때 유용한 패턴입니다.  마치 다양한 종류의 과일을 한꺼번에 믹서에 갈아서 주스를 만드는 것과 같다고 생각하면 이해하기 쉬울 것입니다.  믹서(Visitor)가 다양한 과일(객체)들을 일관된 방식으로 처리(방문하여 작업 수행)하는 것이죠.",65,7
8,1,1,8,자료 사전에서 자료의 생략을 의미하는 기호는?,,{ },**,=,(　),4,"자료 사전에서 자료의 생략을 나타내는 기호는 괄호 안에 내용을 비워두는 것입니다.  데이터베이스나 프로그래밍에서 자료를 일시적으로 생략하거나, 아직 값이 정해지지 않은 경우, 혹은 값이 없음을 표현할 때 빈 괄호 `(　)`를 사용합니다.  다른 기호들은 각각 다른 의미를 가지고 있습니다.  `{}`는 집합을 나타내고, `**`는 보통 강조 표시를 위해 사용하며, `=`는 등호로 값의 대입이나 비교를 나타냅니다. 따라서 자료의 생략을 명확하게 표현하는 기호는 빈 괄호 `(　)`입니다.  이는 정보처리기사 공식 교재의 자료구조 및 데이터베이스 관련 내용에서 확인할 수 있습니다.  빈 괄호를 통해 데이터의 누락이나 미정의 상태를 명확하게 나타내어 데이터의 무결성을 유지하고 오류를 방지하는 데 중요한 역할을 합니다.",79,11
9,1,1,9,트랜잭션이 올바르게 처리되고 있는지 데이터를 감시하고 제어하는 미들웨어는?,,RPC,ORB,TP monitor,HUB,3,"이 문제는 트랜잭션 처리의 안정성과 신뢰성을 보장하는 미들웨어를 묻고 있습니다.  트랜잭션이란 여러 작업을 하나의 논리적 단위로 묶어서 처리하는 것을 말하는데, 예를 들어 은행 계좌 이체를 생각해 볼 수 있습니다.  돈을 보내는 계좌에서 돈을 빼고 받는 계좌에 돈을 넣는 두 작업은 반드시 함께 성공하거나 함께 실패해야 합니다.  만약 한 작업만 성공하고 다른 작업이 실패한다면 계좌 잔액이 맞지 않는 심각한 문제가 발생하겠죠.  이처럼 트랜잭션은 데이터의 일관성을 유지하는 데 매우 중요합니다.",83,10
10,1,1,10,UI 설계 원칙에서 누구나 쉽게 이해하고 사용할 수 있어야 한다는 것은?,,유효성,직관성,무결성,유연성,2,"UI 설계의 핵심 목표는 사용자가 시스템을 쉽고 편리하게 사용할 수 있도록 만드는 것입니다.  문제에서 제시된 내용은 사용자의 입장에서 시스템을 얼마나 쉽게 이해하고 사용할 수 있는지를 나타내는 중요한 요소를 묻고 있습니다.  ""누구나 쉽게 이해하고 사용할 수 있어야 한다""는 것은 바로 UI의 직관성을 의미합니다. 직관적인 UI는 사용자가 별도의 설명이나 학습 없이도 시스템의 기능을 쉽게 파악하고 사용할 수 있도록 디자인된 인터페이스를 말합니다.  예를 들어, 버튼의 위치나 아이콘의 의미가 명확하고, 사용자의 행동에 대한 시스템의 반응이 예측 가능하다면 이는 직관적인 UI라고 할 수 있습니다.  반면, 복잡한 메뉴 구조나 모호한 아이콘을 사용하는 UI는 직관적이지 않아 사용자에게 혼란을 야기할 수 있습니다. 따라서, 사용자 친화적인 UI를 설계하기 위해서는 직관성을 최우선적으로 고려해야 합니다.  다른 선택지들은 UI 설계에 중요한 요소이지만, 문제에서 제시된 ""누구나 쉽게 이해하고 사용할 수 있어야 한다""는 조건에 가장 잘 부합하는 것은 직관성입니다.",91,5
11,1,1,11,XP(eXtreme Programming)의 5가지 가치로 거리가 먼 것은?,,용기,의사소통,정형분석,피드백,3,"XP(eXtreme Programming)는 소프트웨어 개발 방법론 중 하나로, 빠르게 변화하는 요구사항에 유연하게 대처하고 고품질의 소프트웨어를 개발하기 위해 고안되었습니다.  XP의 핵심 가치는  개발 과정 전반에 걸쳐  '소통', '단순성', '피드백', '용기', '존중'을 강조합니다.  '소통'은 개발팀 내부 및 고객과의 원활한 의사소통을 통해 요구사항의 오류를 최소화하고,  '단순성'은 복잡한 기능을 최대한 간소화하여 개발 과정을 효율적으로 관리하며, '피드백'은 지속적인 테스트와 고객의 의견을 통해 개발 방향을 수정하고 개선하는 데 중요한 역할을 합니다. '용기'는 변화를 수용하고 과감한 결정을 내리는 것을 의미하며, '존중'은 팀원 상호간의 존중을 통해 협력적인 분위기를 조성합니다.  문제에서 제시된 선지 중 '정형분석'은 XP의 가치와는 거리가 멉니다. XP는  경직된 계획과 분석보다는 유연하고 반복적인 개발 과정을 중시하기 때문입니다.  정형분석은  체계적이고 엄격한 분석 방법론으로, XP의 유연성과 민첩성과는 상반되는 개념입니다. 따라서 XP의 5가지 가치 중 '정형분석'은 포함되지 않습니다.",81,2
12,1,1,12,UML 모델에서 사용하는 Structural Diagram 에 속하지 않은 것은?,,Class Diagram,Object Diagram,Component Diagram,Activity Diagram,4,"이 문제는 UML(Unified Modeling Language) 다이어그램 중에서 구조적인 측면을 보여주는 다이어그램들을 묻고 있습니다.  UML 다이어그램은 크게 구조 다이어그램(Structural Diagram)과 행위 다이어그램(Behavioral Diagram)으로 나뉘는데, 구조 다이어그램은 시스템의 정적인 구조, 즉 시스템을 구성하는 요소들과 그 요소들 간의 관계를 표현합니다.  클래스 다이어그램은 시스템의 클래스들과 그 관계를 나타내고, 객체 다이어그램은 특정 시점의 객체들과 그 관계를 보여주며, 컴포넌트 다이어그램은 시스템의 구성 요소들을 표현합니다. 반면에,  정답으로 제시된 다이어그램은 시스템의 동적인 행위, 즉 시스템의 동작 흐름을 나타내는 행위 다이어그램에 속합니다.  따라서 시스템의 구조를 나타내는 다이어그램이 아닌 것입니다.  쉽게 말해,  건물의 설계도(구조 다이어그램)와 건물에서 사람들이 어떻게 이동하는지 보여주는 안내도(행위 다이어그램)의 차이라고 생각하면 이해하기 쉽습니다.  건물의 설계도는 건물의 구조를 보여주지만, 안내도는 사람들의 행위를 보여주는 것처럼 말이죠.  문제에서 묻는 것은 건물의 설계도(구조)에 해당하는 다이어그램이므로,  시스템의 동작 흐름을 보여주는 다이어그램은 정답이 될 수 없습니다.",76,2
13,1,1,13,소프트웨어 개발 방법 중 요구사항 분석(requirements annalysis)과 거리가 먼 것은?,,비용과 일정에 대한 제약설정,타당성 조사,요구사항 정의 문서화,설계 명세서 작성,4,"소프트웨어 개발은 크게 요구사항 분석, 설계, 구현, 테스트 등의 단계를 거칩니다.  요구사항 분석 단계에서는 사용자의 요구를 정확하게 파악하고 문서화하는 작업이 이루어집니다.  비용과 일정 설정, 타당성 조사는 프로젝트의 전반적인 계획을 세우는 단계에서 중요한 요소이며, 요구사항 분석에 앞서 수행되거나 병행될 수 있습니다.  요구사항 정의 문서화는 사용자의 요구를 명확하게 기록하고 개발팀과 공유하기 위한 필수적인 과정입니다.  반면, 설계 명세서 작성은 요구사항 분석이 완료된 후,  실제 시스템을 구현하기 위한 구체적인 설계를 기술하는 단계입니다. 따라서 요구사항 분석과는 구분되는 별개의 단계라고 할 수 있습니다.  요구사항 분석은 사용자의 니즈를 파악하는 단계이고, 설계는 그 니즈를 어떻게 구현할지 구체적으로 계획하는 단계이기 때문에 서로 다른 단계입니다.  문제에서 묻고 있는 것은 요구사항 분석과 거리가 먼 것이므로,  요구사항 분석 이후에 수행되는 설계 단계에 해당하는 선지가 정답이 됩니다.",65,6
14,1,1,14,럼바우(Rumbaugh)의 객체지향 분석 절차를 가장 바르게 나열한 것은?,,객체 모형→동적 모형→기능 모형,객체 모형→기능 모형→동적 모형,기능 모형→동적 모형→객체 모형,기능 모형→객체 모형→동적 모형,1,"럼바우의 객체지향 분석 절차는 시스템을 객체, 동작, 기능의 세 가지 관점에서 모델링하는 방법입니다.  먼저 시스템을 구성하는 객체들을 식별하고 그들의 속성과 관계를 정의하는 **객체 모형**을 만듭니다.  이후 객체들 간의 상호작용과 시스템의 동적인 흐름을 나타내는 **동적 모형**을 생성합니다. 마지막으로 시스템이 제공하는 기능들을 정의하는 **기능 모형**을 만듭니다.  따라서 객체를 먼저 파악하고, 그 객체들의 상호작용을 분석한 후, 마지막으로 기능을 정의하는 순서가 가장 논리적입니다.  객체가 없으면 동작이나 기능을 정의할 수 없고, 객체의 상호작용을 이해해야만 시스템의 기능을 정확하게 파악할 수 있기 때문입니다.  따라서 객체 모형을 먼저 만들고, 그 다음 동적 모형, 마지막으로 기능 모형을 만드는 순서가 럼바우의 객체지향 분석 절차를 가장 잘 반영합니다.  이는 객체지향 분석의 기본 원칙에 부합하며, 시스템을 체계적이고 효율적으로 분석하는 데 도움을 줍니다.",86,7
15,1,1,15,공통 모듈에 대한 명세 기법 중 해당 기능에 대해 일관되게 이해하고 한 가지로 해석될 수 있도록 작성하는 원칙은?,,상호작용성,명확성,독립성,내용성,2,"공통 모듈이란 여러 프로그램에서 공통적으로 사용되는 기능을 모아놓은 부분입니다.  이러한 공통 모듈은 여러 곳에서 사용되기 때문에, 기능에 대한 이해가 서로 달라 모호하게 해석될 여지가 없도록 명확하게 작성되어야 합니다.  만약 명세가 모호하다면, 각 프로그램에서 공통 모듈을 다르게 해석하고 사용하게 되어 프로그램 간의 호환성 문제나 오류가 발생할 수 있습니다.  따라서 공통 모듈의 명세는 누가 보더라도 동일하게 이해하고 해석할 수 있도록, 즉 명확하게 작성하는 것이 매우 중요합니다.  다른 선택지들은 중요한 요소이지만, 공통 모듈의 명세에서 가장 기본적이고 필수적인 원칙은 명확성입니다.  상호작용성은 모듈 간의 관계를, 독립성은 모듈 자체의 독립적인 기능을, 내용성은 모듈이 포함하는 기능의 충실성을 의미하지만,  모듈을 여러 곳에서 일관되게 사용하기 위해서는 무엇보다 명확한 명세가 우선되어야 합니다.",86,6
16,1,1,16,객체지향 기법에서 클래스들 사이의 ‘부분-전체(part-whole)' 관계 또는 ’부분(is-a-part-of)'의 관계로 설명되는 연관성을 나타내는 용어는?,,일반화,추상화,캡슐화,집단화,4,"객체지향 기법에서 클래스는 객체의 설계도와 같습니다.  여러 개의 클래스가 모여서 하나의 시스템을 구성하는데, 이때 클래스들 간의 관계를 나타내는 여러 용어가 있습니다.  문제에서 묻는 것은 '부분-전체' 관계, 즉 하나의 큰 객체가 여러 작은 객체들로 구성되는 관계를 표현하는 용어입니다.  예를 들어, 자동차라는 큰 객체는 엔진, 바퀴, 시트 등 여러 작은 부품 객체들로 이루어져 있습니다. 이러한 '부분-전체' 관계를 객체지향 기법에서는 '집단화'라고 표현합니다.  '집단화'는 전체를 구성하는 부분들을 하나로 묶어서 관리하는 개념입니다.  다른 선택지들은 클래스 간의 다른 종류의 관계를 나타내는 용어들입니다. '일반화'는 상속 관계를, '추상화'는 복잡한 내용을 단순화하여 표현하는 것을, '캡슐화'는 데이터와 함수를 하나로 묶어서 외부로부터 보호하는 것을 의미합니다. 따라서 자동차와 그 부품들의 관계를 가장 잘 설명하는 용어는 '집단화'입니다.",63,7
17,1,1,17,CASE가 갖고 있는 주요 기능이 아닌 것은?,,그래픽 지원,소프트웨어 생명주기 전 단계의 연결,언어번역,다양한 소프트웨어 개발 모형 지원,3,"CASE(Computer-Aided Software Engineering)는 소프트웨어 개발 과정을 지원하는 도구들의 총칭입니다.  소프트웨어 개발의 여러 단계, 예를 들어 요구사항 분석, 설계, 구현, 테스트 등을 자동화하거나 지원하는 기능을 제공하여 개발 생산성을 높이고, 개발 과정의 오류를 줄이는 데 도움을 줍니다.  그래픽 지원을 통해 시각적으로 소프트웨어 구조를 표현하고, 소프트웨어 생명주기 전 단계를 연결하여 개발 과정의 흐름을 원활하게 만들며, 다양한 소프트웨어 개발 방법론(예: 폭포수 모델, 애자일)을 지원하는 기능을 제공합니다. 하지만 CASE는 소프트웨어 개발 과정을 지원하는 도구이지, 언어 자체를 번역하는 기능은 제공하지 않습니다.  언어 번역은 별도의 번역 도구나 시스템을 필요로 합니다. 따라서 CASE의 주요 기능이 아닌 것은 언어 번역입니다.",84,47
18,1,1,18,DBMS 분석시 고려사항으로 거리가 먼 것은?,,가용성,성능,네트워크 구성도,상호 호환성,3,"DBMS(데이터베이스 관리 시스템)를 분석할 때는 여러 가지 중요한 요소들을 고려해야 합니다.  데이터베이스의 안정적인 운영을 위해 얼마나 자주 문제없이 사용할 수 있는지 나타내는 '가용성', 데이터베이스의 처리 속도와 효율성을 의미하는 '성능', 그리고 서로 다른 시스템 간에 데이터를 주고받을 수 있는 '상호 호환성'은 모두 DBMS 분석에 필수적인 고려사항입니다. 하지만 '네트워크 구성도'는 DBMS 자체의 특성이나 성능, 안정성을 직접적으로 평가하는 요소는 아닙니다. 네트워크 구성은 DBMS가 동작하는 환경에 영향을 미칠 수 있지만, DBMS 분석의 핵심적인 고려사항이라고 보기는 어렵습니다.  DBMS 분석은 데이터베이스 시스템 자체의 기능과 성능에 초점을 맞추어야 하며, 네트워크 구성은 DBMS를 사용하는 응용 프로그램이나 시스템의 설계 단계에서 고려해야 할 사항입니다. 따라서 DBMS 분석 시 고려사항으로 적절하지 않은 것은 네트워크 구성도입니다.  쉽게 말해,  DBMS가 얼마나 잘 작동하는지, 빠른지, 다른 시스템과 잘 연결되는지를 보는 것이 DBMS 분석인데, 네트워크가 어떻게 생겼는지는 DBMS 자체의 성능과는 직접적인 관련이 없기 때문입니다.",83,1
19,1,1,19,HIPO(Hierarchy Input Process Output)에 대한 설명으로 거리가 먼 것은?,,상향식 소프트웨어 개발을 위한 문서화 도구이다.,"HIPO 차트 종류에는 가시적 도표, 총체적 도표, 세부적 도표가 있다.",기능과 자료의 의존 관계를 동시에 표현할 수 있다.,보기 쉽고 이해하기 쉽다.,1,"HIPO는 계층적 입력-처리-출력(Hierarchy Input Process Output)의 약자로, 시스템의 기능을 계층적으로 표현하는 문서화 도구입니다.  상향식 개발 방식을 지원하며, 시스템의 전체적인 흐름부터 세부적인 기능까지 단계적으로 표현하여 이해도를 높입니다.  HIPO 차트는 시스템의 기능을 시각적으로 보여주는 가시적 도표, 전체 시스템의 기능을 개괄적으로 보여주는 총체적 도표, 그리고 각 기능의 세부적인 처리 과정을 보여주는 세부적 도표로 구성됩니다.  이를 통해 기능과 자료의 의존 관계를 명확하게 파악할 수 있도록 도와주며, 결과적으로 시스템을 쉽게 이해하고 관리할 수 있도록 합니다.  문제에서 틀린 선지는 HIPO의 특징과 부합하지 않는 내용입니다.  HIPO는 시스템의 기능을 명확하고 체계적으로 표현하여 이해도를 높이는 데 초점을 맞추기 때문에, 보기 쉽고 이해하기 쉽다는 것은 HIPO의 장점이지 거리가 먼 설명이 아닙니다.  따라서 문제에서 제시된 네 가지 설명 중 하나는 HIPO의 특징과 일치하지 않습니다.",78,2
20,1,1,20,"객체지향 분석 방법론 중 E-R 다이어그램을 사용하여 객체의 행위를 모델링하며, 객체식별, 구조 식별, 주체 정의, 속성 및 관계 정의, 서비스 정의 등의 과정으로 구성되는 것은?",,Coad와 Yourdon 방법,Booch 방법,Jacobson 방법,Wirfs-Brocks 방법,1,"이 문제는 객체지향 분석 방법론 중 E-R 다이어그램을 사용하는 방법을 묻고 있습니다.  객체지향 분석은 현실 세계의 문제를 객체라는 개념으로 모델링하여 소프트웨어를 개발하는 방법론입니다.  여러 객체지향 분석 방법론 중에서 E-R 다이어그램을 사용하여 객체의 행위를 모델링하는 방법은 특정 방법론의 특징입니다. E-R 다이어그램은 데이터베이스 설계에 주로 사용되는 도구로,  엔티티(Entity, 객체)와 관계(Relationship)를 표현하여 데이터 구조를 시각적으로 보여줍니다. 문제에서 언급된 '객체 식별, 구조 식별, 주체 정의, 속성 및 관계 정의, 서비스 정의' 등의 과정은  E-R 다이어그램을 이용하여 객체와 객체 간의 관계를 정의하고, 객체가 수행하는 기능(서비스)을 명세하는 과정을 나타냅니다.  정답으로 제시된 방법론은 이러한 과정을 모두 포함하고 있으며, E-R 다이어그램을 활용하여 객체의 행위를 모델링하는 특징을 가지고 있습니다. 다른 방법론들은 객체의 행위 모델링에 다른 접근 방식을 사용할 수 있습니다. 따라서 E-R 다이어그램을 사용하여 객체의 행위를 모델링하는 특징을 가진 방법론을 선택하는 것이 정답입니다.",79,7
21,1,1,21,정렬된 N개의 데이터를 처리하는데 O(Nlog2N)의 시간이 소요되는 정렬 알고리즘은?,,선택정렬,삽입정렬,버블정렬,합병정렬,4,"정렬된 N개의 데이터를 처리하는 데 걸리는 시간을 나타내는 표기법 O(Nlog₂N)은 알고리즘의 시간 복잡도를 나타냅니다.  시간 복잡도는 데이터의 양(N)이 증가함에 따라 알고리즘의 실행 시간이 어떻게 증가하는지를 나타내는 척도입니다.  O(Nlog₂N)은 데이터의 양이 증가할수록 실행 시간이 비교적 효율적으로 증가함을 의미합니다.  선택 정렬, 삽입 정렬, 버블 정렬은 모두 단순한 정렬 알고리즘으로, 최악의 경우 O(N²)의 시간 복잡도를 가지므로 데이터의 양이 많아지면 실행 시간이 매우 길어집니다. 반면에 합병 정렬은 데이터를 반으로 계속 나누어 정렬한 후 합치는 분할 정복(Divide and Conquer) 방식을 사용하는데, 이 방식은 O(Nlog₂N)의 시간 복잡도를 가지므로 데이터 양이 많아져도 상대적으로 효율적인 정렬이 가능합니다. 따라서 정렬된 N개의 데이터를 처리하는 데 O(Nlog₂N)의 시간이 소요되는 정렬 알고리즘은 합병 정렬입니다.  쉽게 말해,  데이터가 많아질수록 합병 정렬은 다른 정렬 방법들보다 훨씬 빠르게 정렬을 완료할 수 있다는 뜻입니다.",69,11
22,1,1,22,White Box Testing 에 대한 설명으로 옳지 않은 것은?,,"Base Path Testing, Boundary Value Analysis가 대표적인 기법이다.",Source Code 의 모든 문장을 한번 이상 수행함으로서 진행된다.,모듈 안의 작동을 직접 관찰 할 수 있다.,"산출물의 각 기능별로 적절한 프로그램의 제어구조에 따라 선택, 반복 등의 부분들을 수행함으로써 논리적 경로를 점검한다.",1,"화이트박스 테스트는 소스 코드를 직접 들여다보면서 테스트하는 방법입니다.  마치 상자의 내부 구조를 모두 알고 있는 것처럼 테스트를 진행하기 때문에 '화이트박스'라는 이름이 붙었습니다.  따라서 소스 코드의 모든 문장을 적어도 한 번 이상 실행시켜보는 것이 중요하고, 프로그램의 내부 동작을 직접 확인할 수 있습니다.  Base Path Testing이나 Boundary Value Analysis는 화이트박스 테스트의 대표적인 기법으로, 프로그램의 모든 논리적 경로를 점검하거나 경계값을 중심으로 테스트하는 방법입니다.  하지만,  프로그램의 산출물(결과)의 각 기능별로 테스트하는 것은 블랙박스 테스트의 특징입니다. 화이트박스 테스트는 내부 구조를 중심으로 테스트하기 때문에 산출물의 기능에만 초점을 맞추지 않습니다.  결론적으로,  산출물의 기능에 따라 테스트하는 방식은 화이트박스 테스트의 특징이 아니므로,  옳지 않은 설명이 됩니다.",67,19
23,1,1,23,소프트웨어 품질 측정을 위해 개발자 관점에서 고려해야 할 항목으로 거리가 먼 것은?,,정확성,무결성,사용성,간결성,4,"소프트웨어 품질을 측정할 때 개발자는 여러 가지 요소를 고려합니다.  정확성은 소프트웨어가 올바른 결과를 내는지, 무결성은 소프트웨어가 의도하지 않은 변경이나 손상으로부터 안전한지를, 사용성은 사용자가 얼마나 쉽고 편리하게 소프트웨어를 사용할 수 있는지를 나타냅니다.  하지만 간결성은 개발자 관점에서 코드의 길이가 짧고 효율적인지를 의미하는데, 소프트웨어 품질 측정의 주요 목표는 사용자에게 좋은 경험을 제공하는 것이지, 개발자의 코딩 스타일을 평가하는 것이 아닙니다.  따라서 사용자 관점에서의 품질 요소인 정확성, 무결성, 사용성과 달리 간결성은 개발자의 편의성에 초점을 맞춘 항목이므로 소프트웨어 품질 측정에서 개발자 관점으로 고려해야 할 항목으로는 적절하지 않습니다.  결론적으로 소프트웨어의 품질은 사용자의 만족도를 최우선으로 고려해야 하며, 간결성은 개발 효율성과 관련된 요소이므로  소프트웨어 품질 측정 항목으로는 적합하지 않습니다.",63,17
24,1,1,24,인터페이스 구현 검증도구 중 아래에서 설명하는 것은?,https://www.cbtbank.kr/images/iz/iz20200606/iz20200606m24.gif,xUnit,STAF,FitNesse,RubyNode,2,"문제에서 설명하는 검증 도구는 서비스 호출이나 컴포넌트 재사용 등 다양한 환경을 지원하는 테스트 프레임워크이며, 각 테스트 대상 분산 환경에 데몬을 사용하여 테스트를 자동화하는 특징을 가지고 있습니다.  이러한 특징들을 종합적으로 고려했을 때, STAF(Software Testing Automation Framework)가 가장 적합한 설명입니다. STAF는 분산 환경에서의 자동화된 테스트를 지원하는 프레임워크로, 다양한 플랫폼과 환경에서 테스트를 수행할 수 있도록 설계되었으며, 데몬을 이용하여 테스트 대상 시스템과 통신하고 테스트를 관리합니다.  다른 선택지들은 STAF와 같은 분산 환경 지원 및 자동화 테스트 기능을 제공하지 않거나, 그 기능이 STAF만큼 포괄적이지 않습니다. 따라서 문제에서 제시된 설명에 가장 부합하는 것은 STAF입니다.",64,24
25,1,1,25,EAI(Enterprise Application Integration)의 구축 유형으로 옳지 않은 것은?,,Point-to-Point,Hub&Spoke,Message Bus,Tree,4,"EAI(Enterprise Application Integration)는 여러 기업 애플리케이션들을 서로 연결하고 통합하여 데이터와 프로세스를 공유할 수 있도록 하는 기술입니다.  문제에서는 EAI 구축 유형 중 옳지 않은 것을 고르라고 했습니다.  Point-to-Point는 각 애플리케이션을 개별적으로 연결하는 방식이고, Hub&Spoke는 중앙 허브를 통해 여러 애플리케이션을 연결하는 방식이며, Message Bus는 메시지를 중개하는 방식으로 애플리케이션 간 통신을 처리합니다. 이 세 가지 방식은 모두 실제로 사용되는 EAI 구축 유형입니다.  반면에 Tree 구조는 계층적인 구조를 의미하는데, EAI 시스템에서 모든 애플리케이션이 계층적으로 연결되는 구조는 일반적이지 않고 효율적이지도 않습니다.  EAI는 여러 애플리케이션 간의 유연하고 효율적인 통합을 목표로 하기 때문에, Tree 구조처럼 엄격한 계층 구조는 적합하지 않습니다. 따라서 Tree 구조는 EAI 구축 유형으로 적절하지 않은 선택지입니다.  다양한 애플리케이션의 상호작용을 고려할 때, Point-to-Point 방식은 복잡성이 증가하고 유지보수가 어려워지며, Hub&Spoke 방식은 중앙 허브에 대한 의존도가 높아지고 단일 지점 장애의 위험이 있습니다. Message Bus 방식은 이러한 문제점을 어느 정도 해결할 수 있지만, Tree 구조는 애플리케이션 간의 관계를 효율적으로 표현하지 못합니다.  결론적으로,  제시된 선택지 중 Tree 구조는 EAI 구축 유형으로 적합하지 않습니다.",73,10
26,1,1,26,다음 트리를 전위 순회(preorder traversal)한 결과는?,https://www.cbtbank.kr/images/iz/iz20200606/iz20200606m26.gif,+*AB/*CDE,AB/C*D*E+,A/B*C*D+E,+**/ABCDE,4,"이 문제는 트리 자료구조를 전위 순회(preorder traversal)하는 방법을 묻고 있습니다. 전위 순회란, 트리를 순회하는 방법 중 하나로,  먼저 루트 노드를 방문하고, 그 다음 왼쪽 서브트리를 순회한 후, 마지막으로 오른쪽 서브트리를 순회하는 방식입니다.  주어진 트리를 살펴보면 루트 노드는 '+' 입니다. 따라서 '+'를 먼저 방문합니다. 그 다음 왼쪽 서브트리('*')를 순회해야 하는데, 이 서브트리도 전위 순회 방식을 따라야 합니다.  '*' 노드를 방문하고, 그 왼쪽 서브트리('*')를 순회합니다.  이 서브트리의 루트는 '*'이고, 왼쪽 자식은 'A', 오른쪽 자식은 'B'이므로 'A'를 먼저 방문하고 'B'를 방문합니다. 그 다음 '*' 노드의 오른쪽 서브트리('C')를 방문합니다. 이제 '+' 노드의 오른쪽 서브트리('E')를 방문합니다. 따라서 전체 순회 결과는 '+ * * A B C E' 가 됩니다.  이를 표현한 것이 정답입니다.  쉽게 말해, 트리를 위에서부터 아래로, 왼쪽에서 오른쪽으로 차례대로 방문하는 방식이라고 생각하면 됩니다.",79,11
27,1,1,27,인터페이스 보안을 위해 네트워크 영역에 적용될 수 있는 솔루션과 거리가 먼 것은?,,IPSec,SMTP,SSL,S-HTTP,2,"이 문제는 인터페이스 보안을 위해 네트워크 영역에 적용될 수 있는 솔루션을 묻고 있습니다.  네트워크를 통해 데이터를 주고받을 때 안전하게 보호하는 기술들이 여러 가지 있는데,  정답으로 제시된 옵션은 네트워크 통신의 보안을 담당하지 않는,  다른 목적으로 사용되는 프로토콜입니다.  나머지 옵션들은 모두 네트워크 상에서 데이터를 안전하게 전송하기 위한 보안 프로토콜입니다.  IPSec은 IP 패킷을 암호화하여 네트워크를 통해 전송하는 프로토콜이고, SSL(Secure Sockets Layer)과 S-HTTP(Secure Hypertext Transfer Protocol)는 웹 통신에서 데이터를 안전하게 전송하기 위해 사용되는 프로토콜입니다.  반면에 문제에서 정답으로 제시된 것은 이메일 전송 프로토콜로,  네트워크 보안을 위한 목적으로 설계되지 않았습니다. 따라서 네트워크 영역의 인터페이스 보안과는 거리가 먼 솔루션입니다.  쉽게 말해,  집의 현관문(네트워크)을 튼튼하게 지키는 방법(인터페이스 보안)을 묻는 질문에,  우편함(이메일 전송 프로토콜)을 언급하는 것은 적절하지 않은 것과 같습니다.",77,56
28,1,1,28,평가 점수에 따른 성적부여는 다음 표와 같다. 이를 구현한 소프트웨어를 경계값 분석 기법으로 테스트 하고자 할 때 다음 중 테스트 케이스의 입력 값으로 옳지 않은 것은?,https://www.cbtbank.kr/images/iz/iz20200606/iz20200606m28.gif,59,80,90,101,3,"이 문제는 소프트웨어 테스트 기법 중 하나인 경계값 분석을 이해하고 있는지 묻는 문제입니다. 경계값 분석은 입력값의 경계선에 해당하는 값들을 테스트 케이스로 사용하여 프로그램의 오류를 찾는 기법입니다.  문제에서 주어진 성적 부여 기준표를 보면, 각 성적 등급의 경계값은 59, 60, 79, 80, 100입니다.  경계값 분석에서는 이러한 경계값들을 테스트 케이스로 사용하여 프로그램이 경계값에서도 정상적으로 동작하는지 확인해야 합니다.  따라서 59, 60, 79, 80, 100은 모두 테스트 케이스로 적합한 입력값입니다.  하지만 주어진 선택지 중 하나는 이러한 경계값 범위를 벗어나 있습니다.  이 값은 프로그램이 예상치 못한 동작을 할 가능성이 높으므로,  테스트 케이스로 적합하지 않습니다.  결론적으로, 경계값 분석의 목적은 프로그램의 경계값에서의 동작을 검증하는 것이므로, 경계값 범위를 벗어난 값은 테스트 케이스로 적절하지 않습니다.",77,19
29,1,1,29,반정규화(Denormalization) 유형중 중복 테이블을 추가하는 방법에 해당하지 않는 것은?,,빌드 테이블의 추가,집계 테이블의 추가,진행 테이블의 추가,특정 부분만을 포함하는 테이블의 추가,1,"반정규화는 데이터베이스의 성능을 향상시키기 위해 정규화된 데이터베이스를 의도적으로 비정규화하는 기법입니다.  중복 데이터를 허용하여 데이터베이스 조회 속도를 높이는 것이 목표죠.  문제에서 묻고 있는 것은 중복 테이블을 추가하는 방법 중 해당하지 않는 것인데,  '빌드 테이블', '집계 테이블', '진행 테이블'은 모두 특정 목적을 위해 중복 데이터를 포함하는 테이블을 추가하는 반정규화 기법의 예시입니다.  하지만 '특정 부분만을 포함하는 테이블의 추가'는 반정규화의 목적과는 다소 다릅니다.  반정규화는 데이터 중복을 통해 성능을 개선하는 것이 주 목적이지만,  '특정 부분만 포함하는 테이블'은 오히려 데이터의 중복을 줄이거나 특정 부분에 대한 접근성을 높이기 위한 목적으로 추가될 수 있습니다.  따라서 데이터 중복을 통한 성능 향상이라는 반정규화의 핵심 목표와는 부합하지 않는 선택지가 정답이 되는 것입니다.  쉽게 말해, 반정규화는 데이터를 여러 곳에 복사해서 조회 속도를 높이는 건데, 특정 부분만 뽑아서 새로운 테이블을 만드는 것은 데이터 중복을 위한 것이 아니기 때문입니다.",47,33
30,1,1,30,ISO/IEC 9126의 소프트웨어 품질 특성 중 기능성(Functionlity)의 하위 특성으로 옳지 않은 것은?,,학습성,적합성,정확성,보안성,1,"ISO/IEC 9126는 소프트웨어의 품질을 평가하기 위한 국제 표준입니다.  이 표준에서는 소프트웨어 품질을 기능성, 신뢰성, 사용성, 효율성, 유지보수성, 이식성의 6가지 주요 특성으로 분류하고, 각 특성은 다시 여러 하위 특성으로 세분화합니다.  문제에서 묻고 있는 기능성은 소프트웨어가 얼마나 정확하고, 완벽하게 요구된 기능을 수행하는지를 나타내는 특성입니다.  정확성, 적합성 등은 소프트웨어가 의도된 대로 정확하게 작동하고, 사용자의 요구사항을 충족하는지에 대한 측면을 평가하는 하위 특성들입니다.  반면에,  학습성은 소프트웨어를 처음 접하는 사용자가 얼마나 쉽게 사용법을 익힐 수 있는지를 나타내는 사용성의 하위 특성입니다.  보안성은 소프트웨어가 무단 접근이나 변경으로부터 안전하게 데이터를 보호하는 능력을 나타내는 신뢰성의 하위 특성입니다. 따라서, 기능성의 하위 특성으로 보기 어울리지 않는 것은 학습성과 보안성 중 하나입니다.  학습성은 사용성과 관련된 개념이고, 보안성은 신뢰성과 관련된 개념이기 때문에 기능성과는 직접적인 관련이 없습니다.  따라서 문제의 정답은 학습성입니다.",61,17
31,1,1,31,다음 트리의 차수(degree)와 단말 노드(terminal node)의 수는?,https://www.cbtbank.kr/images/iz/iz20200606/iz20200606m31.gif,"차수: 4, 단말 노드: 4","차수: 2, 단말 노드: 4","차수: 4, 단말 노드: 8","차수: 2, 단말 노드: 8",2,"문제에서 제시된 트리는 계층적인 구조를 가지고 있습니다.  트리에서 각 노드는 가지(branch)를 통해 다른 노드와 연결되는데,  '차수(degree)'는 각 노드가 가지고 있는 자식 노드의 개수를 의미합니다.  루트 노드 A는 두 개의 자식 노드(B, C)를 가지고 있고, 노드 B는 하나의 자식 노드(D)를, 노드 C는 두 개의 자식 노드(E, F)를 가지고 있습니다. 노드 E는 두 개의 자식 노드(G, H)를 가지고 있습니다.  트리의 차수는 각 노드의 차수 중 가장 큰 값으로 정의되는 것이 아니라,  **각 노드의 자식 노드의 수 중 최댓값**으로 정의됩니다. 따라서 이 트리에서 가장 많은 자식 노드를 가진 노드는 A, C, E 노드로 2개의 자식 노드를 가지고 있으므로 트리의 차수는 2가 됩니다.",72,11
32,1,1,32,디지털 저작권 관리(DRM)의 기술 요소가 아닌 것은?,,크랙 방지 기술,정책 관리 기술,암호화 기술,방화벽 기술,4,"디지털 저작권 관리(DRM)은 디지털 콘텐츠의 저작권을 보호하기 위한 기술입니다.  쉽게 말해,  내가 만든 음악이나 영화를 함부로 복사하거나 불법으로 유통하는 것을 막기 위한 기술이죠.  문제에서 제시된 선택지들을 살펴보면, 콘텐츠의 불법 복제를 막는 '크랙 방지 기술'이나, 콘텐츠 접근 권한을 제어하는 '암호화 기술', 그리고 DRM 시스템 자체의 운영 및 권한 관리를 위한 '정책 관리 기술'은 모두 DRM의 핵심적인 기술 요소입니다.  반면 '방화벽 기술'은 외부의 불법적인 접근을 차단하는 네트워크 보안 기술로,  DRM 시스템의 보안을 강화하는 데 도움을 줄 수는 있지만,  DRM의 핵심 기능 자체는 아닙니다.  DRM은 콘텐츠 자체의 보호에 초점을 맞추는 반면, 방화벽은 네트워크 전체의 보안에 초점을 맞추기 때문입니다. 따라서 DRM의 기술적 요소로 볼 수 없는 것은 방화벽 기술입니다.",77,16
33,1,1,33,소프트 웨어 테스트에서 오류의 80%는 전체 모듈의 20% 내에서 발견된다는 법칙은?,,Brooks의 법칙,Boehm의 법칙,Pareto의 법칙,Jackson의 법칙,3,"소프트웨어 테스트를 진행하다 보면, 전체 코드에서 발견되는 오류의 대부분이 특정 부분에 집중되어 있다는 것을 경험하게 됩니다.  마치 20%의 원인이 80%의 결과를 만들어내는 것처럼 말이죠. 이러한 현상을 설명하는 것이 바로 이 법칙입니다.  소프트웨어 개발에서도 전체 모듈 중 20%의 모듈에 전체 오류의 80%가 집중되어 있다는 의미입니다.  따라서 소프트웨어 테스트 시, 이 법칙을 고려하여 오류가 많이 발생할 가능성이 높은 부분에 집중적으로 테스트를 수행하면 효율적으로 오류를 발견하고 수정할 수 있습니다. 이는 개발 시간과 비용을 절감하는 데 큰 도움이 됩니다. 이 법칙을 이해하고 적용하면 테스트의 효율성을 높일 수 있고, 결과적으로 더욱 안정적이고 품질 높은 소프트웨어를 개발하는 데 기여할 수 있습니다.  이처럼 특정 소수의 원인이 대부분의 결과를 초래하는 현상을 일반적으로 설명하는 법칙이 문제에서 제시된 정답입니다.",75,19
34,1,1,34,소프트웨어 형상 관리의 의미로 적절한 것은?,,비용에 관한 사항을 효율적으로 관리하는 것,개발 과정의 변경 사항을 관리하는 것,테스트 과정에서 소프트웨어를 통합하는 것,개발 인력을 관리하는 것,2,"소프트웨어 형상 관리란 소프트웨어 개발 과정에서 발생하는 모든 변경 사항을 체계적으로 관리하는 것을 의미합니다.  소프트웨어 개발은 여러 사람이 함께 진행하고, 코드는 끊임없이 수정되고 추가됩니다.  이러한 변경 사항들을 제대로 관리하지 않으면 버전 충돌이 발생하거나, 어떤 버전의 코드가 어떤 기능을 가지고 있는지 파악하기 어려워져 개발 과정이 매우 혼란스러워집니다.  따라서 소프트웨어 형상 관리는 개발 과정의 효율성을 높이고, 오류를 줄이며, 최종적으로는 소프트웨어의 품질을 향상시키는 데 매우 중요한 역할을 합니다.  비용 관리, 테스트 과정의 통합, 개발 인력 관리 등은 소프트웨어 개발에 필요한 요소이지만, 소프트웨어 형상 관리의 핵심 내용은 개발 과정에서 발생하는 변경 사항을 추적하고 관리하는 것입니다.  마치 건축 현장에서 설계 변경 사항을 기록하고 관리하는 것과 같다고 생각하면 이해하기 쉬울 것입니다.  각 변경 사항을 버전으로 관리하고, 필요시 이전 버전으로 돌아갈 수 있도록 하는 것이 소프트웨어 형상 관리의 주요 목표입니다.",69,15
35,1,1,35,알고리즘 시간복잡도 O(1)이 의미하는 것은?,,컴퓨터 처리가 불가,알고리즘 입력 데이터 수가 한 개,알고리즘 수행시간이 입력 데이터 수와 관계없이 일정,알고리즘 길이가 입력 데이터보다 작음,3,"알고리즘의 시간 복잡도는 알고리즘이 수행되는 데 걸리는 시간을 입력 데이터의 크기에 따라 나타낸 것입니다.  O(1)은 상수 시간 복잡도를 의미하며, 입력 데이터의 크기가 아무리 커져도 알고리즘의 수행 시간이 일정하게 유지됨을 나타냅니다.  예를 들어, 배열의 특정 인덱스에 접근하는 작업은 항상 같은 시간이 걸리므로 O(1)의 시간 복잡도를 가집니다.  입력 데이터의 개수가 1개인 경우는 특수한 경우이고, 알고리즘의 길이가 입력 데이터보다 작다는 것은 시간 복잡도와 직접적인 관련이 없습니다.  컴퓨터 처리가 불가능하다는 것은 시간 복잡도와 전혀 무관한 내용입니다. 따라서 O(1)은 입력 데이터의 크기와 관계없이 알고리즘의 수행 시간이 항상 일정하다는 것을 의미합니다.",76,21
36,1,1,36,소스코드 품질분석 도구 중 정적분석 도구가 아닌 것은?,,pmd,cppcheck,valMeter,checkstyle,3,"소스코드 품질분석 도구는 개발된 소스코드의 품질을 분석하는 도구입니다.  정적 분석 도구는 코드를 실행하지 않고 소스코드 자체를 분석하여 버그나 취약점, 스타일 가이드 위반 등을 찾아내는 도구입니다.  반면에 동적 분석 도구는 코드를 실제로 실행하면서 분석하는 방식입니다.  문제에서 제시된 도구들 중 pmd, cppcheck, checkstyle은 모두 코드를 실행하지 않고 분석하는 정적 분석 도구입니다.  하지만 나머지 하나는 코드를 실행하여 분석하는 동적 분석 도구이기 때문에 정적 분석 도구가 아닙니다. 따라서 정답은 코드를 실행하여 분석하는 동적 분석 도구입니다.  쉽게 말해, 정적 분석 도구는 책을 읽어서 오타나 문법 오류를 찾는 것과 같고, 동적 분석 도구는 책을 직접 읽어보면서 이해가 되는지, 내용이 일관성이 있는지 확인하는 것과 같습니다.  정답은 코드를 실행해야만 알 수 있는 문제점을 찾는 도구이므로 정적 분석 도구가 아닌 것입니다.",66,21
37,1,1,37,"검증 검사 기법 중 개발자의 장소에서 사용자가 개발자 앞에서 행하는 기법이며, 일반적으로 통제된 환경에서 사용자와 개발자가 함께 확인하면서 수행되는 검사는?",,동치 분할 검사,형상 검사,알파 검사,베타 검사,3,"이 문제는 소프트웨어 검사 기법 중 하나를 묻고 있습니다.  문제에서 ""개발자의 장소에서 사용자가 개발자 앞에서 행하는 기법"" 이라고 명시되어 있고, ""일반적으로 통제된 환경에서 사용자와 개발자가 함께 확인하면서 수행되는 검사"" 라고 설명하고 있죠. 이러한 조건을 만족하는 검사 기법은 바로 알파 검사입니다.  알파 검사는 개발이 완료된 소프트웨어를 개발 현장에서 제한된 수의 사용자들이 직접 사용해보면서 문제점을 찾는 검사입니다.  개발자의 감독 하에 이루어지기 때문에 사용자의 피드백을 바로 받아 수정할 수 있다는 장점이 있습니다.  반면 베타 검사는 개발이 거의 완료된 소프트웨어를 실제 사용 환경에서 다수의 사용자에게 배포하여 사용하게 하고, 그 결과를 바탕으로 문제점을 파악하는 검사입니다.  따라서 개발자의 장소에서 개발자의 감독 하에 이루어지는 검사라는 문제의 조건과는 맞지 않습니다.  동치 분할 검사는 테스트 케이스를 효율적으로 설계하는 기법이고, 형상 검사는 소프트웨어의 변경 사항을 관리하는 기법이므로 문제의 조건과는 무관합니다.  결론적으로, 개발자의 장소에서 사용자와 개발자가 함께 소프트웨어를 검사하는 상황은 알파 검사의 정의와 정확히 일치합니다.",79,19
38,1,1,38,하향식 통합에 있어서 모듈 간의 통합 시험을 위해 일시적으로 필요한 조건만을 가지고 임시로 제공되는 시험용 모듈을 무엇이라고 하는가?,,Stub,Driver,Procedure,Function,1,"하향식 통합 방식은 큰 모듈부터 통합하여 시스템을 구축하는 방식입니다.  이때, 아직 개발되지 않은 하위 모듈과의 인터페이스를 테스트하기 위해 임시로 기능을 제공하는 모듈이 필요합니다.  이러한 임시 모듈은 실제 기능을 구현하지 않고, 하위 모듈이 호출했을 때 미리 정의된 값을 반환하거나, 특정 동작을 시뮬레이션하는 역할을 합니다.  문제에서 설명하는 ""일시적으로 필요한 조건만을 가지고 임시로 제공되는 시험용 모듈""은 바로 이러한 역할을 하는 모듈을 의미하며, 이를  ""Stub"" 이라고 합니다.  반대로 상위 모듈을 테스트하기 위해 하위 모듈을 대신하는 임시 모듈은 ""Driver""라고 합니다.  ""Procedure""와 ""Function""은 프로그램의 구성 요소를 나타내는 일반적인 용어이지, 하향식 통합에서 특별히 사용되는 시험용 모듈을 의미하지는 않습니다. 따라서, 하향식 통합에서 하위 모듈을 대체하는 임시 모듈인 ""Stub""이 정답입니다.",82,14
39,1,1,39,SW 패키징 도구 활용 시 고려 사항과 거리가 먼 것은?,,패키징 시 사용자에게 배포되는 SW이므로 보안을 고려한다.,사용자 편의성을 위한 복합성 및 비효율성 문제를 고려한다.,보안상 단일 기종에서만 사용할 수 있도록 해야 한다.,제품 SW 종류에 적합한 암호화 알고리즘을 적용한다.,3,"SW 패키징은 소프트웨어를 사용자에게 배포하기 위한 과정입니다.  마치 선물을 포장하듯, 소프트웨어를 사용하기 쉽고 안전하게 전달하는 데 초점을 맞춥니다.  따라서 패키징 과정에서는 사용자의 편의성을 높이고, 소프트웨어의 보안을 강화하는 데 신경 써야 합니다.  보안을 위해 적절한 암호화 알고리즘을 사용하는 것도 중요한 고려사항입니다. 하지만 소프트웨어를 단일 기종에서만 사용하도록 제한하는 것은 사용자의 편의성을 떨어뜨리고, 소프트웨어의 활용성을 저해하는 요소입니다.  소프트웨어는 다양한 환경에서 작동하도록 설계되는 것이 일반적이며, 특정 기종에만 국한하는 것은 오히려 비효율적이고 시장 경쟁력을 낮추는 결과를 초래할 수 있습니다.  따라서 단일 기종에서만 사용하도록 제한하는 것은 SW 패키징 도구 활용 시 고려 사항과 거리가 멉니다.",89,16
40,1,1,40,외계인코드(Alien Code)에 대한 설명으로 옳은 것은?,,프로그램의 로직이 복잡하여 이해하기 어려운 프로그램을 의미한다.,아주 오래되거나 참고문서 또는 개발자가 없어 유지보수 작업이 어려운 프로그램을 의미한다.,오류가 없어 디버깅 과정이 필요 없는 프로그램을 의미한다.,사용자가 직접 작성한 프로그램을 의미한다.,2,"외계인 코드(Alien Code)는 오랫동안 방치되어 관리가 제대로 되지 않거나, 원래 개발자를 찾을 수 없어 유지보수가 매우 어려운 프로그램을 의미합니다. 마치 외계인이 만든 것처럼 이해하기 어렵고 수정하기 힘든 코드라는 뜻에서 비유적으로 사용하는 용어입니다.  프로그램의 로직이 복잡하다고 해서 무조건 외계인 코드라고 부르는 것은 아니며, 오류가 없거나 사용자가 직접 작성했다고 해서 외계인 코드라고 할 수 없습니다.  핵심은 '유지보수의 어려움'에 있습니다.  오래된 코드는 문서화가 부족하거나 코드 자체가 시대에 뒤떨어진 기술로 작성되어 있을 가능성이 높고, 이는 유지보수 비용과 시간을 엄청나게 증가시키는 주요 원인이 됩니다.  따라서,  유지보수가 어려운 프로그램을 설명하는 가장 적절한 답변은 오래되고 참고문서나 개발자가 없어 유지보수가 어려운 프로그램을 의미하는 것입니다.",82,17
41,1,1,41,SQL 의 분류 중 DDL에 해당하지 않는 것은?,,UPDATE,ALTER,DROP,CREATE,1,"SQL은 데이터베이스를 관리하고 조작하는 데 사용되는 언어입니다.  SQL은 크게 데이터 정의어(DDL), 데이터 조작어(DML), 데이터 제어어(DCL)로 나눌 수 있습니다.  DDL은 데이터베이스의 구조를 정의하는 명령어들을 포함합니다.  예를 들어, 데이터베이스나 테이블을 생성(CREATE), 수정(ALTER), 삭제(DROP)하는 명령어들이 DDL에 속합니다. 반면에,  UPDATE 명령어는 이미 존재하는 테이블의 데이터를 변경하는 명령어이므로 데이터를 조작하는 DML에 속합니다. 따라서,  데이터베이스의 구조를 정의하는 DDL에 해당하지 않는 것은 데이터를 변경하는 명령어입니다.",74,27
42,1,1,42,다음 두 릴레이션에서 외래키로 사용된 것은? (단 밑줄 친 속성은 기본키이다.),https://www.cbtbank.kr/images/iz/iz20200606/iz20200606m42.gif,수강번호,과목번호,학번,과목명,2,"두 릴레이션 '과목'과 '수강'을 살펴보면, '과목' 릴레이션에는 과목에 대한 정보(과목번호, 과목명)가 저장되어 있고, '수강' 릴레이션에는 수강생의 정보(수강번호, 학번, 학기)와 어떤 과목을 수강했는지에 대한 정보(과목번호)가 저장되어 있습니다.  '수강' 릴레이션에서 '과목번호'는 '과목' 릴레이션의 '과목번호'를 참조하고 있습니다.  즉, '수강' 릴레이션의 '과목번호'는 다른 릴레이션인 '과목' 릴레이션의 기본키를 참조하는 외래키 역할을 합니다.  '수강' 릴레이션에서 어떤 학생이 어떤 과목을 수강했는지 연결하는 역할을 하는 것이 바로 '과목번호'인 것입니다.  마치 주민등록번호처럼,  '과목번호'는 '과목' 릴레이션에서 과목을 유일하게 식별하는 키이고, '수강' 릴레이션에서는 그 과목을 참조하여 수강 정보를 연결하는 역할을 수행합니다.  따라서 '수강' 릴레이션에서 외래키로 사용된 것은 '과목번호'입니다.",86,29
43,1,1,43,데이터 무결성 제약조건 중 “개체 무결성 제약”조건에 대한 설명으로 맞는 것은?,,릴레이션 내의 튜플들이 각 속성의 도메인에 지정된 값만을 가져야 한다.,기본키에 속해 있는 애트리뷰트는 널값이나 중복값을 가질 수 없다.,릴레이션은 참조할 수 없는 외래키 값을 가질 수 없다.,외래키 값은 참조 릴레이션의 기본키 값과 동일해야 한다.,2,"데이터 무결성이란 데이터베이스에 저장된 데이터의 정확성과 신뢰성을 유지하는 것을 의미합니다.  여러 가지 제약 조건들이 데이터 무결성을 보장하는데, 그 중 ""개체 무결성 제약""은 기본키에 대한 제약 조건입니다.  기본키는 테이블 내 각 행(튜플)을 유일하게 식별하는 속성(애트리뷰트)의 집합입니다.  따라서 기본키를 구성하는 속성들은 절대로 빈 값(널값)이나 중복된 값을 가질 수 없습니다.  만약 널값이나 중복값을 허용한다면, 각 행을 유일하게 식별할 수 없어 데이터베이스의 정확성과 신뢰성이 떨어지게 되겠죠.  마치 사람의 주민등록번호처럼, 각 개인을 유일하게 구분하기 위해서는 중복되거나 비어있어서는 안되는 것과 같은 이치입니다.  따라서 정답은 기본키에 속한 애트리뷰트는 널값이나 중복값을 가질 수 없다는 설명입니다. 다른 선지는 외래키에 대한 제약 조건을 설명하고 있습니다.",76,33
44,1,1,44,뷰(view)에 대한 설명으로 옳지 않은 것은?,,뷰는 CREATE 문을 사용하여 정의한다.,뷰는 데이터의 논리적 독립성을 제공한다.,뷰를 제거할 때에는 DROP 문을 사용한다.,뷰는 저장장치 내에 물리적으로 존재한다.,4,"뷰(view)는 데이터베이스에 저장된 실제 데이터가 아닌, 기존 테이블의 데이터를 기반으로 가상적으로 생성된 테이블입니다.  마치 특정 테이블의 일부분만 보여주는 창문과 같은 역할을 하죠.  따라서 뷰는 실제 데이터를 저장하는 공간이 아니라,  데이터베이스에 물리적으로 저장되지 않고,  데이터베이스 시스템이 필요할 때마다 기존 테이블의 데이터를 참조하여 가상의 테이블을 생성합니다.  뷰를 통해 데이터에 접근하는 방식을 제어하고, 복잡한 쿼리를 간단하게 만들 수 있으며, 데이터의 논리적 독립성을 제공하여 데이터 구조 변경 시에도 뷰를 사용하는 애플리케이션에 영향을 최소화할 수 있습니다.  문제에서 틀린 설명은 뷰가 저장장치 내에 물리적으로 존재한다는 부분입니다.  뷰는 물리적으로 저장되지 않고,  필요할 때마다 동적으로 생성되는 가상 테이블이기 때문입니다.  CREATE 문으로 정의하고, DROP 문으로 제거하는 것은 맞는 설명입니다.",76,28
45,1,1,45,다음 SQL 문의 실행 결과는?,https://www.cbtbank.kr/images/iz/iz20200606/iz20200606m45.gif,"10,000","15,000","20,000","25,000",4,"이 문제는 두 개의 테이블, `도서` 테이블과 `도서가격` 테이블을 사용하여 특정 책의 가격을 찾는 SQL 쿼리를 다루고 있습니다.  먼저 안쪽의 `SELECT` 문 (서브쿼리) 에서 '자료구조'라는 책의 책번호를 찾습니다. `도서` 테이블을 조회하여 책명이 '자료구조'인 행을 찾으면, 그 행의 책번호(222)가 얻어집니다.  이렇게 얻어진 책번호(222)는 바깥쪽 `SELECT` 문의 `WHERE` 절에 사용됩니다. 바깥쪽 `SELECT` 문은 `도서가격` 테이블에서 책번호가 222인 행의 가격을 찾습니다. `도서가격` 테이블을 보면 책번호 222의 가격은 25,000원입니다. 따라서 최종적으로 SQL 쿼리는 25,000이라는 결과를 반환합니다.  쉽게 말해,  '자료구조'라는 책의 책번호를 먼저 찾고, 그 책번호를 이용하여 해당 책의 가격을 찾는 과정입니다. 마치 주민등록번호를 이용하여 주민등록상의 정보를 찾는 것과 같은 원리라고 생각하면 이해하기 쉬울 것입니다.",89,28
46,1,1,46,데이터베이스의 논리적 설계(logical design) 단계에서 수행하는 작업이 아닌 것은?,,레코드 집중의 분석 및 설계,논리적 데이터베이스 구조로 매핑(mapping),트랜잭션 인터페이스 설계,스키마의 평가 및 정제,1,"데이터베이스의 논리적 설계 단계는 데이터베이스가 어떻게 구성될지 개념적으로 설계하는 단계입니다.  마치 건물을 짓기 전에 설계도를 그리는 것과 같습니다.  이 단계에서는 데이터베이스에 어떤 정보가 저장될지, 그 정보들 간의 관계는 어떻게 될지 등을 정의합니다.  제시된 선택지 중에서 레코드 집중 분석, 논리적 데이터베이스 구조 매핑, 스키마 평가 및 정제는 모두 논리적 설계 단계에서 수행하는 작업입니다.  레코드 집중 분석은 데이터 중복을 줄이고 효율적인 데이터 구조를 설계하기 위한 분석이고, 논리적 데이터베이스 구조 매핑은 개념적인 데이터 모델을 실제 데이터베이스 구조로 변환하는 작업이며, 스키마 평가 및 정제는 설계된 데이터베이스 구조의 완성도를 높이기 위한 검토 및 수정 과정입니다.  반면, 트랜잭션 인터페이스 설계는 데이터베이스와 사용자 또는 다른 시스템 간의 데이터 교환 방식을 설계하는 것으로, 논리적 설계 단계보다는 물리적 설계 단계 또는 구현 단계에서 주로 고려되는 사항입니다.  논리적 설계는 데이터 자체의 구조와 관계에 집중하는 반면, 트랜잭션 인터페이스는 데이터를 어떻게 주고받을지에 초점을 맞추기 때문입니다. 따라서 트랜잭션 인터페이스 설계는 논리적 설계 단계에서 수행하는 작업이 아닙니다.",45,30
47,1,1,47,이행적 함수 종속 관계를 의미하는 것은?,,"A→B이고 B→C 일 때, A→C를 만족하는 관계","A→B이고 B→C 일 때, C→A를 만족하는 관계","A→B이고 B→C 일 때, B→A를 만족하는 관계","A→B이고 B→C 일 때, C→B를 만족하는 관계",1,"이 문제는 이행적 함수 종속성의 개념을 묻고 있습니다. 함수 종속성이란, 어떤 속성(A)의 값이 결정되면 다른 속성(B)의 값도 결정되는 관계를 말합니다.  A → B 라고 표기합니다.  문제에서 A → B 이고 B → C 라는 함수 종속성이 주어졌습니다. 이는 A의 값이 결정되면 B의 값이 결정되고, B의 값이 결정되면 C의 값이 결정된다는 의미입니다. 따라서, 결국 A의 값이 결정되면 C의 값도 결정되는 관계가 성립합니다. 이것이 바로 이행적 함수 종속성(A → C)입니다.  다른 선지는 A, B, C 속성 간의 관계가 이행적 함수 종속성의 정의와 일치하지 않습니다.  쉽게 말해, A가 B를 결정하고, B가 C를 결정하면, A는 C를 결정한다는 것이 이행적 함수 종속성의 핵심입니다.  마치 도미노처럼 A가 쓰러지면 B가 쓰러지고, B가 쓰러지면 C가 쓰러지는 것과 같은 원리입니다.",85,29
48,1,1,48,하나의 애트리뷰트가 가질 수 있는 원자값들의 집합을 의미하는 것은?,,도메인,튜플,엔티티,다형성,1,"하나의 애트리뷰트(속성)가 가질 수 있는 값들의 집합을 묻는 문제입니다.  데이터베이스를 설계할 때, 각 속성(예를 들어, '나이'라는 속성)은 어떤 값들을 가질 수 있을까요?  '나이'라는 속성은 음수가 될 수 없고, 아주 큰 수도 현실적으로 불가능하겠죠.  따라서 '나이'라는 속성은 0 이상의 어떤 범위의 정수 값을 가질 수 있을 것입니다. 이처럼 특정 속성이 가질 수 있는 값들의 전체 집합을 도메인이라고 합니다.  예를 들어, '성별'이라는 애트리뷰트의 도메인은 '남자', '여자' 와 같이 제한된 값들의 집합이 될 것입니다. 다른 선택지는 데이터베이스의 다른 개념을 나타냅니다. 튜플은 테이블의 한 행을, 엔티티는 실세계의 개체를, 다형성은 객체지향 프로그래밍의 개념을 의미합니다. 따라서 애트리뷰트가 가질 수 있는 값들의 집합을 가장 정확하게 나타내는 용어는 도메인입니다.  쉽게 말해,  어떤 속성에 들어갈 수 있는 값들의 목록이라고 생각하면 됩니다.",66,27
49,1,1,49,"STUDENT 테이블에 독일어과 학생 50명, 중국어과 학생 30명, 영어영문학과 학생 50명의 정보가 저장되어 있을 때, 다음 두 SQL문의 실행 결과 튜플 수는? (단, DEPT 컬럼은 학과명)",https://www.cbtbank.kr/images/iz/iz20200606/iz20200606m49.gif,"ⓐ 3, ⓑ 3","ⓐ 50, ⓑ 3","ⓐ 130, ⓑ 3","ⓐ 130, ⓑ 130",3,"이 문제는 SQL의 SELECT 문에서 DISTINCT 키워드의 역할을 이해하고 있는지 묻는 문제입니다.  STUDENT 테이블에는 독일어과, 중국어과, 영어영문학과 학생들의 정보가 저장되어 있습니다.  첫 번째 SQL 문인 `SELECT DEPT FROM STUDENT;`는 STUDENT 테이블에서 DEPT(학과명) 컬럼의 모든 값을 가져오는 명령어입니다.  따라서 독일어과 학생 50명, 중국어과 학생 30명, 영어영문학과 학생 50명의 정보가 각각 50, 30, 50개의 행으로 나타나므로 총 130개의 튜플(행)이 결과로 출력됩니다.  두 번째 SQL 문인 `SELECT DISTINCT DEPT FROM STUDENT;`는  `DISTINCT` 키워드 때문에 중복된 학과명을 제거하고 유일한 학과명만을 출력합니다.  테이블에는 독일어과, 중국어과, 영어영문학과 세 개의 학과만 존재하므로, 결과는 독일어과, 중국어과, 영어영문학과 세 개의 튜플(행)만 출력됩니다.  따라서 첫 번째 SQL 문의 결과는 130개의 튜플이고, 두 번째 SQL 문의 결과는 3개의 튜플입니다.",82,27
50,1,1,50,관계대수 연산에서 두 릴레이션이 공통으로 가지고 있는 속성을 이용하여 두 개의 릴레이션을 하나로 합쳐서 새로운 릴레이션을 만드는 연산은?,,https://www.cbtbank.kr/images/iz/iz20200606/iz20200606m50b1.gif,https://www.cbtbank.kr/images/iz/iz20200606/iz20200606m50b2.gif,https://www.cbtbank.kr/images/iz/iz20200606/iz20200606m50b3.gif,https://www.cbtbank.kr/images/iz/iz20200606/iz20200606m50b4.gif,1,"두 개의 릴레이션(관계형 데이터베이스의 테이블이라고 생각하면 쉬워요)을 하나로 합치는 연산을 묻는 문제입니다.  두 릴레이션이 공통으로 가지고 있는 속성(테이블의 열, 즉 데이터의 종류라고 생각하면 돼요)을 이용한다는 점이 중요한 힌트입니다.  예를 들어,  '학생' 테이블과 '성적' 테이블이 있다고 가정해 봅시다.  '학생' 테이블에는 학생의 이름과 학번이, '성적' 테이블에는 학번과 점수가 있다고 하면, 두 테이블 모두 '학번'이라는 공통 속성을 가지고 있죠.  이 공통 속성인 '학번'을 이용하여 두 테이블을 합치면, 학생의 이름, 학번, 점수가 모두 포함된 하나의 새로운 테이블을 만들 수 있습니다. 이러한 연산을 관계대수에서는 **조인(JOIN)** 연산이라고 합니다. 조인 연산은 공통 속성을 기준으로 두 테이블의 행들을 연결하여 새로운 테이블을 생성하는 것이죠.  따라서 문제에서 설명하는 연산은 조인 연산입니다.  비전공자도 이해하기 쉽게 설명하자면, 레고 블록을 조립하는 것과 비슷하다고 생각할 수 있습니다.  각각의 레고 블록이 테이블이고,  블록을 연결하는 부분이 공통 속성입니다.  공통 부분을 이용해서 블록들을 연결하여 더 큰 블록(새로운 테이블)을 만드는 것이죠.",82,29
51,1,1,51,트랜잭션의 특성 중 다음 설명에 해당하는 것은?,https://www.cbtbank.kr/images/iz/iz20200606/iz20200606m51.gif,Durability,Share,Consistency,Atomicity,4,"문제에서 제시된 설명은 ""트랜잭션의 연산은 데이터베이스에 모두 반영되든지 아니면 전혀 반영되지 않아야 한다"" 입니다.  이는 데이터베이스의 일관성을 유지하기 위한 매우 중요한 개념입니다.  예를 들어, 은행 계좌 이체를 생각해 봅시다. A 계좌에서 B 계좌로 1000원을 이체하는 트랜잭션이 있다고 가정해 봅시다. 이 트랜잭션은 A 계좌에서 1000원을 차감하고 B 계좌에 1000원을 추가하는 두 가지 연산으로 구성됩니다.  만약 A 계좌에서 1000원을 차감하는 연산은 성공했지만, B 계좌에 1000원을 추가하는 연산이 실패한다면 데이터베이스는 일관성을 잃게 됩니다.  즉, 돈이 사라진 상태가 되는 것이죠.  이러한 상황을 방지하기 위해 트랜잭션은 '모두 성공하거나 모두 실패'하는 특성을 가져야 합니다. 이것이 바로 '원자성(Atomicity)'입니다.  원자성 덕분에 데이터베이스는 항상 일관된 상태를 유지할 수 있으며, 부분적인 변경으로 인한 오류를 예방할 수 있습니다.  따라서 문제의 설명은 원자성(Atomicity)의 개념을 정확하게 설명하고 있습니다.",73,27
52,1,1,52,분산 데이터베이스 목표 중 “데이터베이스의 분산된 물리적 환경에서 특정 지역의 컴퓨터 시스템이나 네트워크에 장애가 발생해도 데이터 무결성이 보장된다”는 것과 관계있는 것은?,,장애 투명성,병행 투명성,위치 투명성,중복 투명성,1,"문제에서 분산 데이터베이스의 목표 중 하나로 특정 지역의 시스템 장애에도 데이터 무결성이 유지되는 것을 언급하고 있습니다. 이는 시스템의 어떤 부분에 장애가 발생하더라도 사용자는 그 사실을 인지하지 못하고, 마치 장애가 없는 것처럼 시스템을 계속 사용할 수 있음을 의미합니다.  즉, 장애가 발생했음에도 불구하고 시스템은 정상적으로 작동하는 것처럼 보이는 투명성을 제공하는 것입니다.  이러한 특징을 가장 잘 나타내는 용어가 바로 ""장애 투명성""입니다. 다른 선지는 데이터베이스의 물리적 위치, 병행 처리, 데이터 중복과 관련된 투명성을 나타내므로 문제의 상황과는 직접적인 관련이 없습니다. 따라서 특정 지역의 컴퓨터 시스템이나 네트워크 장애에도 데이터 무결성이 보장되는 분산 데이터베이스의 목표는 장애 투명성을 통해 달성됩니다.  이는 정보처리기사 공식 교재에서 분산 데이터베이스의 주요 특징으로 설명되는 내용입니다.",71,31
53,1,1,53,"데이터베이스 시스템에서 삽입, 갱신, 삭제 등의 이벤트가 발생할 때마다 관련 작업이 자동으로 수행되는 절차형 SQL은?",,트리거(trigger),무결성(integrity),잠금(lock),복귀(rollback),1,"데이터베이스 시스템에서 데이터가 변경될 때(삽입, 갱신, 삭제) 특정 작업을 자동으로 수행하도록 하는 기능이 필요하다고 생각해 보세요.  예를 들어, 상품의 재고가 0이 되면 자동으로 '품절' 상태로 변경하거나, 회원 정보가 변경될 때마다 변경 내역을 기록하는 등의 작업이 필요할 수 있습니다. 이러한 자동화된 작업을 처리하는 것이 바로 '트리거'입니다.  트리거는 데이터베이스 이벤트에 반응하여 미리 정의된 SQL 문을 자동으로 실행하는 절차형 SQL 기능입니다.  다른 선택지들은 데이터베이스의 무결성, 데이터 접근 제어, 트랜잭션의 복구 등과 관련된 개념이지만, 데이터 변경 이벤트에 따라 자동으로 특정 작업을 수행하는 기능은 트리거만이 가지고 있습니다.  따라서 데이터베이스 이벤트 발생 시 자동으로 관련 작업을 수행하는 절차형 SQL은 트리거라고 할 수 있습니다.",82,25
54,1,1,54,참조 무결성을 유지하기 위하여 DROP문에서 부모 테이블의 항목 값을 삭제할 경우 자동적으로 자식 테이블의 해당 레코드를 삭제하기 위한 옵션은?,,CLUSTER,CASCADE,SET-NULL,RESTRICTED,2,"부모 테이블과 자식 테이블이 있는 관계형 데이터베이스에서 부모 테이블의 데이터를 삭제할 때, 자식 테이블의 관련 데이터를 어떻게 처리할 것인지를 결정하는 옵션이 문제에서 묻고 있습니다.  참조 무결성이란 데이터베이스의 정확성과 일관성을 유지하기 위한 중요한 개념입니다.  자식 테이블은 부모 테이블에 종속적인데, 부모 테이블의 데이터가 삭제되면 자식 테이블의 관련 데이터도 일관성을 유지하기 위해 적절히 처리되어야 합니다.  정답으로 제시된 옵션은 부모 테이블의 항목이 삭제될 때, 자식 테이블에 있는 해당 부모 항목과 관련된 모든 레코드를 자동으로 함께 삭제하는 기능을 제공합니다.  이는 데이터베이스의 참조 무결성을 유지하는 가장 직관적이고 효율적인 방법입니다. 다른 옵션들은 부모 데이터 삭제 시 자식 데이터 처리에 대한 다른 규칙을 정의하지만, 문제에서 요구하는 ""자동적으로 자식 테이블의 해당 레코드를 삭제""하는 조건을 만족하지 못합니다.  마치 나무의 가지를 잘라내면 그 가지에 달린 잎들도 함께 제거되는 것과 같은 원리입니다.  따라서 부모 테이블의 데이터 삭제와 동시에 자식 테이블의 관련 데이터도 함께 삭제하는 옵션이 참조 무결성을 유지하는 데 가장 적합합니다.",77,27
55,1,1,55,DML에 해당하는 SQL 명령으로만 나열된 것은?,,"DELETE, UPDATE, CREATE, ALTER","INSERT, DELETE, UPDATE, DROP","SELECT, INSERT, DELETE, UPDATE","SELECT, INSERT, DELETE, ALTER",3,"이 문제는 데이터베이스를 조작하는 SQL 명령어 중 DML(Data Manipulation Language, 데이터 조작 언어)에 해당하는 명령어만을 고르는 문제입니다.  SQL은 데이터베이스를 관리하는 데 사용되는 표준 언어인데, 크게 DDL(Data Definition Language, 데이터 정의 언어), DML, DCL(Data Control Language, 데이터 제어 언어)로 나뉩니다.",81,26
56,1,1,56,데이터 제어언어(DCL)의 기능으로 옳지 않은 것은?,,데이터 보안,"논리적, 물리적 데이터 구조 정의",무결성 유지,병행수행 제어,2,"데이터 제어 언어(DCL)은 데이터베이스 시스템에서 데이터에 대한 접근 권한을 관리하고 제어하는 데 사용되는 언어입니다.  쉽게 말해, 누가 어떤 데이터를 볼 수 있고, 수정할 수 있고, 삭제할 수 있는지를 설정하는 역할을 합니다.  데이터 보안, 무결성 유지, 병행 수행 제어 등은 모두 데이터베이스의 안전성과 효율적인 운영을 위해 DCL이 담당하는 중요한 기능입니다.  하지만 데이터베이스의 논리적, 물리적 구조 자체를 정의하는 것은 데이터 정의 언어(DDL)의 영역입니다.  DDL은 테이블, 뷰, 인덱스 등 데이터베이스의 기본적인 구조를 만드는 명령어들을 제공하는 반면, DCL은 이미 만들어진 데이터베이스 구조에 대한 접근 권한을 관리하는 데 초점을 맞춥니다. 따라서 데이터베이스의 논리적, 물리적 구조를 정의하는 것은 DCL의 기능이 아니라고 할 수 있습니다.  마치 건물의 설계도를 그리는 것이 DDL이라면, 건물 출입문의 자물쇠와 출입 권한을 관리하는 것이 DCL이라고 생각하면 이해하기 쉬울 것입니다.",67,26
57,1,1,57,병행제어의 로킹(Locking) 단위에 대한 설명으로 옳지 않은 것은?,,"데이터베이스, 파일, 레코드 등은 로킹 단위가 될 수 있다.",로킹 단위가 작아지면 로킹 오버헤드가 감소한다.,로킹 단위가 작아지면 데이터베이스 공유도가 증가한다.,한꺼번에 로킹 할 수 있는 객체의 크기를 로킹 단위라고 한다.,2,"병행 제어에서 로킹(Locking)은 여러 사용자가 동시에 데이터베이스를 접근하여 데이터의 일관성을 유지하기 위해 사용하는 중요한 기법입니다.  여러 사용자가 동시에 같은 데이터를 변경하려고 시도하면 데이터가 손상될 수 있기 때문에, 로킹을 통해 특정 사용자에게만 데이터에 대한 접근 권한을 일시적으로 부여합니다.  로킹 단위는 한 번에 잠글 수 있는 데이터의 크기를 의미하는데, 이 단위가 작을수록 더 세분화된 접근 제어가 가능해집니다.  예를 들어, 로킹 단위가 전체 데이터베이스라면 한 사용자가 데이터베이스 전체를 잠그게 되어 다른 사용자는 아무것도 할 수 없게 됩니다. 반면 로킹 단위가 레코드 단위라면 특정 레코드만 잠그고 다른 레코드는 다른 사용자가 접근할 수 있게 됩니다.",77,31
58,1,1,58,E-R 모델의 표현 방법으로 옳지 않은 것은?,,개체타입: 사각형,관계타입: 마름모,속성: 오각형,연결: 선,3,"E-R 모델은 데이터베이스 설계에 사용되는 개체-관계 모델입니다.  데이터베이스를 구성하는 요소들을 시각적으로 표현하여 설계 과정을 효율적으로 관리하고 이해하기 쉽도록 도와줍니다.  개체(Entity)는 사각형으로, 관계(Relationship)는 마름모로, 속성(Attribute)은 타원형으로 표현하는 것이 일반적입니다.  개체와 관계, 속성 사이의 연결은 선으로 나타냅니다.  문제에서 오각형으로 속성을 표현하는 것은 E-R 모델의 표준 표현 방식과 일치하지 않으므로 옳지 않은 표현 방법입니다.  E-R 다이어그램을 그릴 때 일관된 기호를 사용하는 것이 중요하며, 이는 다른 사람들이 다이어그램을 이해하고 해석하는 데 도움이 됩니다.  따라서 오각형을 속성으로 사용하는 것은 E-R 다이어그램의 표준적인 표현법을 따르지 않아 잘못된 것입니다.",87,30
59,1,1,59,다음 설명의 ( )안에 들어갈 내용으로 적합한 것은?,https://www.cbtbank.kr/images/iz/iz20200606/iz20200606m59.gif,중복성,최소성,참조성,동일성,2,"후보키는 테이블 내의 각 행(튜플)을 유일하게 식별하는 데 사용되는 속성 또는 속성들의 집합입니다.  유일성이란, 후보키를 구성하는 속성값들의 조합이 테이블 내 모든 행에서 중복되지 않아야 함을 의미합니다.  그런데 유일성만으로는 후보키가 될 수 없습니다.  예를 들어, 학생 테이블에서 '학번'과 '주민등록번호'가 모두 유일한 값을 가진다고 가정해봅시다.  이 경우 '학번'과 '주민등록번호' 모두 유일성 조건을 만족하지만,  '주민등록번호'는 '학번'으로 학생을 충분히 식별할 수 있으므로 불필요한 정보입니다.  따라서 후보키는 유일성과 함께 최소성, 즉 더 이상 속성을 줄일 수 없는 최소한의 속성 집합이어야 합니다.  '최소성'을 만족하지 않으면 불필요한 정보를 포함하게 되어 데이터베이스의 효율성을 떨어뜨리게 됩니다.  따라서 후보키는 유일성과 최소성을 모두 만족해야 합니다.",78,29
60,1,1,60,정규화 과정 중 1NF에서 2NF가 되기 위한 조건은?,,1NF를 만족하는 모든 도메인이 원자 값이어야 한다.,1NF를 만족하고 키가 아닌 모든 애트리뷰트들이 기본 키에 이행적으로 함수 종속되지 않아야 한다.,1NF를 만족하고 다치 종속이 제거되어야 한다.,1NF를 만족하고 키가 아닌 모든 속성이 기본키에 대하여 완전 함수적 종속 관계를 만족해야 한다.,4,"데이터베이스 정규화는 데이터 중복을 최소화하고 데이터 무결성을 유지하기 위해 데이터베이스를 체계적으로 구성하는 과정입니다.  1NF(제1정규형)는 각 속성(애트리뷰트)이 원자값을 가져야 한다는 조건을 만족해야 합니다. 즉, 하나의 속성에 여러 값을 저장할 수 없다는 의미입니다.  이를 만족하는 데이터베이스가 1NF를 만족한다고 합니다.",57,30
61,1,1,61,IPv6에 대한 설명으로 틀린 것은?,,128비트의 주소 공간을 제공한다.,인증 및 보안 기능을 포함하고 있다.,패킷 크기가 64Kbyte로 고정되어 있다.,IPv6 확장 헤더를 통해 네트워크 기능 확장이 용이하다.,3,"IPv6는 인터넷 프로토콜 버전 6으로, 기존 IPv4의 주소 부족 문제를 해결하기 위해 개발된 차세대 인터넷 프로토콜입니다.  IPv4가 32비트 주소를 사용하는 반면, IPv6는 128비트의 훨씬 넓은 주소 공간을 제공하여 엄청난 수의 장치에 고유한 IP 주소를 할당할 수 있습니다. 또한, 보안 기능을 강화하여 네트워크의 안전성을 높였습니다.  IPv6 확장 헤더는 다양한 네트워크 기능을 추가할 수 있도록 유연성을 제공합니다. 하지만,  패킷 크기는 고정되어 있지 않고, 최대 크기만 정의되어 있습니다.  따라서 패킷 크기가 64Kbyte로 고정되어 있다는 설명은 틀린 것입니다.  마치 집 주소를 생각해보세요. IPv4는 주소가 부족해서 집집마다 주소를 제대로 부여하기 어려웠지만, IPv6는 훨씬 더 많은 주소를 제공하여 모든 집에 충분한 주소를 줄 수 있게 된 것입니다.  그리고 IPv6는 도둑이 들어오지 못하도록 보안 시스템을 더욱 강화한 것과 같습니다.",80,45
62,1,1,62,C언어에서 비트 논리연산자에 해당하지 않는 것은?,,^,?,&,~,2,"C언어에서 비트 논리 연산자는 컴퓨터가 숫자를 2진수(0과 1로 이루어진 수)로 처리할 때, 각 비트(0 또는 1) 단위로 연산을 수행하는 연산자입니다.  '&'(AND), '|'(OR), '^'(XOR), '~'(NOT) 등이 대표적인 비트 논리 연산자입니다.  예를 들어, '&' 연산자는 두 비트가 모두 1일 때만 1을 결과로 반환하고, 나머지는 0을 반환합니다.  '|' 연산자는 두 비트 중 하나라도 1이면 1을, 모두 0일 때만 0을 반환합니다. '^' 연산자는 두 비트가 다를 때 1을, 같을 때 0을 반환합니다. '~' 연산자는 비트를 반전시키는 연산자입니다.  문제에서 제시된 옵션 중 '?'는 C언어의 비트 논리 연산자가 아닙니다. '?'는 조건 연산자로, 세 개의 피연산자를 가지고 조건에 따라 값을 반환하는 연산자입니다.  따라서, C언어의 비트 논리 연산자에 해당하지 않는 것은 '?'입니다.  비트 논리 연산자는 비트 단위의 연산을 수행하는 반면, '?'는 조건에 따라 값을 선택하는 연산이기 때문에 전혀 다른 종류의 연산자라고 할 수 있습니다.  마치 더하기와 곱하기가 다른 연산처럼 말이죠.",69,41
63,1,1,63,TCP/IP 프로토콜 중 전송계층 프로토콜은?,,HTTP,SMTP,FTP,TCP,4,"TCP/IP 프로토콜은 인터넷에서 데이터를 주고받는 데 사용되는 일종의 통신 규약입니다.  이 프로토콜은 여러 계층으로 나뉘는데, 그 중 전송 계층은 데이터를 안전하고 신뢰성 있게 전달하는 역할을 합니다.  문제에서 묻고 있는 전송 계층 프로토콜은 데이터의 전송을 담당하는 프로토콜을 의미합니다.  HTTP, SMTP, FTP는 각각 웹 페이지 접근, 이메일 전송, 파일 전송을 위한 응용 계층 프로토콜입니다.  반면 TCP는 전송 계층에서 데이터의 신뢰성 있는 전달을 보장하는 프로토콜입니다.  TCP는 데이터를 패킷으로 나누어 순서대로 전송하고, 오류 검출 및 재전송 기능을 제공하여 데이터 손실이나 오류 없이 목적지에 도착하도록 합니다. 따라서 전송 계층 프로토콜로는 TCP가 가장 적합합니다.",71,45
64,1,1,64,시스템에서 모듈 사이의 결합도(Coupling)에 대한 설명으로 옳은 것은?,,한 모듈 내에 있는 처리요소들 사이의 기능적인 연관 정도를 나타낸다.,결합도가 높으면 시스템 구현 및 유지보수 작업이 쉽다.,모듈간의 결합도를 약하게 하면 모듈 독립성이 향상된다.,자료결합도는 내용결합도 보다 결합도가 높다.,3,"시스템에서 모듈이란, 특정 기능을 수행하는 독립적인 코드의 단위라고 생각하면 됩니다.  마치 레고 블록처럼, 각각의 블록(모듈)이 특정 기능을 담당하고, 여러 블록을 조합하여 전체 시스템을 만드는 것이죠.  결합도(Coupling)는 이러한 모듈들 간의 의존성 정도를 나타내는 척도입니다.  결합도가 높다는 것은 모듈들이 서로 긴밀하게 연결되어 있어, 하나의 모듈을 변경하면 다른 모듈에도 영향을 미칠 가능성이 높다는 것을 의미합니다. 반대로 결합도가 낮으면 모듈들이 서로 독립적으로 작동하여, 하나의 모듈을 변경하더라도 다른 모듈에는 영향을 거의 미치지 않습니다.  따라서 모듈 간의 결합도를 약하게 하는 것은 각 모듈의 독립성을 높여주고, 시스템의 유지보수 및 변경을 쉽게 만들어줍니다.  높은 결합도는 시스템을 복잡하게 만들고, 오류 수정이나 기능 추가 시 예상치 못한 문제를 발생시킬 수 있습니다.  마치 레고 블록을 아주 꽉 끼워 맞춰서 하나의 큰 블록처럼 만들면,  블록 하나를 빼내기 어렵고, 다른 블록에도 영향을 미치는 것과 같습니다.  반면에 블록들을 느슨하게 연결하면,  원하는 블록을 쉽게 빼내거나 추가할 수 있습니다.  정답은 모듈 간의 결합도를 약하게 하면 모듈의 독립성이 향상된다는 것을 설명하는 선지입니다.",69,6
65,1,1,65,은행가 알고리즘(Banker's Algorithm)은 교착상태의 해결 방법 중 어떤 기법에 해당하는가?,,Avoidance,Detection,Prevention,Recovery,1,"은행가 알고리즘은 시스템의 자원 할당을 미리 검사하여 교착상태(데드락)가 발생할 가능성이 있는지를 확인하고, 교착상태가 발생하지 않도록 자원 할당을 제어하는 기법입니다.  즉, 교착상태가 발생하기 *전에* 예방하는 것이 아니라,  교착상태가 발생할 *가능성을 미리 검토*하여 안전한 자원 할당을 결정하는 것입니다.  마치 은행원이 고객에게 돈을 빌려줄 때, 고객이 돈을 갚을 수 있는지 꼼꼼히 확인하는 것과 같습니다.  만약 고객이 돈을 갚을 능력이 없다면, 은행원은 돈을 빌려주지 않겠죠?  은행가 알고리즘도 이와 마찬가지로, 자원을 요청하는 프로세스가 자원을 할당받은 후에도 교착상태에 빠질 가능성이 있다면 자원 할당을 거부하여 교착상태를 *회피(Avoidance)*하는 것입니다.  교착상태를 감지하거나, 예방하거나, 발생 후 복구하는 것과는 다릅니다.",73,21
66,1,1,66,UNIX의 쉘(Shell)에 관한 설명으로 옳지 않은 것은?,,명령어 해석기이다.,시스템과 사용자 간의 인터페이스를 담당한다.,여러 종류의 쉘이 있다.,"프로세스, 기억장치, 입출력 관리를 수행한다.",4,"UNIX 시스템에서 쉘(Shell)은 사용자가 명령어를 입력하면 그 명령어를 해석하고 시스템에 전달하여 실행하는 역할을 합니다. 마치 시스템과 사용자 사이의 중개자 역할을 하는 것이죠.  쉽게 말해, 사용자가 컴퓨터에게 ""이 작업을 해줘!""라고 말하면, 쉘이 그 말을 컴퓨터가 이해할 수 있는 언어로 바꿔서 전달하는 역할을 합니다.  따라서 쉘은 명령어 해석기이며, 시스템과 사용자 간의 인터페이스 역할을 수행하고, 다양한 종류의 쉘(bash, zsh, csh 등)이 존재합니다. 하지만 쉘 자체는 시스템의 프로세스, 기억장치, 입출력 관리와 같은 저수준의 작업을 직접 수행하지 않습니다. 이러한 작업들은 운영체제 커널(Kernel)에서 담당하는 영역입니다. 쉘은 커널에게 작업을 요청하고, 커널이 그 작업을 수행한 결과를 사용자에게 다시 보여주는 역할에 집중합니다.  따라서  ""프로세스, 기억장치, 입출력 관리를 수행한다""는 설명은 쉘의 역할이 아니므로 옳지 않습니다.",67,44
67,1,1,67,교착 상태 발생의 필요 충분 조건이 아닌 것은?,,상호 배제(mutual exclusion),점유와 대기(hold and wait),환형 대기(circular wait),선점(preemption),4,"교착 상태(Deadlock)는 두 개 이상의 프로세스가 서로 상대방이 갖고 있는 자원을 기다리면서 영원히 진행되지 못하는 상황을 말합니다.  교착 상태가 발생하기 위한 필요충분조건은  '상호 배제', '점유와 대기', '비선점', '환형 대기' 입니다.  문제에서 제시된 보기 중 '선점'은 교착 상태 발생 조건이 아닙니다.  선점이란 한 프로세스가 다른 프로세스가 사용 중인 자원을 강제로 빼앗아 사용하는 것을 의미하는데,  만약 자원이 선점 가능하다면,  한 프로세스가 다른 프로세스가 점유하고 있는 자원을 빼앗아 사용할 수 있으므로 교착 상태에 빠질 가능성이 줄어듭니다.  즉, 자원을 선점할 수 있다면 환형 대기 상황이 발생하더라도 교착 상태에 빠지지 않을 수 있습니다. 다른 세 가지 조건은 모두 교착 상태 발생에 필수적인 요소입니다.  상호 배제는 한 번에 하나의 프로세스만 자원을 사용할 수 있도록 제한하는 것이고, 점유와 대기는 프로세스가 적어도 하나의 자원을 점유하고 다른 자원을 기다리는 상황을 말하며, 환형 대기는 여러 프로세스가 순환적으로 서로 다른 프로세스가 점유한 자원을 기다리는 상황을 의미합니다. 따라서 선점 가능한 자원은 교착 상태 발생의 필요충분조건이 아닌 것입니다.",67,44
68,1,1,68,"OSI-7계층에서 종단간 신뢰성 있고 효율적인 데이터를 전송하기 위해 오류검출과 복구, 흐름 제어를 수행하는 계층은?",,전송 계층,세션 계층,표현 계층,응용 계층,1,"OSI 7계층 모델에서 데이터를 안전하고 효율적으로 전송하는 것은 매우 중요합니다.  각 계층은 특정한 역할을 담당하는데,  데이터의 신뢰성 있는 전송을 위해 오류 검출 및 복구, 그리고 데이터 전송 속도를 조절하는 흐름 제어는 특정 계층에서 담당합니다.  우리가 편지(데이터)를 보낼 때,  상대방에게 편지가 제대로 도착했는지 확인하고,  편지가 너무 많이 몰려서 상대방이 감당하지 못하는 일이 없도록 속도를 조절하는 것과 같은 역할이라고 생각하면 됩니다.  이러한 오류 검출 및 복구, 흐름 제어 기능을 담당하는 계층이 바로 전송 계층입니다.  전송 계층은  데이터를  종단 시스템(데이터를 보내는 곳과 받는 곳) 사이에서 신뢰성 있게 전달하기 위해 다양한 프로토콜(예: TCP)을 사용하여  데이터의 순서를 보장하고,  손실된 데이터를 재전송하며,  전송 속도를 조절합니다.  다른 계층들은 각자의 역할에 집중하기 때문에,  종단 간 신뢰성 있는 데이터 전송이라는 목표를 달성하기 위해서는 전송 계층의 역할이 필수적입니다.  따라서 정답은 전송 계층입니다.",78,45
69,1,1,69,IPv6의 주소체계로 거리가 먼 것은?,,Unicast,Anycast,Broadcast,Multicast,3,"IPv6은 차세대 인터넷 프로토콜로, 기존 IPv4보다 훨씬 더 많은 IP 주소를 지원하여 인터넷 연결 장치의 폭발적인 증가에 대응하기 위해 고안되었습니다.  IPv6 주소 체계는 여러 가지 통신 방식을 지원하는데,  '유니캐스트(Unicast)'는 하나의 발신자에서 하나의 수신자로 데이터를 전송하는 방식이고, '애니캐스트(Anycast)'는 여러 대의 서버 중 가장 가까운 서버에 데이터를 전송하는 방식이며, '멀티캐스트(Multicast)'는 하나의 발신자에서 여러 수신자에게 동시에 데이터를 전송하는 방식입니다.  하지만 '브로드캐스트(Broadcast)'는 네트워크 상의 모든 장치에 데이터를 전송하는 방식인데, 이는 IPv6에서는 효율성과 보안 문제로 인해 제한적으로 사용되거나,  전혀 사용되지 않는 경향이 있습니다. IPv6에서는 브로드캐스트 대신 멀티캐스트를 사용하여 여러 대상에 효율적으로 데이터를 전달합니다. 따라서 IPv6의 주소 체계와 거리가 먼 것은 브로드캐스트 방식입니다.  IPv6은 브로드캐스트의 기능을 제한하고, 보다 효율적이고 안전한 통신을 위해 다른 방식들을 채택하고 있기 때문입니다.",74,45
70,1,1,70,TCP/IP 네트워크에서 IP 주소를 MAC 주소로 변환하는 프로토콜은?,,UDP,ARP,TCP,ICMP,2,"TCP/IP 네트워크에서 컴퓨터는 서로 통신하기 위해 IP 주소를 사용합니다.  IP 주소는 네트워크 상의 컴퓨터를 식별하는 논리적인 주소라고 생각하면 됩니다.  하지만 실제로 데이터를 주고받는 물리적인 통신은 네트워크 인터페이스 카드(NIC)의 MAC 주소를 통해 이루어집니다. MAC 주소는 각 네트워크 장비에 고유하게 할당된 물리적인 주소입니다.  IP 주소를 알고 있더라도 상대방 컴퓨터의 MAC 주소를 몰라서는 데이터를 전송할 수 없습니다.  따라서 IP 주소를 MAC 주소로 변환해주는 프로토콜이 필요한데, 이 역할을 하는 것이 바로 ARP(Address Resolution Protocol)입니다.  ARP는 네트워크 상에서 특정 IP 주소를 가지는 컴퓨터의 MAC 주소를 찾아내는 프로토콜입니다.  마치 전화번호부에서 전화번호(IP 주소)를 통해 사람의 주소(MAC 주소)를 찾는 것과 같습니다.  다른 프로토콜들은 각각 다른 네트워크 기능을 담당하기 때문에 IP 주소와 MAC 주소 변환과는 직접적인 관련이 없습니다.",71,45
71,1,1,71,프로세스 상태의 종류가 아닌 것은?,,Ready,Running,Request,Exit,3,"이 문제는 운영체제에서 프로세스의 상태를 묻고 있습니다.  프로세스는 컴퓨터가 실행 중인 프로그램을 의미하는데요, 이 프로세스는 항상 특정 상태에 있습니다.  예를 들어,  프로세스가 CPU를 할당받아 실행 중이라면 '실행' 상태이고, CPU를 할당받기 위해 대기 중이라면 '준비' 상태입니다.  프로세스가 작업을 완료하고 종료되면 '종료' 상태가 됩니다.  문제에서 제시된 '요청' 상태는 프로세스의 일반적인 상태가 아닙니다.  프로세스는 CPU를 요청하거나 자원을 요청할 수 있지만,  '요청' 자체가 프로세스의 상태를 나타내는 것은 아니죠.  '준비', '실행', '종료'는 프로세스의 생명주기에서 명확하게 구분되는 상태를 나타내는 반면, '요청'은 프로세스가 특정 상태로 전이되는 과정에서의 일시적인 상황을 표현하는 단어에 가깝습니다. 따라서 정보처리기사 공식 교재에서 설명하는 프로세스 상태의 종류와 비교해 볼 때, '요청' 상태는 프로세스의 상태로 분류되지 않습니다.",67,44
72,1,1,72,스레드(Thread)에 대한 설명으로 옳지 않은 것은?,,한 개의 프로세스는 여러 개의 스레드를 가질 수 없다.,커널 스레드의 경우 운영체제에 의해 스레드를 운용한다.,사용자 스레드의 경우 사용자가 만든 라이브러리를 사용하여 스레드를 운용한다.,"스레드를 사용함으로써 하드웨어, 운영체제의 성능과 응용 프로그램의 처리율을 향상시킬 수 있다.",1,"이 문제는 스레드(Thread)의 개념에 대한 이해도를 묻고 있습니다.  프로세스는 컴퓨터가 실행하는 프로그램의 독립적인 실행 단위라고 생각하면 됩니다.  반면 스레드는 하나의 프로세스 안에서 동시에 실행되는 더 작은 실행 단위입니다.  마치 한 집(프로세스) 안에 여러 사람(스레드)이 각자 일을 하는 것과 같습니다.  따라서 하나의 프로세스는 여러 개의 스레드를 가질 수 있습니다.  이는 스레드의 가장 기본적인 특징 중 하나입니다.  틀린 설명은 바로 이 부분을 지적하고 있습니다.  나머지 선지는 모두 스레드의 특징을 정확하게 설명하고 있습니다. 커널 스레드는 운영체제가 직접 관리하고, 사용자 스레드는 사용자 프로그램이 관리하는 방식이며, 스레드를 사용하면 여러 작업을 동시에 처리하여 시스템 성능과 응용 프로그램의 처리 속도를 향상시킬 수 있습니다.  따라서, 하나의 프로세스가 여러 개의 스레드를 가질 수 없다는 설명은 잘못된 것입니다.",79,44
73,1,1,73,HRN(Highest Response-ratio Next) 스케줄링 방식에 대한 설명으로 옳지 않은 것은?,,대기 시간이 긴 프로세스의 경우 우선 순위가 높아진다.,SJF 기법을 보완하기 위한 방식이다.,긴 작업과 짧은 작업 간의 지나친 불평등을 해소할 수 있다.,우선 순위를 계산하여 그 수치가 가장 낮은 것부터 높은 순으로 우선 순위가 부여된다.,4,"HRN 스케줄링은 프로세스의 우선순위를 결정하는 방식으로, 단순히 작업 시간만 고려하는 SJF(Shortest Job First) 스케줄링의 단점을 보완하기 위해 고안되었습니다.  SJF는 짧은 작업이 먼저 처리되므로 긴 작업은 계속 대기하게 되어, 긴 작업의 응답 시간이 매우 길어지는 문제가 있습니다.  HRN은 이러한 문제를 해결하기 위해 대기 시간을 고려하여 우선순위를 계산합니다.  대기 시간이 길수록 우선순위가 높아지도록 설계되어, 오랫동안 기다린 프로세스가 먼저 처리될 가능성이 높아집니다.  이는 긴 작업이라도 너무 오랫동안 기다리지 않도록 하여, 긴 작업과 짧은 작업 간의 불평등을 완화하는 효과를 가져옵니다.  따라서,  대기 시간이 긴 프로세스일수록 우선순위가 높아지는 것은 HRN 스케줄링의 핵심 원리입니다.  문제에서 옳지 않다고 하는 선지는 우선순위 계산 방식에 대한 설명인데, HRN은 우선순위를 계산하는 공식을 사용하며, 그 값이 높을수록 우선순위가 높아집니다.  가장 낮은 값부터 처리하는 것이 아니라는 점이 핵심입니다.  쉽게 말해,  오래 기다린 프로세스에게 먼저 처리 기회를 주는 방식이 HRN이며,  이를 위해 계산된 우선순위 값이 높은 프로세스부터 처리하는 것입니다.",70,44
74,1,1,74,IEEE 802.11 워킹 그룹의 무선 LAN 표준화 현황 중 QoS 강화를 위해 MAC 지원 가능을 채택한 것은?,,802.11a,802.11b,802.11g,802.11e,4,"이 문제는 무선랜 표준인 IEEE 802.11의 여러 버전 중에서 QoS(Quality of Service, 서비스 품질) 향상을 위해 MAC 계층에서 QoS 기능을 지원하는 버전을 묻고 있습니다.  QoS는 네트워크 상에서 특정 데이터의 우선순위를 높여 지연 시간을 줄이고, 중요한 데이터의 전송을 보장하는 기술입니다.  예를 들어, 화상회의 중에 음성 데이터가 끊기지 않도록 우선적으로 전송하는 것이 QoS의 대표적인 예시입니다.  초기의 802.11 표준들은 기본적인 데이터 전송에 초점을 맞추었지만,  네트워크 사용이 증가하고 다양한 애플리케이션이 등장하면서 QoS 지원의 필요성이 커졌습니다.  문제에서 제시된 답변 중에서 MAC 계층에서 QoS를 지원하도록 설계된 것은 특정 버전입니다. 이 버전은  다양한 종류의 트래픽에 대해 우선순위를 부여하고, 지연 시간과 대역폭을 효율적으로 관리하여  음성이나 영상과 같은 실시간 애플리케이션의 성능을 향상시키는 기능을 제공합니다. 따라서  QoS 강화를 위해 MAC 지원 가능을 채택한 것은  정답입니다.",61,49
75,1,1,75,C언어에서 사용할 수 없는 변수명은?,,student2019,text-color,_korea,amount,2,"C언어에서 변수명을 지을 때는 몇 가지 규칙을 따라야 합니다.  변수명은 영문자(대소문자 구분), 숫자, 그리고 밑줄(_)을 사용할 수 있습니다.  하지만 가장 중요한 규칙 중 하나는 변수명은 숫자로 시작할 수 없다는 것입니다. 또한, 변수명에는 공백이나 특수 문자(하이픈(-) 등)를 사용할 수 없습니다.  문제에서 제시된 변수명들을 살펴보면, 하나의 변수명은 하이픈(-)을 포함하고 있습니다.  C언어는 이러한 하이픈을 변수명에 사용하는 것을 허용하지 않기 때문에,  그 변수명은 C언어에서 사용할 수 없는 변수명입니다.  다른 변수명들은 모두 C언어의 변수명 규칙에 부합합니다. 따라서 정답은 하이픈을 포함한 변수명입니다.",70,41
76,1,1,76,스크립트 언어가 아닌 것은?,,PHP,Cobol,Basic,Python,2,"이 문제는 다양한 프로그래밍 언어 중에서 스크립트 언어가 아닌 것을 고르는 문제입니다.  스크립트 언어는 컴파일 과정 없이 인터프리터에 의해 바로 실행되는 언어로,  PHP, Basic, Python 등이 대표적인 예시입니다.  이들은 일반적으로 웹 개발, 자동화 스크립트 작성, 빠른 프로토타이핑 등에 사용됩니다. 반면, Cobol은 컴파일 과정을 거쳐 실행되는 절차지향적 프로그래밍 언어로,  주로 대규모 비즈니스 애플리케이션 개발에 사용되어 왔습니다. 따라서 스크립트 언어가 아닌 것은 Cobol입니다.  스크립트 언어는 일반적으로 해석되어 바로 실행되는 반면, Cobol과 같은 컴파일 언어는 먼저 기계어로 변환(컴파일)된 후 실행됩니다. 이러한 차이가 바로 이 문제의 핵심입니다.  쉽게 말해, 스크립트 언어는 ""번역 없이 바로 읽어서 실행하는 언어""이고, Cobol은 ""번역(컴파일)해서 실행하는 언어""라고 생각하면 이해하기 쉬울 것입니다.",61,42
77,1,1,77,"다음의 페이지 참조 열(Page reference string)에 대해 페이지 교체 기법으로 선입선출 알고리즘을 사용할 경우 페이지 부재(Page Fault) 횟수는? (단, 할당된 페이지 프레임 수는 3이고, 처음에는 모든 프레임이 비어 있다.)",https://www.cbtbank.kr/images/iz/iz20200606/iz20200606m77.gif,13,14,15,20,2,"이 문제는 페이지 교체 알고리즘 중 하나인 선입선출(FIFO) 알고리즘을 이해하고 적용하는 문제입니다.  페이지 프레임이 3개라는 것은 동시에 3개의 페이지만 메모리에 적재할 수 있다는 의미입니다.  페이지 참조 열 7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0을 순서대로 따라가며 페이지 부재(Page Fault) 횟수를 계산해 보겠습니다.",56,11
78,1,1,78,C언어에서 배열 b[5]의 값은?,https://www.cbtbank.kr/images/iz/iz20200606/iz20200606m78.gif,0,1,2,3,1,"C언어에서 배열 `b[9]`는 크기가 9인 정수형 배열을 선언하고, `static int b[9] = {1, 2, 3};` 와 같이 초기화를 할 경우,  초기화 리스트에 명시된 값들(1, 2, 3)은 배열의 처음 세 요소(`b[0]`, `b[1]`, `b[2]`)에 각각 할당됩니다.  초기화 리스트에 명시되지 않은 나머지 요소들(`b[3]`, `b[4]`, `b[5]`, `b[6]`, `b[7]`, `b[8]`)은 자동으로 0으로 초기화됩니다. 따라서 `b[5]`의 값은 0입니다.  `static` 키워드는 전역 변수와 같은 의미로, 프로그램 시작 시 메모리에 할당되고 프로그램 종료 시 해제되는 변수를 의미합니다.  문제에서 묻는 것은 `b[5]`의 값이므로, 초기화되지 않은 부분이므로 0이 되는 것입니다.",73,11
79,1,1,79,응집도가 가장 낮은 것은?,,기능적 응집도,시간적 응집도,절차적 응집도,우연적 응집도,4,"소프트웨어 모듈의 응집도는 모듈 내부 요소들의 관련성을 나타내는 척도입니다.  응집도가 높다는 것은 모듈 내부 요소들이 서로 밀접하게 관련되어 하나의 기능을 수행한다는 의미이고, 응집도가 낮다는 것은 모듈 내부 요소들이 서로 관련성이 적거나 아예 무관하다는 것을 의미합니다.  문제에서 가장 낮은 응집도를 묻고 있는데,  이는 모듈 내 요소들이 서로 아무런 관련이 없거나 매우 느슨하게 연결되어 있는 경우를 의미합니다.  예를 들어, 서로 다른 기능을 수행하는 여러 함수들이 하나의 모듈에 우연히 모여 있는 경우가 이에 해당합니다. 이러한 경우 유지보수가 어렵고, 오류 발생 시 문제 해결이 복잡해지며, 재사용성도 떨어집니다.  반면 기능적 응집도는 하나의 기능만을 수행하는 요소들로 구성되어 응집도가 가장 높습니다. 시간적, 절차적 응집도는 기능적 응집도보다는 낮지만,  여전히 요소들 간에 어느 정도의 관련성이 존재합니다. 따라서 가장 낮은 응집도는 서로 관련 없는 요소들이 모여 있는 경우입니다.",80,6
80,1,1,80,JAVA 언어에서 접근제한자가 아닌 것은?,,public,protected,package,private,3,"JAVA에서 접근 제한자는 클래스나 클래스 멤버(변수, 메서드)에 대한 접근 권한을 제어하는 역할을 합니다.  `public`, `protected`, `private`는 모두 접근 제한자로, 각각 다른 접근 수준을 정의합니다.  `public`은 모든 곳에서 접근 가능하고, `protected`는 같은 패키지 내부 또는 상속 관계에 있는 클래스에서 접근 가능하며, `private`는 같은 클래스 내부에서만 접근 가능합니다.  문제에서 제시된  `package`는 접근 제한자가 아닙니다.  `package`는 JAVA에서 클래스들을 논리적으로 그룹화하는 데 사용되는 키워드로, 접근 제어와는 직접적인 관련이 없습니다.  따라서,  JAVA에서 접근 제한자가 아닌 것은 `package`입니다.  쉽게 말해,  `package`는 클래스들을 폴더처럼 묶는 역할을 하는 것이고, 나머지 세 가지는 그 폴더 안에 있는 클래스나 멤버에 대한 접근 권한을 설정하는 역할을 합니다.",75,7
81,1,1,81,Rayleigh-Norden 곡선의 노력 분포도를 이용한 프로젝트 비용 산정기법은?,,Putnam 모형,델파이 모형,COCOMO 모형,기능점수 모형,1,"이 문제는 소프트웨어 개발 프로젝트의 비용을 산정하는 기법 중 하나인 Rayleigh-Norden 곡선을 이용하는 방법을 묻고 있습니다.  Rayleigh-Norden 곡선은 노력(effort)과 시간(time)의 관계를 종 모양의 곡선으로 나타내는데, 프로젝트 초반과 후반에는 노력이 적게 들고, 중간에 노력이 가장 많이 드는 것을 보여줍니다.  이러한 노력 분포도를 이용하여 프로젝트 비용을 예측하는 모델이 바로 Putnam 모형입니다.  Putnam 모형은 Rayleigh-Norden 곡선을 기반으로 개발 노력의 시간적 분포를 모델링하여 프로젝트 기간과 비용을 예측하는 데 사용됩니다.  다른 선택지들은 소프트웨어 개발 비용 산정에 사용되는 다른 기법들을 제시하고 있지만, Rayleigh-Norden 곡선의 노력 분포도를 직접적으로 활용하는 것은 Putnam 모형만의 특징입니다.  따라서 Rayleigh-Norden 곡선을 이용한 프로젝트 비용 산정 기법으로는 Putnam 모형이 가장 적합합니다.  쉽게 말해,  프로젝트의 노력이 시간에 따라 어떻게 변하는지 그래프로 나타내는 방법을 이용해서 비용을 예측하는 모델이라고 생각하면 됩니다.",57,47
82,1,1,82,메모리상에서 프로그램의 복귀 주소와 변수사이에 특정 값을 저장해 두었다가 그 값이 변경되었을 경우 오버플로우 상태로 가정하여 프로그램 실행을 중단하는 기술은?,,모드체크,리커버리 통제,시스로그,스택가드,4,"프로그램이 실행될 때, 메모리에는 프로그램의 실행에 필요한 정보들이 저장됩니다.  그 중 중요한 정보 중 하나가 바로 '복귀 주소'입니다.  함수가 호출되면 현재 실행 위치(복귀 주소)를 메모리의 특정 영역(스택)에 저장해 두었다가 함수 실행이 끝나면 그 주소로 돌아가 실행을 계속합니다.  변수들도 스택에 저장되는데,  만약 악의적인 공격이나 프로그래밍 오류로 인해 스택에 저장된 변수의 값이 너무 커져서(오버플로우) 복귀 주소를 덮어쓰게 되면 프로그램은 잘못된 주소로 돌아가게 되고, 시스템이 예상치 못한 동작을 하거나 심각한 오류를 발생시킬 수 있습니다.",76,11
83,1,1,83,백도어 탐지 방법으로 틀린 것은?,,무결성 검사,닫힌 포트 확인,로그 분석,SetUID 파일 검사,2,"백도어는 악의적인 목적으로 시스템에 숨겨진 비밀 통로입니다.  공격자는 이를 통해 시스템에 무단으로 접근하여 데이터를 탈취하거나 시스템을 손상시킬 수 있습니다.  따라서 백도어 탐지를 위한 다양한 방법들이 존재합니다.  무결성 검사는 시스템 파일이나 데이터의 변조 여부를 확인하여 백도어 설치 여부를 파악하는 방법입니다. 로그 분석은 시스템 로그를 분석하여 의심스러운 활동(예: 비정상적인 접근 시도, 특정 포트의 사용)을 찾아 백도어를 탐지하는 방법입니다. SetUID 파일 검사는 특권을 가진 사용자 권한으로 실행되는 파일들을 검사하여 백도어가 숨겨져 있는지 확인하는 방법입니다.  하지만 닫힌 포트 확인은 백도어 탐지 방법으로 적절하지 않습니다.  백도어는 닫힌 포트를 통해서도 작동할 수 있기 때문입니다.  닫힌 포트는 외부 접근을 차단하는 것이지, 내부에서 작동하는 백도어를 막는 것은 아닙니다.  백도어는 시스템 내부에서 작동하므로 외부에서 포트를 확인하는 것만으로는 탐지가 어렵습니다.  따라서 닫힌 포트 확인은 백도어 탐지에 효과적이지 않은 방법입니다.",71,56
84,1,1,84,IP 또는 ICMP의 특성을 악용하여 특정 사이트에 집중적으로 데이터를 보내 네트워크 또는 시스템의 상태를 불능으로 만드는 공격 방법은?,,TearDrop,Smishing,Qshing,Smurfing,4,"이 문제는 네트워크 공격 기법 중 하나인 Smurfing 공격에 대한 문제입니다. Smurfing 공격은 IP 또는 ICMP 프로토콜의 특징을 악용하여 특정 대상 시스템에 과도한 양의 패킷을 전송하여 시스템을 마비시키는 방식입니다.  쉽게 설명하자면,  여러 대의 컴퓨터를 이용해 특정 목표 사이트에 동시에 메시지를 보내는 것과 같습니다.  마치 수많은 사람들이 한꺼번에 한 곳에 전화를 걸어 전화망을 마비시키는 것과 같은 원리입니다.  IP 브로드캐스트 주소나 ICMP 에코 요청(ping)을 이용하여,  공격자는 자신이 아닌 다른 컴퓨터의 IP 주소를 가짜로 사용하여 목표 사이트에 패킷을 보냅니다.  목표 사이트는 이 패킷들을 모두 처리하려고 하다가 과부하가 걸려 서비스를 제공할 수 없게 되는 것입니다.  따라서 네트워크 또는 시스템의 상태를 불능으로 만드는 공격 방법에 대한 설명과 가장 잘 맞는 것이 Smurfing 공격입니다. 다른 선택지는 다른 종류의 네트워크 공격 또는 피싱 기법을 나타냅니다.",67,45
85,1,1,85,CMM(Capability Maturity Model) 모델의 레벨로 옳지 않은 것은?,,최적단계,관리단계,정의단계,계획단계,4,"CMM(Capability Maturity Model)은 소프트웨어 개발 조직의 성숙도를 5단계로 평가하는 모델입니다.  각 단계는 소프트웨어 개발 프로세스의 안정성과 예측 가능성을 나타내는 지표로,  낮은 단계일수록 프로세스가 불안정하고 예측이 어렵지만, 높은 단계로 갈수록 프로세스가 체계적이고 효율적으로 관리됩니다.  CMM의 5단계는 초기, 관리, 정의, 관리, 최적화 단계로 구성됩니다. 문제에서 제시된 선지 중 '계획단계'는 CMM의 공식적인 레벨이 아니기 때문에 옳지 않은 것입니다.  CMM은 계획 단계를 포함하지 않고,  프로세스의 성숙도를 평가하는 데 초점을 맞추고 있기 때문입니다.  즉,  CMM은 개발 프로세스 자체의 성숙도를 평가하는 것이지,  개별 프로젝트의 계획 단계를 평가하는 것이 아니라는 점을 이해하는 것이 중요합니다.  따라서,  CMM의 레벨로서 '계획단계'는 존재하지 않습니다.",52,47
86,1,1,86,웹과 컴퓨터 프로그램에서 용량이 적은 데이터를 교환하기 위해 데이터 객체를 속성·값의 쌍 형태로 표현하는 형식으로 자바스크립트(JavaScript)를 토대로 개발되어진 형식은?,,Python,XML,JSON,WEB SEVER,3,"문제에서 설명하고 있는 데이터 교환 방식은 용량이 적은 데이터를 속성(key)과 값(value)의 쌍으로 표현하는 형식입니다.  웹 환경에서 자주 사용되는 이유는 가독성이 좋고, 데이터를 간결하게 표현할 수 있기 때문입니다.  자바스크립트 기반으로 개발되었다는 점도 중요한 정보입니다.  제시된 선택지 중에서 속성-값 쌍으로 데이터를 표현하고 자바스크립트 기반으로 개발된 형식은 JSON(JavaScript Object Notation)입니다.  XML도 데이터를 표현하는 형식이지만, JSON보다 구조가 복잡하고 용량이 더 클 수 있습니다. Python은 프로그래밍 언어이고, 웹 서버는 데이터를 교환하는 방식이 아닌 데이터를 제공하는 시스템의 일부입니다. 따라서,  용량이 적은 데이터를 효율적으로 교환하기 위한 속성-값 쌍 형태의 자바스크립트 기반 데이터 표현 방식은 JSON이 가장 적합합니다.",79,42
87,1,1,87,"크래커가 침입하여 백도어를 만들어 놓거나, 설정 파일을 변경했을 때 분석하는 도구는?",,trace,tripwire,udpdump,cron,2,"시스템의 무결성을 감시하는 도구에 대한 문제입니다.  크래커가 시스템에 침입하여 백도어를 심거나 설정 파일을 변경하는 것은 시스템의 무결성을 침해하는 행위입니다.  이러한 침해를 감지하기 위해서는 시스템의 파일이나 설정의 변화를 지속적으로 모니터링하고, 변경 사항이 발생하면 관리자에게 알려주는 도구가 필요합니다.  정답으로 제시된 도구는 바로 이러한 기능을 수행하는 시스템 무결성 감시 도구입니다.  이 도구는 시스템의 특정 파일이나 디렉토리의 변경 사항을 감지하여, 무단 변경이 발생했을 때 관리자에게 경고를 보내줍니다.  따라서 크래커의 침입 흔적을 찾는 데 매우 유용하게 사용될 수 있습니다. 다른 선택지들은 네트워크 패킷 분석(trace, udpdump)이나 시스템 작업 예약(cron)과 관련된 도구이므로 시스템 무결성 감시와는 직접적인 관련이 없습니다.",73,56
88,1,1,88,소프트웨어 개발 프레임워크를 적용할 경우 기대효과로 거리가 먼 것은?,,품질보증,시스템 복잡도 증가,개발 용이성,변경 용이성,2,"소프트웨어 개발 프레임워크는 소프트웨어 개발 과정을 체계화하고 효율성을 높이기 위한 일종의 틀이나 가이드라인입니다.  마치 레고 블록을 조립할 때,  미리 만들어진 블록 세트(프레임워크)를 사용하면  훨씬 쉽고 빠르게 원하는 모양을 만들 수 있는 것과 같습니다.  따라서 프레임워크를 사용하면 개발이 용이해지고(개발 용이성),  나중에 수정이나 변경이 필요할 때도 쉽게 할 수 있습니다(변경 용이성). 또한,  일관된 개발 방식을 적용하여 소프트웨어의 품질을 높이는 데에도 도움이 됩니다(품질보증). 하지만 프레임워크를 도입한다고 해서 무조건 시스템이 단순해지는 것은 아닙니다. 오히려 프레임워크 자체의 복잡성 때문에 시스템 전체의 복잡도가 증가할 수도 있습니다.  이는 프레임워크가 제공하는 기능과 구조를 이해하고 적절히 활용해야 함을 의미하며,  잘못 적용하면 오히려 개발 과정을 더 복잡하게 만들 수 있다는 것을 보여줍니다.  따라서 프레임워크 도입은 신중한 검토와 계획이 필요합니다.",87,48
89,1,1,89,"COCOMO model 중 기관 내부에서 개발된 중소 규모의 소프트웨어로 일괄 자료 처리나 과학기술 계산용, 비즈니스 자료 처리용으로 5만 라인 이하의 소프트웨어를 개발하는 유형은?",,embeded,organic,semi-detached,semi-embeded,2,"COCOMO 모델은 소프트웨어 개발에 필요한 시간과 비용을 예측하는 모델입니다.  문제에서 제시된 상황은 기관 내부에서 개발되는 중소 규모의 소프트웨어(5만 라인 이하)로, 일괄 자료 처리나 과학기술 계산, 비즈니스 자료 처리 등을 목적으로 합니다.  COCOMO 모델은 개발 규모와 복잡도에 따라  Organic, Semi-detached, Embedded 세 가지 유형으로 나뉘는데,  문제에서 설명하는 소프트웨어의 특징은  '기관 내부 개발', '중소 규모', '상대적으로 단순한 기능' 등입니다. 이러한 특징들은  COCOMO 모델에서 'Organic' 유형에 가장 잘 부합합니다.  Organic 유형은 소규모 팀이 개발하며, 요구사항이 명확하고 안정적이며, 개발 과정이 상대적으로 간단한 프로젝트에 적용됩니다.  반면 Semi-detached 유형은 중간 규모의 프로젝트로 요구사항 변경이 어느 정도 발생할 수 있으며, Embedded 유형은 하드웨어와 밀접하게 연동되는 시스템 소프트웨어 개발에 적용됩니다. 따라서 문제의 조건에 가장 적합한 COCOMO 모델 유형은 Organic입니다.",71,47
90,1,1,90,여러 개의 독립된 통신장치가 UWB(Ultra Wideband)기술 또는 블루투스 기술을 사용하여 통신망을 형성하는 무선 네트워크 기술은?,,PICONET,SCRUM,NFC,WI-SUN,1,"문제에서 여러 개의 독립된 통신 장치가 UWB(Ultra Wideband) 기술 또는 블루투스 기술을 사용하여 통신망을 형성하는 무선 네트워크 기술을 묻고 있습니다.  UWB와 블루투스는 모두 근거리 무선 통신 기술로, 여러 장치가 서로 연결되어 통신하는 특징을 가지고 있습니다.  정답은 여러 개의 장치가 하나의 네트워크를 형성하는 개념을 잘 나타내는 용어입니다.  블루투스 통신에서 여러 장치가 연결되는 네트워크 형태를 특히 '피코넷(PICONET)'이라고 부릅니다.  피코넷은 하나의 마스터 장치와 여러 개의 슬레이브 장치로 구성되며, 마스터 장치를 중심으로 통신이 이루어집니다.  따라서 여러 개의 독립된 통신 장치가 UWB 또는 블루투스를 이용하여 통신망을 형성하는 기술을 가장 잘 설명하는 용어는 피코넷입니다.  다른 선지는 NFC는 근거리 무선 통신이지만, 네트워크를 형성하는 개념과는 거리가 있으며, SCRUM은 소프트웨어 개발 방법론, WI-SUN은 저전력 광역 통신 기술입니다.  따라서 문제의 조건에 가장 부합하는 것은 피코넷입니다.",55,49
91,1,1,91,프로토타입을 지속적으로 발전시켜 최종 소프트웨어 개발까지 이르는 개발방법으로 위험관리가 중심인 소프트웨어 생명주기 모형은?,,나선형 모형,델파이 모형,폭포수 모형,기능점수 모형,1,"이 문제는 소프트웨어 개발 방법론 중 프로토타입을 지속적으로 발전시켜 최종 소프트웨어를 개발하는 방식, 그리고 위험 관리에 중점을 두는 모형을 묻고 있습니다.  소프트웨어 개발은 예측 불가능한 요소들이 많아 위험 관리가 매우 중요한데요,  폭포수 모형처럼 한 단계씩 순차적으로 진행하는 방식은 초기 단계의 잘못된 판단이 후반부에 큰 문제를 야기할 수 있습니다.  반면,  정답으로 제시된 모형은 프로토타입(시제품)을 만들어 테스트하고, 그 결과를 바탕으로 개선하는 과정을 반복합니다.  나선형으로 점점 완성도를 높여가는 것이죠.  이러한 반복적인 개발 과정을 통해 위험을 조기에 발견하고 관리하며,  변화하는 요구사항에도 유연하게 대처할 수 있습니다.  다른 선택지들은 위험 관리보다는 다른 측면에 초점을 맞추거나,  소프트웨어 개발 방법론이 아닌 다른 개념을 제시하고 있기 때문에 적절하지 않습니다.  따라서 프로토타입 기반의 반복적 개발과 위험 관리에 초점을 맞춘 나선형 모형이 가장 적합한 답입니다.",74,47
92,1,1,92,다음이 설명하는 용어로 옳은 것은?,https://www.cbtbank.kr/images/iz/iz20200606/iz20200606m92.gif,하둡(Hadoop),비컨(Beacon),포스퀘어(Foursquare),맴리스터(Memristor),1,"문제에서 설명하는 용어는 오픈소스 기반의 분산 컴퓨팅 플랫폼으로, 일반 PC들을 활용하여 대용량 스토리지를 구축하고 빅데이터를 효율적으로 저장 및 처리하는 기능을 가지고 있습니다. 이러한 특징은 바로 하둡(Hadoop)의 핵심 기능과 정확히 일치합니다. 하둡은 수많은 컴퓨터들을 하나의 거대한 시스템처럼 연결하여,  각 컴퓨터가 데이터를 나눠 저장하고 처리하는 분산 처리 방식을 사용합니다.  따라서 일반 PC급 컴퓨터들을 이용해 가상화된 대형 스토리지를 구성하고, 다양한 소스의 빅데이터를 효율적으로 관리하는 데 적합합니다.  반면 다른 선택지는 하둡과 같은 분산 처리 및 빅데이터 저장/처리 기능과는 관련이 없습니다. 비컨은 근거리 무선 통신 기술, 포스퀘어는 위치 기반 서비스 플랫폼, 맴리스터는 새로운 종류의 메모리 소자를 의미하며, 문제에서 제시된 설명과는 부합하지 않습니다.  따라서 문제의 설명에 가장 적합한 용어는 하둡입니다.",76,31
93,1,1,93,소인수 분해 문제를 이용한 공개키 암호화 기법에 널리 사용되는 암호 알고리즘 기법은?,,RSA,ECC,PKI,PEM,1,"이 문제는 소인수분해 문제를 이용한 공개키 암호화 기법에 대해 묻고 있습니다.  공개키 암호화는 두 개의 키, 즉 공개키와 개인키를 사용하는 암호화 방식입니다.  공개키는 누구에게나 공개되어도 되지만, 개인키는 소유자만 알고 있어야 합니다.  암호화는 공개키를 사용하고, 복호화는 개인키를 사용합니다.  이때, 안전성을 보장하기 위해 매우 큰 수의 소인수분해가 어려워야 합니다.  큰 수를 소수의 곱으로 분해하는 것은 계산량이 엄청나게 많아 현재 기술로는 불가능에 가깝기 때문에, 개인키를 알아내는 것이 매우 어렵습니다.  문제에서 언급된 알고리즘 중에서 이러한 소인수분해의 어려움을 기반으로 하는 알고리즘은 RSA 알고리즘입니다. RSA 알고리즘은 매우 큰 두 소수의 곱으로 이루어진 수를 공개키로 사용하고, 이 두 소수를 알아야만 복호화가 가능하도록 설계되어 있습니다.  따라서 소인수분해 문제를 이용한 공개키 암호화 기법에 널리 사용되는 알고리즘은 RSA입니다.  다른 선택지는 각각 다른 암호화 방식이나 개념을 나타내므로 정답이 될 수 없습니다.",79,54
94,1,1,94,"LOC 기법에 의하여 예측된 총 라인수가 50000라인, 프로그래머의 월 평균 생산성이 200라인, 개발에 참여할 프로그래머가 10인 일 때, 개발 소요 기간은?",,25개월,50개월,200개월,2000개월,1,"이 문제는 소프트웨어 개발에 필요한 시간을 계산하는 문제입니다.  문제에서 주어진 정보는 총 라인 수(50,000라인), 프로그래머 1인당 월 평균 생산성(200라인), 그리고 개발에 참여하는 프로그래머 수(10명)입니다.  먼저, 한 명의 프로그래머가 한 달에 200라인을 작성한다면, 10명의 프로그래머는 한 달에 200라인/명 * 10명 = 2000라인을 작성할 수 있습니다.  총 50,000라인을 개발해야 하므로, 필요한 개발 기간은 50,000라인 / 2,000라인/월 = 25개월이 됩니다. 따라서 개발 소요 기간은 25개월입니다.  LOC(Lines of Code) 기법은 소프트웨어의 크기를 코드 라인 수로 측정하여 개발 시간을 예측하는 간단한 방법입니다.  물론 실제 개발 기간은 여러 요인(예: 요구사항 변경, 버그 수정 등)에 따라 달라질 수 있지만, 이 문제에서는 주어진 정보만을 가지고 계산하는 간단한 예시입니다.",86,47
95,1,1,95,최대 홉수를 15로 제한한 라우팅 프로토콜은?,,RIP,OSPF,Static,EIGRP,1,"라우팅 프로토콜은 네트워크 상의 두 지점 간 최적의 경로를 찾아주는 프로토콜입니다.  각 프로토콜은 최대 홉수(한 패킷이 목적지에 도달하기 위해 거쳐야 하는 라우터 수)에 제한을 두는 경우가 있는데,  문제에서 최대 홉수를 15로 제한하는 프로토콜을 묻고 있습니다.  RIP(Routing Information Protocol)은 거리 벡터 라우팅 프로토콜로,  최대 홉수를 15로 제한합니다.  이는 RIP가 홉 수를 세어 경로를 선택하기 때문에, 15홉을 넘어가면 경로를 찾을 수 없도록 설계되었기 때문입니다.  다른 프로토콜들은 최대 홉수에 대한 제한이 없거나, 다른 방식으로 최적 경로를 계산합니다. 따라서 최대 홉수를 15로 제한하는 라우팅 프로토콜은 RIP입니다.  쉽게 말해, RIP는 길찾기 게임에서 최대 15번의 갈림길만 지날 수 있도록 제한하는 것과 같습니다.  15번 이상의 갈림길을 지나야 하는 목적지는 RIP로는 찾을 수 없습니다.",72,49
96,1,1,96,"컴퓨터 사용자의 키보드 움직임을 탐지해 ID, 패스워드 등 개인의 중요한 정보를 몰래 빼가는 해킹 공격은?",,Key Logger Attack,Worm,Rollback,Zombie Worm,1,"이 문제는 컴퓨터 사용자의 키보드 입력을 몰래 기록하여 개인 정보를 빼내는 해킹 기법에 대한 문제입니다.  키보드 입력을 기록하는 악성 프로그램을 사용하여 사용자가 입력하는 ID, 비밀번호, 신용카드 번호 등 중요한 정보를 몰래 빼돌리는 공격 방식을  키로거(Key Logger) 공격이라고 합니다.  키로거는 사용자의 키보드 입력을 감지하여 로그 파일로 저장하거나, 해커의 서버로 실시간으로 전송합니다.  사용자는 자신이 입력하는 정보가 몰래 기록되고 있다는 사실을 전혀 인지하지 못한 채 개인 정보가 유출되는 위험에 노출됩니다.  따라서, 컴퓨터 사용자의 키보드 움직임을 탐지하여 개인 정보를 빼가는 해킹 공격은 키로거 공격이라고 정확하게 정의할 수 있습니다. 다른 선지들은 웜(Worm)이나 좀비 웜(Zombie Worm)처럼 네트워크를 통해 자체적으로 확산되는 악성 프로그램 또는 롤백(Rollback)처럼 시스템 복구와 관련된 용어이므로 문제의 상황과는 맞지 않습니다.",87,56
97,1,1,97,테일러링(Tailoring) 개발 방법론의 내부 기준에 해당하지 않는 것은?,,납기/비용,기술환경,구성원 능력,국제표준 품질기준,4,"테일러링(Tailoring) 개발 방법론은 표준적인 소프트웨어 개발 방법론을 특정 프로젝트의 상황에 맞게 조정하는 것을 의미합니다.  프로젝트의 성공적인 수행을 위해서는  프로젝트의 특성을 고려하여 방법론을 맞춤형으로 조정해야 합니다.  예를 들어, 프로젝트의 납기가 촉박하면 개발 속도를 높이는 방법을 선택해야 하고, 개발팀의 구성원 능력이 부족하다면 교육이나 지원을 강화해야 합니다. 기술 환경 또한 중요한 고려 사항입니다. 사용하는 기술에 따라 개발 방법론을 조정해야 효율적인 개발이 가능합니다.  하지만 국제 표준 품질 기준은 프로젝트의 특성에 따라 바뀌는 것이 아니라, 모든 프로젝트에서 일관되게 적용되어야 하는 객관적인 기준입니다. 따라서 프로젝트의 특성에 맞춰 조정하는 테일러링의 대상이 될 수 없습니다.  국제 표준 품질 기준은 프로젝트의 품질을 보장하기 위한 외부적인 기준이며, 테일러링은 프로젝트의 내부적인 요소들을 고려하여 방법론을 조정하는 것이기 때문입니다.  즉, 테일러링은 프로젝트의 내부적인 상황(납기, 비용, 기술 환경, 구성원 능력 등)에 맞춰 방법론을 조정하는 것이지, 외부적인 기준인 국제 표준 품질 기준을 조정하는 것이 아니라는 점을 이해하는 것이 중요합니다.",60,48
98,1,1,98,폭포수 모형의 특징으로 거리가 먼 것은,,개발 중 발생한 요구사항을 쉽게 반영할 수 있다.,순차적인 접근방법을 이용한다.,단계적 정의와 산출물이 명확하다.,모형의 적용 경험과 성공사례가 많다.,1,"폭포수 모형은 소프트웨어 개발 과정을 여러 단계로 나누어 순차적으로 진행하는 방식입니다.  각 단계는 명확하게 정의되고, 이전 단계가 완료되어야만 다음 단계로 진행할 수 있습니다.  따라서 단계적 정의와 산출물이 명확하다는 특징을 가지고 있으며, 오랫동안 사용되어 많은 적용 경험과 성공 사례가 축적되어 있습니다.  하지만 개발 과정 중에 새로운 요구사항이 발생하면 이를 반영하기 어렵다는 단점이 있습니다.  왜냐하면 이미 다음 단계로 진행되었거나, 이전 단계로 돌아가 수정하는 것이 매우 어렵고 비용이 많이 들기 때문입니다.  따라서 개발 중 발생한 요구사항을 쉽게 반영할 수 있다는 것은 폭포수 모형의 특징이라고 보기 어렵습니다.  결론적으로, 폭포수 모형의 순차적이고 단계적인 특성 때문에 개발 중 요구사항 변경에 유연하게 대처할 수 없다는 점이 문제의 핵심입니다.",84,47
99,1,1,99,다음 설명의 정보보안 침해 공격 관련 용어는?,https://www.cbtbank.kr/images/iz/iz20200606/iz20200606m99.gif,Smishing,C-brain,Trojan Horse,Ransomware,4,"문제에서 제시된 설명은 이미지로 제공되었으나, 이미지 내용을 알 수 없다는 점이 아쉽습니다. 하지만 문제의 핵심은 ""정보보안 침해 공격 관련 용어""를 찾는 것이므로, 제시된 보기들을 살펴보면 정답을 유추할 수 있습니다.  Smishing은 SMS를 이용한 피싱이고, C-brain은 문제와 관련이 없는 용어입니다. Trojan Horse는 악성 코드의 일종으로, 사용자에게 알리지 않고 시스템에 침입하여 정보를 훔치거나 시스템을 손상시키는 방식입니다. Ransomware는 컴퓨터 시스템이나 파일을 암호화하고, 암호 해제를 위해 금전을 요구하는 악성 프로그램입니다.  보기 중에서 정보보안 침해 공격과 가장 직접적으로 관련된 용어는 Ransomware입니다. Ransomware는 최근 급증하는 사이버 공격의 주요 유형으로,  정보의 가치를 돈으로 전환하여 피해를 입히는 대표적인 예시입니다. 따라서,  제공된 보기 중 정보보안 침해 공격과 가장 잘 맞는 용어는 랜섬웨어입니다.  정보처리기사 공식 교재에서도 랜섬웨어에 대한 설명을 찾아볼 수 있을 것입니다.  다른 보기들은 정보보안과 관련은 있지만, 문제에서 요구하는 핵심적인 공격 유형을 명확하게 나타내지는 않습니다.",83,55
100,1,1,100,시스템 내의 정보는 오직 인가된 사용자만 수정할 수 있는 보안 요소는?,,기밀성,부인방지,가용성,무결성,4,"시스템 내 정보의 무결성이란 정보의 정확성과 신뢰성을 유지하는 것을 의미합니다.  즉, 정보가 허락되지 않은 변경이나 손상으로부터 보호되는 상태를 말하죠. 문제에서 ""인가된 사용자만 수정할 수 있는 보안 요소""를 묻고 있는데, 이는 정보의 무결성을 보장하는 핵심적인 요소입니다.  만약 인가되지 않은 사용자가 정보를 수정할 수 있다면, 정보의 정확성과 신뢰성이 훼손되어 시스템 전체의 안정성에 심각한 문제가 발생할 수 있습니다.  다른 선택지들은 정보 보안의 다른 측면을 나타내지만,  인가되지 않은 수정으로부터 정보를 보호하는 직접적인 요소는 무결성입니다.  예를 들어, 은행 계좌 정보가 허락 없이 변경된다면, 그것은 무결성이 깨진 것입니다.  따라서 시스템 내 정보를 오직 인가된 사용자만 수정할 수 있도록 하는 보안 요소는 정보의 무결성을 보장하는 기능이라고 할 수 있습니다.",45,53
101,1,2,1,요구사항 분석 시에 필요한 기술로 가장 거리가 먼 것은?,,청취와 인터뷰 질문 기술,분석과 중재기술,설계 및 코딩 기술,관찰 및 모델 작성 기술,3,"요구사항 분석은 사용자의 요구를 정확하게 파악하고 시스템에 반영하는 과정입니다.  이 과정에는 사용자와의 소통, 요구사항의 분석 및 정리, 그리고 시스템에 대한 모델링 등이 포함됩니다.  사용자 인터뷰를 통해 요구사항을 청취하고, 분석하여 우선순위를 정하고,  관찰을 통해 사용자의 행동 패턴을 파악하여 모델을 만드는 등의 활동이 중요합니다.  하지만,  실제 시스템을 구현하는 설계 및 코딩은 요구사항 분석 *이후*에 진행되는 단계입니다.  요구사항 분석 단계에서는 사용자의 요구를 명확히 이해하고 문서화하는 데 집중해야 하며,  코딩과 같은 구현 단계의 기술은 아직 필요하지 않습니다. 따라서 설계 및 코딩 기술은 요구사항 분석 시에 필요한 기술과는 거리가 멉니다.  마치 건물을 짓기 전에 설계도를 그리는 것과 같이, 요구사항 분석은 건물의 설계도를 그리는 단계이고, 코딩은 실제 건물을 짓는 단계라고 생각하면 이해하기 쉽습니다.",90,2
102,1,2,2,다음 내용이 설명하는 디자인 패턴은?,https://www.cbtbank.kr/images/iz/iz20200822/iz20200822m2.gif,Visitor패턴,Observer패턴,Factory Method 패턴,Bridge 패턴,3,"문제에서 설명하는 디자인 패턴은 객체 생성을 위한 인터페이스를 제공하지만, 실제 어떤 객체를 생성할지는 서브클래스에서 결정하는 방식입니다.  마치 레스토랑 메뉴판(인터페이스)을 보고 고객(서브클래스)이 원하는 메뉴(객체)를 선택하는 것과 같습니다.  메뉴판 자체는 스테이크, 파스타 등 각 메뉴의 종류를 보여주지만, 실제 스테이크를 만들지 파스타를 만들지는 주방장(서브클래스)이 결정합니다.  이처럼 객체 생성 과정을 추상화하여 서브클래스에서 구체적인 객체 생성을 담당하게 하는 패턴이 바로 Factory Method 패턴입니다.  ""Virtual Constructor""라는 별칭도 이러한 객체 생성의 추상화를 강조하는 표현입니다.  다른 패턴들은 객체 생성과는 직접적인 관련이 적거나, 객체 생성 방식이 다릅니다.  따라서 문제의 설명에 가장 잘 맞는 디자인 패턴은 Factory Method 패턴입니다.",73,7
103,1,2,3,럼바우 객체 지향 분석과 거리가 먼 것은?,,기능 모델링,동적 모델링,객체 모델링,정적 모델링,4,"럼바우 객체 지향 분석은 시스템을 객체들의 상호작용으로 모델링하는 방법입니다.  객체는 데이터(속성)와 그 데이터를 조작하는 행위(메소드)를 함께 갖는 개념입니다.  럼바우 방법론은 시스템의 정적인 구조(객체들의 관계)와 동적인 행위(객체들의 상호작용)를 모두 모델링합니다.  객체 모델링은 객체들의 구조와 관계를 나타내는 정적인 측면을, 동적 모델링은 객체들의 상호작용과 시간에 따른 변화를 나타내는 동적인 측면을 다룹니다. 기능 모델링은 시스템이 수행하는 기능들을 중심으로 모델링하는 방식입니다.  따라서 럼바우 객체 지향 분석은 객체 모델링과 동적 모델링을 포함하지만, 정적 모델링만을 다루지는 않습니다. 정적 모델링은 시스템의 구조와 관계를 나타내는 데 초점을 맞추지만, 객체의 행위나 상호작용은 고려하지 않을 수 있습니다.  럼바우 방법론은 객체의 행위와 상호작용을 중요하게 다루기 때문에 정적 모델링만으로는 럼바우 분석을 완벽하게 표현할 수 없습니다.  즉, 럼바우 객체 지향 분석은 정적인 측면뿐 아니라 동적인 측면도 고려해야 하므로, 정적 모델링만으로는 부족합니다.  다른 선택지들은 모두 럼바우 객체 지향 분석의 핵심 요소이거나 관련된 개념입니다.",92,7
104,1,2,4,애자일 기법에 대한 설명으로 맞지 않은 것은?,,절차와 도구보다 개인과 소통을 중요하게 생각한다.,계획에 중점을 두어 변경 대응이 난해하다.,소프트웨어가 잘 실행되는데 가치를 둔다.,고객과의 피드백을 중요하게 생각한다.,2,"애자일 기법은 소프트웨어 개발 방식 중 하나로,  변화에 유연하게 대처하고 고객 만족도를 높이는 데 중점을 둡니다.  기존의 폭포수 모델처럼 처음부터 모든 것을 완벽하게 계획하고 진행하는 것이 아니라,  짧은 주기(스프린트)를 통해 개발을 반복하며,  각 주기마다 고객의 피드백을 받아 수정하고 개선해 나갑니다.  따라서 고객과의 소통과 개인의 역량을 중요시하며,  작동하는 소프트웨어를 빠르게 제공하는 것을 목표로 합니다.  문제에서 틀린 설명은  '계획에 중점을 두어 변경 대응이 난해하다' 입니다. 애자일은 오히려 계획보다 유연성과 변경 대응에 훨씬 더 중점을 두는 개발 방식입니다.  계획은 있지만, 그 계획은 고정적인 것이 아니라,  변화에 따라 유연하게 조정될 수 있도록 설계되어 있습니다.",92,2
105,1,2,5,미들웨어 솔루션의 유형에 포함되지 않는 것은?,,WAS,Web Server,RPC,ORB,2,"이 문제는 미들웨어 솔루션의 종류를 묻고 있습니다. 미들웨어는 애플리케이션과 운영체제 사이에서 동작하며 애플리케이션 간의 상호 작용을 원활하게 해주는 소프트웨어입니다.  WAS(Web Application Server), RPC(Remote Procedure Call), ORB(Object Request Broker)는 모두 애플리케이션들이 서로 통신하고 데이터를 주고받을 수 있도록 중계 역할을 하는 대표적인 미들웨어 솔루션의 유형입니다.  반면에 웹 서버는 정적인 콘텐츠(HTML, 이미지 등)를 제공하는 역할을 주로 담당하며, 애플리케이션 간의 상호 작용을 직접적으로 중계하는 미들웨어의 기능은 수행하지 않습니다.  웹 서버는 미들웨어와 함께 사용될 수 있지만, 그 자체로 미들웨어 솔루션의 유형으로 분류되지는 않습니다. 따라서 웹 서버는 미들웨어 솔루션의 유형에 포함되지 않는 것이 맞습니다.  쉽게 말해,  웹 서버는 집의 현관문과 같다면, 미들웨어는 집 안에서 방과 방 사이를 연결해주는 통로와 같다고 생각할 수 있습니다.  웹 서버는 외부에서 접근할 수 있도록 문을 열어주는 역할이고, 미들웨어는 집 안의 여러 방(애플리케이션)들이 서로 소통할 수 있도록 연결해주는 역할입니다.",73,10
106,1,2,6,UML에서 시퀀스 다이어그램의 구성 항목에 해당하지 않는 것은?,,생명선,실행,확장,메시지,3,"UML 시퀀스 다이어그램은 시스템 구성 요소 간의 상호 작용을 시간 순서대로 보여주는 다이어그램입니다.  생명선은 각 구성 요소를 나타내는 수직선이고, 메시지는 구성 요소 간의 상호 작용을 나타내는 화살표입니다.  실행은 특정 작업이나 메서드의 실행을 나타내는 사각형으로 생명선 위에 표시되며, 메시지의 전달과 수신을 시각적으로 보여줍니다.  따라서 생명선, 실행, 메시지는 모두 시퀀스 다이어그램의 필수 구성 요소입니다.  하지만 '확장'은 시퀀스 다이어그램의 기본 구성 요소가 아니며, 특정 조건 하에서 발생하는 예외적인 상황이나 대체적인 흐름을 나타낼 때 사용하는 선택적인 요소입니다.  즉, 시퀀스 다이어그램을 이해하고 그리는 데는 필수적이지 않은 부분입니다.  따라서 시퀀스 다이어그램의 구성 항목에 해당하지 않는 것은 '확장'입니다.  마치 레시피에 기본 재료는 필수지만, 특별한 경우에만 추가하는 재료가 있는 것과 같습니다.  시퀀스 다이어그램의 기본적인 틀을 이해하는 데는 '확장'이 필요하지 않습니다.",63,2
107,1,2,7,객체지향에서 정보 은닉과 가장 밀접한 관계가 있는 것은?,,Encapsulation,Class,Method,Instance,1,"객체지향 프로그래밍에서 정보 은닉(Data Hiding)이란, 객체 내부의 데이터를 외부에서 직접 접근하지 못하도록 숨기는 것을 의미합니다.  이는 객체의 내부 구현 방식을 변경하더라도 외부에서 사용하는 방식을 바꿀 필요가 없도록 하여,  소프트웨어의 유지보수 및 확장성을 높이는 데 매우 중요한 개념입니다.  정보 은닉을 통해 데이터의 무결성을 보장하고,  잘못된 데이터 접근으로 인한 오류를 방지할 수 있습니다.  이러한 정보 은닉을 구현하는 핵심적인 개념이 바로 캡슐화(Encapsulation)입니다.  캡슐화는 데이터와 데이터를 처리하는 메서드(함수)를 하나의 단위로 묶어서 외부로부터 데이터를 보호하고,  메서드를 통해서만 데이터에 접근할 수 있도록 제어하는 것을 말합니다.  클래스(Class)는 객체의 설계도 역할을 하고, 메서드(Method)는 객체가 수행하는 동작을, 인스턴스(Instance)는 클래스를 바탕으로 생성된 실제 객체를 나타내지만, 정보 은닉과 가장 직접적으로 관련된 개념은 데이터와 메서드를 하나로 묶어 보호하는 캡슐화입니다.  마치 집의 내부를 외부인으로부터 보호하는 벽과 같은 역할을 한다고 생각하면 이해하기 쉬울 것입니다.",89,7
108,1,2,8,디자인 패턴 중에서 행위적 패턴에 속하지 않는 것은?,,커맨드 (Command) 패턴,옵저버 (Observer) 패턴,프로토타입 (Prototype) 패턴,상태 (State) 패턴,3,"디자인 패턴은 소프트웨어 개발에서 자주 발생하는 문제에 대한 재사용 가능한 해결책을 제공하는 설계 패턴입니다.  크게 생성 패턴, 구조 패턴, 행위 패턴으로 나뉘는데,  행위 패턴은 객체나 클래스 사이의 알고리즘과 책임 분배에 초점을 맞춥니다.  문제에서 제시된 옵저버 패턴, 커맨드 패턴, 상태 패턴은 모두 객체 간의 상호작용과 책임 분담을 다루는 행위 패턴의 예시입니다.  반면, 프로토타입 패턴은 객체의 생성 과정에 초점을 맞추어, 기존 객체를 복제하여 새로운 객체를 생성하는 방법을 제공합니다.  따라서 객체의 생성 방식을 다루는 프로토타입 패턴은 행위 패턴이 아닌 생성 패턴에 속합니다.  쉽게 말해, 행위 패턴은 '어떻게 협력할까?'에 대한 해답을 제시하는 반면, 프로토타입 패턴은 '어떻게 만들까?'에 대한 해답을 제시하는 것이죠.  따라서 행위적 패턴에 속하지 않는 것은 프로토타입 패턴입니다.",71,7
109,1,2,9,UI 설계 원칙 중 누구나 쉽게 이해하고 사용할 수 있어야 한다는 원칙은?,,희소성,유연성,직관성,멀티운용성,3,"UI 설계의 핵심 목표는 사용자가 쉽고 편리하게 시스템을 이용할 수 있도록 하는 것입니다.  마치 잘 설계된 도로처럼, 목적지에 쉽게 도달할 수 있도록 직관적인 경로를 제공해야 합니다.  문제에서 제시된 원칙은 바로 이러한 사용자 중심의 설계 철학을 반영하고 있습니다.  사용자가 별도의 설명이나 교육 없이도 시스템의 기능을 쉽게 이해하고 사용할 수 있도록 하는 것이 중요하며, 이러한 특징을 가장 잘 나타내는 용어가 바로 '직관성'입니다.  다른 선택지들은 UI 설계와 직접적인 관련이 적거나, UI 설계의 부차적인 요소를 나타냅니다. 따라서 사용자의 편의성을 최우선으로 고려하는 UI 설계 원칙에 가장 적합한 답은 '누구나 쉽게 이해하고 사용할 수 있는' 특성을 의미하는 '직관성'입니다.",93,5
110,1,2,10,코드의 기본 기능으로 거리가 먼 것은?,,복잡성,표준화,분류,식별,1,"코드의 기본 기능은 데이터를 처리하고 특정 작업을 수행하는 데 있습니다.  코드는 데이터를 분류하고, 특정 데이터를 식별하며, 표준화된 방식으로 작성되어 다른 사람들이 이해하고 활용할 수 있도록 합니다.  하지만 '복잡성'은 코드의 본질적인 기능이라기보다는 코드를 작성하고 유지보수하는 과정에서 발생하는 부수적인 현상입니다.  잘 작성된 코드는 복잡성을 최소화하도록 노력하지만, 복잡성 자체가 코드의 목표나 기능이 되는 것은 아닙니다.  따라서 코드의 기본 기능과 거리가 먼 것은 복잡성입니다.  정보처리기사 공식 교재에서 코드의 목적은 문제 해결 및 자동화이며, 이를 위해서는 표준화, 분류, 식별 등의 기능이 필수적임을 확인할 수 있습니다.  복잡성은 오히려 이러한 기능을 방해하는 요소로 작용할 수 있습니다.",94,6
111,1,2,11,다음 ( ) 안에 들어갈 내용으로 옳은 것은?,https://www.cbtbank.kr/images/iz/iz20200822/iz20200822m11.gif,협약(Contract),프로토콜(Protocol),패턴(Pattern),관계(Relation),1,"컴포넌트 설계에서 '협약(Contract)'에 기반한 설계는 컴포넌트가 다른 컴포넌트와 상호작용할 때, 그 상호작용의 조건을 명확하게 정의하는 것을 의미합니다.  마치 계약서처럼 말이죠.  컴포넌트가 어떤 작업을 수행하기 전에 충족되어야 하는 조건(선행조건), 작업 수행 후에 보장되어야 하는 결과(결과조건), 그리고 작업 수행 중 항상 유지되어야 하는 조건(불변조건)을 명시적으로 정의함으로써, 컴포넌트 간의 상호운용성과 안정성을 높일 수 있습니다.  문제에서 제시된 (1) 선행조건, (2) 결과조건, (3) 불변조건은 바로 이러한 협약(Contract)의 핵심 요소들을 설명하고 있습니다.  프로토콜은 통신규약, 패턴은 반복되는 문제에 대한 해결책, 관계는 데이터베이스에서의 개념으로, 문제에서 설명하는 컴포넌트 간의 상호작용 조건을 정의하는 데는 적합하지 않습니다. 따라서 컴포넌트 간의 명확한 상호작용 조건을 정의하는 방법으로 '협약(Contract)'이 가장 적절한 답입니다.  이는 소프트웨어 공학에서 컴포넌트 기반 개발의 중요한 개념이며, 정보처리기사 공식 교재에서도 자세히 다루고 있는 내용입니다.",81,6
112,1,2,12,"UML에서 활용되는 다이어그램 중, 시스템의 동작을 표현하는 행위(Behavioral) 다이어그램에 해당하지 않는 것은?",,유스케이스 다이어그램(Use Case Diagram),시퀀스 다이어그램(Sequence Diagram),활동 다이어그램(Activity Diagram),배치 다이어그램(Deployment Diagram),4,"이 문제는 UML 다이어그램 중 시스템의 동작을 표현하는 다이어그램을 묻고 있습니다.  UML(Unified Modeling Language)은 소프트웨어 시스템을 시각적으로 모델링하는 표준 언어입니다.  여기서 '행위(Behavioral) 다이어그램'이란 시스템이 어떻게 동작하는지, 어떤 흐름으로 진행되는지를 보여주는 다이어그램을 의미합니다.  유스케이스 다이어그램은 사용자의 관점에서 시스템의 기능을 보여주고, 시퀀스 다이어그램은 객체 간의 상호작용을 시간 순서대로 보여주며, 활동 다이어그램은 시스템의 활동 흐름을 보여줍니다.  이들은 모두 시스템의 동작을 설명하는 데 사용됩니다.  반면에, 정답으로 제시된 다이어그램은 시스템의 물리적인 배치, 즉 하드웨어 구성 요소와 그들의 연결 관계를 나타냅니다.  시스템의 동작과는 직접적인 관련이 없으므로 행위 다이어그램에 포함되지 않습니다.  쉽게 말해,  행위 다이어그램은 시스템이 '무엇을 하는가'를 보여주는 것이고, 정답으로 제시된 다이어그램은 시스템이 '어디에 있는가'를 보여주는 것입니다. 따라서 정답은 시스템의 동작을 표현하는 다이어그램이 아닌 것을 고르는 문제에서 정답이 됩니다.",71,2
113,1,2,13,객체 지향 소프트웨어 공학에서 하나 이상의 유사한 객체들을 묶어서 하나의 공통된 특성을 표현한 것은?,,트랜지션,클래스,시퀀스,서브루틴,2,"객체 지향 소프트웨어 공학은 현실 세계의 개념을 객체라는 단위로 모델링하여 소프트웨어를 개발하는 방법입니다.  여러 개의 자동차를 생각해 보세요. 각 자동차는 색깔, 모델, 속도 등의 고유한 특징(속성)을 가지고 있고, 달리다, 멈추다 등의 행동(메소드)을 할 수 있습니다.  이처럼 유사한 특징과 행동을 공유하는 여러 객체들을 하나로 묶어서 표현하는 것이 바로 '클래스'입니다.  클래스는 객체들의 설계도와 같다고 생각하면 됩니다.  클래스를 정의하면, 그 클래스를 바탕으로 여러 개의 객체(자동차)를 만들 수 있습니다.  따라서 하나 이상의 유사한 객체들을 묶어 공통된 특성을 표현한 것은 클래스가 됩니다.  다른 선택지는 객체 지향 프로그래밍과는 직접적인 관련이 없습니다. 트랜지션은 상태 변화를, 시퀀스는 객체 간의 상호 작용 순서를, 서브루틴은 특정 기능을 수행하는 코드 블록을 나타냅니다.",92,7
114,1,2,14,아래의 UML 모델에서 '차' 클래스와 각 클래스의 관계로 옳은 것은?,https://www.cbtbank.kr/images/iz/iz20200822/iz20200822m14.gif,추상화 관계,의존 관계,일반화 관계,그룹 관계,3,"문제에서 제시된 UML 모델은 '차'라는 상위 개념(부모 클래스) 아래에 '버스', '트럭', '택시'라는 하위 개념(자식 클래스)들이 속해있는 구조를 보여줍니다.  이는 '차'라는 일반적인 개념에서 각각의 특징을 가진 세부적인 종류들이 파생되는 것을 의미합니다.  이러한 관계를 객체지향 프로그래밍에서 '일반화 관계'라고 합니다.  '일반화'는 상위 클래스가 하위 클래스의 공통적인 속성과 행위를 정의하고, 하위 클래스는 상위 클래스의 속성과 행위를 상속받으면서 자신만의 특징을 추가하는 관계를 말합니다.  예를 들어, '차' 클래스가 '바퀴'라는 속성과 '주행'이라는 행위를 가지고 있다면, '버스', '트럭', '택시' 클래스는 이러한 속성과 행위를 상속받으면서 각각 '승객 수', '적재량', '요금' 등의 자신만의 고유한 속성을 추가할 수 있습니다.  따라서 '차'와 그 하위 클래스들의 관계는 일반화 관계로 정확하게 표현됩니다.  다른 관계들은 이러한 상속과 일반화의 개념을 반영하지 못합니다. 추상화는 공통적인 특징을 추출하는 과정이고, 의존 관계는 한 클래스가 다른 클래스의 기능에 의존하는 관계이며, 그룹 관계는 클래스들을 그룹으로 묶는 관계입니다.  이 문제의 그림은 명확하게 상속과 일반화의 관계를 보여주고 있으므로 일반화 관계가 가장 적절한 답입니다.",75,2
115,1,2,15,객체지향 소프트웨어 설계시 디자인 패턴을 구성하는 요소로서 가장 거리가 먼 것은?,,개발자이름,문제 및 배경,사례,샘플코드,1,"객체지향 소프트웨어 설계에서 디자인 패턴은 소프트웨어 개발 과정에서 자주 발생하는 문제들을 해결하기 위한 재사용 가능한 솔루션을 제공하는 일종의 템플릿입니다.  디자인 패턴은 특정 문제에 대한 해결책을 제공하는데, 이는 일반적으로 문제 상황, 해결 방법, 그리고 그 방법을 적용한 예시 코드 등으로 구성됩니다.  개발자의 이름은 디자인 패턴 자체의 구성 요소가 아니며, 디자인 패턴을 사용하는 개발자의 개인적인 정보일 뿐입니다.  디자인 패턴은 문제와 배경, 해결 사례, 그리고 샘플 코드를 통해 설명되고 이해되기 때문에 개발자의 이름은 디자인 패턴의 본질적인 요소와는 거리가 멉니다.  마치 요리 레시피에 요리사의 이름이 필수적인 요소가 아닌 것과 같습니다.  레시피는 재료(문제), 조리법(해결책), 완성된 요리(사례), 그리고 사진(샘플코드)으로 구성되어 있지 요리사의 이름으로 구성되어 있지는 않죠. 디자인 패턴도 마찬가지입니다.",93,7
116,1,2,16,자료 사전에서 자료의 반복을 의미하는 것은?,,=,( ),{ },[ ],3,"자료 사전에서 자료의 반복을 나타내는 기호는 중괄호 `{}`입니다.  프로그래밍이나 자료구조를 공부해본 적이 있다면 익숙할 수 있는데요,  중괄호 안에는 같은 종류의 자료가 여러 개 들어갈 수 있습니다.  예를 들어, 학생들의 이름을 저장하는 자료 사전이 있다면,  같은 이름의 학생이 여러 명 있을 수 있죠. 이럴 때 중괄호를 사용하여 같은 이름의 학생들을 하나의 집합으로 묶어 표현할 수 있습니다.  다른 기호들은 자료의 반복을 나타내는 데 적합하지 않습니다.  따라서 자료의 반복을 의미하는 기호는 중괄호 `{}`입니다.  쉽게 생각하면, 같은 종류의 여러 데이터를 하나로 묶는 상자라고 생각하면 됩니다.",81,11
117,1,2,17,"객체지향 설계 원칙 중, 서브타입(상속받은 하위 클래스)은 어디에서나 자신의 기반타입(상위클래스)으로 교체할 수 있어야 함을 의미하는 원칙은?",,ISP(Interface Segregation Principle),DIP(Dependency Inversion Principle),LSP(Liskov Substitution Principle),SRP(Single Responsibility Principle),3,"객체지향 설계의 핵심 원칙 중 하나는 상속을 통해 만들어진 하위 클래스(서브타입)가 상위 클래스(기반타입)를 대체해서 사용될 수 있어야 한다는 것입니다.  마치 레고 블록처럼, 큰 블록(상위 클래스) 대신에 작고 기능이 추가된 블록(하위 클래스)을 끼워 넣어도 전체 시스템이 제대로 작동해야 한다는 의미입니다.  만약 하위 클래스가 상위 클래스를 제대로 대체하지 못한다면, 시스템의 안정성과 유지보수에 심각한 문제가 발생할 수 있습니다.  이러한 원칙을 만족하는 설계는 코드의 재사용성을 높이고, 시스템의 유연성과 확장성을 보장합니다.  문제에서 제시된 원칙은 바로 이러한 개념을 명확하게 설명하고 있습니다.  하위 클래스가 상위 클래스를 어떤 상황에서도 대체 가능해야 한다는 것은 객체지향 설계의 기본적인 전제이자, 안정적인 시스템 구축을 위한 필수적인 조건입니다.  따라서,  서브타입이 기반타입을 대체할 수 있어야 한다는 원칙이 정답입니다.",71,7
118,1,2,18,자료흐름도(Data Flow Diagram)의 구성요소로 옳은 것은?,,"process, data flow, data store, comment","process, data flow, data store, terminator","data flow, data store, terminator, data dictionary","process, data store, terminator, mini-spec",2,"자료흐름도(DFD)는 시스템의 자료 흐름을 그림으로 표현하는 기법입니다.  시스템 내에서 어떤 자료가 어떻게 처리되고 이동하는지를 시각적으로 보여주어 시스템 분석 및 설계에 매우 유용하게 사용됩니다.  자료흐름도를 구성하는 기본 요소는 크게 네 가지로, 자료의 처리를 담당하는 '프로세스(Process)', 자료가 이동하는 경로를 나타내는 '자료흐름(Data Flow)', 자료를 저장하는 '자료 저장소(Data Store)', 그리고 시스템과 상호작용하는 외부 개체인 '종단(Terminator)'입니다.  '주석(Comment)', '데이터 사전(Data Dictionary)', '미니 사양서(Mini-Spec)'는 자료흐름도의 구성 요소가 아니고,  자료흐름도를 보조 설명하거나 추가적인 정보를 제공하는 부가적인 요소입니다. 따라서 자료흐름도의 핵심 구성 요소는 프로세스, 자료흐름, 자료 저장소, 그리고 종단입니다.",87,3
119,1,2,19,CASE(Computer-Aided Software Engineering)도구에 대한 설명으로 거리가 먼 것은?,,소프트웨어 개발 과정의 일부 또는 전체를 자동화하기 위한 도구이다.,표준화된 개발 환경 구축 및 문서 자동화 기능을 제공한다.,작업 과정 및 데이터 공유를 통해 작업자간 커뮤니케이션을 증대한다.,"2000년대 이후 소개되었으며, 객체지향 시스템에 한해 효과적으로 활용된다.",4,"CASE 도구는 소프트웨어 개발 과정을 효율적으로 지원하는 도구입니다.  소프트웨어 개발의 여러 단계를 자동화하거나, 표준화된 개발 환경을 제공하여 개발자 간의 협업을 원활하게 하고, 문서 작업을 자동화하는 등의 기능을 제공합니다.  개발 과정에서 발생하는 여러 가지 작업들을 자동화하고, 데이터를 공유함으로써 개발자들 간의 소통을 더욱 원활하게 만들어주는 것이 CASE 도구의 주요 목적입니다.  하지만 CASE 도구는 소프트웨어 개발 전반에 걸쳐 사용되는 도구이며, 특정 시대(2000년대 이후)에 등장하거나 특정 시스템(객체지향 시스템)에만 국한되어 사용되는 것은 아닙니다.  CASE 도구는  절차적 프로그래밍 방식을 사용하는 소프트웨어 개발에도 활용될 수 있으며,  오래전부터 소프트웨어 개발에 사용되어 왔습니다. 따라서,  CASE 도구에 대한 설명 중  특정 시대나 특정 시스템에 한정 지어 설명하는 것은 사실과 다릅니다.",84,3
120,1,2,20,인터페이스 요구 사항 검토 방법에 대한 설명이 옳은 것은?,,"리팩토링 : 작성자 이외의 전문 검토 그룹이 요구사항 명세서를 상세히 조사하여 결함, 표준 위배, 문제점 등을 파악",동료검토 : 요구 사항 명세서 작성자가 요구 사항 명세서를 설명하고 이해관계자들이 설명을 들으면서 결함을 발견,인스펙션 : 자동화된 요구 사항 관리 도구를 이용하여 요구 사항 추적성과 일관성을 검토,CASE 도구 : 검토 자료를 회의 전에 배포해서 사전 검토한 후 짧은 시간 동안 검토 회의를 진행하면서 결함을 발견,2,"인터페이스 요구사항 검토 방법에 대한 문제입니다.  정답은 요구사항 명세서 작성자가 직접 설명하고 이해관계자들이 함께 검토하는 방식을 의미합니다.  이는  소프트웨어 개발에서 요구사항 오류를 조기에 발견하고 수정하는 데 매우 중요한 단계입니다.  다른 선지는 자동화 도구 사용이나 외부 전문가 검토 등을 언급하지만,  요구사항의 이해도를 높이고 작성자의 의도를 명확히 전달하는 데 가장 효과적인 방법은 작성자의 직접적인 설명과 이해관계자들의 참여를 통한 검토입니다.  마치 건축 설계도를 건축가가 직접 설명하고 건축주, 시공사 등 이해관계자들이 함께 검토하는 것과 같습니다. 이를 통해 의사소통 오류를 최소화하고 요구사항에 대한 공통된 이해를 도출할 수 있습니다. 이러한 검토 방식은  비공식적인 분위기에서 자유롭게 의견을 교환하며 문제점을 찾아내는 데 효과적이기 때문에,  '동료 검토' 라는 용어가 가장 적절하게 설명하고 있습니다.",75,8
121,1,2,21,인터페이스 보안을 위해 네트워크 영역에 적용될 수 있는 솔루션과 거리가 먼 것은?,,IPSec,SSL,SMTP,S-HTTP,3,"이 문제는 인터페이스 보안을 위해 네트워크 영역에 적용될 수 있는 솔루션을 묻고 있습니다.  네트워크를 통해 데이터를 주고받을 때 안전하게 보호하는 방법을 생각해보면 됩니다.  IPSec과 SSL은 모두 네트워크 통신의 보안을 강화하는 프로토콜입니다. IPSec은 IP 패킷 자체를 암호화하여 네트워크 상에서의 데이터 유출을 막고, SSL은 웹 브라우저와 웹 서버 간의 통신을 안전하게 보호하는 데 사용됩니다.  반면 SMTP는 이메일을 전송하는 프로토콜이고, S-HTTP는 웹 상에서 안전한 거래를 위한 프로토콜이지만,  네트워크 영역 전체의 보안을 위한 솔루션으로 보기에는 적합하지 않습니다.  SMTP와 S-HTTP는 특정 애플리케이션(이메일, 웹 거래)에 국한된 보안을 제공하지만,  IPSec과 SSL은 네트워크 계층에서 광범위한 보안을 제공한다는 점에서 차이가 있습니다. 따라서 네트워크 영역 전체의 보안을 고려했을 때,  나머지 세 가지 솔루션과 달리 네트워크 전반의 보안과는 거리가 먼 것은  이메일 전송이나 웹 상의 특정 거래에만 초점을 맞춘 프로토콜입니다.",87,55
122,1,2,22,소프트웨어 공학의 기본 원칙이라고 볼 수 없는 것은?,,품질 높은 소프트웨어 상품 개발,지속적인 검증 시행,결과에 대한 명확한 기록 유지,최대한 많은 인력 투입,4,"소프트웨어 공학의 기본 원칙은 효율적이고 효과적인 소프트웨어 개발을 위한 지침입니다.  품질 높은 소프트웨어를 개발하고, 지속적으로 검증하며, 결과를 명확하게 기록하는 것은 모두 소프트웨어의 신뢰성과 유지보수성을 높이기 위한 필수적인 요소입니다. 하지만 개발 인력을 최대한 많이 투입하는 것이 항상 좋은 결과를 보장하는 것은 아닙니다.  인력 투입은 개발 기간과 비용에 영향을 미치며, 무작정 많은 인력을 투입한다고 해서 소프트웨어의 품질이 자동으로 향상되는 것은 아닙니다. 오히려 효율적인 팀 구성과 역할 분담이 더 중요하며,  잘못된 방향으로 많은 인력이 투입될 경우 오히려 개발 과정을 복잡하게 만들고 생산성을 떨어뜨릴 수 있습니다. 따라서 소프트웨어 개발에서는 적절한 인력 배치와 효율적인 협업이 중요하며, 단순히 인력 수를 늘리는 것이 소프트웨어 공학의 기본 원칙이라고 볼 수는 없습니다.  정보처리기사 공식 교재에서도 소프트웨어 개발의 효율성과 품질 관리에 대한 내용을 다루고 있으며,  인력 투입의 중요성보다는 적절한 프로세스와 관리, 그리고 숙련된 인력의 효율적인 활용을 강조하고 있습니다.",94,47
123,1,2,23,패키지 소프트웨어의 일반적인 제품 품질 요구사항 및 테스트를 위한 국제 표준은?,,ISO/IEC 2196,IEEE 19554,ISO/IEC 12119,ISO/IEC 14959,3,"패키지 소프트웨어는 완성된 소프트웨어 제품을 포장하여 판매하는 형태입니다.  이러한 패키지 소프트웨어의 품질을 보장하고, 테스트를 위한 국제 표준이 필요한데,  정답으로 제시된 ISO/IEC 12119는 바로 이러한 패키지 소프트웨어의 품질 요구사항과 테스트에 대한 국제 표준을 규정하고 있습니다.  다른 선지들은 소프트웨어 개발이나 다른 분야의 표준을 다루고 있기 때문에 패키지 소프트웨어의 품질과 테스트에 직접적으로 관련된 표준은 아닙니다.  마치 건물을 지을 때 건축 기준이 있듯이, 소프트웨어도 품질을 보장하기 위한 표준이 필요하며, ISO/IEC 12119는 패키지 소프트웨어에 대한 그러한 표준을 제시하는 것입니다.  따라서 패키지 소프트웨어의 품질과 테스트에 대한 국제 표준을 묻는 질문에 가장 적합한 답변입니다.",72,17
124,1,2,24,다음 중 클린 코드 작성원칙으로 거리가 먼 것은?,,누구든지 쉽게 이해하는 코드 작성,중복이 최대화된 코드 작성,다른 모듈에 미치는 영향 최소화,"단순, 명료한 코드 작성",2,"클린 코드란, 누구나 쉽게 이해하고 유지보수하기 쉬운 코드를 말합니다.  가독성이 좋고, 오류가 적으며, 확장성이 뛰어난 코드가 좋은 클린 코드의 예시입니다.  문제에서 제시된 보기 중 '중복이 최대화된 코드 작성'은 클린 코드의 원칙과 정반대입니다. 중복된 코드는 가독성을 떨어뜨리고, 유지보수 비용을 증가시키며, 오류 발생 가능성을 높입니다.  반면, 다른 보기들은 모두 코드의 가독성, 유지보수성, 확장성을 높이는 방향으로 제시되어 클린 코드 작성 원칙에 부합합니다. 따라서 중복을 최대화하는 것은 클린 코드 작성 원칙과 거리가 멉니다.  쉽게 말해, 같은 코드를 여러 번 반복해서 쓰는 것은 좋지 않다는 의미입니다.  한 번 작성한 코드는 재사용하고, 필요하다면 함수나 클래스로 만들어서 관리하는 것이 클린 코드의 핵심입니다.",94,7
125,1,2,25,블랙박스 테스트의 유형으로 틀린 것은?,,경계값 분석,오류 예측,동등 분할 기법,"조건, 루프 검사",4,"블랙박스 테스트는 소프트웨어의 내부 구조를 알지 못한 채, 입력값과 출력값만을 가지고 테스트하는 방법입니다.  마치 검은 상자(블랙박스) 안에서 무슨 일이 일어나는지 모르고 외부에서만 동작을 확인하는 것과 같습니다.  문제에서 제시된 옵션들은 블랙박스 테스트의 대표적인 기법들입니다.  '경계값 분석'은 입력값의 최대값, 최소값, 그리고 그 바로 근처 값들을 테스트하여 경계선에서 발생할 수 있는 오류를 찾는 기법이고, '오류 예측'은 과거 경험이나 유사한 시스템의 오류를 바탕으로 예상되는 오류들을 중점적으로 테스트하는 기법이며, '동등 분할 기법'은 입력값의 범위를 여러 개의 동등한 부분으로 나누고 각 부분에서 대표값을 선택하여 테스트하는 기법입니다.  반면, '조건, 루프 검사'는 소프트웨어의 내부 구조(조건문, 반복문 등)를 직접적으로 확인하며 테스트하는 기법입니다.  이는 화이트박스 테스트의 영역에 속하며, 블랙박스 테스트의 원칙에 어긋납니다. 블랙박스 테스트는 내부 구조를 모른다는 전제하에 테스트를 진행하기 때문에, 코드의 내부 구조를 직접적으로 확인하는 '조건, 루프 검사'는 블랙박스 테스트의 유형이 될 수 없습니다. 따라서 '조건, 루프 검사'가 블랙박스 테스트의 유형으로 틀린 것입니다.",74,19
126,1,2,26,제어흐름 그래프가 다음과 같을 때 McCabe의 cyclomatic 수는 얼마인가?,https://www.cbtbank.kr/images/iz/iz20200822/iz20200822m26.gif,3,4,5,6,2,"McCabe의 cyclomatic 수는 소프트웨어의 복잡도를 측정하는 지표입니다.  쉽게 말해, 프로그램의 제어 흐름이 얼마나 복잡한지를 나타내는 수치입니다.  제어 흐름 그래프에서 cyclomatic 수는 그래프의 선형 독립 경로의 수와 같습니다.  선형 독립 경로란, 다른 경로와 중복되지 않는 경로를 의미합니다.  그래프를 살펴보면, 여러 갈래로 나뉘는 부분(결정 지점)이 여러 개 있습니다.  각 결정 지점은 프로그램의 흐름을 여러 방향으로 분기시키므로 복잡도를 높입니다.  이 문제의 그래프에는 결정 지점이 3개 있고,  McCabe의 cyclomatic 수는 결정 지점의 수에 1을 더한 값으로 계산됩니다. 따라서, 3(결정 지점) + 1 = 4가 됩니다.  즉, 이 프로그램에는 4개의 선형 독립 경로가 존재하며, 이는 프로그램의 복잡도를 나타내는 cyclomatic 수가 4임을 의미합니다.  따라서 정답은 4입니다.",64,7
127,1,2,27,다음 자료에 대하여 선택(Selection) 정렬을 이용하여 오름차순으로 정렬하고자 한다. 3회전 후의 결과로 옳은 것은?,https://www.cbtbank.kr/images/iz/iz20200822/iz20200822m27.gif,"14, 17, 37, 40, 35","14, 37, 17, 40, 35","17, 14, 37, 35, 40","14, 17, 35, 40, 37",4,"선택 정렬은 주어진 자료들 중 가장 작은 값을 찾아서 맨 앞으로 보내는 과정을 반복하는 정렬 알고리즘입니다.  처음 자료는 37, 14, 17, 40, 35 입니다.",69,11
128,1,2,28,형상 관리 도구의 주요 기능으로 거리가 먼 것은?,,정규화(Normalization),체크인(Check-in),체크아웃(Check-out),커밋(commit),1,"형상 관리 도구는 소프트웨어 개발 과정에서 소스 코드, 문서, 디자인 등의 변경 사항을 추적하고 관리하는 데 사용되는 도구입니다.  소프트웨어 개발은 여러 사람이 동시에 작업하고, 코드가 지속적으로 수정되기 때문에 버전 관리와 협업이 매우 중요합니다.  형상 관리 도구는 이러한 과정을 효율적으로 관리하기 위해 체크인(Check-in), 체크아웃(Check-out), 커밋(Commit)과 같은 기능을 제공합니다.  체크인은 변경된 내용을 저장소에 저장하는 것이고, 체크아웃은 저장소에서 파일을 가져와 수정하는 것이며, 커밋은 변경 사항을 저장소에 반영하는 것입니다.  반면, 정규화(Normalization)는 데이터베이스 설계에서 데이터 중복을 줄이고 데이터 무결성을 높이기 위한 기법으로, 소프트웨어의 버전 관리나 협업과는 직접적인 관련이 없습니다. 따라서 형상 관리 도구의 주요 기능과 거리가 먼 것은 정규화입니다.  쉽게 말해, 형상관리 도구는 여러 사람이 함께 작업하는 소프트웨어의 '변경 내역'을 관리하는 도구이고, 정규화는 데이터베이스의 '데이터 구조'를 관리하는 기법이라고 생각하면 이해하기 쉬울 것입니다.",71,15
129,1,2,29,다음 트리를 Preorder 운행법으로 운행할 경우 가장 먼저 탐색되는 것은?,https://www.cbtbank.kr/images/iz/iz20200822/iz20200822m29.gif,A,B,D,G,1,"이 문제는 트리 자료구조를 Preorder 방식으로 순회하는 방법을 묻고 있습니다.  Preorder 방식은 트리의 노드를 방문하는 순서가 다음과 같습니다.  먼저 현재 노드를 방문하고, 그 다음 왼쪽 서브트리를 순회하고, 마지막으로 오른쪽 서브트리를 순회합니다.  이를 재귀적으로 적용합니다.",80,11
130,1,2,30,소프트웨어 품질 목표 중 주어진 시간동안 주어진 기능을 오류없이 수행하는 정도를 나타내는 것은?,,직관성,사용 용이성,신뢰성,이식성,3,"소프트웨어 품질 목표는 소프트웨어가 얼마나 잘 만들어졌는지를 평가하는 기준입니다.  문제에서 묻고 있는 것은 주어진 시간 안에 주어진 기능을 오류 없이 수행하는 정도인데, 이는 바로 소프트웨어의 '신뢰성'을 나타냅니다.  신뢰성이 높은 소프트웨어는 예상대로 작동하고 오류가 적게 발생하며, 사용자에게 안정적인 서비스를 제공합니다.  반대로 신뢰성이 낮은 소프트웨어는 자주 오류가 발생하거나 예상치 못한 동작을 하여 사용자에게 불편을 초래할 수 있습니다.  직관성이나 사용 용이성은 사용자 인터페이스와 관련된 측면이고, 이식성은 다른 환경에서도 동작하는 정도를 나타내는 것이므로 문제의 질문과는 부합하지 않습니다. 따라서 주어진 시간 동안 주어진 기능을 오류 없이 수행하는 정도는 소프트웨어의 신뢰성으로 정의할 수 있습니다.",82,17
131,1,2,31,알고리즘 설계 기법으로 거리가 먼 것은?,,Divide and Conquer,Greedy,Static Block,Backtracking,3,"알고리즘 설계 기법은 문제 해결을 위한 단계적인 절차를 설계하는 방법론입니다.  제시된 선택지 중 'Divide and Conquer'(분할 정복), 'Greedy'(탐욕적), 'Backtracking'(백트래킹)은 모두 알고리즘 설계에 사용되는 대표적인 기법입니다.  'Divide and Conquer'는 문제를 작은 하위 문제로 나누어 해결하고, 'Greedy'는 각 단계에서 최적의 선택을 하는 방법이며, 'Backtracking'은 모든 가능성을 탐색하며 해결책을 찾는 방법입니다.  반면 'Static Block'은 알고리즘 설계 기법이 아닙니다.  'Static Block'은 특정 프로그래밍 언어(예: Java)에서 클래스 초기화에 사용되는 정적 블록을 의미하며, 문제 해결 절차를 설계하는 알고리즘 기법과는 관련이 없습니다. 따라서 알고리즘 설계 기법과 거리가 먼 것은 'Static Block'입니다.  쉽게 말해,  요리 레시피를 만드는 방법(알고리즘 설계)과는 달리,  'Static Block'은 요리 재료를 미리 준비하는 과정과 같은 부수적인 작업에 가깝습니다.",53,21
132,1,2,32,제품 소프트웨어의 형상 관리 역할로 틀린 것은?,,형상 관리를 통해 이전 리버전이나 버전에 대한 정보에 접근 가능하여 배포본 관리에 유용,불필요한 사용자의 소스 수정 제한,프로젝트 개발비용을 효율적으로 관리,동일한 프로젝트에 대해 여러 개발자 동시 개발 가능,3,"제품 소프트웨어의 형상 관리란 소프트웨어 개발 과정에서 발생하는 변경 사항들을 체계적으로 관리하고 추적하는 것을 말합니다.  이는 소프트웨어의 버전 관리, 변경 이력 추적, 배포 관리 등을 포함합니다.  문제에서 제시된 보기 중 틀린 것은 프로젝트 개발 비용을 효율적으로 관리하는 것이 형상 관리의 직접적인 역할이 아니라는 점입니다. 형상 관리는 개발 과정의 효율성을 높여 결과적으로 비용 절감에 기여할 수는 있지만, 형상 관리 자체가 비용 관리를 위한 도구는 아닙니다.  형상 관리는 소스 코드의 변경 사항을 추적하고 관리하여 여러 개발자가 동시에 작업하더라도 충돌을 최소화하고, 이전 버전으로 돌아갈 수 있도록 하는 등의 역할을 합니다.  따라서 소스 코드의 변경 관리, 버전 관리, 협업 환경 제공 등이 형상 관리의 주요 목표이며, 개발 비용의 직접적인 관리와는 다소 거리가 있습니다.  다른 보기들은 모두 형상 관리의 주요 기능을 잘 나타내고 있습니다.",58,15
133,1,2,33,제품 소프트웨어 패키징 도구 활용 시 고려사항이 아닌 것은?,,제품 소프트웨어의 종류에 적합한 암호화 알고리즘을 고려한다.,추가로 다양한 이기종 연동을 고려한다.,사용자 편의성을 위한 복잡성 및 비효율성 문제를 고려한다.,내부 콘텐츠에 대한 보안은 고려하지 않는다.,4,"제품 소프트웨어 패키징은 소프트웨어를 사용자에게 배포하기 위한 최종 단계입니다.  이 과정에는 소프트웨어를 안전하게 포장하고, 사용자가 쉽게 설치하고 사용할 수 있도록 하는 여러 가지 작업이 포함됩니다.  여기에는 소프트웨어의 종류에 맞는 적절한 암호화 방식을 선택하는 것,  다양한 운영체제나 하드웨어 환경과의 호환성을 고려하는 것, 그리고 사용자의 편의성을 높이기 위해 설치 과정이나 사용법을 간편하게 만드는 노력 등이 포함됩니다.  하지만 소프트웨어 패키징 과정에서 가장 중요한 것은 바로 소프트웨어 자체의 보안입니다.  만약 내부 콘텐츠에 대한 보안을 고려하지 않는다면,  해커가 소프트웨어를 통해 중요한 정보를 탈취하거나 시스템을 공격할 수 있는 위험이 발생합니다. 따라서 제품 소프트웨어 패키징 과정에서는 내부 콘텐츠 보안을 가장 우선적으로 고려해야 하며,  이는 소프트웨어의 안전성과 신뢰성을 확보하는 데 필수적입니다.  따라서 '내부 콘텐츠에 대한 보안은 고려하지 않는다'는 것은 제품 소프트웨어 패키징 도구 활용 시 고려사항이 될 수 없습니다.",90,16
134,1,2,34,디지털 저작권 관리(DRM) 기술과 거리가 먼 것은?,,콘텐츠 암호화 및 키 관리,콘텐츠 식별체계 표현,콘텐츠 오류 감지 및 복구,라이센스 발급 및 관리,3,"디지털 저작권 관리(DRM) 기술은 디지털 콘텐츠의 저작권을 보호하기 위한 기술입니다.  콘텐츠의 불법 복제 및 배포를 막기 위해 다양한 방법을 사용하는데, 대표적으로 콘텐츠를 암호화하여 무단 접근을 차단하고,  누가 어떤 콘텐츠에 접근할 수 있는지 라이선스를 통해 관리하는 등의 방법이 있습니다. 또한 콘텐츠를 식별하는 고유한 정보를 부여하여 추적 및 관리를 용이하게 합니다.  하지만 콘텐츠의 오류 감지 및 복구는 콘텐츠의 무결성을 유지하는 기술이지, 저작권 보호와는 직접적인 관련이 없습니다.  오류 감지 및 복구는 콘텐츠의 내용 자체를 보호하는 것이지, 콘텐츠의 사용 권한을 제어하는 DRM 기술의 핵심 목표와는 다릅니다.  따라서 콘텐츠 오류 감지 및 복구 기술은 DRM 기술과 거리가 먼 기술이라고 할 수 있습니다.  DRM은 콘텐츠의 *사용 권한*을 관리하는 데 초점을 맞추는 반면, 오류 감지 및 복구는 콘텐츠의 *데이터 무결성*을 유지하는 데 초점을 맞춥니다.",82,16
135,1,2,35,물리데이터 저장소의 파티션 설계에서 파티션 유형으로 옳지 않은 것은?,,범위분할(Range Partitioning),해시분할(Hash Partitioning),조합분할(Composite Partitioning),유닛분할(Unit Partitioning),4,"물리 데이터 저장소의 파티션 설계는 데이터베이스의 성능 향상과 관리 효율을 높이기 위한 중요한 작업입니다.  파티션이란 큰 테이블을 여러 개의 작은 조각으로 나누는 것을 말하는데, 이를 통해 특정 조건에 맞는 데이터만 빠르게 접근할 수 있게 됩니다.  문제에서 제시된 파티션 유형들은 데이터를 나누는 기준이 다릅니다.  범위 분할은 데이터의 값 범위를 기준으로 나누고, 해시 분할은 해시 함수를 이용하여 데이터를 분산시키며, 조합 분할은 여러 기준을 조합하여 나눕니다.  하지만 '유닛 분할'이라는 파티션 유형은 일반적인 데이터베이스 파티셔닝 기법에서는 사용되지 않습니다.  따라서 물리 데이터 저장소의 파티션 유형으로 옳지 않은 것은 '유닛 분할'입니다.  마치 책을 여러 장으로 나누어 관리하는 것과 같은 원리인데,  '유닛 분할'은 마치 책을 아무런 기준 없이 찢어 놓은 것과 같아 효율적인 관리가 불가능하기 때문입니다.  다른 분할 방식들은 특정 기준에 따라 데이터를 효율적으로 분할하여 관리하는 반면, '유닛 분할'은 그러한 기준이 없어 데이터 접근 및 관리에 비효율적입니다.",55,32
136,1,2,36,다음이 설명하는 애플리케이션 통합 테스트 유형은?,https://www.cbtbank.kr/images/iz/iz20200822/iz20200822m36.gif,하향식 통합 테스트,상향식 통합 테스트,회귀 테스트,빅뱅 테스트,1,"문제에서 설명하는 애플리케이션 통합 테스트 유형은 상위 컴포넌트부터 테스트를 시작하여 점진적으로 하위 컴포넌트를 테스트하는 방식입니다.  ""깊이 우선 방식 또는 너비 우선 방식이 있다""는 설명은 상위 모듈부터 테스트를 진행하는 하향식 통합 테스트의 특징을 보여줍니다.  하향식 통합 테스트는 전체 시스템의 상위 레벨 모듈부터 테스트를 시작하여, 점차 하위 모듈을 통합하며 테스트를 진행합니다.  하위 컴포넌트가 아직 개발되지 않았을 경우,  그 기능을 대신하는 더미 코드인 스텁(Stub)을 사용하여 테스트를 진행하는 것 또한 하향식 통합 테스트의 특징입니다.  반대로 상향식 통합 테스트는 하위 모듈부터 테스트를 시작하여 점차 상위 모듈로 통합해 나가는 방식입니다.  문제에서 제시된 ""상위 컴포넌트를 테스트하고 점증적으로 하위 컴포넌트를 테스트한다""는 설명은 하향식 통합 테스트의 방식을 명확하게 나타내고 있습니다.  따라서 문제의 설명에 가장 적합한 답은 하향식 통합 테스트입니다.",90,20
137,1,2,37,인터페이스 구현시 사용하는 기술 중 다음 내용이 설명하는 것은?,https://www.cbtbank.kr/images/iz/iz20200822/iz20200822m37.gif,Procedure,Trigger,Greedy,AJAX,4,"문제에서 설명하는 기술은 JavaScript를 이용하여 클라이언트(예: 웹 브라우저)와 서버 사이에서 XML 데이터를 비동기적으로 주고받는 기술입니다.  비동기란 서버와의 통신이 완료될 때까지 기다리지 않고, 다른 작업을 계속 진행할 수 있다는 것을 의미합니다.  웹 페이지를 새로고침하지 않고도 서버로부터 데이터를 받아와 페이지의 일부분만 업데이트하는 방식이죠.  예를 들어, 웹사이트에서 상품 목록을 불러오거나 검색 결과를 표시할 때, 전체 페이지를 다시 로딩하지 않고 부분적으로만 업데이트하는 것이 바로 이 기술 덕분입니다.  이러한 방식은 사용자 경험을 향상시키고 웹 애플리케이션의 응답성을 높이는 데 크게 기여합니다. 문제에서 제시된 설명과 정확히 일치하는 기술은 AJAX(Asynchronous JavaScript and XML)입니다. AJAX는 JavaScript를 기반으로 하며, XML 데이터를 사용하여 비동기 통신을 수행하는 기술이기 때문입니다.  Procedure, Trigger, Greedy는 데이터베이스나 알고리즘 관련 용어로, 문제에서 설명하는 웹 기술과는 관련이 없습니다.",84,8
138,1,2,38,소프트웨어 재공학이 소프트웨어의 재개발에 비해 갖는 장점으로 거리가 먼 것은?,,위험부담 감소,비용 절감,시스템 명세의 오류억제,개발시간의 증가,4,"소프트웨어 재공학은 기존 소프트웨어 시스템을 분석하고, 이해하여 개선하는 과정입니다.  새롭게 개발하는 것(재개발)과 비교했을 때, 재공학은 기존 시스템의 기능과 구조를 활용하기 때문에 위험 부담을 줄이고 비용을 절감할 수 있습니다.  또한, 기존 시스템의 명세를 분석하고 수정하는 과정에서 오류를 억제하는 데 도움이 됩니다. 하지만 재공학은 재개발에 비해 시간이 더 걸릴 수 있습니다. 기존 시스템을 분석하고 이해하는 데 시간이 소요되며,  개선된 시스템을 구축하는 데에도 추가적인 시간이 필요하기 때문입니다. 따라서 소프트웨어 재공학이 재개발에 비해 갖는 장점으로 거리가 먼 것은 개발 시간의 증가입니다.  재공학은 완전히 새로 만드는 것보다 시간이 더 오래 걸릴 수 있다는 점을 명심해야 합니다.",93,47
139,1,2,39,"알파, 베타 테스트와 가장 밀접한 연관이 있는 테스트 단계는?",,단위 테스트,인수 테스트,통합 테스트,시스템 테스트,2,"알파, 베타 테스트는 소프트웨어 개발의 마지막 단계에서 실제 사용자 환경과 유사한 환경에서 제품을 테스트하는 과정입니다.  알파 테스트는 개발팀 내부 또는 제한된 사용자 그룹을 대상으로 진행되며, 베타 테스트는 보다 넓은 범위의 일반 사용자들을 대상으로 진행되어 실제 사용 환경에서의 문제점을 발견하고 개선하는 데 목적이 있습니다.  따라서 알파, 베타 테스트는 개발이 완료된 후, 전체 시스템이 제대로 작동하는지, 사용자의 요구사항을 충족하는지 확인하는 최종 단계의 테스트에 해당합니다. 이러한 최종 단계의 테스트는 시스템 전체의 기능을 검증하는 것이므로,  전체 시스템을 대상으로 하는 테스트 단계와 가장 밀접한 관련이 있습니다.  단위 테스트나 통합 테스트는 시스템의 일부분 또는 부분적인 통합에 대한 테스트이기 때문에 알파, 베타 테스트와는 목적과 범위가 다릅니다.",70,19
140,1,2,40,다음 트리의 차수(degree)는?,https://www.cbtbank.kr/images/iz/iz20200822/iz20200822m40.gif,2,3,4,5,2,"문제에서 주어진 트리의 구조를 살펴보면, 루트 노드 A에서 시작하여 여러 갈래로 가지가 뻗어나가는 것을 확인할 수 있습니다.  트리에서 각 노드의 차수(degree)는 그 노드에 연결된 자식 노드의 개수를 의미합니다.  루트 노드 A는 B와 C라는 두 개의 자식 노드를 가지고 있으므로 A의 차수는 2입니다.  B 노드는 D, E, F 세 개의 자식 노드를 가지고 있으므로 B의 차수는 3입니다. C 노드는 G라는 하나의 자식 노드를 가지고 있으므로 C의 차수는 1입니다. F 노드는 H와 I라는 두 개의 자식 노드를 가지고 있으므로 F의 차수는 2입니다.  문제에서 묻고 있는 것은 트리 전체의 차수가 아니라, 각 노드의 차수 중 가장 큰 값을 의미하는 것으로 보입니다. 따라서, 각 노드의 차수를 살펴본 결과, 가장 큰 차수는 3이 됩니다.  따라서 정답은 3입니다.  (단, 문제에서 트리의 차수를 어떻게 정의하는지에 따라 정답이 달라질 수 있습니다.  일반적으로 트리의 차수는 노드의 차수 중 최댓값으로 정의되지만, 문제의 의도에 따라 다를 수 있으므로 문제의 정확한 정의를 확인하는 것이 중요합니다.)",77,11
141,1,2,41,릴레이션 R의 모든 결정자(determinant)가 후보키이면 그 릴레이션 R은 어떤 정규형에 속하는가?,,제 1 정규형,제 2 정규형,보이스/코드 정규형,제 4 정규형,3,"릴레이션이라는 것은 데이터베이스에서 테이블을 의미합니다.  결정자(determinant)는 어떤 속성(컬럼)의 값이 다른 속성의 값을 유일하게 결정하는 속성을 말합니다.  예를 들어, 주민등록번호가 있다면 이름과 주소를 유일하게 알 수 있죠. 이때 주민등록번호가 결정자입니다. 후보키는 테이블의 모든 튜플(행)을 유일하게 식별할 수 있는 최소한의 속성 집합입니다.  문제에서 모든 결정자가 후보키라는 것은, 테이블의 어떤 속성도 다른 속성을 결정할 수 있지만, 그 결정자 자체가 테이블의 모든 행을 유일하게 구분할 수 있다는 의미입니다. 이러한 조건을 만족하는 릴레이션은 중복된 정보가 없고, 데이터의 무결성이 매우 높은 상태입니다. 이는 바로 보이스-코드 정규형(BCNF)의 정의와 일치합니다.  보이스-코드 정규형은 제3정규형보다 더 강력한 정규형으로, 데이터 중복을 최소화하고 데이터 무결성을 보장하는 데 매우 효과적입니다.  따라서 모든 결정자가 후보키인 릴레이션은 보이스-코드 정규형에 속합니다.",67,30
142,1,2,42,다음 관계형 데이터 모델에 대한 설명으로 옳은 것은?,https://www.cbtbank.kr/images/iz/iz20200822/iz20200822m42.gif,"relation 3개, attribute 3개, tuple 5개","relation 3개, attribute 5개, tuple 3개","relation 1개, attribute 5개, tuple 3개","relation 1개, attribute 3개, tuple 5개",4,"문제에서 제시된 표는 고객 정보를 나타냅니다.  '고객ID', '고객이름', '거주도시' 라는 세 가지 정보(속성, attribute)를 가지고 있으며, 각 행은 한 명의 고객을 나타내는 데이터 집합(튜플, tuple)입니다.  전체 표 자체가 하나의 관계(relation)를 이룹니다.  따라서 표에는 총 하나의 관계, 세 개의 속성, 그리고 다섯 개의 튜플이 존재합니다.  다른 선지들은 관계의 개수나 속성, 튜플의 개수를 잘못 파악한 것입니다.  쉽게 말해, 하나의 표(테이블) 안에 고객 정보가 정리되어 있고, 이 표가 관계형 데이터 모델의 기본 단위인 관계를 나타내는 것입니다.  각 열이 속성이고, 각 행이 튜플입니다.",76,27
143,1,2,43,Commit과 Rollback 명령어에 의해 보장 받는 트랜잭션의 특성은?,,병행성,보안성,원자성,로그,3,"데이터베이스에서 트랜잭션(Transaction)이란 여러 개의 작업을 하나의 논리적 단위로 묶어서 처리하는 것을 말합니다.  예를 들어 은행 계좌 이체를 생각해 보세요.  돈을 보내는 계좌에서 돈을 빼고, 받는 계좌에 돈을 입금하는 두 가지 작업이 모두 성공해야만 이체가 완료된다고 할 수 있습니다.  만약 돈을 보내는 계좌에서만 돈이 빠져나가고 받는 계좌에는 입금이 되지 않는다면,  계좌 잔액이 맞지 않게 되어 심각한 문제가 발생하겠죠.",72,27
144,1,2,44,관계 데이터베이스인 테이블 R1에 대한 아래 SQL 문의 실행결과로 옳은 것은?,https://www.cbtbank.kr/images/iz/iz20200822/iz20200822m44.gif,https://www.cbtbank.kr/images/iz/iz20200822/iz20200822m44b1.gif,https://www.cbtbank.kr/images/iz/iz20200822/iz20200822m44b2.gif,https://www.cbtbank.kr/images/iz/iz20200822/iz20200822m44b3.gif,https://www.cbtbank.kr/images/iz/iz20200822/iz20200822m44b4.gif,2,"문제에서 제시된 SQL 문은 `SELECT DISTINCT 학년 FROM R1;` 입니다. 이 문장은 R1 테이블에서 '학년' 컬럼의 값들을 가져오되, 중복되는 값은 하나만 출력하라는 의미입니다.  `DISTINCT` 키워드가 중복 제거 역할을 합니다.  R1 테이블을 살펴보면 학년은 1, 2, 3 이렇게 세 가지 값이 존재하며, 각 값은 여러 학생에게 중복되어 적용될 수 있습니다.  따라서 `SELECT DISTINCT 학년` 구문을 실행하면 중복을 제거하고 학년 1, 2, 3이 각각 한 번씩만 출력되는 결과가 나옵니다.  따라서 정답은 학년 1, 2, 3을 순서대로 나열한 결과입니다. 다른 선지는 중복된 학년 값을 포함하거나, 학년 외의 다른 컬럼 값을 포함하고 있어 정답이 아닙니다.  쉽게 말해,  '학년'이라는 목록에서 중복되는 숫자를 없애고, 유일한 숫자만 보여주는 것이라고 생각하면 됩니다.",83,27
145,1,2,45,DCL(Data Control Language) 명령어가 아닌 것은?,,COMMIT,ROLLBACK,GRANT,SELECT,4,"이 문제는 데이터베이스 관리 시스템(DBMS)에서 사용하는 명령어의 종류를 묻고 있습니다.  데이터 제어 언어(DCL, Data Control Language)는 데이터베이스의 접근 권한을 관리하거나 트랜잭션을 제어하는 명령어들을 포함합니다.  제시된 보기 중 'COMMIT'과 'ROLLBACK'은 트랜잭션을 각각 성공적으로 완료하거나 취소하는 명령어이고, 'GRANT'는 사용자에게 특정 권한을 부여하는 명령어입니다. 반면, 'SELECT' 명령어는 데이터베이스에서 데이터를 조회하는 명령어로, 데이터를 제어하는 것이 아니라 데이터를 읽어오는 역할을 합니다. 따라서 데이터를 제어하는 DCL 명령어가 아닌 것은 'SELECT'입니다.  쉽게 말해, COMMIT, ROLLBACK, GRANT는 데이터베이스의 상태를 변경하거나 접근 권한을 조정하는 명령어이지만, SELECT는 데이터베이스의 상태를 변경하지 않고 단순히 데이터를 가져오는 명령어이기 때문에 DCL에 속하지 않습니다.",84,26
146,1,2,46,병행제어 기법 중 로킹에 대한 설명으로 옳지 않은 것은?,,로킹의 대상이 되는 객체의 크기를 로킹 단위라고 한다.,"데이터베이스, 파일, 레코드 등은 로킹 단위가 될 수 있다.",로킹의 단위가 작아지면 로킹 오버헤드가 증가한다.,로킹의 단위가 커지면 데이터베이스 공유도가 증가한다.,4,"병행 제어 기법 중 하나인 로킹은 여러 프로세스가 동시에 공유 자원에 접근하여 발생할 수 있는 데이터의 일관성 문제를 해결하기 위해 사용하는 기법입니다.  쉽게 말해, 여러 사람이 동시에 같은 문서를 수정하는 것을 막기 위해 한 사람만 수정할 수 있도록 잠금 장치를 거는 것과 같습니다.  로킹의 대상이 되는 객체의 크기는 로킹 단위라고 하며, 데이터베이스 전체, 파일, 레코드 등 다양한 크기의 객체가 로킹 단위가 될 수 있습니다.  로킹 단위가 작을수록 더 세밀하게 제어할 수 있지만, 그만큼 잠금과 해제 작업이 빈번해져 시스템의 오버헤드가 증가합니다. 반대로 로킹 단위가 크면 오버헤드는 줄어들지만,  자원 공유가 제한되어 데이터베이스의 공유도가 낮아집니다. 따라서 로킹 단위가 커진다고 해서 데이터베이스 공유도가 증가하는 것은 옳지 않습니다.  작은 단위로 로킹을 하면 충돌을 더 잘 방지할 수 있지만,  오히려 시스템 자원을 더 많이 소모하게 되는 것이죠.  문제에서 틀린 설명은 바로 이러한 로킹 단위와 데이터베이스 공유도의 관계를 잘못 기술한 부분입니다.",80,31
147,1,2,47,관계 데이터모델의 무결성 제약 중 기본키 값의 속성 값이 널(Null)값이 아닌 원자 값을 갖는 성질은?,,개체 무결성,참조 무결성,도메인 무결성,튜플의 유일성,1,"관계 데이터 모델에서 무결성(Integrity)이란 데이터의 정확성과 일관성을 유지하는 것을 의미합니다.  여러 종류의 무결성 제약 조건이 있는데, 문제에서 묻고 있는 것은 기본키(Primary Key)에 대한 무결성입니다. 기본키는 테이블 내 각 행(튜플)을 유일하게 식별하는 속성(또는 속성들의 집합)입니다.  기본키 값은 절대로 중복될 수 없고,  빈 값(Null)을 가질 수 없습니다.  즉, 항상 유일하고 의미있는 값을 가져야 합니다.  문제에서 설명하는 ""기본키 값의 속성 값이 널(Null)값이 아닌 원자 값을 갖는 성질""은 바로 이 기본키의 특징을 나타내는 것이며, 이를 데이터베이스 용어로 ""개체 무결성""이라고 합니다.  개체 무결성은 각 튜플(행)이 유일하게 식별될 수 있도록 기본키의 무결성을 보장하는 규칙입니다.  다른 선택지는 기본키와 직접적인 관련이 없거나, 다른 종류의 무결성 제약 조건을 설명하고 있습니다.  따라서 기본키의 널 값 허용 불가 및 유일성을 보장하는 개념이 바로 개체 무결성입니다.",81,27
148,1,2,48,뷰(View)의 장점이 아닌 것은?,,뷰 자체로 인덱스를 가짐,데이터 보안 용이,논리적 독립성 제공,사용자 데이터 관리 용이,1,"뷰(View)는 기존 테이블의 데이터를 기반으로 만들어진 가상 테이블입니다.  쉽게 말해, 특정 목적에 맞게 테이블의 일부분만 보여주는 창문과 같은 역할을 합니다.  따라서 데이터 보안 강화, 논리적 독립성 제공, 사용자 데이터 관리 용이성 등의 장점을 가지고 있습니다.  데이터 보안 측면에서는 실제 데이터를 직접 접근하지 않고 뷰를 통해 제한된 데이터만 보여주므로 보안을 강화할 수 있습니다. 논리적 독립성은 기존 테이블의 구조가 변경되더라도 뷰의 구조를 변경하지 않고도 계속 사용할 수 있다는 장점을 의미합니다.  사용자는 뷰를 통해 자신에게 필요한 데이터만 쉽게 관리하고 사용할 수 있습니다.  하지만 뷰 자체는 실제 데이터를 저장하는 것이 아니기 때문에,  뷰에 인덱스를 생성하여 성능을 향상시킬 수는 있지만, 뷰 자체가 독립적인 인덱스를 가지고 있는 것은 아닙니다.  뷰는 기존 테이블의 인덱스를 활용하거나, 뷰에 대한 별도의 인덱스를 생성해야 성능 향상을 기대할 수 있습니다. 따라서 뷰의 장점이 아닌 것은 뷰 자체가 독립적인 인덱스를 가진다는 것입니다.",64,28
149,1,2,49,분산 데이터베이스의 투명성(Transparency)에 해당 하지 않는 것은?,,Location Transparency,Replication Transparency,Failure Transparency,Media Access Transparency,4,"분산 데이터베이스는 여러 개의 컴퓨터에 데이터를 나누어 저장하는 시스템입니다.  투명성(Transparency)이란, 사용자가 데이터가 어디에 저장되어 있는지, 어떻게 복제되어 있는지, 어떤 컴퓨터가 고장났는지 등을 신경 쓰지 않고 데이터에 접근할 수 있도록 하는 것을 의미합니다.  문제에서 묻고 있는 것은 분산 데이터베이스의 투명성에 해당하지 않는 것인데요.  데이터가 어떤 저장매체(하드디스크, SSD 등)에 저장되어 있는지는 사용자에게 중요하지 않습니다.  사용자는 단순히 데이터에 접근하는 것에만 집중하면 되지, 데이터가 어떤 물리적인 저장장치에 있는지 알 필요는 없죠.  따라서 데이터가 저장된 매체에 대한 정보는 사용자에게 투명하게 감춰져야 합니다.  나머지 선택지들은 모두 사용자에게 데이터의 위치, 복제 상태, 시스템 장애 등을 숨겨주는 투명성을 제공하는 반면,  '데이터 저장 매체'에 대한 정보는 사용자에게 불필요한 정보이기 때문에 투명성에 해당하지 않습니다.  즉, 사용자는 데이터에 접근하는 방법만 알면 되고, 어떤 매체에 저장되어 있는지는 알 필요가 없다는 것이죠.  따라서 정답은 데이터 저장 매체에 대한 투명성을 제공하지 않는다는 의미입니다.",66,31
150,1,2,50,정규화의 목적으로 옳지 않은 것은?,,어떠한 릴레이션이라도 데이터베이스 내에서 표현 가능하게 만든다.,데이터 삽입시 릴레이션을 재구성할 필요성을 줄인다.,"중복을 배제하여 삽입, 삭제, 갱신 이상의 발생을 야기한다.",효과적인 검색 알고리즘을 생성할 수 있다.,3,"정규화는 데이터베이스의 중복을 제거하고 데이터 무결성을 높이기 위한 과정입니다.  데이터베이스에 중복된 데이터가 많으면 데이터를 삽입, 삭제, 수정할 때 일관성을 유지하기 어렵고, 데이터의 불일치가 발생할 가능성이 높아집니다.  예를 들어, 고객 정보에 주소가 여러 곳에 중복되어 저장되어 있다면, 주소를 변경할 때 모든 곳을 일일이 수정해야 하는 번거로움이 있고, 어떤 곳을 수정하지 못하면 데이터 불일치가 발생하게 됩니다.  정규화는 이러한 문제를 해결하기 위해 데이터를 여러 테이블로 분해하여 중복을 최소화하는 것을 목표로 합니다.",83,30
151,1,2,51,다음에 해당하는 함수 종속의 추론 규칙은?,https://www.cbtbank.kr/images/iz/iz20200822/iz20200822m51.gif,분해 규칙,이행 규칙,반사 규칙,결합 규칙,2,"문제에서 제시된 함수 종속의 규칙 ""X→Y이고 Y→Z이면 X→Z이다""는  데이터베이스 설계에서 매우 중요한 개념인 **이행성(Transitivity)**을 나타냅니다.  쉽게 설명하자면,  X라는 정보가 Y를 결정하고, Y라는 정보가 Z를 결정한다면, 결국 X라는 정보만으로도 Z를 결정할 수 있다는 의미입니다.  마치 도미노처럼, X가 넘어지면 Y가 넘어지고, Y가 넘어지면 Z가 넘어지는 것과 같습니다.  따라서 X가 Z를 결정한다는 함수 종속(X→Z)을 추론할 수 있습니다.  이러한 추론 규칙을  ""이행 규칙""이라고 합니다.  다른 규칙들은 이러한 이행성과는 다른 함수 종속의 성질을 나타냅니다.  예를 들어, 분해 규칙은 함수 종속을 더 작은 단위로 나누는 규칙이고, 반사 규칙은 X→X와 같은 자명한 함수 종속을 나타냅니다. 결합 규칙은 여러 함수 종속을 하나로 합치는 규칙입니다.  문제에서 제시된 규칙은 이행성을 명확하게 보여주므로, 정답은 이행 규칙입니다.",86,29
152,1,2,52,다음 R과 S 두 릴레이션에 대한 Division 연산의 수행 결과는?,https://www.cbtbank.kr/images/iz/iz20200822/iz20200822m52.gif,https://www.cbtbank.kr/images/iz/iz20200822/iz20200822m52b1.gif,https://www.cbtbank.kr/images/iz/iz20200822/iz20200822m52b2.gif,https://www.cbtbank.kr/images/iz/iz20200822/iz20200822m52b3.gif,https://www.cbtbank.kr/images/iz/iz20200822/iz20200822m52b4.gif,4,"이 문제는 관계형 데이터베이스에서의 Division 연산을 묻고 있습니다. Division 연산은 R 릴레이션에 있는 모든 튜플이 S 릴레이션의 모든 튜플과 일치하는 D2와 D3 값을 가지는 튜플을 찾는 연산입니다.  쉽게 말해, R 릴레이션에서 S 릴레이션의 조건을 만족하는 D1 값들을 찾는 것입니다.",83,28
153,1,2,53,"player 테이블에는 player_name, team_id, height 컬럼이 존재한다. 아래 SQL문에서 문법적 오류가 있는 부분은?",https://www.cbtbank.kr/images/iz/iz20200822/iz20200822m53.gif,-1,-2,-3,-4,4,"문제에서 제시된 SQL 문은 player 테이블에서 player의 이름과 키 정보를 가져오는 쿼리입니다.  `WHERE` 절에서는 `team_id`가 'Korea'인 레코드만 선택하고, `AND` 절에서는 키(`height`)가 170과 180 사이인 레코드를 선택하려고 합니다.  하지만 `BETWEEN` 연산자는 두 값 사이의 범위를 지정할 때 사용하는데,  `170 or 180` 과 같이 `or` 연산자를 사용하는 것은 문법적으로 잘못되었습니다.  `BETWEEN`은  `BETWEEN 170 AND 180` 과 같이 `AND` 연산자와 함께 사용하여 170 이상 180 이하의 범위를 지정해야 합니다.  따라서 `AND height BETWEEN 170 AND 180;` 와 같이 수정해야 올바른 SQL 문이 됩니다.  `or` 연산자를 사용하려면 `height >= 170 OR height <= 180` 과 같이 각 조건을 따로 작성해야 합니다.  결론적으로,  `BETWEEN` 연산자와 `or` 연산자의 결합이 문법적 오류를 발생시키는 원인입니다.  이는 SQL의 기본적인 문법 규칙을 이해하고 있는지 묻는 문제입니다.",85,25
154,1,2,54,데이터베이스 로그(log)를 필요로 하는 회복 기법은?,,즉각 갱신 기법,대수적 코딩 방법,타임 스탬프 기법,폴딩 기법,1,"데이터베이스의 복구(recovery)는 시스템 장애나 오류 발생 후 데이터베이스의 일관성을 유지하기 위해 매우 중요한 과정입니다.  데이터베이스 로그(log)는 데이터베이스의 변경 사항을 기록하는 일종의 ""일기장""과 같습니다.  시스템에 문제가 발생하면 이 로그를 이용하여 문제 발생 이전의 상태로 데이터베이스를 복구할 수 있습니다.  즉각 갱신 기법은 데이터베이스에 대한 변경 사항이 발생할 때마다 즉시 로그에 기록하고 데이터베이스 자체에도 변경 사항을 반영하는 기법입니다.  만약 시스템 장애가 발생하더라도 로그에 기록된 정보를 이용하여 데이터베이스를 일관성 있는 상태로 복구할 수 있습니다.  반면 다른 기법들은 로그를 사용하지 않거나, 로그를 사용하더라도 즉각적인 갱신을 보장하지 않아 복구 과정이 복잡해지거나 데이터 손실이 발생할 가능성이 있습니다. 따라서 데이터베이스 로그를 필요로 하는 회복 기법은 즉각 갱신 기법입니다.  쉽게 말해, 컴퓨터가 작업 중 갑자기 꺼졌다고 생각해 보세요.  ""즉각 갱신 기법""은 작업 내용을 실시간으로 저장해두었기 때문에 컴퓨터를 다시 켜도 작업 내용을 복구할 수 있습니다.  하지만 다른 기법들은 작업 내용을 저장하지 않았거나, 저장하더라도 완벽하게 저장하지 못했을 수 있기 때문에 작업 내용을 잃을 수 있습니다.",52,27
155,1,2,55,DML(Data Manipulation Language) 명령어가 아닌 것은?,,INSERT,UPDATE,ALTER,DELETE,3,"이 문제는 데이터베이스를 조작하는 명령어인 DML(Data Manipulation Language)에 대한 이해도를 묻고 있습니다.  DML은 데이터베이스에 있는 데이터를 추가, 수정, 삭제, 조회하는 데 사용되는 명령어 집합입니다.  문제에서 제시된 선택지 중 INSERT, UPDATE, DELETE는 모두 데이터를 추가하거나 수정하거나 삭제하는 명령어이므로 DML에 속합니다.  하지만 ALTER는 데이터베이스의 구조(테이블의 컬럼 추가, 수정, 삭제 등)를 변경하는 명령어로, 데이터 자체를 조작하는 것이 아니라 데이터베이스의 스키마(schema)를 변경하는 DDL(Data Definition Language) 명령어에 속합니다. 따라서 DML 명령어가 아닌 것은 ALTER입니다.  쉽게 말해, INSERT, UPDATE, DELETE는 데이터베이스 안의 내용물을 바꾸는 것이고, ALTER는 데이터베이스의 서랍 자체를 바꾸는 것과 같다고 생각하면 이해하기 쉬울 것입니다.  정보처리기사 공식 교재의 데이터베이스 관련 단원을 참고하면 더 자세한 내용을 확인할 수 있습니다.",82,26
156,1,2,56,다음과 같이 위쪽 릴레이션을 아래쪽 릴레이션으로 정규화를 하였을 때 어떤 정규화 작업을 한 것인가?,https://www.cbtbank.kr/images/iz/iz20200822/iz20200822m56.gif,제1정규형,제2정규형,제3정규형,제4정규형,1,"문제에서 보여주는 테이블 변환은  처음에는 '국가'라는 하나의 속성에 여러 개의 도시 정보가 쉼표(,)로 구분되어 저장되어 있었습니다.  이러한 형태는 데이터 중복을 야기하고, 데이터 수정 시 문제를 발생시킬 수 있습니다.  예를 들어, '대한민국'의 도시 정보를 수정하려면 '대한민국'이라는 레코드를 찾아서 도시 정보 전체를 수정해야 합니다.  부산만 추가하거나 삭제하는 것이 불가능합니다.",76,30
157,1,2,57,관계대수의 순수관계 연산자가 아닌 것은?,,Select,Cartesian Product,Division,Project,2,"관계대수는 관계형 데이터베이스를 조작하는 데 사용되는 수학적 언어입니다.  여러 가지 연산자를 통해 데이터베이스의 테이블을 조작하고 새로운 테이블을 생성할 수 있습니다.  문제에서 제시된 연산자들은 모두 관계대수에서 사용되는 중요한 연산자들입니다.  'Select' 연산자는 특정 조건을 만족하는 행(row)들을 선택하는 데 사용되고, 'Project' 연산자는 특정 열(column)들을 선택하여 새로운 테이블을 생성하는 데 사용됩니다. 'Division' 연산자는 두 테이블 간의 나눗셈 연산을 수행하여 특정 조건을 만족하는 결과를 얻습니다.  하지만 'Cartesian Product' (카테시안 곱) 연산자는 두 테이블의 모든 행들의 조합을 생성하는 연산입니다.  이는 순수하게 두 테이블의 모든 가능한 조합을 만들어내는 것이지, 특정 조건에 따른 선택이나 투영(projection)을 수행하는 것이 아니기 때문에 다른 연산자들과는 성격이 다릅니다.  따라서 순수 관계 연산자라고 보기 어렵습니다.  다른 연산자들은 특정 조건에 따라 데이터를 선택하거나 변환하는 반면, 카테시안 곱은 단순히 모든 조합을 생성하는 것이므로,  관계대수의 다른 순수한 관계 연산과는 차이가 있습니다.  따라서 정답은 카테시안 곱입니다.",72,29
158,1,2,58,다음 중 SQL의 집계 함수(aggregation function)가 아닌 것은?,,AVG,COUNT,SUM,CREATE,4,"이 문제는 SQL의 집계 함수 중에서 어떤 것이 집계 함수가 아닌지를 묻고 있습니다.  집계 함수란, 여러 행의 데이터를 하나의 값으로 요약하는 함수입니다.  예를 들어, AVG 함수는 여러 행의 값들의 평균을 구하고, COUNT 함수는 행의 개수를 세며, SUM 함수는 여러 행의 값들의 합을 구합니다.  반면에 CREATE는 데이터베이스 객체(테이블, 뷰 등)를 생성하는 명령어입니다.  데이터를 요약하는 것이 아니라 새로운 객체를 만드는 것이죠. 따라서 CREATE는 집계 함수가 아니며, 다른 세 가지는 모두 여러 행의 데이터를 하나의 값으로 집계하는 함수이므로 정답은 CREATE입니다. 정보처리기사 공식 교재의 SQL 관련 단원을 참고하면 집계 함수의 정의와 다양한 종류(AVG, COUNT, SUM, MAX, MIN 등)에 대한 설명을 자세히 찾아볼 수 있습니다.  비전공자도 쉽게 이해하도록 설명하자면,  집계 함수는 여러 개의 숫자를 가지고 하나의 결과값(합계, 평균 등)을 내는 계산기와 같다고 생각하면 됩니다.  CREATE는 계산기가 아니라 새로운 계산기를 만드는 공장과 같은 역할을 합니다.",90,26
159,1,2,59,릴레이션 조작 시 데이터들이 불필요하게 중복되어 예기치 않게 발생하는 곤란한 현상을 의미하는 것은?,,normalization,rollback,cardinality,anomaly,4,"릴레이션(관계)은 데이터베이스에서 테이블을 의미합니다.  데이터베이스를 설계할 때, 데이터 중복을 최소화하고 데이터 무결성을 유지하는 것이 매우 중요합니다.  만약 데이터가 불필요하게 중복되어 저장된다면, 데이터를 추가, 수정, 삭제할 때 여러 테이블을 일일이 수정해야 하는 문제가 발생할 수 있습니다.  이러한 작업은 매우 번거롭고 실수를 유발할 가능성이 높습니다.  더 심각한 문제는 데이터의 일관성을 깨뜨려 잘못된 정보가 저장되거나, 데이터베이스의 무결성에 심각한 문제를 야기할 수 있다는 점입니다.  이처럼 데이터 중복으로 인해 발생하는 예기치 못한 문제, 즉 데이터베이스의 이상 현상을  '이상 현상(anomaly)'이라고 부릅니다.  예를 들어, 고객 정보와 주문 정보를 하나의 테이블에 저장한다면, 같은 고객이 여러 번 주문했을 때 고객 정보가 중복 저장됩니다.  이 경우 고객 정보를 수정할 때 모든 행을 일일이 수정해야 하며, 고객 정보를 삭제할 때는 해당 고객의 모든 주문 정보도 함께 삭제해야 하는 등의 문제가 발생합니다.  이러한 문제들을 방지하기 위해 데이터베이스 정규화(normalization) 기법을 사용합니다.  정규화는 데이터 중복을 최소화하고 데이터 무결성을 높이는 설계 기법입니다.  따라서 데이터 중복으로 인해 발생하는 곤란한 현상을 설명하는 용어는 이상 현상(anomaly)입니다.",78,29
160,1,2,60,릴레이션에 대한 설명으로 거리가 먼 것은?,,"튜플들의 삽입, 삭제 등의 작업으로 인해 릴레이션은 시간에 따라 변한다.",한 릴레이션에 포함된 튜플들은 모두 상이하다.,애트리뷰트는 논리적으로 쪼갤 수 없는 원자값으로 저장한다.,한 릴레이션에 포함된 튜플 사이에는 순서가 있다.,4,"릴레이션은 데이터베이스에서 테이블과 같은 개념입니다.  테이블은 행(튜플)과 열(애트리뷰트)로 구성되는데, 각 행은 데이터베이스에 저장된 하나의 레코드를 나타내고, 각 열은 레코드의 특정 속성(예: 이름, 나이, 주소)을 나타냅니다. 문제에서 틀린 설명은 릴레이션 내 튜플(행) 사이에 순서가 있다는 것입니다.  릴레이션은 집합과 같은 개념으로, 집합의 원소에는 순서가 없듯이, 릴레이션에 있는 튜플들도 순서가 없습니다.  데이터베이스 시스템은 튜플을 저장하는 순서를 관리하지 않으며, 질의 결과를 표시할 때도 특별한 순서가 보장되지 않습니다.  다른 설명들은 모두 릴레이션의 특징을 정확하게 나타내고 있습니다. 튜플의 삽입, 삭제는 데이터베이스의 동적 특성을 보여주고, 각 튜플은 고유해야 하며(중복 불가), 애트리뷰트는 더 이상 쪼갤 수 없는 원자값으로 저장됩니다. 따라서 튜플 사이에 순서가 있다는 설명만이 릴레이션의 특징과 일치하지 않습니다.",77,29
161,1,2,61,다음 자바 프로그램 조건문에 대해 삼항 조건 연산자를 사용하여 옳게 나타낸 것은?,https://www.cbtbank.kr/images/iz/iz20200822/iz20200822m61.gif,"int i = 7, j = 9;",int k;,k = (i＞j)?(i ? j):(i + j);,"int i = 7, j = 9;",1,"문제에서 제시된 `if`문은 변수 `i`와 `j`의 크기를 비교하여 `i`가 `j`보다 크면 `k`에 `i - j`를, 그렇지 않으면 `k`에 `i + j`를 저장합니다.  이러한 조건문을 삼항 조건 연산자를 이용하여 간결하게 표현할 수 있습니다. 삼항 조건 연산자는  `(조건) ? (참일 때 값) : (거짓일 때 값)` 의 형태를 가지는데요,  문제의 `if`문을 이 형태에 맞춰 변환하면  `(i > j) ? (i - j) : (i + j)` 가 됩니다.  `i > j` 가 조건이고, 참이면 `i - j`, 거짓이면 `i + j` 가 `k`에 할당되는 것이죠. 따라서 정답은 `k`에 삼항 조건 연산자를 이용하여 값을 할당하는 코드입니다.  `i`와 `j`의 값을 선언하는 부분은 삼항 조건 연산자의 동작과는 무관하므로,  `i`와 `j`를 선언하는 코드는 정답에 포함될 필요가 없으며, `k`를 정수형 변수로 선언하는 부분도 마찬가지입니다.  따라서 정답은 삼항 조건 연산자를 이용하여 `i`와 `j`의 크기를 비교하고 그 결과에 따라 `k`의 값을 계산하는 코드입니다.",82,41
162,1,2,62,다음 내용이 설명하는 소프트웨어 취약점은?,https://www.cbtbank.kr/images/iz/iz20200822/iz20200822m62.gif,FTP 바운스 공격,SQL 삽입,버퍼 오버플로,디렉토리 접근 공격,3,"문제에서 설명하는 소프트웨어 취약점은 메모리를 다루는 과정에서 오류가 발생하여 프로그램이 잘못 동작하는 것입니다.  이는 프로그램이 할당받은 메모리 공간을 벗어나 다른 메모리 영역을 침범하는 '버퍼 오버플로우(Buffer Overflow)' 현상을 의미합니다.  버퍼 오버플로우는 프로그램이 데이터를 버퍼(임시 저장 공간)에 저장할 때, 버퍼의 크기를 초과하는 데이터를 기록하려고 시도하면 발생합니다. 이로 인해 인접한 메모리 영역의 데이터가 덮어쓰여져 프로그램이 예상치 못한 동작을 하거나, 심각한 경우 시스템 전체가 충돌하거나 악의적인 코드가 실행될 수 있습니다.  예를 들어, 사용자 입력값을 제대로 검증하지 않고 버퍼에 저장하는 경우, 악의적인 사용자가 과도한 입력값을 통해 버퍼를 넘쳐 흐르게 만들어 시스템을 공격할 수 있습니다.  따라서 메모리 관리 오류로 인한 잘못된 동작은 버퍼 오버플로우 취약점의 전형적인 특징입니다.  다른 선택지들은 네트워크 공격이나 데이터베이스 관련 취약점으로, 메모리 관리 오류와는 직접적인 관련이 없습니다.",78,54
163,1,2,63,다음 중 bash 쉘 스크립트에서 사용할 수 있는 제어문이 아닌 것은?,,if,for,repeat_do,while,3,"bash 쉘 스크립트는 리눅스나 유닉스 계열 운영체제에서 명령어들을 자동으로 실행하는 스크립트를 작성하는 데 사용하는 언어입니다.  if, for, while 문은 프로그래밍에서 흔히 사용되는 제어문으로,  bash 쉘 스크립트에서도  조건에 따라 코드 실행을 제어하거나 반복적인 작업을 수행하는 데 사용됩니다.  `if` 문은 조건이 참일 때만 코드 블록을 실행하고, `for` 문은 특정 횟수만큼 또는 목록의 요소들을 순회하며 코드 블록을 실행하며, `while` 문은 조건이 참인 동안 코드 블록을 반복적으로 실행합니다.  하지만 문제에서 제시된  `repeat_do` 문은 bash 쉘 스크립트에서 기본적으로 제공하는 제어문이 아닙니다.  bash 쉘 스크립트는 `until` 문을 제공하지만, `repeat_do` 와 같은 문법은 존재하지 않아,  `repeat_do`는 bash 쉘 스크립트에서 사용할 수 없는 제어문입니다. 따라서 정답은 `repeat_do`가 아닌 다른 선택지입니다.  쉽게 말해, bash 스크립트는  `if`, `for`, `while`을 알고 있지만 `repeat_do`라는 명령어는 모르는 것과 같습니다.",85,44
164,1,2,64,IPv6에 대한 설명으로 틀린 것은?,,32비트의 주소체계를 사용한다.,멀티미디어의 실시간 처리가 가능하다.,IPv4보다 보안성이 강화되었다.,자동으로 네트워크 환경구성이 가능하다.,1,"IPv6는 인터넷 프로토콜 버전 6으로, 기존 IPv4의 주소 부족 문제를 해결하기 위해 개발된 차세대 인터넷 프로토콜입니다.  IPv4는 32비트 주소 체계를 사용하여 약 43억 개의 주소만을 제공하지만, IPv6는 128비트 주소 체계를 사용하여 엄청나게 많은 수의 주소를 제공합니다. 따라서 문제에서 '32비트의 주소체계를 사용한다'는 설명은 IPv6의 특징과 맞지 않아 틀린 설명입니다.  나머지 선택지들은 모두 IPv6의 장점을 잘 나타내고 있습니다. 멀티미디어 실시간 처리의 향상, 보안성 강화, 자동 네트워크 환경 구성 등은 IPv6가 IPv4에 비해 갖는 주요한 개선 사항들입니다.  결론적으로, 32비트 주소 체계를 사용한다는 설명만이 IPv6의 실제 특징과 일치하지 않으므로 틀린 설명입니다.",89,45
165,1,2,65,효과적인 모듈 설계를 위한 유의사항으로 거리가 먼 것은?,,모듈간의 결합도를 약하게 하면 모듈 독립성이 향상된다.,복잡도와 중복성을 줄이고 일관성을 유지시킨다.,모듈의 기능은 예측이 가능해야 하며 지나치게 제한적 이여야 한다.,유지보수가 용이해야 한다.,3,"효과적인 모듈 설계를 위해서는 여러 가지 원칙을 고려해야 합니다.  모듈 간의 의존성을 최소화하여 각 모듈이 독립적으로 동작하고 유지보수가 용이하도록 하는 것이 중요합니다.  복잡성과 중복을 줄이고 일관성을 유지하는 것 또한 효율적인 설계를 위한 필수적인 요소입니다.  하지만 모듈의 기능이 지나치게 제한적이어야 한다는 것은 잘못된 생각입니다.  모듈은 특정 기능을 수행하도록 설계되지만,  너무 제한적인 기능만을 가지도록 설계하면 다른 모듈과의 연동이 어려워지고 전체 시스템의 효율성을 떨어뜨릴 수 있습니다.  오히려 적절한 수준의 기능을 가지면서 다른 모듈과의 상호작용을 최소화하는 방향으로 설계하는 것이 중요합니다.  따라서,  모듈의 기능이 예측 가능해야 하면서 동시에 지나치게 제한적이어야 한다는 주장은 효과적인 모듈 설계의 원칙과는 거리가 멉니다.  모듈은 독립적이면서도 전체 시스템의 목표를 달성하기 위해 필요한 기능을 적절히 수행할 수 있도록 설계되어야 합니다.  마치 잘 만들어진 레고 블록처럼, 각 블록(모듈)은 독립적으로 기능하지만,  조합하여 더 큰 구조물(시스템)을 만들 수 있어야 하는 것과 같습니다.",90,6
166,1,2,66,"HRN 방식으로 스케줄링 할 경우, 입력된 작업이 다음과 같을 때 처리되는 작업 순서로 옳은 것은?",https://www.cbtbank.kr/images/iz/iz20200822/iz20200822m66.gif,A→B→C→D,A→C→B→D,D→B→C→A,D→A→B→C,3,HRN(Highest Response Ratio Next) 스케줄링은 응답률이 가장 높은 작업부터 처리하는 방식입니다. 응답률은 (대기시간 + 서비스시간) / 서비스시간으로 계산됩니다.  각 작업의 응답률을 계산해보면 다음과 같습니다.,61,44
167,1,2,67,운영체제에 대한 설명으로 거리가 먼 것은?,,다중 사용자와 다중 응용프로그램 환경하에서 자원의 현재 상태를 파악하고 자원 분배를 위한 스케줄링을 담당한다.,"CPU, 메모리 공간, 기억 장치, 입출력 장치 등의 자원을 관리한다.","운영체제의 종류로는 매크로 프로세서, 어셈블러, 컴파일러 등이 있다.",입출력 장치와 사용자 프로그램을 제어한다.,3,"이 문제는 운영체제의 역할과 기능에 대한 이해도를 묻고 있습니다.  운영체제는 컴퓨터 시스템의 하드웨어와 소프트웨어 자원을 관리하고, 사용자와 응용 프로그램이 하드웨어를 효율적으로 사용할 수 있도록 중개하는 역할을 합니다.  제시된 보기 중 세 가지는 운영체제의 주요 기능을 정확하게 설명하고 있습니다.  예를 들어, 다중 사용자 환경에서 자원을 관리하고 분배하는 것, CPU, 메모리, 입출력 장치 등의 하드웨어 자원을 관리하는 것, 그리고 사용자 프로그램과 입출력 장치를 제어하는 것은 모두 운영체제의 핵심적인 역할입니다.  하지만 나머지 하나는 운영체제의 기능과는 관련이 없습니다.  매크로 프로세서, 어셈블러, 컴파일러는 프로그래밍 언어를 처리하고 기계어 코드로 변환하는 데 사용되는 도구들로, 운영체제 자체의 종류가 아니며 운영체제 내부에서 작동하는 프로그램이라고 볼 수 있습니다.  따라서 운영체제의 설명으로 거리가 먼 것은 바로 이 부분입니다.  쉽게 말해, 운영체제는 컴퓨터의 '관리자'와 같은 역할을 하는데,  '관리자'의 종류가 매크로 프로세서, 어셈블러, 컴파일러라는 것은 맞지 않죠.  운영체제는 이러한 도구들을 *활용*할 수는 있지만, 그 자체가 이러한 도구들의 종류는 아닙니다.",79,44
168,1,2,68,배치 프로그램의 필수 요소에 대한 설명으로 틀린 것은?,,자동화는 심각한 오류 상황 외에는 사용자의 개입 없이 동작해야 한다.,"안정성은 어떤 문제가 생겼는지, 언제 발생했는지 등을 추적할 수 있어야 한다.",대용량 데이터는 대용량의 데이터를 처리할 수 있어야 한다.,"무결성은 주어진 시간 내에 처리를 완료할 수 있어야 하고, 동시에 동작하고 있는 다른 애플리케이션을 방해하지 말아야 한다.",4,"배치 프로그램은 사용자의 개입 없이 자동으로 대량의 데이터를 처리하는 프로그램입니다.  문제에서 틀린 설명은 '주어진 시간 내에 처리를 완료할 수 있어야 하고, 동시에 동작하고 있는 다른 애플리케이션을 방해하지 말아야 한다'는 부분입니다.  배치 프로그램은 대량의 데이터를 처리하는 데 시간이 오래 걸릴 수 있으며,  실행 중 다른 애플리케이션에 영향을 미칠 수 있습니다.  즉,  무결성이란 데이터의 정확성과 신뢰성을 의미하는데,  문제의 설명은 처리 속도와 다른 애플리케이션과의 동시 실행 가능성에 초점을 맞추고 있어 배치 프로그램의 무결성과는 직접적인 관련이 없습니다.  배치 프로그램의 무결성은 오류 없이 정확한 결과를 생성하는 것에 더 중점을 두어야 합니다.  다른 선지들은 배치 프로그램의 필수적인 요소들을 잘 나타내고 있습니다. 자동화는 사용자 개입 없이 동작해야 하고, 안정성을 위해 오류 추적 기능이 필요하며, 대용량 데이터 처리 능력은 필수적입니다. 따라서,  처리 시간과 다른 애플리케이션과의 동시 실행 여부는 배치 프로그램의 무결성을 정의하는 데 적절하지 않습니다.",62,40
169,1,2,69,TCP 프로토콜에 대한 설명으로 거리가 먼 것은?,,신뢰성이 있는 연결 지향형 전달 서비스이다.,기본 헤더 크기는 100byte이고 160byte까지 확장 가능하다.,스트림 전송 기능을 제공한다.,"순서제어, 오류제어, 흐름제어 기능을 제공한다.",2,"TCP 프로토콜은 인터넷에서 데이터를 안전하고 신뢰성 있게 전송하는 데 사용되는 중요한 프로토콜입니다.  데이터를 보낼 때,  순서대로 전달되었는지,  데이터가 손상되었는지 등을 확인하고,  문제가 발생하면 재전송하는 등의 기능을 제공하여 신뢰성을 보장합니다.  마치 편지를 부칠 때,  우체부가 편지를 안전하게 목적지까지 배달하고,  배달 확인을 해주는 것과 비슷합니다.  문제에서 틀린 설명은 TCP 헤더의 크기에 대한 부분입니다. TCP 헤더의 기본 크기는 20바이트이며, 옵션을 추가하면 최대 60바이트까지 확장될 수 있습니다.  100바이트 또는 160바이트라는 설명은 사실과 다릅니다.  나머지 설명들은 모두 TCP 프로토콜의 주요 특징을 정확하게 나타내고 있습니다.  따라서 TCP 헤더 크기에 대한 잘못된 정보를 포함한 선지가 정답입니다.",77,45
170,1,2,70,다음이 설명하는 응집도의 유형은?,https://www.cbtbank.kr/images/iz/iz20200822/iz20200822m70.gif,기능적 응집도,우연적 응집도,논리적 응집도,절차적 응집도,4,"문제에서 설명하는 응집도 유형은 모듈 내 구성 요소들이 순차적으로 기능을 수행하는 경우를 말합니다.  마치 조립 라인처럼, 하나의 작업이 끝나면 다음 작업으로 넘어가는 방식이죠.  이러한 순차적인 처리 과정을 강조하는 응집도 유형이 바로 '절차적 응집도'입니다.  다른 응집도 유형들은 각 구성 요소들이 서로 다른 기능을 수행하거나(우연적 응집도), 논리적으로 관련은 있지만 순차적 처리가 아닌 경우(논리적 응집도),  하나의 명확한 기능을 수행하는 경우(기능적 응집도)를 나타냅니다.  문제에서 제시된 ""모듈이 다수의 관련 기능을 가질 때 모듈 안의 구성 요소들이 그 기능을 순차적으로 수행할 경우""라는 설명은 절차적 응집도의 특징을 정확하게 보여줍니다.  따라서,  모듈 내 구성 요소들이 순차적인 절차에 따라 기능을 수행하는 이러한 응집도 유형은 절차적 응집도라고 할 수 있습니다.",81,6
171,1,2,71,"OSI-7Layer에서 링크의 설정과 유지 및 종료를 담당하며, 노드간의 오류제어와 흐름제어 기능을 수행하는 계층은?",,데이터링크 계층,물리 계층,세션 계층,응용 계층,1,"OSI 7계층 모델은 네트워크 통신을 7개의 계층으로 나누어 각 계층이 특정 기능을 담당하도록 설계된 모델입니다.  문제에서 언급된 ""링크의 설정과 유지 및 종료를 담당하며, 노드 간의 오류 제어와 흐름 제어 기능을 수행하는 계층""은 바로 데이터링크 계층입니다.  쉽게 말해, 데이터를 실제로 전송하기 전에,  데이터가 제대로 전송될 수 있도록 통로(링크)를 준비하고 관리하는 역할을 합니다.  마치 고속도로를 건설하고 관리하는 것과 같습니다.  고속도로(링크)를 만들고(설정),  유지보수하고(유지),  필요 없으면 폐쇄하는(종료) 역할을 하는 것이죠.  또한, 데이터가 손상되지 않고 제대로 도착하도록 오류를 검출하고 수정하며(오류 제어),  데이터가 너무 빨리 쏟아져서 수신측이 감당하지 못하는 것을 방지하기 위해 데이터 전송 속도를 조절하는(흐름 제어) 역할도 수행합니다.  물리 계층은 전기 신호를 통해 데이터를 전송하는 가장 기본적인 계층이고, 세션 계층과 응용 계층은 더 상위 계층으로,  데이터 전송보다는 통신 세션 관리나 응용 프로그램과의 인터페이스 역할을 합니다. 따라서 데이터링크 계층이 문제의 조건에 가장 부합합니다. 정보처리기사 공식 교재의 OSI 7계층 설명 부분을 참고하면 더욱 자세한 내용을 확인할 수 있습니다.",79,45
172,1,2,72,다음 중 가장 결합도가 강한 것은?,,data coupling,stamp coupling,common coupling,control coupling,3,"이 문제는 소프트웨어 모듈 간의 결합도(Coupling)에 대한 이해를 묻고 있습니다.  결합도란 모듈 간의 상호 의존성 정도를 나타내는 척도로, 결합도가 높을수록 모듈 간의 의존성이 강하고, 결합도가 낮을수록 모듈 간의 독립성이 높습니다.  결합도가 높으면 하나의 모듈을 변경할 때 다른 모듈에도 영향을 미칠 가능성이 높아져 유지보수가 어려워지고, 오류 발생 가능성도 증가합니다. 반대로 결합도가 낮으면 모듈 간의 독립성이 높아져 유지보수가 용이하고, 오류 수정 및 새로운 기능 추가가 쉽습니다.",64,6
173,1,2,73,메모리 관리 기법 중 Worst fit 방법을 사용할 경우 10K 크기의 프로그램 실행을 위해서는 어느 부분에 할당되는가?,https://www.cbtbank.kr/images/iz/iz20200822/iz20200822m73.gif,NO.2,NO.3,NO.4,NO.5,4,"Worst fit 메모리 할당 기법은 사용 가능한 메모리 블록 중 가장 큰 크기의 블록에 프로그램을 할당하는 방법입니다.  문제에서 10K 크기의 프로그램을 실행하기 위해 메모리를 할당해야 하는데, 사용 가능한 메모리 블록은 8K, 12K, 16K 세 곳이 있습니다. Worst fit 기법은 가장 큰 크기의 블록을 선택하므로, 16K 크기의 메모리 블록(NO.5)에 프로그램을 할당하게 됩니다.  8K와 12K 블록은 프로그램 크기보다 작아 할당할 수 없고,  16K 블록은 10K 프로그램을 충분히 수용할 수 있으며 남는 공간(6K)도 발생하지만, Worst fit은 가장 큰 블록을 우선적으로 사용하기 때문에  16K 블록이 선택되는 것입니다.  따라서 정답은 16K 크기의 메모리 영역입니다.",69,44
174,1,2,74,200.1.1.0/24 네트워크를 FLSM 방식을 이용하여 10개의 Subnet으로 나누고 ip subnet-zero를 적용했다. 이때 서브네팅된 네트워크 중 10번째 네트워크의 broadcast IP주소는?,,200.1.1.159,201.1.5.175,202.1.11.254,203.1.255.245,1,"200.1.1.0/24 네트워크는 24비트의 네트워크 주소를 사용하므로, 호스트 주소 부분은 8비트(256개의 IP 주소)를 사용할 수 있습니다.  이 네트워크를 10개의 서브넷으로 나누려면, 호스트 주소 부분에서 일부 비트를 서브넷 주소로 사용해야 합니다. 10개의 서브넷을 표현하려면 최소 4비트(2⁴=16)가 필요합니다.  따라서, 원래의 네트워크 주소 /24에서 4비트를 빌려와 /28로 변경합니다.  (/28은 256개의 IP 주소에서 16개의 서브넷으로 나누어 각 서브넷은 14개의 호스트 주소를 가집니다. (2?-2=254-16=238)).",52,45
175,1,2,75,다음은 사용자로부터 입력받은 문자열에서 처음과 끝의 3글자를 추출한 후 합쳐서 출력하는 파이썬 코드에서 ㉠에 들어갈 내용은?,https://www.cbtbank.kr/images/iz/iz20200822/iz20200822m75.gif,string[1:3] + string[-3:],string[:3] + string[-3:-1],string[0:3] + string[-3:],string[0:] + string[:-1],3,"문제에서 요구하는 것은 사용자로부터 입력받은 문자열의 처음 3글자와 끝 3글자를 추출하여 합치는 것입니다.  파이썬에서는 문자열을 리스트처럼 인덱싱하여 접근할 수 있습니다.  문자열의 첫 번째 글자는 인덱스 0, 두 번째 글자는 인덱스 1, ... 이런 식으로 접근합니다.  마지막 글자는 인덱스 -1, 그 앞 글자는 -2, ... 와 같이 음수 인덱스를 사용하여 뒤에서부터 접근할 수도 있습니다.",73,41
176,1,2,76,파이썬의 변수 작성 규칙 설명으로 옳지 않은 것은?,,첫 자리에 숫자를 사용할 수 없다.,"영문 대문자/소문자, 숫자, 밑줄(_)의 사용이 가능하다.",변수 이름의 중간에 공백을 사용할 수 있다.,이미 사용되고 있는 예약어는 사용할 수 없다.,3,"파이썬 변수 작성 규칙에 대한 문제입니다.  프로그래밍에서 변수는 데이터를 저장하는 공간의 이름이라고 생각하면 됩니다.  이름을 잘 지어야 나중에 코드를 이해하기 쉽고, 오류를 줄일 수 있죠.  문제에서 옳지 않은 설명을 찾는 것이므로, 파이썬 변수 이름 규칙을 잘 알고 있어야 합니다.",84,41
177,1,2,77,"어떤 모듈이 다른 모듈의 내부 논리 조직을 제어하기 위한 목적으로 제어신호를 이용하여 통신하는 경우이며, 하위 모듈에서 상위 모듈로 제어신호가 이동하여 상위 모듈에게 처리 명령을 부여하는 권리 전도현상이 발생하게 되는 결합도는?",,data coupling,stamp coupling,control coupling,common coupling,3,"문제에서 설명하는 상황은 어떤 모듈이 다른 모듈에게 단순히 데이터를 전달하는 것이 아니라, **제어 신호**를 이용하여 다른 모듈의 동작을 직접 제어하는 경우입니다.  마치 상사가 부하 직원에게 특정 업무를 지시하는 것과 같습니다.  하위 모듈은 상위 모듈로부터 받은 제어 신호에 따라 동작을 변경하는데, 이때 상위 모듈이 하위 모듈의 동작을 결정하는 권한을 갖게 되는 현상, 즉 **권리 전도**가 발생합니다. 이러한 결합 방식은 모듈 간의 의존성을 높이고, 유지보수 및 변경에 어려움을 초래할 수 있습니다.  이처럼 제어 신호를 통해 다른 모듈의 내부 논리를 제어하는 결합도를  **제어 결합(Control Coupling)**이라고 합니다.  데이터 결합은 단순히 데이터만 주고받는 것이고, 스탬프 결합은 데이터 구조체 전체를 전달하는 것이며, 공통 결합은 여러 모듈이 공유 변수를 사용하는 경우입니다.  문제에서 제시된 상황은 제어 신호를 이용하여 하위 모듈의 동작을 직접 제어하는 것이므로, 제어 결합이 가장 적절한 설명입니다.  정보처리기사 공식 교재의 모듈화 및 결합도, 응집도에 대한 내용을 참고하면 더욱 명확하게 이해할 수 있을 것입니다.",80,6
178,1,2,78,다음 C 프로그램의 결과 값은?,https://www.cbtbank.kr/images/iz/iz20200822/iz20200822m78.gif,15,19,25,27,3,"이 C 프로그램은 1부터 10까지의 홀수들의 합을 계산하는 프로그램입니다.  `for` 문에서 `i = i + 2` 부분은 `i` 값을 2씩 증가시키므로, `i`는 1, 3, 5, 7, 9의 값을 순차적으로 가지게 됩니다.  `sum` 변수는 이 홀수들을 누적하여 더하는 역할을 합니다. 따라서 프로그램의 실행 결과는 1 + 3 + 5 + 7 + 9 = 25가 됩니다.  `printf` 함수는 계산된 `sum` 값(25)을 출력합니다.  따라서 정답은 25입니다.",79,41
179,1,2,79,UNIX에서 새로운 프로세스를 생성하는 명령어는?,,ls,cat,fork,chmod,3,"UNIX 운영체제에서 새로운 프로세스를 생성하는 것은 매우 중요한 기능입니다.  프로세스란, 컴퓨터에서 실행 중인 프로그램을 의미하는데, 하나의 프로그램이 여러 개의 작업을 동시에 처리해야 할 때는 여러 개의 프로세스로 나누어 처리하는 것이 효율적입니다.  이때, 기존 프로세스에서 새로운 프로세스를 생성하는 명령어가 필요한데, UNIX에서는 `fork()` 시스템 콜이 바로 그 역할을 합니다.  `fork()`는 부모 프로세스가 자신과 동일한 자식 프로세스를 생성하는 명령어입니다. 자식 프로세스는 부모 프로세스의 메모리 공간을 복사하여 시작하며, 부모 프로세스와 독립적으로 실행됩니다.  반면, 나머지 선택지들은 파일 목록을 보여주는 명령어, 파일 내용을 출력하는 명령어, 파일 접근 권한을 변경하는 명령어로, 새로운 프로세스를 생성하는 기능과는 관련이 없습니다. 따라서 UNIX에서 새로운 프로세스를 생성하는 명령어는 `fork()`입니다.",68,44
180,1,2,80,C언어에서 정수 자료형으로 옳은 것은?,,int,float,char,double,1,"C언어에서 자료형은 변수에 저장될 값의 종류와 크기를 나타냅니다.  정수 자료형은 정수 값(소수점이 없는 숫자)을 저장하는 데 사용됩니다.  제시된 선택지 중에서 `int`는 C언어에서 정수를 저장하기 위해 사용하는 기본적인 자료형입니다.  `float`와 `double`은 실수(소수점이 있는 숫자)를 저장하는 자료형이며, `char`는 문자 하나를 저장하는 자료형입니다. 따라서 정수 자료형으로 옳은 것은 `int`입니다.  마치 레고 블록처럼,  컴퓨터는 다양한 종류의 데이터를 다루는데,  정수를 저장하는 특별한 용기가 필요하고, 그 용기의 이름이 바로 `int`인 것입니다.",88,41
181,1,2,81,"물리적인 사물과 컴퓨터에 동일하게 표현되는 가상의 모델로 실제 물리적인 자산 대신 소프트웨어로 가상화함으로써 실제 자산의 특성에 대한 정확한 정보를 얻을 수 있고, 자산 최적화, 돌발사고 최소화, 생산성 증가 등 설계부터 제조, 서비스에 이르는 모든 과정의 효율성을 향상시킬 수 있는 모델은?",,최적화,실행 시간,디지털 트윈,N-Screen,3,"문제에서 설명하는 모델은 실제 존재하는 물리적인 사물을 컴퓨터 안에 가상으로 완벽하게 구현한 것입니다.  마치 실제 사물의 쌍둥이(Twin)처럼 똑같이 동작하고, 데이터를 주고받으며, 실제 사물의 상태를 정확하게 반영합니다.  이를 통해 실제 사물을 직접 조작하지 않고도 시뮬레이션을 통해 다양한 상황을 예측하고, 문제점을 미리 파악하여 해결할 수 있습니다.  예를 들어, 자동차를 설계할 때 실제 자동차를 만들어 테스트하는 대신 디지털 트윈을 이용하여 가상으로 충돌 테스트를 수행하고, 성능을 분석할 수 있습니다.  이러한 가상 모델을 통해 실제 자산을 운영하는 것보다 훨씬 효율적으로 자산을 최적화하고, 예상치 못한 사고를 최소화하며, 생산성을 높일 수 있습니다.  따라서 설계부터 제조, 서비스까지 전 과정의 효율성을 향상시키는 데 크게 기여하는 모델이 바로 문제에서 묻고 있는 모델입니다.  최적화, 실행 시간, N-Screen은 모두 디지털 트윈을 구현하거나 활용하는 과정에서 나타날 수 있는 결과이거나 관련 기술이지만, 디지털 트윈 자체를 정의하는 것은 아닙니다.",73,50
182,1,2,82,정보보안의 3대 요소에 해당하지 않는 것은?,,기밀성,휘발성,무결성,가용성,2,"정보보안의 핵심은 정보 자산을 안전하게 보호하는 데 있습니다.  이를 위해서는 정보의 기밀성(비밀 유지), 무결성(데이터의 정확성과 신뢰성 유지), 가용성(필요한 사람이 필요한 때에 정보에 접근할 수 있는 상태 유지)이라는 세 가지 중요한 요소가 필요합니다.  마치 삼각형의 세 변과 같이, 이 세 가지 요소가 모두 충족되어야만 정보 시스템이 안전하게 운영될 수 있습니다.  문제에서 제시된 나머지 선택지는 정보보안의 3대 요소에 포함되지 않습니다.  '휘발성'은 데이터가 일정 시간이 지나면 사라지는 성질을 의미하는데, 이는 정보보안의 목표와는 직접적인 관련이 없습니다.  정보보안은 데이터가 얼마나 오래 저장되는지가 아니라, 저장된 데이터가 안전하게 보호되는지에 초점을 맞춥니다. 따라서 정보보안의 3대 요소에 해당하지 않는 것은 '휘발성'입니다.",88,53
183,1,2,83,다음 빈칸에 알맞은 기술은,https://www.cbtbank.kr/images/iz/iz20200822/iz20200822m83.gif,Quantum Key Distribution,Digital Rights Management,Grayware,Mashup,4,"문제에서 빈칸에 들어갈 기술은 웹에서 제공하는 정보와 서비스를 활용하여 새로운 소프트웨어, 서비스, 데이터베이스 등을 만드는 기술입니다.  쉽게 말해, 이미 존재하는 여러 웹 서비스들을 조합하여 새로운 것을 만들어내는 기술이라고 생각하면 됩니다.  예를 들어, 지도 서비스의 정보와 부동산 정보 서비스를 결합하여 특정 지역의 부동산 정보를 지도 위에 표시하는 새로운 서비스를 만드는 것이죠.  이처럼 기존 웹 서비스들을 재조합하여 새로운 가치를 창출하는 기술이 바로 정답입니다.  다른 선지들은 웹 서비스의 조합과는 직접적인 관련이 없습니다.  양자암호키분배(Quantum Key Distribution)는 보안 통신 기술이고, 디지털 저작권 관리(Digital Rights Management)는 콘텐츠 보호 기술이며, 그레이웨어(Grayware)는 악성코드의 일종입니다. 따라서, 웹 서비스의 재조합을 통해 새로운 것을 만드는 기술의 개념과 가장 잘 부합하는 것은 정답입니다.",73,38
184,1,2,84,기능점수(Functional Point)모형에서 비용산정에 이용되는 요소가 아닌 것은?,,클래스 인터페이스,명령어(사용자 질의수),데이터파일,출력보고서,1,"기능점수(Functional Point) 모형은 소프트웨어 개발 비용을 산정하는 방법 중 하나입니다.  이 모형은 소프트웨어의 기능적인 측면에 초점을 맞춰 비용을 예측하는데,  소프트웨어가 제공하는 기능의 양을 측정하여 비용을 추산합니다.  여기서 중요한 것은 소프트웨어의 기능을 구성하는 요소들을 정확하게 파악하는 것입니다.  데이터 파일, 출력 보고서, 그리고 사용자의 질의(명령어)는 모두 소프트웨어가 제공하는 기능의 중요한 구성 요소입니다.  데이터 파일은 소프트웨어가 처리하는 데이터의 저장소 역할을 하고, 출력 보고서는 처리 결과를 사용자에게 전달하는 매개체이며, 사용자 질의는 소프트웨어가 어떤 기능을 수행할지 결정하는 입력값입니다.  반면에 클래스 인터페이스는 소프트웨어의 내부 구조를 나타내는 개념으로,  소프트웨어의 기능 자체를 직접적으로 나타내는 요소는 아닙니다.  클래스 인터페이스는 개발자 관점에서 중요하지만, 기능점수 모형에서 소프트웨어의 기능 크기를 측정하는 데는 직접적으로 사용되지 않습니다. 따라서 소프트웨어 기능의 양을 측정하는 기능점수 모형에서 비용 산정에 직접적으로 사용되지 않는 요소는 클래스 인터페이스입니다.  쉽게 말해, 사용자는 데이터 파일, 보고서, 질의를 통해 소프트웨어와 상호작용하지만, 클래스 인터페이스는 사용자에게 직접적으로 보이거나 영향을 주는 요소가 아니기 때문입니다.",42,47
185,1,2,85,블록 암호화 방식이 아닌 것은?,,DES,RC4,AES,SEED,2,"이 문제는 블록 암호화 방식과 그렇지 않은 방식을 구분하는 문제입니다.  블록 암호화는 데이터를 일정 크기의 블록으로 나누어 각 블록을 독립적으로 암호화하는 방식입니다.  DES(Data Encryption Standard), AES(Advanced Encryption Standard), SEED는 모두 데이터를 고정된 크기의 블록으로 나누어 암호화하는 대표적인 블록 암호 알고리즘입니다.  반면, RC4는 스트림 암호 방식입니다. 스트림 암호는 데이터를 비트 또는 바이트 단위로 순차적으로 암호화하는 방식으로, 블록 단위로 나누지 않고 연속적으로 암호화를 수행합니다. 따라서 블록 암호화 방식이 아닌 것은 RC4입니다.  쉽게 말해, 블록 암호는 레고 블록을 하나씩 조립하듯 데이터를 암호화하는 것이고, 스트림 암호는 긴 끈을 계속 엮어나가듯 데이터를 암호화하는 것입니다.  문제에서 묻는 것은 블록 암호화 방식이 *아닌* 것을 찾는 것이므로, 블록 단위로 암호화하지 않는 RC4가 정답입니다.",65,54
186,1,2,86,Putnam 모형을 기초로 해서 만든 자동화 추정 도구는?,,SQLR/30,SLIM,MESH,NFV,2,"이 문제는 소프트웨어 개발 및 시스템 분석에서 자동화된 추정 도구에 대한 이해를 묻고 있습니다.  Putnam 모형은 소프트웨어 개발 프로젝트의 노력, 기간, 비용 등을 예측하는데 사용되는 유명한 모델입니다.  이 모형을 기반으로 하여 실제 프로젝트의 추정을 자동화하는 도구가 필요한데,  제시된 선택지 중에서 Putnam 모형을 기초로 하여 만들어진 자동화 추정 도구는 SLIM입니다.  SLIM(Software Life Cycle Management)은 소프트웨어 개발 프로젝트의 다양한 측면을 관리하고 예측하는 데 사용되는 도구이며, Putnam 모형의 복잡한 계산을 자동화하여 개발 프로젝트의 효율적인 관리를 지원합니다. 다른 선택지는 소프트웨어 개발이나 시스템 관리와 관련된 용어이지만, Putnam 모형을 기반으로 한 자동화 추정 도구와는 직접적인 관련이 없습니다. 따라서 SLIM이 정답입니다.",73,3
187,1,2,87,큰 숫자를 소인수 분해하기 어렵다는 기반 하에 1978년 MIT에 의해 제안된 공개키 암호화 알고리즘은?,,DES,ARIA,SEED,RSA,4,"이 문제는 큰 숫자를 소인수분해하는 것이 어렵다는 수학적 원리를 이용한 암호화 알고리즘을 묻고 있습니다.  RSA 알고리즘은 바로 이 원리를 기반으로 설계된 공개키 암호화 알고리즘입니다.  공개키 암호화는 두 개의 키, 즉 공개키와 개인키를 사용하는데, 공개키는 누구에게나 공개되어도 안전하고 개인키는 소유자만 알고 있어야 합니다.  RSA 알고리즘은 매우 큰 두 소수(100자리 이상)를 곱하여 얻은 수(n)를 공개키로 사용합니다.  이 n을 소인수분해하는 것은 엄청난 계산량을 필요로 하기 때문에,  실제로는 거의 불가능에 가깝습니다.  따라서 공개키로 암호화된 정보는 개인키를 가지고 있는 사람만 해독할 수 있습니다.  다른 선택지들은 대칭키 암호화 알고리즘(DES, ARIA, SEED)이거나, 문제의 조건(공개키 암호화 알고리즘, 1978년 MIT 제안)을 만족하지 않습니다.  따라서 큰 수의 소인수분해의 어려움을 기반으로 한 공개키 암호화 알고리즘인 RSA가 정답입니다.",78,54
188,1,2,88,COCOMO 모델의 프로젝트 유형으로 거리가 먼 것은?,,Organic,Semi-detached,Embedded,Sequentail,4,"COCOMO 모델은 소프트웨어 개발 프로젝트의 개발 기간과 비용을 예측하는 모델입니다.  이 모델은 프로젝트의 규모와 복잡성에 따라 Organic, Semi-detached, Embedded 세 가지 유형으로 프로젝트를 분류합니다.  Organic 유형은 소규모, 잘 정의된 프로젝트에 적용되고, Semi-detached 유형은 중간 규모의 프로젝트, Embedded 유형은 하드웨어와 밀접하게 연관된 시스템 소프트웨어 개발 프로젝트에 적용됩니다.  반면에 문제에서 거리가 먼 것으로 제시된 유형은  소프트웨어 개발 프로젝트의 유형 분류와는 관련이 없습니다.  COCOMO 모델은 프로젝트의 특성(규모, 복잡성, 요구사항의 명확성 등)을 고려하여 개발 기간과 비용을 예측하는 데 초점을 맞추고 있기 때문에,  해당 유형은 COCOMO 모델의 프로젝트 분류 체계와는 맞지 않습니다. 따라서 COCOMO 모델의 프로젝트 유형으로 분류되지 않는 것이 정답입니다.",81,47
189,1,2,89,빅데이터 분석 기술 중 대량의 데이터를 분석하여 데이터 속에 내재되어 있는 변수 사이의 상호관례를 규명하여 일정한 패턴을 찾아내는 기법은?,,Data Mining,Wm-Bus,Digital Twin,Zigbee,1,"이 문제는 빅데이터 분석 기술 중 데이터 속에 숨겨진 패턴을 찾는 기법을 묻고 있습니다.  쉽게 말해, 방대한 데이터 더미 속에서 유용한 정보를 캐내는 기술이라고 생각하면 됩니다.  예를 들어, 온라인 쇼핑몰의 구매 데이터를 분석하여 어떤 고객이 어떤 상품을 선호하는지, 어떤 상품들이 함께 구매되는지 등의 패턴을 찾아내는 것이죠.  이러한 패턴 분석을 통해 마케팅 전략을 개선하거나 새로운 상품 개발에 활용할 수 있습니다.  제시된 선택지 중에서 대량의 데이터를 분석하여 변수 간의 상호관계와 패턴을 찾는 기법을 가장 잘 설명하는 것은 바로 데이터 마이닝(Data Mining)입니다. 데이터 마이닝은 통계, 머신러닝 등 다양한 기법을 활용하여 데이터 속에 숨겨진 지식을 발견하는 과정을 의미합니다.  다른 선택지는 특정 기술이나 개념을 나타내는 용어로, 데이터 분석의 핵심 기법으로 볼 수 없습니다. 따라서 정답은 데이터 마이닝입니다. 정보처리기사 공식 교재에서도 데이터 마이닝이 빅데이터 분석의 핵심 기술로 소개되고 있으며, 대량 데이터 분석을 통해 패턴을 발견하는 기법으로 설명하고 있습니다.",80,30
190,1,2,90,"기존 무선 랜의 한계 극복을 위해 등장하였으며, 대규모 디바이스의 네트워크 생성에 최적화되어 차세대 이동통신, 홈네트워킹, 공공 안전 등의 특수목적을 위한 새로운 방식의 네트워크 기술을 의미하는 것은?",,Software Defined Perimeter,Virtual Private Network,Local Area Network,Mesh Network,4,"이 문제는 기존 무선랜의 한계를 극복하고 대규모 기기 연결에 적합한 차세대 네트워크 기술을 묻고 있습니다.  기존 무선랜은 중앙 장치(Access Point)를 중심으로 기기들이 연결되는 방식이라,  장치 수가 많아지거나 통신 거리가 멀어지면 성능이 저하되고 안정성이 떨어지는 문제가 있었습니다.  반면, 정답으로 제시된 네트워크 기술은 여러 장치들이 서로 직접 연결되어 네트워크를 형성하는 구조입니다.  마치 벌집처럼 각 장치가 다른 장치들과 연결되어 있어, 하나의 장치가 고장 나더라도 다른 경로를 통해 통신이 가능하다는 장점이 있습니다.  이러한 특징 때문에 대규모 기기 연결이 필요한 차세대 이동통신, 스마트홈 네트워크, 재난 대응 등의 분야에 적합합니다.  따라서 대규모 디바이스의 네트워크 생성에 최적화되어 있고, 특수 목적을 위한 새로운 방식의 네트워크 기술이라는 문제의 조건에 가장 잘 부합하는 것은 메시 네트워크입니다.",62,49
191,1,2,91,DDoS 공격과 연관이 있는 공격 방법은?,,Secure shell,Tribe Flood Network,Nimda,Deadlock,2,"DDoS 공격은 분산 서비스 거부 공격으로, 여러 대의 컴퓨터를 이용하여 특정 서버나 네트워크에 과도한 트래픽을 발생시켜 서비스를 마비시키는 공격 방식입니다.  Tribe Flood Network는 이러한 DDoS 공격에 사용되는 대표적인 방법 중 하나입니다.  Tribe Flood Network는 여러 대의 감염된 컴퓨터(봇넷)을 이용하여 목표 서버에 동시에 많은 요청을 보내 과부하를 일으켜 서비스를 중단시키는 방식입니다.  다른 선택지들은 DDoS 공격과 직접적인 관련이 없습니다. Secure shell은 안전한 원격 접속을 위한 프로토콜이고, Nimda는 웜 바이러스의 일종이며, Deadlock은 프로그램 실행 중 발생하는 교착 상태를 의미합니다. 따라서 DDoS 공격과 직접적으로 연관된 공격 방법은 Tribe Flood Network입니다.  정보처리기사 시험에서는 네트워크 보안에 대한 이해를 묻는 문제가 자주 출제되며, DDoS 공격과 그에 사용되는 방법들을 숙지하는 것이 중요합니다.",68,55
192,1,2,92,CPM 네트워크가 다음과 같을 때 임계경로의 소요기일은?,https://www.cbtbank.kr/images/iz/iz20200822/iz20200822m92.gif,10일,12일,14일,16일,3,"이 문제는 CPM(Critical Path Method, 임계경로 방법)을 이용하여 프로젝트의 최소 소요 기간을 구하는 문제입니다. CPM은 프로젝트의 작업들을 네트워크로 표현하고, 각 작업의 소요 시간을 고려하여 프로젝트 완료까지 걸리는 최소 시간(임계경로)을 찾는 기법입니다.  문제에서 주어진 네트워크는 여러 개의 경로를 가지고 있습니다.  각 경로의 소요 기간을 계산하여 가장 긴 경로를 찾아야 하는데, 이 가장 긴 경로가 바로 임계경로이며, 그 기간이 프로젝트의 최소 소요 기간이 됩니다.",75,47
193,1,2,93,RIP(Routing Information Protocol)에 대한 설명으로 틀린 것은?,,거리 벡터 라우팅 프로토콜이라고도 한다.,소규모 네트워크 환경에 적합하다.,최대 홉 카운트를 115홉 이하로 한정하고 있다.,최단경로탐색에는 Bellman-Ford 알고리즘을 사용한다.,3,"RIP(Routing Information Protocol)는 네트워크 내에서 라우터들이 서로 경로 정보를 주고받아 최단 경로를 찾는 프로토콜입니다.  쉽게 말해, 여러 길이 있는데 가장 빠른 길을 찾아주는 내비게이션과 같은 역할을 하는 것이죠.  문제에서 틀린 설명을 찾아야 하는데, RIP는 거리 벡터 라우팅 프로토콜을 사용하며, 소규모 네트워크에서 효율적으로 작동합니다.  Bellman-Ford 알고리즘을 사용하여 최단 경로를 계산하는 것도 맞는 설명입니다.  하지만 RIP는 최대 홉 카운트(한 지점에서 다른 지점까지 거치는 라우터의 수)를 15홉으로 제한하고 있습니다. 문제에서 115홉으로 잘못 기술되어 있으므로, 이 부분이 틀린 설명이 됩니다.  따라서 15홉이라는 제한 때문에 대규모 네트워크에는 적합하지 않고, 소규모 네트워크에 적합하다는 설명은 맞는 설명입니다.",73,49
194,1,2,94,"소프트웨어 생명주기 모형 중 고전적 생명주기 모형으로 선형 순차적 모델이라고도 하며, 타당성 검토, 계획, 요구사항 분석, 구현, 테스트, 유지보수의 단계를 통해 소프트웨어를 개발하는 모형은?",,폭포수 모형,애자일 모형,컴포넌트 기반 방법론,6GT 모형,1,"이 문제는 소프트웨어 개발 과정을 나타내는 여러 가지 모형 중 하나를 묻고 있습니다.  소프트웨어 개발은 단순한 작업이 아니고, 여러 단계를 거쳐 체계적으로 진행되어야 합니다.  문제에서 설명하는 모형은  '타당성 검토 → 계획 → 요구사항 분석 → 구현 → 테스트 → 유지보수' 와 같은 순차적인 단계를 거치는 것을 특징으로 합니다.  마치 폭포가 위에서 아래로 떨어지는 것처럼 한 단계가 끝나야 다음 단계로 넘어가는 방식이죠.  이러한 특징 때문에 이 모형을 '폭포수 모형' 이라고 부릅니다.  다른 선택지들은 각각 다른 소프트웨어 개발 방식을 나타내는데, 폭포수 모형과는 개발 과정의 흐름과 특징이 다릅니다.  애자일 모형은 반복적인 개발과 고객 피드백을 중시하고, 컴포넌트 기반 방법론은 미리 만들어진 부품들을 조립하는 방식이며, 6GT 모형은 특정한 개발 방법론을 지칭하는 용어가 아닙니다. 따라서, 순차적인 단계를 거쳐 소프트웨어를 개발하는 고전적인 모형의 특징을 가장 잘 나타내는 것은 폭포수 모형입니다.",89,47
195,1,2,95,소프트웨어 개발 모델 중 나선형 모델의 4가지 주요 활동이 순서대로 나열된 것은?,https://www.cbtbank.kr/images/iz/iz20200822/iz20200822m95.gif,?-?-?-? 순으로 반복,?-?-?-? 순으로 반복,?-?-?-? 순으로 반복,?-?-?-? 순으로 반복,2,"나선형 모델은 소프트웨어 개발의 위험을 줄이고, 고객의 요구사항 변화에 유연하게 대처하기 위해 고안된 모델입니다.  반복적인 개발 과정을 통해 점진적으로 소프트웨어를 완성해 나가는 것이 특징인데요,  각 반복 주기마다  계획 수립, 위험 분석, 개발 및 검증, 고객 평가의 네 가지 주요 활동을 거치게 됩니다.  먼저,  **계획 수립** 단계에서는  다음 단계에서 수행할 작업을 계획하고, 목표와 범위를 정의합니다.  그 다음 **위험 분석** 단계에서는  계획된 작업에서 발생할 수 있는 위험 요소들을 파악하고,  그에 대한 대응 방안을 마련합니다.  위험이 크게 예상되면 개발을 중단하거나 방향을 수정할 수도 있죠.  다음으로 **개발 및 검증** 단계에서는  실제 소프트웨어를 개발하고,  테스트를 통해 개발 결과물의 품질을 검증합니다.  마지막으로 **고객 평가** 단계에서는  개발된 소프트웨어를 고객에게 보여주고 피드백을 받아 다음 반복 주기의 계획에 반영합니다.  이러한 네 가지 활동은 순차적으로 진행되며,  각 주기가 끝날 때마다 고객의 요구사항을 반영하여  개선된 소프트웨어를 만들어 나가는 것이 나선형 모델의 핵심입니다. 따라서 정답은 계획 수립, 위험 분석, 개발 및 검증, 고객 평가 순서로 반복되는 것입니다.",82,47
196,1,2,96,"전자 칩과 같은 소프트웨어 부품, 즉 블록(모듈)을 만들어서 끼워 맞추는 방법으로 소프트웨어를 완성시키는 재사용 방법은?",,합성 중심,생성 중심,분리 중심,구조 중심,1,"이 문제는 소프트웨어를 개발하는 방식 중, 미리 만들어 놓은 소프트웨어 부품(블록, 모듈)들을 조립하듯이 엮어서 완성하는 방법에 대한 질문입니다.  마치 레고 블록을 가지고 집을 짓는 것처럼, 이미 만들어진 기능들을 조합하여 새로운 소프트웨어를 만드는 것이죠.  이러한 방식은 소프트웨어 개발 시간과 비용을 절감하고, 개발의 안정성을 높이는 데 큰 도움이 됩니다.  문제에서 제시된 ""전자 칩과 같은 소프트웨어 부품""이라는 표현은 미리 만들어진 기능들을 의미하며, 이러한 부품들을 조립하는 방식을 '합성 중심'이라고 합니다.  다른 선택지는 소프트웨어를 처음부터 새로 만드는 방식이나,  특정 부분에 집중하는 방식 등을 의미하여 문제의 상황과 맞지 않습니다. 따라서 미리 만들어진 부품들을 조립하는 방식, 즉 합성 중심이 정답입니다.",73,6
197,1,2,97,"다음 JAVA코드에서 밑줄로 표시된 부분에는 어떤 보안 약점이 존재하는가? (단, key는 암호화 키를 저장하는 변수이다.)",https://www.cbtbank.kr/images/iz/iz20200822/iz20200822m97.gif,무결성 검사 없는 코드 다운로드,중요 자원에 대한 잘못된 권한 설정,하드코드된 암호화 키 사용,적절한 인증없는 중요 기능 허용,3,"JAVA 코드에서 암호화 키가 `""22df3023sf~2:asn!@#/as>""` 와 같이 코드 내부에 직접적으로 작성되어 있습니다. 이렇게 키를 하드코딩하는 것은 매우 위험한 보안 취약점입니다.  만약 이 코드가 악의적인 목적으로 해킹당하거나, 소스 코드 자체가 유출된다면, 암호화 키가 그대로 노출되어 누구든지 암호화된 데이터를 복호화할 수 있게 됩니다.  이는 데이터의 기밀성을 심각하게 위협하는 행위입니다.  안전한 암호화 시스템을 구축하려면, 암호화 키는 코드 외부의 안전한 저장소에 보관하고, 프로그램 실행 시 안전하게 불러와 사용해야 합니다.  예를 들어, 운영체제의 키 저장소나, 암호화 전용 하드웨어(HSM)를 활용하는 것이 좋습니다.  코드 내부에 키를 직접 작성하는 것은 마치 집 열쇠를 현관문에 매달아 놓는 것과 같이 매우 위험한 행위입니다. 따라서, 코드에서 암호화 키를 하드코딩하는 것은 심각한 보안 문제를 야기할 수 있으며, 반드시 개선되어야 합니다. 정보처리기사 공식 교재에서도 암호화 키 관리의 중요성과 하드코딩의 위험성에 대해 자세히 설명하고 있습니다.",78,54
198,1,2,98,소프트웨어 개발 표준 중 소프트웨어 품질 및 생산성 향상을 위해 소프트웨어 프로세스를 평가 및 개선하는 국제 표준은?,,SCRUM,ISO/IEC 12509,SPICE,CASE,3,"소프트웨어 개발 과정에서 품질을 높이고 생산성을 향상시키기 위해서는 개발 프로세스 자체를 체계적으로 평가하고 개선하는 것이 중요합니다.  마치 공장에서 제품 생산 과정을 점검하고 개선하는 것과 같습니다.  문제에서 묻고 있는 것은 바로 이러한 소프트웨어 프로세스의 평가 및 개선을 위한 국제 표준입니다.  제시된 답변들 중 SPICE는  Software Process Improvement and Capability dEtermination의 약자로, 소프트웨어 프로세스 성숙도를 평가하고 개선하기 위한 국제 표준 프레임워크입니다.  SPICE는 소프트웨어 개발 조직의 프로세스를 평가하여 그 수준을 측정하고, 개선을 위한 구체적인 방향을 제시해줍니다.  따라서 소프트웨어 품질 및 생산성 향상을 위해 소프트웨어 프로세스를 평가 및 개선하는 국제 표준으로 가장 적합한 것은 SPICE입니다. 다른 선택지는 소프트웨어 개발 방법론(스크럼), 소프트웨어 품질 특성에 대한 표준(ISO/IEC 12509), 컴퓨터 지원 소프트웨어 공학 도구(CASE)를 나타내므로 문제의 질문과 정확히 일치하지 않습니다.",69,48
199,1,2,99,실무적으로 검증된 개발보안 방법론 중 하나로써 SW보안의 모범 사례를 SDLC(Software Development Life Cycle)에 통합한 소프트웨어 개발 보안 생명주기 방법론은?,,CLASP,CWE,PIMS,Seven Touchpoints,4,"소프트웨어 개발 과정 전반에 걸쳐 보안을 고려하는 방법론을 묻는 문제입니다.  단순히 개발 후 보안 취약점을 찾는 것이 아니라, 초기 단계부터 보안을 설계하고 구현하는 것이 중요하다는 점을 강조하는  개념입니다.  제시된 답변 중에서 소프트웨어 개발 생명주기(SDLC) 전 단계에 보안을 통합하는 모범 사례를 제시하는 방법론은 'Seven Touchpoints'입니다.  Seven Touchpoints는 개발 단계별로 필요한 보안 활동을 명확하게 제시하여 실무에서 효과적으로 적용할 수 있도록 지원하는 검증된 방법론으로 알려져 있습니다. 다른 선택지는  SW 보안과 관련된 개념이나 표준이지만, SDLC 전반에 걸친 보안 통합 방법론으로서 Seven Touchpoints만큼 명확하고 실무 지향적인 접근 방식을 제공하지 않습니다.  따라서 소프트웨어 개발 보안 생명주기 방법론으로는 Seven Touchpoints가 가장 적절한 답변입니다.",55,53
200,1,2,100,다음 LAN의 네트워크 토폴로지는?,https://www.cbtbank.kr/images/iz/iz20200822/iz20200822m100.gif,버스형,성형,링형,그물형,1,"그림에서 볼 수 있듯이, 모든 스테이션들이 하나의 통로(버스)를 통해 데이터를 주고받고 있습니다.  데이터는 이 통로를 따라 모든 스테이션으로 전송되며, 특정 스테이션을 거치지 않고 직접 전송됩니다.  마치 버스가 한 방향으로만 운행하며 모든 정류장(스테이션)을 지나는 것과 같습니다.  이러한 네트워크 구조를 버스형 토폴로지라고 합니다.  반면, 다른 토폴로지들은 각 스테이션의 연결 방식이 다릅니다.  예를 들어, 성형 토폴로지는 중앙 허브를 중심으로 스테이션들이 연결되고, 링형 토폴로지는 스테이션들이 링 형태로 연결되어 데이터가 순차적으로 전달됩니다.  그물형 토폴로지는 여러 경로를 통해 데이터가 전달되는 복잡한 구조입니다.  문제의 그림은 단순한 일방향 통로를 보여주므로 버스형 토폴로지가 가장 적합합니다.  정보처리기사 공식 교재의 네트워크 토폴로지 설명 부분을 참고하면 더욱 자세히 이해할 수 있을 것입니다.",90,45
201,1,3,1,XP(eXtreme Programming)의 기본원리로 볼 수 없는 것은?,,Linear Sequential Method,Pair Programming,Collective Ownership,Continuous Integration,1,"이 문제는 XP(eXtreme Programming)의 핵심 원리를 얼마나 잘 이해하고 있는지 묻는 문제입니다. XP는 소프트웨어 개발의 민첩성(Agile)을 중시하는 방법론으로, 빠른 개발 주기와 고객과의 긴밀한 협력을 통해 변화하는 요구사항에 효과적으로 대응하는 것을 목표로 합니다.  제시된 선지 중에서 틀린 것은 '선형 순차적 방법(Linear Sequential Method)'입니다.  선형 순차적 방법은 폭포수 모델(Waterfall Model)과 같이, 개발 과정을 순차적으로 진행하는 전통적인 방법론입니다.  반면 XP는 반복적이고 점진적인 개발을 강조하며, 고객의 피드백을 지속적으로 반영하여 유연성을 확보합니다.  '짝 프로그래밍(Pair Programming)', '집단 소유(Collective Ownership)', '지속적 통합(Continuous Integration)'은 모두 XP의 핵심 원리로, 개발의 효율성과 품질 향상을 위해 사용됩니다.  짝 프로그래밍은 두 명의 개발자가 함께 코드를 작성하고 검토하는 방식이며, 집단 소유는 모든 개발자가 코드베이스에 대한 책임을 공유하는 방식입니다. 지속적 통합은 코드 변경 사항을 자주 통합하여 문제를 조기에 발견하고 해결하는 방식입니다. 따라서 선형 순차적 방법은 XP의 기본 원리와 상반되는 개념이므로 정답입니다.",72,2
202,1,3,2,럼바우(Rumbaugh) 객체지향 분석 기법에서 동적 모델링에 활용되는 다이어그램은?,,객체 다이어그램(Object Diagram),패키지 다이어그램(Package Diagram),상태 다이어그램(State Diagram),자료 흐름도(Data Flow Diagram),3,"럼바우 객체지향 분석 기법은 시스템을 객체들의 상호작용으로 모델링하는 기법입니다.  여기서 시스템의 동적인 측면, 즉 시간에 따라 객체의 상태가 어떻게 변하는지를 나타내는 데 사용되는 다이어그램이 바로 상태 다이어그램입니다.  예를 들어, 자동판매기라는 시스템을 생각해보면,  자동판매기는 '대기', '돈 투입', '음료 선택', '음료 제공', '잔돈 반환' 등 여러 가지 상태를 가집니다.  상태 다이어그램은 이러한 상태들과 상태 간의 전이(이벤트에 의해 상태가 변하는 것)를 시각적으로 보여주어 시스템의 동작을 명확하게 이해하도록 도와줍니다.  반면 객체 다이어그램은 특정 시점의 객체들의 상태와 관계를 보여주고, 패키지 다이어그램은 시스템을 여러 개의 패키지로 나누어 조직화하는 데 사용됩니다. 자료 흐름도는 데이터가 시스템 내에서 어떻게 흘러가는지를 보여주는 기법으로, 객체지향 분석과는 다른 접근 방식입니다. 따라서 럼바우 기법의 동적 모델링에는 상태의 변화를 표현하는 상태 다이어그램이 가장 적합합니다.",68,2
203,1,3,3,CASE(Computer Aided Software Engineering)의 주요 기능으로 옳지 않은 것은?,,S/W 라이프 사이클 전 단계의 연결,그래픽 지원,다양한 소프트웨어 개발 모형 지원,언어 번역,4,"CASE(Computer Aided Software Engineering)는 소프트웨어 개발 과정을 자동화하고 효율적으로 관리하기 위한 도구입니다.  소프트웨어 개발의 전 단계를 연결하여 통합적으로 관리하고, 그래픽적인 도구를 제공하여 시각적으로 설계를 표현하고 이해하기 쉽게 만들어줍니다. 또한, 다양한 소프트웨어 개발 방법론(예: 폭포수 모델, 애자일 모델 등)을 지원하여 개발 프로젝트의 특성에 맞는 방법론을 선택하고 적용할 수 있도록 돕습니다. 하지만 CASE 도구는 소프트웨어의 언어를 직접 번역하는 기능은 제공하지 않습니다.  언어 번역은 컴파일러나 인터프리터와 같은 별도의 도구가 담당하는 영역입니다. CASE는 개발 과정을 지원하는 도구이지, 프로그래밍 언어 자체를 변환하는 도구가 아니기 때문입니다. 따라서, CASE의 주요 기능으로 언어 번역은 적절하지 않습니다.",86,47
204,1,3,4,객체지향 기법의 캡슐화(Encapsulation)에 대한 설명으로 틀린 것은?,,인터페이스가 단순화 된다.,소프트웨어 재사용성이 높아진다.,변경 발생 시 오류의 파급효과가 적다.,상위 클래스의 모든 속성과 연산을 하위 클래스가 물려받는 것을 의미한다.,4,"객체지향 기법의 핵심 개념 중 하나인 캡슐화는 데이터(속성)와 그 데이터를 처리하는 함수(메서드)를 하나로 묶어 외부로부터의 직접적인 접근을 제한하는 것을 의미합니다.  마치 보석 상자에 보석을 담아 외부에서 함부로 만지거나 훼손하는 것을 막는 것과 같습니다.  이를 통해 인터페이스는 단순해지고, 내부 구현이 변경되더라도 외부 시스템에 미치는 영향을 최소화하여 소프트웨어의 재사용성과 안정성을 높일 수 있습니다.  하지만 틀린 설명은 상속과 관련된 내용입니다.  캡슐화는 데이터와 메서드를 묶는 것이지, 상위 클래스의 모든 속성과 연산을 하위 클래스가 자동으로 물려받는 상속과는 개념이 다릅니다. 상속은 객체지향의 또 다른 중요한 개념이지만, 캡슐화와는 별개로 작용합니다.  따라서 상위 클래스의 모든 것을 하위 클래스가 물려받는다는 것은 상속의 개념이며, 캡슐화에 대한 설명으로는 적절하지 않습니다.",90,7
205,1,3,5,다음 내용이 설명하는 객체지향 설계 원칙은?,https://www.cbtbank.kr/images/iz/iz20200926/iz20200926m5.gif,인터페이스 분리 원칙,단일 책임 원칙,개방 폐쇄의 원칙,리스코프 교체의 원칙,1,"문제에서 제시된 내용은 클라이언트(시스템을 사용하는 부분)가 자신이 사용하지 않는 메서드나 인터페이스에 의존하지 않아야 한다는 것을 강조하고 있습니다.  이는 시스템의 유연성과 확장성을 높이기 위한 중요한 원칙입니다.  만약 클라이언트가 불필요한 메서드나 인터페이스에 의존한다면, 해당 메서드나 인터페이스가 변경될 때 클라이언트도 함께 변경되어야 하는 문제가 발생합니다. 이는 시스템 유지보수의 어려움과 비용 증가로 이어질 수 있습니다.  따라서 클라이언트는 자신이 필요로 하는 기능만을 제공하는 작고 특정 목적의 인터페이스에만 의존해야 합니다. 이러한 원칙을 통해 시스템의 각 부분은 독립적으로 변경 및 유지보수가 가능해지고, 시스템 전체의 안정성과 유연성을 확보할 수 있습니다. 이는 바로 인터페이스 분리 원칙의 핵심 내용입니다.  단일 책임 원칙은 하나의 클래스가 하나의 책임만 가져야 한다는 것이고, 개방 폐쇄 원칙은 확장에는 열려 있고 변경에는 닫혀 있어야 한다는 것이며, 리스코프 교체 원칙은 서브 클래스가 기본 클래스를 대체할 수 있어야 한다는 것입니다. 문제에서 제시된 내용은 이러한 다른 원칙들과는 다르게, 인터페이스의 분리와 클라이언트의 의존성에 초점을 맞추고 있으므로 인터페이스 분리 원칙이 가장 적절한 답입니다.",79,7
206,1,3,6,파이프 필터 형태의 소프트웨어 아키텍처에 대한 설명으로 옳은 것은?,,노드와 간선으로 구성된다.,서브시스템이 입력데이터를 받아 처리하고 결과를 다음 서브시스템으로 넘겨주는 과정을 반복한다.,계층 모델이라고도 한다.,"3개의 서브시스템(모델, 뷰, 제어)으로 구성되어 있다.",2,"파이프 필터 아키텍처는 데이터 처리 과정을 여러 개의 서브시스템(필터)으로 나누어, 각 서브시스템이 특정 작업을 수행하고 결과를 다음 서브시스템으로 전달하는 방식입니다. 마치 공장의 조립라인처럼, 각 필터는 입력 데이터를 받아 처리하고, 그 결과를 다음 필터로 넘겨주는 과정을 반복합니다.  이러한 특징은 데이터 처리 과정을 모듈화하고, 각 필터의 기능을 독립적으로 개발하고 관리할 수 있도록 해줍니다.  따라서 입력 데이터가 하나의 필터를 통과하면 다음 필터로 자동으로 전달되는 구조를 가지고 있으며, 각 필터는 독립적으로 동작하고, 병렬 처리가 가능하다는 장점이 있습니다.  반면에 다른 선지들은 파이프 필터 아키텍처의 특징을 제대로 반영하지 못하고 있습니다. 노드와 간선으로 구성된다는 것은 일반적인 그래프 구조의 특징이고, 계층 모델은 서로 다른 계층으로 구성된 구조를 의미하며, 모델-뷰-컨트롤러(MVC) 아키텍처는 3개의 서브시스템으로 구성되지만, 파이프 필터 아키텍처와는 다른 개념입니다.  결론적으로, 파이프 필터 아키텍처는 서브시스템들이 데이터를 순차적으로 처리하는 방식을 핵심으로 합니다.",78,6
207,1,3,7,"코드화 대상 항목의 중량, 면적, 용량 등의 물리적 수치를 이용하여 만든 코드는?",,순차 코드,10진 코드,표의 숫자 코드,블록 코드,3,"문제에서 ""코드화 대상 항목의 중량, 면적, 용량 등의 물리적 수치를 이용하여 만든 코드""를 묻고 있습니다.  이는 물리적인 크기나 양을 숫자로 표현하는 코드를 의미합니다.  예를 들어, 제품의 무게(중량)를 숫자로 표현하거나, 상자의 크기(면적)를 숫자로 나타내는 코드, 또는 용기의 부피(용량)를 숫자로 표현하는 코드 등이 이에 해당합니다.  이러한 코드는 단순히 순서를 나타내는 순차 코드나, 10진수 체계를 사용하는 10진 코드, 또는 특정 블록을 나타내는 블록 코드와는 다릅니다.  대신,  물리적인 속성을 숫자로 변환하여 표현하는 코드, 즉 '표의 숫자 코드'가 가장 적절한 답입니다.  각 물리적 속성(중량, 면적, 용량)에 해당하는 숫자를 미리 정의된 표를 이용하여 코드로 변환하는 방식이기 때문입니다.  따라서 물리적 수치를 코드로 변환하는 방식을 가장 잘 설명하는 것은 표의 숫자 코드입니다.",76,33
208,1,3,8,디자인 패턴 사용의 장?단점에 대한 설명으로 거리가 먼 것은?,,소프트웨어 구조 파악이 용이하다.,객체지향 설계 및 구현의 생산성을 높이는데 적합하다.,재사용을 위한 개발 시간이 단축된다.,절차형 언어와 함께 이용될 때 효율이 극대화된다.,4,"디자인 패턴은 소프트웨어 개발에서 반복적으로 발생하는 문제에 대한 해결책을 미리 정의해 놓은 일종의 템플릿입니다.  마치 레고 블록처럼, 이미 만들어진 패턴들을 조합하여 소프트웨어를 개발하면 코드의 재사용성이 높아지고, 개발 시간을 단축할 수 있습니다. 또한,  소프트웨어의 구조를 이해하기 쉽게 만들어주고, 객체지향 설계 및 구현의 생산성을 향상시키는 데 큰 도움이 됩니다. 하지만 디자인 패턴은 객체지향 프로그래밍 언어에 최적화되어 있으며, 절차형 언어와 함께 사용한다고 해서 효율이 극대화되는 것은 아닙니다.  절차형 언어는 디자인 패턴의 장점을 충분히 활용하기 어려운 구조를 가지고 있기 때문입니다. 따라서 디자인 패턴 사용의 장단점을 설명하는 보기 중에서 절차형 언어와의 연관성을 언급하는 것은 디자인 패턴의 본질과 맞지 않습니다.  디자인 패턴은 객체지향적인 사고방식과 설계 원칙을 바탕으로 효율을 발휘하도록 설계되었기 때문입니다.",85,7
209,1,3,9,DFD(data flow diagram)에 대한 설명으로 틀린 것은?,,자료 흐름 그래프 또는 버블(bubble) 차트라고도 한다.,구조적 분석 기법에 이용된다.,시간 흐름을 명확하게 표현할 수 있다.,"DFD의 요소는 화살표, 원, 사각형, 직선(단선/이중선)으로 표시한다.",3,"DFD는 시스템의 자료 흐름을 시각적으로 표현하는 도구입니다.  마치 물이 파이프를 통해 흐르는 모습을 그림으로 나타내는 것과 같다고 생각하면 이해하기 쉽습니다.  각각의 작업(처리)은 원(버블)으로 표현하고, 자료의 흐름은 화살표로 나타냅니다.  데이터 저장소는 사각형으로 표현하며,  자료 흐름의 양이 많거나 중요한 경우 이중선을 사용하기도 합니다. 따라서 원, 화살표, 사각형 등으로 구성된다는 설명은 맞는 말입니다.  또한 DFD는 시스템 분석 단계에서 구조적 분석 기법의 일환으로 사용되어 시스템의 전반적인 자료 흐름을 파악하고 설계하는 데 중요한 역할을 합니다. 하지만 DFD는 자료의 흐름을 중점적으로 표현하는 도구이기 때문에 시간의 흐름을 명확하게 표현하는 데는 적합하지 않습니다.  시간 흐름을 표현하려면 다른 기법(예: 시퀀스 다이어그램)을 사용해야 합니다.  따라서 시간 흐름을 명확하게 표현할 수 있다는 설명은 틀린 것입니다.",71,3
210,1,3,10,그래픽 표기법을 이용하여 소프트웨어 구성 요소를 모델링하는 럼바우 분석 기법에 포함되지 않는 것은?,,객체 모델링,기능 모델링,동적 모델링,블랙박스 분석 모델링,4,"이 문제는 럼바우 분석 기법에서 사용하는 그래픽 표기법을 이해하고 있는지 묻는 문제입니다.  럼바우 분석 기법은 소프트웨어 시스템을 객체, 기능, 동적인 측면에서 모델링하는 방법론입니다.  객체 모델링은 시스템을 구성하는 객체와 객체 간의 관계를 표현하고, 기능 모델링은 시스템의 기능과 기능 간의 관계를 표현하며, 동적 모델링은 시스템의 시간에 따른 변화를 표현합니다.  이 세 가지 모델링 기법은 모두 그래픽 표기법을 사용하여 시각적으로 소프트웨어 구성 요소를 표현합니다. 반면에 블랙박스 분석 모델링은 시스템의 내부 구조를 고려하지 않고, 입력과 출력만을 고려하여 시스템을 분석하는 방법입니다.  따라서 그래픽 표기법을 사용하지 않습니다. 럼바우 분석 기법은 시스템의 내부 구조를 명확하게 보여주는 데 중점을 두기 때문에, 시스템의 내부 동작을 무시하는 블랙박스 분석 모델링은 럼바우 기법에 포함되지 않습니다.  쉽게 말해, 럼바우 기법은 소프트웨어의 '속'을 그림으로 보여주는 방법인데, 블랙박스 분석은 '겉'만 보고 분석하는 방법이라 서로 다르다는 것입니다.",94,3
211,1,3,11,UML의 기본 구성요소가 아닌 것은?,,Things,Terminal,Relationship,Diagram,2,"UML은 소프트웨어 시스템을 시각적으로 모델링하는 표준 언어입니다.  UML을 사용하면 복잡한 시스템을 이해하기 쉽게 그림으로 표현하여 개발 과정에서 발생할 수 있는 오류를 줄이고 효율적인 개발을 가능하게 합니다.  UML의 기본 구성 요소는 크게 'Things'(요소), 'Relationships'(관계), 'Diagrams'(다이어그램)으로 나눌 수 있습니다. 'Things'는 시스템을 구성하는 요소들을 나타내고, 'Relationships'는 요소들 간의 관계를 나타내며, 'Diagrams'는 다양한 관점에서 시스템을 보여주는 그림입니다.  문제에서 제시된 보기 중 'Terminal'은 UML의 기본 구성 요소가 아닙니다. 'Terminal'은 일반적으로 컴퓨터 시스템의 입출력 장치를 의미하며, UML 모델링과는 직접적인 관련이 없습니다. 따라서 UML의 기본 구성 요소가 아닌 것은 'Terminal'입니다.",70,2
212,1,3,12,소프트웨어의 상위설계에 속하지 않는 것은?,,아키텍처 설계,모듈 설계,인터페이스 정의,사용자 인터페이스 설계,2,"소프트웨어 상위 설계는 시스템의 전체적인 구조와 흐름을 설계하는 단계입니다.  아키텍처 설계는 시스템의 기본적인 구조, 구성 요소 간의 관계, 그리고 각 구성 요소의 기능을 정의하는 가장 상위 레벨의 설계입니다.  인터페이스 정의는 시스템의 여러 구성 요소 또는 시스템과 외부 시스템 간의 상호 작용 방식을 정의하는 것이고, 사용자 인터페이스 설계는 사용자가 시스템과 상호 작용하는 방식을 디자인하는 것입니다.  반면, 모듈 설계는 상위 설계에서 정의된 아키텍처와 인터페이스를 바탕으로 시스템을 구성하는 개별 모듈(작은 기능 단위)의 내부 구조와 동작을 설계하는 단계입니다.  따라서 상위 설계는 시스템의 전체적인 틀을 잡는 것이고, 모듈 설계는 그 틀 안에서 개별 부품을 설계하는 것이라고 생각하면 이해하기 쉽습니다.  문제에서 묻고 있는 것은 상위 설계에 속하지 *않는* 것이므로, 개별 모듈의 내부 설계인 모듈 설계가 정답이 됩니다.  상위 설계는 시스템의 큰 그림을 그리는 단계이며, 모듈 설계는 그 그림을 채우는 세부적인 작업이라고 볼 수 있습니다.  정보처리기사 공식 교재의 소프트웨어 공학 부분을 참고하면 이러한 상위 설계와 하위 설계의 차이를 더욱 명확하게 이해할 수 있을 것입니다.",54,6
213,1,3,13,다음 중 자료사전(Data Dictionary)에서 선택의 의미를 나타내는 것은?,,[ ],{ },＋,＝,1,"자료사전(Data Dictionary)은 데이터베이스 시스템에서 사용되는 데이터의 구조와 의미를 정의하는 사전과 같은 역할을 합니다.  여기서 각 데이터 항목의 속성, 데이터 타입, 그리고 제약 조건 등을 명확하게 기술합니다.  문제에서 묻고 있는 것은 '선택'의 의미를 나타내는 기호입니다.  데이터베이스 설계에서 선택(optional)이라는 개념은 특정 데이터 항목이 필수적으로 존재해야 하는 것이 아니라, 선택적으로 존재할 수 있음을 의미합니다.  따라서 선택적 속성을 표현하는 데 사용되는 기호는 대괄호([])입니다.  대괄호 안에 있는 항목은 선택적으로 포함될 수 있음을 나타내는 것이죠.  다른 기호들은 집합({}), 덧셈(+), 대입(=) 등의 수학적 또는 프로그래밍적 의미를 가지고 있지만, 자료사전에서 선택적 속성을 나타내는 데는 적합하지 않습니다.  따라서 자료사전에서 선택의 의미를 나타내는 기호는 대괄호([])입니다.",82,27
214,1,3,14,소프트웨어의 사용자 인터페이스개발시스템(User Interface Development System)이 가져야 할 기능이 아닌 것은?,,사용자 입력의 검증,에러 처리와 에러 메시지 처리,도움과 프롬프트(prompt) 제공,소스 코드 분석 및 오류 복구,4,"사용자 인터페이스 개발 시스템(UI Development System)은 사용자가 소프트웨어를 쉽고 효율적으로 사용할 수 있도록 인터페이스를 디자인하고 구현하는 데 사용되는 시스템입니다.  사용자 입력 검증, 에러 처리 및 메시지 표시, 도움말 및 안내 제공은 모두 사용자에게 원활한 경험을 제공하기 위한 필수적인 기능입니다.  사용자 입력이 올바른 형식인지 확인하고, 오류 발생 시 사용자가 이해할 수 있는 메시지를 표시하며, 필요한 경우 사용자에게 도움을 제공하는 것은 UI 개발 시스템의 핵심적인 역할입니다.  반면, 소스 코드 분석 및 오류 복구는 개발자를 위한 기능이며, 사용자 인터페이스의 디자인이나 사용성과는 직접적인 관련이 없습니다.  소스 코드 분석 및 오류 복구는 개발 단계에서 이루어지는 작업으로, 사용자 인터페이스 개발 시스템 자체의 기능이라고 보기 어렵습니다. 따라서 소스 코드 분석 및 오류 복구는 사용자 인터페이스 개발 시스템이 가져야 할 기능이 아닙니다.  이는 마치 자동차의 기능을 설명할 때, 자동차의 엔진 내부 기계 부품의 정비를 자동차의 기능이라고 말하는 것과 같은 이치입니다.  자동차의 기능은 운전자에게 편리하고 안전한 주행 경험을 제공하는 것이지, 엔진 정비 자체가 자동차의 기능은 아닌 것과 같습니다.",85,4
215,1,3,15,요구 사항 명세기법에 대한 설명으로 틀린 것은?,,비정형 명세기법은 사용자의 요구를 표현할 때 자연어를 기반으로 서술한다.,비정형 명세기법은 사용자의 요구를 표현할 때 Z 비정형 명세기법을 사용한다.,정형 명세기법은 사용자의 요구를 표현할 때 수학적인 원리와 표기법을 이용한다.,정형 명세기법은 비정형 명세기법에 비해 표현이 간결하다.,2,"요구사항 명세 기법은 사용자의 요구를 개발자가 이해할 수 있도록 문서화하는 방법입니다. 크게 정형 기법과 비정형 기법으로 나뉘는데요,  비정형 기법은 자연어(일상적인 언어)를 사용하여 요구사항을 설명합니다.  쉽게 말해, 우리가 평소 대화하듯이 요구사항을 적는 것이죠.  반면 정형 기법은 수학적 원리와 표기법(예를 들어, 수식이나 특정 기호)을 사용하여 명확하고 모호하지 않게 요구사항을 표현합니다.  마치 수학 문제를 풀듯이 논리적으로 표현하는 것이라고 생각하면 됩니다.  문제에서 틀린 설명은 '비정형 명세기법은 사용자의 요구를 표현할 때 Z 비정형 명세기법을 사용한다'는 것입니다. Z는 정형 명세 기법에 속하는 대표적인 기법이지 비정형 기법이 아닙니다.  Z 기법은 수학적 표기법을 사용하여 요구사항을 정확하게 기술하기 때문에 정형 기법의 예시로 볼 수 있습니다. 따라서 비정형 기법에서 Z 기법을 사용한다는 것은 잘못된 설명입니다.  정형 기법은 비정형 기법보다 표현이 간결하고 모호성이 적다는 장점이 있습니다.",70,2
216,1,3,16,소프트웨어 개발 단계에서 요구 분석 과정에 대한 설명으로 거리가 먼 것은?,,분석 결과의 문서화를 통해 향후 유지보수에 유용하게 활용 할 수 있다.,개발 비용이 가장 많이 소요되는 단계이다.,"자료흐름도, 자료 사전 등이 효과적으로 이용될 수 있다.",보다 구체적인 명세를 위해 소단위 명세서(Mini-Spec)가 활용될 수 있다.,2,"소프트웨어 개발 단계 중 요구 분석 단계는 사용자의 요구를 정확하게 파악하고, 이를 바탕으로 시스템의 기능과 성능을 명확하게 정의하는 매우 중요한 단계입니다.  분석 결과는 문서로 작성되어 향후 유지보수 및 시스템 개선에 활용되며, 자료흐름도나 자료 사전과 같은 도구를 사용하여 효율적으로 분석 작업을 수행할 수 있습니다. 또한, 복잡한 시스템의 경우, 보다 구체적인 명세를 위해 소단위 명세서(Mini-Spec)를 활용하기도 합니다. 하지만 요구 분석 단계는 개발 초기 단계이기 때문에, 실제 코딩이나 테스트 단계에 비해 개발 비용이 가장 많이 소요되는 단계는 아닙니다.  코딩, 테스트, 배포 등 후속 단계에서 더 많은 비용이 발생할 수 있습니다. 따라서, 요구 분석 단계에 대한 설명 중 '개발 비용이 가장 많이 소요되는 단계이다'라는 것은 사실과 다릅니다.  요구 분석 단계에서의 비용은 시스템의 규모와 복잡성에 따라 달라지지만, 전체 개발 비용 중 가장 큰 비중을 차지하는 것은 아닙니다.",90,2
217,1,3,17,애자일 방법론에 해당하지 않는 것은?,,기능중심 개발,스크럼,익스트림 프로그래밍,모듈중심 개발,4,"애자일 방법론은 소프트웨어 개발 과정에서 변화에 유연하게 대처하고, 고객과의 협업을 강조하는 개발 방법론입니다.  기능 중심 개발, 스크럼, 익스트림 프로그래밍은 모두 고객 피드백을 빠르게 반영하고, 반복적인 개발 과정을 통해 제품을 점진적으로 개선해나가는 애자일의 핵심 가치를 따르는 대표적인 방법론입니다.  반면에,  모듈 중심 개발은  미리 전체 시스템을 여러 모듈로 나누어 설계하고, 각 모듈을 독립적으로 개발한 후 통합하는 방식입니다. 이는 애자일 방법론처럼 유연하고 빠른 변화 대응보다는 계획과 설계에 중점을 두는 전통적인 접근 방식에 가깝습니다. 애자일 방법론은 계획보다 실행과 고객 피드백을 중시하는데, 모듈 중심 개발은 사전 계획과 설계에 많은 시간을 할애하기 때문에 애자일의 핵심 가치와는 맞지 않습니다. 따라서 애자일 방법론에 해당하지 않는 것은 모듈 중심 개발입니다.  쉽게 말해, 애자일은 ""일단 만들고 고쳐나가자""는 방식이고, 모듈 중심 개발은 ""완벽한 설계 후 만들자""는 방식이라고 생각하면 이해하기 쉬울 것입니다.",68,47
218,1,3,18,클라이언트와 서버 간의 통신을 담당하는 시스템 소프트웨어를 무엇이라고 하는가?,,웨어러블,하이웨어,미들웨어,응용 소프트웨어,3,"클라이언트와 서버 간의 통신을 원활하게 중계해주는 역할을 하는 시스템 소프트웨어를 묻는 문제입니다.  쉽게 말해, 클라이언트(예: 웹 브라우저)가 서버(예: 웹 서버)에 요청을 보내면, 이 요청을 서버에 전달하고 서버의 응답을 다시 클라이언트에게 전달하는 중간 다리 역할을 하는 소프트웨어입니다.  마치 편지를 부치고 받는 과정에서 우체국과 같은 역할을 한다고 생각하면 이해하기 쉽습니다.  이러한 중간 매개체 역할을 하는 소프트웨어를 미들웨어라고 합니다.  웨어러블은 착용 가능한 기기이고, 하이웨어는 하드웨어와 관련된 용어이며, 응용 소프트웨어는 사용자가 직접 사용하는 프로그램(예: 워드프로세서, 게임)을 의미합니다. 따라서 클라이언트와 서버 간의 통신을 담당하는 시스템 소프트웨어는 미들웨어가 정답입니다. 정보처리기사 공식 교재에서도 미들웨어의 정의와 클라이언트-서버 통신에서의 역할에 대한 설명을 찾아볼 수 있습니다.",92,10
219,1,3,19,GoF(Gangs of Four) 디자인 패턴 분류에 해당하지 않는 것은?,,생성 패턴,구조 패턴,행위 패턴,추상 패턴,4,"GoF 디자인 패턴은 소프트웨어 설계에서 자주 발생하는 문제들을 해결하기 위한 디자인 패턴들을 모아놓은 일종의 '레시피' 모음집입니다.  크게 생성 패턴, 구조 패턴, 행위 패턴으로 나뉘는데, 각각 객체 생성 방식, 클래스와 객체의 구성 방식, 객체 간 상호 작용 방식에 대한 해결책을 제시합니다.  문제에서 제시된 '추상 패턴'은 GoF 디자인 패턴의 분류에 포함되지 않습니다.  '추상 패턴'이라는 용어 자체가 디자인 패턴의 종류를 나타내는 것이 아니라, 디자인 패턴을 구성하는 요소 중 하나인 '추상화' 개념을 의미하기 때문입니다.  GoF 디자인 패턴은 구체적인 문제 해결을 위한 구체적인 패턴들을 제공하는 것이지, 추상적인 디자인 원칙을 분류하는 것이 아닙니다. 따라서 추상 패턴은 GoF 디자인 패턴의 분류 체계에 속하지 않는 것이 맞습니다.  마치 요리 레시피 모음집에서 '재료 손질'이라는 분류가 없는 것과 같은 이치입니다.  '재료 손질'은 요리 과정의 일부이지만, 레시피 자체의 분류는 아닌 것처럼 말이죠.",83,7
220,1,3,20,바람직한 소프트웨어 설계 지침이 아닌 것은?,,적당한 모듈의 크기를 유지한다.,모듈 간의 접속 관계를 분석하여 복잡도와 중복을 줄인다.,모듈 간의 결합도는 강할수록 바람직하다.,모듈 간의 효과적인 제어를 위해 설계에서 계층적 자료 조직이 제시되어야 한다.,3,"소프트웨어 설계의 목표는 유지보수가 용이하고, 오류 발생 가능성을 줄이며, 효율적인 시스템을 만드는 것입니다.  좋은 소프트웨어는 여러 개의 작은 모듈로 나뉘어져 각 모듈이 특정 기능을 담당하도록 설계됩니다.  이때 모듈들은 서로 밀접하게 연결되어 있으면서도 독립적으로 동작할 수 있어야 합니다.  모듈 간의 결합도가 강하다는 것은 모듈들이 서로 너무 밀접하게 의존한다는 의미로, 하나의 모듈에 변경이 생기면 다른 모듈에도 영향을 미쳐 유지보수가 어려워지고 오류 발생 가능성이 높아집니다.  따라서 모듈 간의 결합도는 약하게 유지하는 것이 바람직하며,  모듈의 크기는 적절해야 유지보수 및 이해도가 높아집니다.  계층적 자료 조직은 효과적인 제어를 위해 중요한 요소입니다.  반면, 모듈 간의 결합도가 강한 것은 바람직하지 않은 설계 지침입니다.  결합도가 강하면 시스템의 유연성과 확장성이 떨어지고, 변경에 대한 영향이 커지기 때문입니다.  따라서  모듈 간의 결합도는 약하게 유지하는 것이 소프트웨어 설계의 중요한 원칙입니다.  정보처리기사 공식 교재에서도 이러한 내용을 확인할 수 있습니다.",93,6
221,1,3,21,소프트웨어 패키징 도구 활용 시 고려 사항으로 틀린 것은?,,반드시 내부 콘텐츠에 대한 암호화 및 보안을 고려한다.,보안을 위하여 이기종 연동을 고려하지 않아도 된다.,사용자 편의성을 위한 복잡성 및 비효율성 문제를 고려한다.,제품 소프트웨어 종류에 적합한 암호화 알고리즘을 적용한다.,2,"소프트웨어 패키징은 개발된 소프트웨어를 사용자가 쉽게 설치하고 사용할 수 있도록 포장하는 과정입니다.  이 과정에서 여러 가지 사항을 고려해야 하는데,  내부 콘텐츠 보안을 위해 암호화는 필수적이며, 사용자 편의성을 높이기 위해 패키징의 복잡성과 비효율성을 최소화해야 합니다. 또한,  소프트웨어의 종류에 맞는 적절한 암호화 알고리즘을 선택하는 것도 중요합니다.  하지만,  보안을 위해 모든 종류의 시스템과의 연동을 배제할 필요는 없습니다.  오히려 필요에 따라 다른 시스템과의 연동을 고려하여  더욱 안전하고 효율적인 패키징을 구현할 수도 있습니다.  따라서, 보안을 위해 이기종 연동을 고려하지 않아도 된다는 주장은 잘못된 것입니다.  다양한 환경에서 소프트웨어를 사용할 수 있도록  다른 시스템과의 호환성을 고려하는 것이  오히려 더 나은 보안 및 사용자 경험을 제공할 수 있습니다.",92,16
222,1,3,22,EAI(Enterprise Application Integration) 구축유형 중 Hybrid에 대한 설명으로 틀린 것은?,,Hub & Spoke와 Message Bus의 혼합방식이다.,필요한 경우 한 가지 방식으로 EAI구현이 가능하다.,데이터 병목현상을 최소화할 수 있다.,중간에 미들웨어를 두지 않고 각 애플리케이션을 point to point로 연결한다.,4,"EAI(Enterprise Application Integration)는 여러 기업 애플리케이션들을 서로 연결하여 데이터를 공유하고 업무 프로세스를 통합하는 기술입니다.  문제에서 다루는 Hybrid 방식은 Hub & Spoke 방식과 Message Bus 방식을 결합한 것입니다. Hub & Spoke는 중앙 허브를 통해 여러 애플리케이션이 연결되는 방식이고, Message Bus는 애플리케이션들이 메시지를 주고받는 방식입니다. Hybrid 방식은 각 방식의 장점을 취하여 효율성을 높입니다.  틀린 선지는 중간에 미들웨어를 두지 않고 각 애플리케이션을 point to point로 연결한다는 것입니다. Hybrid 방식은 Hub & Spoke나 Message Bus처럼 중간에 미들웨어(Hub 또는 Message Bus)를 사용하여 애플리케이션들을 연결합니다.  point to point 방식은 각 애플리케이션을 직접 연결하는 방식으로, 많은 애플리케이션이 있을 경우 관리가 어렵고, 데이터 병목 현상이 발생할 가능성이 높습니다. 따라서 Hybrid 방식은 point to point 방식이 아닌, 중간에 미들웨어를 두어 효율적인 데이터 교환과 관리를 가능하게 합니다.  쉽게 말해, 여러 개의 방을 연결하는데, 모든 방을 일일이 연결하는 대신(point to point), 복도(미들웨어)를 만들어 연결하는 것이 Hybrid 방식입니다.  이 복도를 통해 데이터 병목 현상을 최소화하고 효율적으로 데이터를 주고받을 수 있습니다.",78,10
223,1,3,23,소스코드 품질분석 도구 중 정적분석 도구가 아닌 것은?,,pmd,checkstyle,valance,cppcheck,3,"소스코드 품질 분석 도구는 개발된 소스코드의 오류나 취약점을 찾아내어 소프트웨어 품질을 향상시키는 데 사용됩니다.  이러한 도구는 크게 정적 분석 도구와 동적 분석 도구로 나뉘는데요. 정적 분석 도구는 코드를 실행하지 않고 코드 자체를 분석하여 오류나 취약점을 찾아냅니다. 반면 동적 분석 도구는 코드를 실제로 실행하면서 오류나 취약점을 찾아냅니다.  문제에서 제시된 도구들 중 pmd, checkstyle, cppcheck는 모두 코드를 실행하지 않고 코드의 구조, 스타일, 잠재적인 오류 등을 분석하는 정적 분석 도구입니다.  하지만 나머지 하나는 코드를 실행해야만 오류를 찾을 수 있는 동적 분석 도구이기 때문에 정적 분석 도구가 아닙니다. 따라서 정답은 동적 분석 도구인 선택지입니다.  쉽게 말해, 정적 분석은 '코드를 보면서' 문제를 찾는 것이고, 동적 분석은 '코드를 돌려보면서' 문제를 찾는 것입니다.",73,21
224,1,3,24,다음 Postfix 연산식에 대한 연산결과로 옳은 것은?,https://www.cbtbank.kr/images/iz/iz20200926/iz20200926m24.gif,35,42,77,360,2,"이 문제는 후위 표기법(Postfix notation)으로 표현된 수식을 계산하는 문제입니다. 후위 표기법은 연산자가 피연산자 뒤에 오는 표기법으로, 괄호 없이도 수식의 계산 순서를 명확하게 나타낼 수 있습니다.  주어진 수식 ""3 4 * 5 6 * +""을 계산하는 과정은 다음과 같습니다.",88,11
225,1,3,25,인터페이스 보안을 위해 네트워크 영역에 적용될 수 있는 것으로 거리가 먼 것은?,,IPSec,SSL,SMTP,S-HTTP,3,"이 문제는 인터페이스 보안을 위해 네트워크 영역에 적용될 수 있는 기술들을 묻고 있습니다.  네트워크를 통해 데이터를 주고받을 때 안전하게 보호하는 방법을 생각해보면 됩니다.  IPSec과 SSL은 모두 네트워크 통신의 보안을 강화하는 프로토콜입니다. IPSec은 IP 패킷 자체를 암호화하여 네트워크 상에서의 데이터 유출을 방지하고, SSL은 웹 브라우저와 웹 서버 간의 통신을 안전하게 보호하는 데 사용됩니다.  반면 SMTP는 이메일을 전송하는 프로토콜이고, S-HTTP는 웹 상에서 안전한 거래를 위한 프로토콜이지만,  네트워크 영역 전체의 보안을 담당하는 IPSec이나 SSL과는 다르게 특정한 목적(이메일 전송, 웹 거래)에만 사용됩니다. 따라서 네트워크 영역 전체의 보안을 고려했을 때,  이메일 전송 프로토콜은 네트워크 보안과는 직접적인 관련이 적다고 볼 수 있습니다.  따라서 네트워크 영역에 적용될 수 있는 것으로 거리가 먼 것은 이메일 전송 프로토콜입니다.",80,55
226,1,3,26,"검증(Validation) 검사 기법 중 개발자의 장소에서 사용자가 개발자 앞에서 행해지며, 오류와 사용상의 문제점을 사용자와 개발자가 함께 확인하면서 검사하는 기법은?",,디버깅 검사,형상 검사,자료구조 검사,알파 검사,4,"이 문제는 소프트웨어 검증(Validation) 단계에서 사용되는 검사 기법 중 하나를 묻고 있습니다.  검증은 개발된 소프트웨어가 사용자의 요구사항을 충족하는지 확인하는 과정입니다.  선택지 중에서 개발자가 아닌 사용자가 직접 참여하여 소프트웨어를 사용해보고 문제점을 발견하는 방식은 바로 '알파 검사'입니다. 알파 검사는 개발자의 장소에서, 사용자가 개발자의 감독 하에 소프트웨어를 사용해 봄으로써 초기 단계의 오류나 사용성 문제를 발견하고 개선하는 데 목적이 있습니다.  다른 선택지는 개발 과정의 다른 단계 또는 다른 검사 기법을 나타내므로 알파 검사만이 문제의 조건을 모두 만족합니다.  쉽게 말해,  알파 검사는 개발이 거의 끝난 시점에 사용자가 직접 제품을 사용해보고 문제점을 찾아주는 '사용자 참여형 테스트'라고 생각하면 됩니다.  마치 베타 테스터가 게임을 미리 플레이해보고 버그를 찾아주는 것과 같은 원리입니다.",88,19
227,1,3,27,다음 초기 자료에 대하여 삽입 정렬(Insertion Sort)을 이용하여 오름차순 정렬할 경우 1회전 후의 결과는?,https://www.cbtbank.kr/images/iz/iz20200926/iz20200926m27.gif,"3, 4, 8, 7, 9","3, 4, 9, 7, 8","7, 8, 3, 4, 9","3, 8, 4, 9, 7",4,삽입 정렬은 이미 정렬된 부분과 정렬되지 않은 부분으로 나누어 정렬하는 알고리즘입니다.  처음에는 모든 자료가 정렬되지 않은 부분에 속합니다.  첫 번째 회전에서는 첫 번째 원소(8)를 제외한 나머지 원소들을 하나씩 확인하며 8보다 작은 원소를 만나면 8의 위치를 바꿉니다.,77,11
228,1,3,28,소프트웨어 설치 매뉴얼에 대한 설명으로 틀린 것은?,,설치과정에서 표시될 수 있는 예외상황에 관련 내용을 별도로 구분하여 설명한다.,설치 시작부터 완료할 때까지의 전 과정을 빠짐없이 순서대로 설명한다.,설치 매뉴얼은 개발자 기준으로 작성한다.,"설치 매뉴얼에는 목차, 개요, 기본사항 등이 기본적으로 포함되어야 한다.",3,"소프트웨어 설치 매뉴얼은 사용자가 소프트웨어를 설치하는 과정을 쉽고 정확하게 안내하기 위해 작성됩니다. 따라서 사용자의 입장에서 명확하고 자세하게 설명되어야 합니다.  설치 과정에서 발생할 수 있는 문제 상황과 해결 방법을 미리 제시하는 것은 사용자의 편의성을 높이는 중요한 부분입니다.  설치 과정 전체를 순서대로 자세히 설명하는 것 또한 필수적입니다.  목차, 개요, 기본 사항 등은 사용자가 매뉴얼을 쉽게 이해하고 사용할 수 있도록 돕는 구성 요소입니다. 하지만 개발자가 어떤 방식으로 소프트웨어를 개발했는지에 대한 내용은 사용자에게 필요한 정보가 아닙니다.  설치 매뉴얼은 사용자 중심으로 작성되어야 하며, 개발 과정이나 내부적인 정보는 포함될 필요가 없습니다. 따라서 개발자의 관점에서 작성된 매뉴얼은 사용자에게 혼란을 야기할 수 있습니다.  결론적으로, 사용자 친화적인 설치 매뉴얼을 작성하기 위해서는 사용자의 입장에서 명확하고, 자세하며, 완전한 정보를 제공해야 합니다.",93,17
229,1,3,29,인터페이스 구현 검증 도구가 아닌 것은?,,ESB,xUnit,STAF,NTAF,1,"이 문제는 인터페이스 구현 검증 도구를 묻고 있습니다.  소프트웨어 개발 과정에서 여러 시스템이나 모듈 간의 인터페이스가 제대로 작동하는지 확인하는 것은 매우 중요합니다.  잘못된 인터페이스는 시스템 전체의 오류나 예상치 못한 동작으로 이어질 수 있기 때문입니다.  문제에서 제시된 옵션들을 살펴보면,  xUnit과 STAF, NTAF는 모두 소프트웨어 테스트 및 자동화에 사용되는 도구들입니다.  xUnit은 단위 테스트 프레임워크로,  개별 모듈이나 함수의 기능을 검증하는 데 사용됩니다. STAF(Software Testing Automation Framework)와 NTAF(Network Test Automation Framework)는  더욱 광범위한 테스트 자동화를 지원하는 프레임워크입니다.  이들은 인터페이스를 포함한 다양한 부분의 검증에 활용될 수 있습니다.  반면, ESB(Enterprise Service Bus)는 여러 애플리케이션 간의 통합을 위한 미들웨어입니다.  ESB 자체는 인터페이스를 *구현*하는 데 사용되지만, 인터페이스의 *검증* 도구는 아닙니다.  ESB는 시스템 간의 연결을 제공하고 데이터를 전달하는 역할을 하지만, 그 연결이 올바르게 작동하는지 확인하는 기능은 제공하지 않습니다.  따라서 ESB는 인터페이스 구현 검증 도구로 볼 수 없습니다.  다른 옵션들은 인터페이스 검증을 위한 테스트나 자동화를 지원하는 도구이므로,  ESB만이 인터페이스 구현 검증 도구가 아닌 것입니다.",65,24
230,1,3,30,소프트웨어 형상 관리에서 관리 항목에 포함되지 않는 것은?,,프로젝트 요구 분석서,소스 코드,운영 및 설치 지침서,프로젝트 개발 비용,4,"소프트웨어 형상 관리(Software Configuration Management, SCM)는 소프트웨어 개발 과정에서 생성되는 모든 산출물을 체계적으로 관리하는 것을 말합니다.  프로젝트의 요구사항 분석서, 소스 코드, 운영 및 설치 지침서와 같은 문서들은 개발 과정에서 생성되고 관리되어야 하는 중요한 산출물입니다.  이러한 산출물들은 버전 관리, 변경 관리, 품질 관리 등을 통해 소프트웨어 개발 프로젝트의 성공적인 완료를 위해 필수적입니다. 하지만 프로젝트 개발 비용은 소프트웨어 자체의 구성 요소가 아니며, 형상 관리의 대상이 되는 산출물이 아닙니다.  비용은 프로젝트 관리의 영역에 속하며, 소프트웨어의 기능이나 성능과 직접적으로 관련이 없기 때문입니다.  따라서 소프트웨어 형상 관리에서 관리 항목에 포함되지 않는 것은 프로젝트 개발 비용입니다.",82,15
231,1,3,31,다음 설명에 해당하는 것은?,https://www.cbtbank.kr/images/iz/iz20200926/iz20200926m31.gif,외부 스키마,내부 스키마,개념 스키마,슈퍼 스키마,2,"문제에서 설명하는 것은 데이터베이스의 물리적인 구조를 나타내는 것입니다.  쉽게 말해, 컴퓨터 하드디스크와 같은 물리적인 저장장치에 데이터가 어떻게 실제로 저장되는지를 정의하는 설계도라고 생각하면 됩니다.  레코드의 형식, 데이터 항목의 표현 방법, 데이터의 저장 순서 등을  물리적 저장 장치 관점에서 정의하는 것이죠.  외부 스키마는 사용자가 데이터베이스를 보는 방식, 개념 스키마는 전체적인 데이터베이스의 개념적인 설계, 슈퍼 스키마는 여러 데이터베이스를 통합 관리하는 데 사용되는 개념입니다.  따라서 물리적인 저장 방식을 정의하는 것은  '내부 스키마'에 해당합니다.  내부 스키마는 데이터베이스 관리 시스템(DBMS)이 데이터를 실제로 어떻게 저장하고 관리할지를 결정하는 설계 단계이기 때문입니다.  마치 건물의 설계도 중에서 실제 벽돌과 철근을 사용하여 건물을 짓는 방법을 자세히 설명하는 도면과 같은 역할을 합니다.",74,30
232,1,3,32,다음 트리에 대한 INORDER 운행 결과는?,https://www.cbtbank.kr/images/iz/iz20200926/iz20200926m32.gif,D B A E C F,A B D C E F,D B E C F A,A B C D E F,1,이 문제는 이진 트리의 순회(Traversal) 방법 중 하나인 INORDER 순회를 이해하고 있는지를 묻는 문제입니다. INORDER 순회는 왼쪽 서브트리 → 루트 노드 → 오른쪽 서브트리 순서로 노드를 방문하는 방법입니다.  주어진 트리를 INORDER 순회로 방문해 보겠습니다.,75,11
233,1,3,33,n 개의 노드로 구성된 무방향 그래프의 최대 간선수는?,,n－1,n／2,n(n－1)／2,n(n＋1),3,"n개의 노드로 이루어진 무방향 그래프에서 최대 간선 수를 구하는 문제입니다.  무방향 그래프란 노드 간의 연결이 방향성을 갖지 않는 그래프입니다.  예를 들어, A 노드와 B 노드가 연결되어 있다면, A에서 B로, B에서 A로 이동하는 것이 동일한 연결을 의미합니다.",80,11
234,1,3,34,다음이 설명하는 테스트 용어는?,https://www.cbtbank.kr/images/iz/iz20200926/iz20200926m34.gif,테스트 케이스,테스트 시나리오,테스트 오라클,테스트 데이터,3,"문제에서 설명하는 테스트 용어는 테스트 결과의 정확성을 검증하는 데 사용되는 기준, 즉 참값과 비교하여 결과를 판단하는 것을 의미합니다.  마치 시험지를 채점할 때 정답지를 가지고 답을 맞춰보는 것과 같습니다.  문제에서 제시된 설명은 ""사전에 정의된 참값을 입력하여 비교하는 기법 및 활동""이라고 명확하게 언급하고 있습니다.  이러한 참값을 제공하는 것을 ""테스트 오라클""이라고 부릅니다.  테스트 케이스는 테스트를 위한 입력값과 기대 결과를 정의한 것이고, 테스트 시나리오는 테스트 케이스들을 순서대로 실행하는 계획이며, 테스트 데이터는 테스트에 사용되는 실제 데이터를 의미합니다.  따라서 문제의 설명에 가장 정확하게 부합하는 용어는 테스트 결과의 참/거짓을 판단하는 기준인 ""테스트 오라클""입니다.  다양한 종류의 테스트 오라클(참 오라클, 샘플링 오라클, 휴리스틱 오라클, 일관성 검사 오라클)이 존재하는 것도 이를 뒷받침합니다.",63,19
235,1,3,35,빌드 자동화 도구에 대한 설명으로 틀린 것은?,,Gradle은 실행할 처리 명령들을 모아 태스크로 만든 후 태스크 단위로 실행한다.,빌드 자동화 도구는 지속적인 통합개발환경 에 서 유용하게 활용된다.,"빌드 자동화 도구에는 Ant, Gradle, Jenkins등이 있다.",Jenkins는 Groovy 기반으로 한 오픈소스로 안드로이드 앱 개발 환경에서 사용된다.,4,"이 문제는 빌드 자동화 도구에 대한 이해도를 묻는 문제입니다.  소프트웨어 개발 과정에서 코드를 컴파일하고, 테스트하고, 배포하는 과정은 매우 반복적이고 지루한 작업입니다. 이러한 반복적인 작업을 자동화하여 개발 효율성을 높이고, 인적 실수를 줄이기 위해 빌드 자동화 도구가 사용됩니다.  문제에서 틀린 설명을 찾는 것이 목표인데,  잘못된 설명은 Jenkins에 대한 것입니다. Jenkins는 빌드 자동화 도구로 널리 사용되지만, Groovy 기반이 아닌 Java 기반의 오픈소스 도구이며, 안드로이드 앱 개발 환경에서만 사용되는 것이 아닙니다. 다양한 종류의 소프트웨어 개발 환경에서 폭넓게 활용됩니다.  다른 선택지들은 빌드 자동화 도구의 특징과 활용에 대한 정확한 설명을 제시하고 있습니다.  Gradle은 태스크 기반으로 작업을 수행하고, 빌드 자동화 도구는 지속적인 통합(CI) 개발 환경에서 효율성을 높이며, Ant와 Gradle 외에도 다양한 빌드 자동화 도구(예: Jenkins, Maven 등)가 존재합니다. 따라서 Jenkins에 대한 설명이 잘못되었으므로, 이것이 틀린 설명입니다.",69,18
236,1,3,36,저작권 관리 구성 요소에 대한 설명이 틀린 것은?,,콘텐츠 제공자(Contents Provider) : 콘텐츠를 제공하는 저작권자,콘텐츠 분배자(Contents Distributor) : 콘텐츠를 메타 데이터와 함께 배포 가능한 단위로 묶는 기능,클리어링 하우스(Clearing House) : 키 관리 및 라이선스 발급 관리,DRM 컨트롤러 : 배포된 콘텐츠의 이용 권한을 통제,2,"저작권 관리 구성 요소에 대한 문제입니다.  정답은 콘텐츠 분배자가 콘텐츠를 메타데이터와 함께 배포 가능한 단위로 묶는 기능을 한다는 설명이 틀렸다는 것입니다.  콘텐츠 분배자는 콘텐츠를 *배포*하는 역할을 하지만,  메타데이터와 함께 배포 가능한 단위로 *묶는* 기능은 콘텐츠 제공자나 클리어링 하우스 등 다른 구성 요소에서 수행하는 작업입니다.  콘텐츠 분배자는 이미 묶여진 콘텐츠를 사용자에게 전달하는 역할에 집중합니다.  마치 책을 출판하는 출판사(콘텐츠 제공자)가 책을 여러 권으로 묶어서(메타데이터 포함) 유통사(콘텐츠 분배자)에 보내면 유통사는 서점 등에 책을 배포하는 것과 같은 원리입니다.  따라서 콘텐츠 분배자가 콘텐츠를 묶는다는 설명은 저작권 관리 시스템의 실제 기능과 맞지 않아 틀린 설명이 됩니다.  다른 선지는 저작권 관리 시스템에서 각 구성 요소가 수행하는 역할을 정확하게 설명하고 있습니다.",72,16
237,1,3,37,블랙박스 테스트 기법으로 거리가 먼 것은?,,기초 경로 검사,동치 클래스 분해,경계값 분석,원인 결과 그래프,1,"블랙박스 테스트는 소프트웨어의 내부 구조나 동작 원리를 알지 못한 채, 외부에서 입력값을 주고 출력값을 검증하는 테스트 기법입니다.  마치 검은 상자(블랙박스) 안에서 무슨 일이 일어나는지 모르고, 입력과 출력만으로 동작을 확인하는 것과 같습니다.  문제에서 제시된 몇몇 기법들은 블랙박스 테스트의 대표적인 예시입니다.  예를 들어, 동치 클래스 분할은 입력값들을 비슷한 특성을 가진 그룹(동치 클래스)으로 나누어 각 그룹에서 대표값을 선택하여 테스트하는 방법이고, 경계값 분석은 입력값의 경계선에 해당하는 값들을 중점적으로 테스트하는 방법입니다.  하지만, 기초 경로 검사는 소프트웨어의 내부 제어 흐름을 분석하여 모든 경로를 테스트하는 기법입니다.  즉, 소프트웨어의 내부 구조를 파악해야 테스트를 설계할 수 있으므로 블랙박스 테스트의 개념과는 거리가 멉니다.  원인 결과 그래프 또한 소프트웨어의 내부 구조를 고려하여 테스트 케이스를 설계하는 기법이므로 블랙박스 테스트와는 다릅니다. 따라서, 소프트웨어 내부 구조를 고려하는 기법은 블랙박스 테스트 기법으로 보기 어렵습니다.",72,19
238,1,3,38,"해싱함수 중 레코드 키를 여러 부분으로 나누고, 나눈 부분의 각 숫자를 더하거나 XOR한 값을 홈 주소로 사용하는 방식은?",,제산법,폴딩법,기수변환법,숫자분석법,2,"이 문제는 해싱 함수 중 레코드 키를 여러 부분으로 나누어 처리하는 방법을 묻고 있습니다.  해싱은 데이터를 빠르게 검색하기 위해 키 값을 해시 함수에 적용하여 주소를 생성하는 기법입니다.  문제에서 설명하는 방식은 레코드 키를 여러 부분으로 나눈 후, 각 부분의 숫자들을 더하거나 XOR 연산을 통해 하나의 값을 만들고, 이 값을 데이터의 저장 위치(홈 주소)로 사용하는 것입니다. 이러한 방식은 레코드 키의 각 부분의 정보를 모두 활용하여 충돌을 줄이고 효율적인 데이터 저장을 가능하게 합니다.  이를 '폴딩법'이라고 합니다.  폴딩법은 레코드 키를 여러 부분으로 나누어 각 부분을 더하거나 XOR 연산을 수행하여 해시 값을 생성하는 방법으로,  키의 모든 부분을 고려하여 해시 주소를 생성하기 때문에 다른 방법들에 비해 충돌을 줄일 수 있다는 장점이 있습니다.  예를 들어, 키가 12345678 이라면,  두 부분으로 나누어 1234와 5678을 더하거나 XOR 연산을 수행하여 해시 값을 생성하는 방식입니다.  다른 선택지들은 레코드 키를 이러한 방식으로 처리하지 않습니다.",61,11
239,1,3,39,다음에서 설명하는 클린 코드 작성 원칙은?,https://www.cbtbank.kr/images/iz/iz20200926/iz20200926m39.gif,다형성,단순성,추상화,의존성,2,"문제에서 제시된 클린 코드 작성 원칙은 ""한 번에 한 가지 처리만 수행한다""와 ""클래스/메소드/함수를 최소 단위로 분리한다""입니다. 이는 코드의 복잡성을 줄이고 가독성을 높여 유지보수 및 확장성을 향상시키는 것을 목표로 합니다.  복잡한 작업을 작고 단순한 여러 단위로 나누어 처리함으로써 각 부분의 기능을 명확하게 하고, 오류 발생 시 원인 파악 및 수정을 용이하게 합니다.  이는 바로 '단순성' 원칙을 따르는 것입니다.  다형성, 추상화, 의존성은 객체지향 프로그래밍의 중요한 개념이지만, 문제에서 제시된 원칙들과 직접적으로 연결되지 않습니다. 다형성은 여러 타입의 객체를 동일한 인터페이스로 다루는 것이고, 추상화는 복잡한 시스템을 단순화하여 표현하는 것이며, 의존성은 모듈 간의 관계를 나타냅니다.  문제의 핵심은 코드의 단순화와 가독성 향상에 있으며, 이를 가장 잘 나타내는 것이 단순성 원칙입니다.  따라서, 제시된 클린 코드 작성 원칙은 단순성을 추구하는 방식입니다.",86,7
240,1,3,40,디지털 저작권 관리(DRM) 기술과 거리가 먼 것은?,,콘텐츠 암호화 및 키 관리,콘텐츠 식별체계 표현,콘텐츠 오류 감지 및 복구,라이선스 발급 및 관리,3,"디지털 저작권 관리(DRM) 기술은 디지털 콘텐츠의 저작권을 보호하기 위한 기술입니다.  콘텐츠의 불법 복제 및 배포를 막기 위해 다양한 방법을 사용하는데, 대표적으로 콘텐츠를 암호화하여 무단 접근을 차단하고,  누가 어떤 콘텐츠에 접근할 수 있는지 권한을 관리하는 키 관리 시스템을 사용합니다. 또한, 콘텐츠를 식별하고 추적할 수 있는 체계를 구축하여 불법 복제물을 식별하는 데 활용합니다.  마지막으로, 콘텐츠 사용에 대한 라이선스를 발급하고 관리하여 저작권자의 권리를 보호합니다.  하지만 콘텐츠의 오류 감지 및 복구는 콘텐츠의 무결성을 유지하는 기술이지, 저작권 보호와는 직접적인 관련이 없습니다.  오류 감지 및 복구는 콘텐츠의 내용 자체를 보호하는 것이지, 콘텐츠의 무단 사용을 막는 DRM 기술의 목표와는 다릅니다. 따라서 콘텐츠 오류 감지 및 복구는 DRM 기술과 거리가 먼 기술입니다.",81,16
241,1,3,41,다음 설명과 관련 있는 트랜잭션의 특징은?,https://www.cbtbank.kr/images/iz/iz20200926/iz20200926m41.gif,Durability,Isolation,Consistency,Atomicity,4,"문제에서 제시된 설명은 ""트랜잭션의 연산은 모두 실행되거나, 모두 실행되지 않아야 한다"" 입니다.  이는 데이터베이스의 일관성을 유지하기 위해 매우 중요한 개념입니다.  예를 들어, 은행 계좌 이체를 생각해 봅시다.  A 계좌에서 B 계좌로 1000원을 이체하는 트랜잭션이 있다고 가정해 봅시다. 이 트랜잭션은 A 계좌에서 1000원을 차감하고 B 계좌에 1000원을 추가하는 두 가지 연산으로 구성됩니다. 만약 첫 번째 연산(A 계좌에서 1000원 차감)만 성공하고 두 번째 연산(B 계좌에 1000원 추가)이 실패한다면, 전체 시스템의 데이터는 일관성을 잃게 됩니다.  즉, 돈이 사라진 상태가 되는 것이죠.  따라서 트랜잭션은 이러한 상황을 방지하기 위해 모든 연산이 성공적으로 완료되거나, 실패할 경우 모든 연산이 취소되어 원래 상태로 되돌아가는 특징을 가져야 합니다. 이러한 특징을  ""모든 연산이 하나의 논리적 단위로 처리되어야 한다"" 라고 표현하는 것이 바로 문제에서 설명하는 트랜잭션의 핵심 특징입니다.  이처럼 모든 연산이 하나의 단위로 처리되는 성질을  **원자성(Atomicity)** 이라고 합니다.  원자성 덕분에 데이터베이스의 일관성을 유지하고, 예측 불가능한 상황으로 인한 데이터 손실을 방지할 수 있습니다.",73,27
242,1,3,42,"데이터베이스에 영향을 주는 생성, 읽기, 갱신, 삭제 연산으로 프로세스와 테이블 간에 매트릭스를 만들어서 트랜잭션을 분석하는 것은?",,CASE 분석,일치 분석,CRUD 분석,연관성 분석,3,"데이터베이스를 다루는 작업은 크게 네 가지로 나눌 수 있습니다.  데이터를 새로 추가하는 **생성(Create)**, 저장된 데이터를 확인하는 **읽기(Read)**, 데이터를 수정하는 **갱신(Update)**, 그리고 데이터를 삭제하는 **삭제(Delete)**입니다.  이 네 가지 연산을 줄여서 CRUD라고 부릅니다. 문제에서 설명하는 ""데이터베이스에 영향을 주는 생성, 읽기, 갱신, 삭제 연산으로 프로세스와 테이블 간에 매트릭스를 만들어서 트랜잭션을 분석하는 것""은 바로 이 CRUD 연산을 이용하여 데이터베이스의 변화를 분석하는 방법을 의미합니다.  프로세스와 테이블 간의 매트릭스를 만든다는 것은 각 프로세스가 어떤 테이블에 대해 어떤 CRUD 연산을 수행하는지 표로 정리하여 시각적으로 분석하는 것을 의미합니다.  따라서 데이터베이스의 트랜잭션을 분석하는 방법으로 가장 적절한 용어는 CRUD 분석입니다.  마치 표를 만들어 각 프로세스가 데이터베이스의 어떤 부분을 어떻게 변경하는지 추적하는 것과 같습니다.",75,34
243,1,3,43,"정규화된 엔티티, 속성, 관계를 시스템의 성능 향상과 개발 운영의 단순화를 위해 중복, 통합, 분리 등을 수행하는 데이터 모델링 기법은?",,인덱스정규화,반정규화,집단화,머징,2,"데이터베이스 설계에서 정규화는 데이터 중복을 최소화하고 데이터 무결성을 높이기 위한 중요한 과정입니다.  정규화를 통해 데이터베이스의 효율성과 관리 편의성을 높일 수 있죠. 하지만, 과도한 정규화는 데이터베이스의 성능 저하를 야기할 수 있습니다.  데이터베이스에 접근하는 쿼리가 여러 테이블을 조인해야 하는 경우가 많아지고, 이는 쿼리 실행 시간을 증가시키는 원인이 됩니다.  따라서 시스템 성능 향상과 개발 운영의 단순화를 위해서는 정규화된 데이터베이스를 다시  중복을 허용하거나 테이블을 통합, 분리하는 등의 작업을 수행하여 성능을 최적화해야 할 필요가 있습니다. 이러한 과정을 반정규화라고 합니다.  문제에서 언급하는 ""정규화된 엔티티, 속성, 관계를 시스템의 성능 향상과 개발 운영의 단순화를 위해 중복, 통합, 분리 등을 수행하는 데이터 모델링 기법""은 바로 이 반정규화를 의미합니다.  정규화의 장점을 유지하면서 성능 저하 문제를 해결하기 위한 최적화 기법인 것이죠.  다른 선지들은 데이터베이스 설계와 직접적인 관련이 없거나, 정규화와 반정규화와 같은 맥락에서 성능 최적화 기법으로 볼 수 없습니다.",70,33
244,1,3,44,"학생 테이블을 생성한 후, 성별 필드가 누락되어 이를 추가하려고 한다. 이에 적합한 SQL 명령어는?",,INSERT,ALTER,DROP,MODIFY,2,"학생 테이블에 성별 필드가 빠졌는데, 이미 생성된 테이블에 새로운 필드를 추가하려면 어떤 SQL 명령어를 사용해야 할까요?  데이터베이스를 처음 설계할 때는 모든 필드를 미리 정의하지만,  필요에 따라 테이블 구조를 변경하는 경우가 있습니다.  이때 사용하는 명령어가 바로 'ALTER TABLE' 명령어입니다.  'INSERT' 명령어는 새로운 데이터를 추가하는 것이고, 'DROP' 명령어는 테이블 자체를 삭제하는 것이며, 'MODIFY' 명령어는 기존 필드의 속성을 변경하는 데 사용됩니다.  따라서 이미 생성된 테이블에 새로운 필드인 '성별'을 추가하려면 'ALTER TABLE' 명령어를 사용하여 테이블 구조를 변경해야 합니다.  마치 레고 블록을 조립하다가 블록이 부족해서 추가하는 것과 같은 원리라고 생각하면 이해하기 쉬울 거예요.  'ALTER TABLE' 명령어는 기존 테이블의 구조를 변경하는 데 유용한 도구입니다.",75,27
245,1,3,45,정규화의 필요성으로 거리가 먼 것은?,,데이터 구조의 안정성 최대화,중복 데이터의 활성화,"수정, 삭제 시 이상현상의 최소화",테이블 불일치 위험의 최소화,2,"정규화는 데이터베이스의 중복을 최소화하고 데이터의 무결성을 유지하기 위한 과정입니다.  데이터베이스에 중복된 정보가 많으면 저장 공간 낭비는 물론이고, 데이터를 수정하거나 삭제할 때 일관성을 유지하기 어려워져서 데이터베이스 전체에 오류가 발생할 위험이 커집니다.  예를 들어, 고객 정보에 주소가 중복되어 저장되어 있다면, 주소를 변경할 때 모든 중복된 주소를 일일이 수정해야 하는 번거로움이 있고, 하나라도 수정하지 못하면 데이터 불일치가 발생하게 됩니다.  정규화는 이러한 문제점을 해결하여 데이터 구조의 안정성을 높이고, 데이터 수정 및 삭제 시 발생할 수 있는 이상 현상을 최소화하며, 테이블 간 불일치 위험을 줄이는 데 목적이 있습니다.  따라서 정규화의 목적과는 반대로 중복 데이터를 '활성화'하는 것은 정규화의 필요성과는 거리가 멉니다.  정규화는 중복 데이터를 제거하고 데이터의 무결성을 확보하는 데 초점을 맞추기 때문입니다.",90,30
246,1,3,46,개체-관계 모델의 E-R 다이어그램에서 사용되는 기호와 그 의미의 연결이 틀린 것은?,,사각형 - 개체 타입,삼각형 - 속성,선 - 개체타입과 속성을 연결,마름모 - 관계 타입,2,"E-R 다이어그램은 데이터베이스 설계에서 개체와 개체 간의 관계를 시각적으로 표현하는 도구입니다.  각 기호는 특정 의미를 가지는데, 문제에서 잘못 연결된 부분은 삼각형이 속성을 나타낸다는 것입니다.  삼각형은 E-R 다이어그램에서 속성을 나타내는 것이 아니라, **관계의 속성**을 나타냅니다.  즉, 개체 자체의 속성은 사각형 안에 표현되고, 개체 간 관계에 추가적인 정보(속성)가 필요한 경우, 그 관계를 나타내는 마름모 안에 표시합니다. 예를 들어 '학생'이라는 개체가 있고, '학생'의 속성으로 '학번', '이름', '전공' 등이 있다면, 이들은 사각형 안에 표시됩니다.  만약 '수강'이라는 관계가 있고, '수강'에 대한 추가적인 정보로 '수강년도'가 있다면, '수강년도'는 '수강' 관계를 나타내는 마름모 안에 표시됩니다. 따라서 삼각형이 속성을 나타낸다는 설명은 잘못된 것입니다.  나머지 기호들은 개체 타입, 개체 타입과 속성의 연결, 관계 타입을 정확하게 나타내고 있습니다.",87,30
247,1,3,47,다음 SQL문에서 빈칸에 들어갈 내용으로 옳은 것은?,https://www.cbtbank.kr/images/iz/iz20200926/iz20200926m47.gif,FROM,SET,INTO,TO,2,"SQL의 UPDATE문은 데이터베이스 내의 테이블에 있는 특정 레코드의 값을 변경하는 데 사용됩니다.  문제의 SQL문은 `회원` 테이블에서 `회원번호`가 'N4'인 레코드의 `전화번호`를 '010-14'로 변경하고자 합니다.  UPDATE문의 기본 구조는 `UPDATE 테이블명 SET 변경할컬럼명 = 새로운값 WHERE 조건` 입니다.  여기서 빈칸은 변경할 컬럼을 지정하는 부분으로,  `SET` 키워드를 사용하여 어떤 컬럼의 값을 변경할지 명시합니다.  따라서 빈칸에는  `SET`이 들어가야  `전화번호` 컬럼의 값을 '010-14'로 변경하라는 명령이 제대로 수행될 수 있습니다. 다른 키워드들은 UPDATE 문의 구조와 맞지 않아 올바른 결과를 가져오지 못합니다.  마치 편지를 쓸 때, 누구에게(WHERE), 무엇을(SET) 변경할지 명확히 적어야 하는 것과 같습니다.",82,25
248,1,3,48,릴레이션에 있는 모든 튜플에 대해 유일성은 만족시키지만 최소성은 만족시키지 못하는 키는?,,후보키,기본키,슈퍼키,외래키,3,"릴레이션에서 키는 특정 튜플(데이터 행)을 유일하게 식별하는 데 사용되는 속성(데이터 열) 또는 속성들의 집합입니다.  문제에서 '모든 튜플에 대해 유일성은 만족시키지만 최소성은 만족시키지 못하는 키'를 묻고 있습니다.  유일성이란 키를 구성하는 속성 값들이 모든 튜플에서 중복되지 않아야 함을 의미하고, 최소성이란 키를 구성하는 속성의 개수가 최소여야 함을 의미합니다.  후보키는 유일성과 최소성을 모두 만족하는 키이고, 기본키는 후보키 중에서 하나를 선택한 것입니다.  외래키는 다른 테이블의 기본키를 참조하는 키입니다.  따라서 유일성은 만족하지만 최소성을 만족하지 않는 키는,  필요 이상으로 많은 속성을 포함하여 유일성을 보장하는 키를 의미하며, 이는 바로 슈퍼키입니다.  슈퍼키는 후보키를 포함하는 모든 속성의 집합으로, 유일성은 보장하지만 최소성을 만족하지 않기 때문에 최소한의 속성으로 유일성을 보장하는 후보키보다 더 많은 속성을 포함합니다. 예를 들어, 학생 테이블에서 학번이 유일한 식별자(후보키)라면, 학번과 이름을 함께 사용하는 키는 유일성을 만족하지만 최소성을 만족하지 않는 슈퍼키가 됩니다.",77,29
249,1,3,49,DBA가 사용자 PARK에게 테이블 [STUDENT]의 데이터를 갱신할 수 있는 시스템 권한을 부여하고자 하는 SQL문을 작성하고자 한다. 다음에 주어진 SQL문의 빈칸을 알맞게 채운 것은?,https://www.cbtbank.kr/images/iz/iz20200926/iz20200926m49.gif,"㉠ INSERT, ㉡ INTO","㉠ ALTER, ㉡ TO","㉠ UPDATE, ㉡ ON","㉠ REPLACE, ㉡ IN",3,"이 문제는 데이터베이스 관리자(DBA)가 특정 사용자에게 테이블에 대한 특정 권한을 부여하는 SQL 문을 작성하는 방법을 묻고 있습니다.  SQL에서 권한을 부여하는 명령어는 `GRANT` 입니다.  `GRANT` 명령어는  어떤 권한을(①), 어떤 테이블에 대해(②), 누구에게(사용자) 부여할지를 지정합니다.  문제에서 DBA는 사용자 PARK에게 STUDENT 테이블의 데이터를 갱신할 수 있는 권한을 주고자 합니다. 데이터를 갱신하는 것은 데이터를 수정하는 것을 의미하며, SQL에서는 이를 `UPDATE` 명령어로 수행합니다. 따라서 ①에는 `UPDATE`가 들어가야 합니다.  그리고  `UPDATE` 권한을 부여할 대상 테이블을 명시하기 위해서는 `ON` 키워드를 사용하여 테이블 이름을 지정합니다. 따라서 ②에는 `ON`이 들어가야 합니다.  결론적으로,  `GRANT UPDATE ON STUDENT TO PARK;` 와 같이 작성되어야 사용자 PARK에게 STUDENT 테이블의 데이터를 갱신할 수 있는 권한이 부여됩니다.  다른 선지는  데이터 삽입(`INSERT`), 테이블 구조 변경(`ALTER`), 데이터 교체(`REPLACE`) 등과 관련된 권한이나 부적절한 키워드를 사용하고 있어 정답이 될 수 없습니다.",76,25
250,1,3,50,관계대수에 대한 설명으로 틀린 것은?,,주어진 릴레이션 조작을 위한 연산의 집합이다.,일반 집합 연산과 순수 관계 연산으로 구분된다.,질의에 대한 해를 구하기 위해 수행해야 할 연산의 순서를 명시한다.,원하는 정보와 그 정보를 어떻게 유도하는가를 기술하는 비절차적방법이다.,4,"관계대수는 데이터베이스 안의 데이터를 조작하기 위한 여러 연산들의 모임입니다.  마치 수학의 대수 연산처럼,  데이터베이스에 있는 테이블들을 가지고  합집합, 교집합, 차집합과 같은 일반적인 집합 연산을 할 수도 있고,  데이터베이스에 특화된 선택(selection), 투영(projection), 조인(join) 등의 연산을 통해 원하는 정보를 추출할 수 있습니다.  문제에서 틀린 설명은  '원하는 정보와 그 정보를 어떻게 유도하는가를 기술하는 비절차적 방법이다' 입니다. 관계대수는 어떤 연산을 먼저 하고, 어떤 연산을 나중에 할지를 순서대로 명시하는 절차적인 방법입니다.  원하는 결과를 얻기 위해 필요한 연산들을 순서대로 나열해야 하기 때문에 비절차적이라고 할 수 없습니다.  SQL과 같은 관계형 데이터베이스 질의어는 관계대수의 개념을 바탕으로 만들어졌지만,  SQL은 관계대수보다 사용하기 쉽도록 설계되었고,  어떤 연산을 먼저 수행할지 명시적으로 작성하지 않아도 되는 부분이 있습니다. 하지만 관계대수 자체는  연산의 순서를 명확히 정의해야 원하는 결과를 얻을 수 있는 절차적인 방법입니다.  따라서, 관계대수가 비절차적이라는 설명은 잘못된 것입니다.",81,29
251,1,3,51,다음 SQL문의 실행 결과는?,https://www.cbtbank.kr/images/iz/iz20200926/iz20200926m51.gif,https://www.cbtbank.kr/images/iz/iz20200926/iz20200926m51b1.gif,https://www.cbtbank.kr/images/iz/iz20200926/iz20200926m51b2.gif,https://www.cbtbank.kr/images/iz/iz20200926/iz20200926m51b3.gif,https://www.cbtbank.kr/images/iz/iz20200926/iz20200926m51b4.gif,3,"문제에서 제시된 SQL문은 어떤 테이블의 '과목이름' 컬럼에 저장된 데이터를 조회하는 쿼리입니다.  추가 설명 이미지가 없어 정확한 테이블 구조는 알 수 없지만,  결과를 보면 '과목이름' 컬럼에 'DB'라는 값이 적어도 두 번 이상 존재한다는 것을 알 수 있습니다.  그리고 '운영체제'라는 값도 적어도 한 번 이상 존재하는 것으로 보입니다.  따라서 정답은 'DB', 'DB', '운영체제' 와 같이 'DB'가 두 번, '운영체제'가 한 번 나타나는 결과를 보여주는 선지가 됩니다.  만약 'DB'가 한 번만 존재하거나 '운영체제'가 존재하지 않는다면 다른 선지가 정답이 될 것입니다.  결국 이 문제는 주어진 쿼리가 어떤 결과를 반환하는지,  즉 테이블 내 데이터의 분포를 파악하는 문제입니다.  비전공자도 이해하기 쉽게 설명하자면,  '과목이름'이라는 목록에서 어떤 과목이 몇 번 나오는지 세어보는 문제와 같습니다.",73,27
252,1,3,52,로킹(Locking) 기법에 대한 설명으로 틀린 것은?,,로킹의 대상이 되는 객체의 크기를 로킹 단위라고 한다.,로킹 단위가 작아지면 병행성 수준이 낮아진다.,데이터베이스도 로킹 단위가 될 수 있다.,로킹 단위가 커지면 로크 수가 작아 로킹 오버헤드가 감소한다.,2,"로킹(Locking)은 데이터베이스나 파일 시스템에서 여러 사용자가 동시에 같은 데이터를 접근하여 변경하는 것을 막기 위해 사용하는 기법입니다.  마치 화장실에 사람이 들어가면 다른 사람이 들어가지 못하도록 문을 잠그는 것과 같습니다.  문제에서 틀린 설명은 로킹 단위가 작아지면 병행성 수준이 낮아진다는 부분입니다.  로킹 단위란 로킹의 대상이 되는 데이터의 크기를 말하는데, 로킹 단위가 작을수록 더 세분화된 데이터에 대해서만 잠금이 걸리게 됩니다.  즉, 여러 사용자가 서로 다른 부분의 데이터를 동시에 접근하고 수정할 수 있으므로 병행성(동시에 여러 작업을 처리하는 능력)이 높아집니다. 반대로 로킹 단위가 크면,  더 많은 데이터가 잠겨 다른 사용자의 접근이 제한되므로 병행성이 낮아집니다.  다른 선지는 모두 로킹 기법의 특징을 올바르게 설명하고 있습니다.  데이터베이스 전체를 로킹 단위로 설정할 수도 있으며, 로킹 단위가 커지면 잠가야 할 대상(로크)의 수가 줄어들어 오버헤드(시스템 자원 소모)가 감소합니다. 따라서 로킹 단위와 병행성 수준은 반비례 관계에 있습니다.",79,29
253,1,3,53,사용자 X1에게 department 테이블에 대한 검색 연산을 회수하는 명령은?,,delete select on department to X1;,remove select on department from X1;,revoke select on department from X1;,grant select on department from X1;,3,"이 문제는 데이터베이스의 접근 권한을 관리하는 SQL 명령어를 묻고 있습니다.  사용자 X1에게 'department' 테이블에 대한 조회(select) 권한을 부여하는 명령어를 찾는 문제입니다.  데이터베이스 시스템에서는  데이터의 무결성과 보안을 위해 사용자에게 특정 테이블에 대한 접근 권한을 부여하거나 취소하는 기능을 제공합니다.  제공된 보기 중 'revoke' 명령어는 이미 부여된 권한을 취소하는 명령어이고, 'grant' 명령어는 권한을 부여하는 명령어입니다.  'delete'와 'remove'는 데이터를 삭제하는 명령어이므로 테이블 접근 권한과는 관련이 없습니다. 따라서 사용자 X1에게 'department' 테이블에 대한 조회 권한을 부여하는 정답은 'grant select on department from X1;' 입니다.  이는 'X1에게 department 테이블에 대해 select(조회) 권한을 부여한다'는 의미를 갖습니다.  마치 도서관에서 특정 책을 열람할 수 있는 권한을 주는 것과 같은 원리입니다.",86,27
254,1,3,54,뷰(VIEW)에 대한 설명으로 틀린 것은?,,뷰 위에 또 다른 뷰를 정의할 수 있다.,"뷰에 대한 조작에서 삽입, 갱신, 삭제 연산은 제약이 따른다.",뷰의 정의는 기본 테이블과 같이 ALTER문을 이용하여 변경한다.,뷰가 정의된 기본 테이블이 제거되면 뷰도 자동적으로 제거된다.,3,"뷰(VIEW)는 기존 테이블의 데이터를 기반으로 만들어진 가상 테이블입니다.  쉽게 말해, 복잡한 SQL 질의문을 간단하게 만들어 사용할 수 있도록 미리 만들어 놓은 '단축키'와 같은 것이라고 생각하면 이해하기 쉬울 거예요.  문제에서 틀린 설명을 찾아야 하는데,  뷰는 기존 테이블의 데이터를 참조하기 때문에 기본 테이블이 삭제되면 뷰도 함께 사라지는 것은 당연합니다.  또한, 뷰 위에 다른 뷰를 만들 수도 있습니다. 마치 단축키 위에 또 다른 단축키를 만들어 사용하는 것과 같죠.  하지만 뷰는 기본 테이블의 데이터를 간접적으로 참조하기 때문에, 뷰를 통해 데이터를 삽입하거나, 수정하거나, 삭제하는 작업에는 제약이 따릅니다.  예를 들어, 뷰의 정의에 따라 특정 열에 대한 삽입이나 수정이 불가능할 수도 있습니다.  마지막으로, 뷰의 정의를 변경할 때는 ALTER문이 아닌 CREATE OR REPLACE VIEW 문을 사용합니다.  ALTER문은 기본 테이블의 구조를 변경할 때 사용하는 명령어이지, 뷰의 정의를 변경하는 데 사용하는 명령어는 아닙니다. 따라서 뷰에 대한 설명 중 틀린 것은 뷰의 정의 변경 방법에 대한 설명입니다.",65,28
255,1,3,55,데이터 모델에 표시해야 할 요소로 거리가 먼 것은?,,논리적 데이터 구조,출력 구조,연산,제약조건,2,"데이터 모델은 데이터베이스를 설계하고 구현하기 위한 청사진과 같습니다.  데이터베이스에 어떤 데이터를 저장하고, 그 데이터들이 어떻게 서로 관련되어 있는지를 정의하는 것이죠.  논리적 데이터 구조는 데이터의 종류와 관계를 정의하고, 제약조건은 데이터의 무결성을 유지하기 위한 규칙을 설정하며, 연산은 데이터를 처리하는 방법을 나타냅니다.  이러한 요소들은 데이터 모델을 구성하는 필수적인 부분입니다.  하지만 출력 구조는 데이터베이스에서 데이터를 어떻게 사용자에게 보여줄 것인가에 대한 부분으로, 데이터 모델 자체에 포함되는 내용이 아닙니다.  데이터 모델은 데이터 자체의 구조와 규칙을 정의하는 것이지, 그 데이터를 어떻게 표현하고 보여줄 것인지까지는 고려하지 않습니다.  출력 구조는 데이터베이스를 사용하는 응용 프로그램이나 보고서 설계 단계에서 고려해야 할 사항입니다. 따라서 데이터 모델에 표시해야 할 요소로 거리가 먼 것은 출력 구조입니다.",51,30
256,1,3,56,제 3정규형에서 보이스코드 정규형(BCNF)으로 정규화하기 위한 작업은?,,원자 값이 아닌 도메인을 분해,부분 함수 종속 제거,이행 함수 종속 제거,결정자가 후보키가 아닌 함수 종속 제거,4,"제3정규형은 부분 함수 종속을 제거하여 데이터 중복을 최소화하는 정규화 단계입니다.  하지만 제3정규형으로는 모든 함수 종속 문제를 해결하지 못할 수 있습니다.  보이스코드 정규형(BCNF)은 제3정규형보다 더 강력한 정규화 형태로,  **결정자가 후보키가 아닌 모든 함수 종속을 제거**합니다.  쉽게 말해,  데이터베이스의 어떤 속성(결정자)이 다른 속성(결정되는 속성)을 결정하는데, 그 결정자가 테이블의 기본키(후보키)가 아니라면 데이터 중복 및 이상 현상이 발생할 가능성이 있습니다. BCNF는 이러한 문제를 완벽하게 해결하기 위해,  결정자가 후보키가 아닌 함수 종속을 모두 제거하는 것을 목표로 합니다.  따라서 제3정규형을 BCNF로 정규화하기 위해서는 결정자가 후보키가 아닌 함수 종속을 찾아 제거하는 작업이 필요합니다.  다른 선택지는 제3정규형의 정의나 다른 정규화 단계와 관련된 내용이므로 BCNF 정규화의 핵심 목표와는 일치하지 않습니다.",81,30
257,1,3,57,"A1, A2, A3 3개 속성을 갖는 한 릴레이션에서 A1의 도메인은 3개 값, A2의 도메인은 2개 값, A3의 도메인은 4개 값을 갖는다. 이 릴레이션에 존재할 수 있는 가능한 튜플(Tuple)의 최대 수는?",,24,12,8,9,1,"이 문제는 릴레이션(관계)에 존재할 수 있는 튜플(레코드, 행)의 최대 개수를 구하는 문제입니다.  릴레이션은 속성(컬럼)들의 집합이고, 각 속성은 도메인(값의 집합)을 가집니다.  A1, A2, A3 세 개의 속성을 가진 릴레이션에서 A1은 3개의 값, A2는 2개의 값, A3는 4개의 값을 가진다고 했죠.  각 속성은 서로 독립적으로 값을 가질 수 있으므로,  A1의 값을 선택하는 방법은 3가지, A2의 값을 선택하는 방법은 2가지, A3의 값을 선택하는 방법은 4가지입니다.  따라서, 가능한 모든 튜플의 개수는 각 속성의 도메인 크기를 모두 곱하면 구할 수 있습니다.  즉, 3(A1) * 2(A2) * 4(A3) = 24가 됩니다.  이것이 릴레이션에 존재할 수 있는 최대 튜플의 수입니다.  쉽게 말해, 각 속성의 값을 조합하는 모든 경우의 수를 계산하는 것입니다. 예를 들어, A1에 1, A2에 a, A3에 X가 있다면 (1, a, X)라는 하나의 튜플이 되고, 이런 조합이 총 24가지가 가능하다는 의미입니다.",79,29
258,1,3,58,데이터베이스 설계 시 물리적 설계 단계에서 수행하는 사항이 아닌 것은?,,저장 레코드 양식 설계,레코드 집중의 분석 및 설계,접근 경로 설계,목표 DBMS에 맞는 스키마 설계,4,"데이터베이스 설계는 크게 논리적 설계와 물리적 설계로 나뉩니다. 논리적 설계는 데이터베이스의 구조를 정의하는 단계이고, 물리적 설계는 논리적 설계 결과를 실제 데이터베이스 시스템에 구현하는 단계입니다.  문제에서 묻고 있는 것은 물리적 설계 단계에서 하는 일이 아닌 것을 고르는 것입니다.  저장 레코드 양식 설계는 데이터를 어떻게 저장할지, 레코드 집중의 분석 및 설계는 데이터를 어떻게 효율적으로 배치할지, 접근 경로 설계는 데이터에 빠르게 접근하기 위한 방법을 설계하는 단계입니다. 이들은 모두 실제 데이터베이스 시스템에 데이터를 구현하는 물리적 설계에 해당합니다.  하지만 '목표 DBMS에 맞는 스키마 설계'는 데이터베이스의 논리적 구조를 특정 DBMS(데이터베이스 관리 시스템, 예: Oracle, MySQL)에 맞게 변환하는 단계입니다.  물리적 설계는 이미 논리적 설계가 완료된 후, 특정 DBMS의 특징을 고려하여 실제 구현에 필요한 세부 사항을 결정하는 단계이기 때문에,  DBMS 선택 자체는 물리적 설계 이전 단계, 즉 논리적 설계 단계 또는 그 이전 단계에서 결정되는 사항입니다. 따라서 목표 DBMS에 맞는 스키마 설계는 물리적 설계 단계에서 수행하는 작업이라고 보기 어렵습니다.  쉽게 말해, 어떤 종류의 집을 지을지(논리적 설계) 정한 후에,  어떤 재료를 사용하고 어떻게 배치할지(물리적 설계)를 결정하는 것과 같습니다.  집의 종류를 정하는 것은 물리적 설계 단계가 아니죠.",71,30
259,1,3,59,"한 릴레이션 스키마가 4개 속성, 2개 후보키 그리고 그 스키마의 대응 릴레이션 인스턴스가 7개 튜플을 갖는다면 그 릴레이션의 차수(degree)는?",,1,2,4,7,3,"이 문제는 릴레이션의 차수(degree)를 묻고 있습니다.  릴레이션이란, 간단히 말해 데이터베이스의 표라고 생각하면 됩니다.  표에는 여러 개의 열(column)과 행(row)이 있는데, 각 열은 속성(attribute)을 나타내고, 각 행은 튜플(tuple)을 나타냅니다.  문제에서 ""한 릴레이션 스키마가 4개 속성을 갖는다""는 것은 표에 4개의 열이 있다는 뜻이고, ""7개 튜플을 갖는다""는 것은 표에 7개의 행이 있다는 뜻입니다.  릴레이션의 차수(degree)는 바로 이 표의 열의 개수, 즉 속성의 개수를 의미합니다.  따라서 문제에서 주어진 정보에 따르면, 릴레이션의 차수는 4가 됩니다. 후보키의 개수나 튜플의 개수는 차수와는 무관합니다.  차수는 릴레이션의 구조(스키마)를 나타내는 것이지, 데이터의 양(튜플의 개수)을 나타내는 것이 아니기 때문입니다.",71,29
260,1,3,60,데이터웨어하우스의 기본적인 OLAP(on-line analytical processing) 연산이 아닌 것은?,,translate,roll-up,dicing,drill-down,1,"데이터 웨어하우스는 기업의 다양한 데이터를 통합하여 분석에 활용하는 시스템입니다.  OLAP(온라인 분석 처리)는 이 데이터 웨어하우스에서 데이터를 효율적으로 분석하기 위한 연산 방법들을 말합니다.  문제에서 제시된 연산들은 데이터를 다양한 관점에서 분석하는 데 사용되는 대표적인 OLAP 연산들입니다.  '롤업(Roll-up)'은 데이터를 요약하는 연산으로, 예를 들어 지역별 매출 데이터를 전국 총 매출로 요약하는 것을 말합니다. '다이싱(Dicing)'은 특정 조건에 맞는 데이터만 선택하여 분석하는 연산입니다. 예를 들어, 특정 지역, 특정 기간의 매출 데이터만 추출하는 것을 말합니다. '드릴다운(Drill-down)'은 요약된 데이터를 더 상세한 데이터로 분해하여 분석하는 연산입니다. 예를 들어, 전국 총 매출 데이터를 지역별, 상품별 매출 데이터로 분해하는 것을 말합니다.  하지만 '번역(Translate)'은 데이터 분석과 직접적인 관련이 없습니다.  데이터 분석은 데이터의 의미를 파악하고 통찰력을 얻는 것이지, 데이터 자체를 다른 언어로 바꾸는 것이 아닙니다. 따라서 데이터 웨어하우스의 OLAP 연산이 아닌 것은 '번역'입니다.",59,29
261,1,3,61,UNIX SHELL 환경 변수를 출력하는 명령어가 아닌 것은?,,configenv,printenv,env,setenv,1,"이 문제는 UNIX SHELL 환경 변수를 출력하는 명령어를 묻고 있습니다.  UNIX 계열 운영체제(리눅스, macOS 등)에서는 환경 변수라는 것이 존재하는데, 이는 프로그램이 실행될 때 필요한 정보(예: 프로그램 실행 경로, 사용자 이름 등)를 저장하는 변수입니다.  `printenv`, `env` 명령어는 현재 설정된 모든 환경 변수들을 화면에 출력하는 명령어입니다. `setenv` 명령어는 환경 변수를 설정하거나 변경하는 명령어입니다.  하지만 문제에서 제시된 나머지 하나의 명령어는 UNIX SHELL에서 환경 변수를 출력하는 명령어가 아닙니다.  따라서 정답은  UNIX SHELL 환경 변수를 출력하는 명령어가 아닌 것을 고르는 문제이므로,  `printenv`, `env` 와 같은 환경 변수 출력 명령어가 아닌 것을 선택해야 합니다.",52,44
262,1,3,62,Java 프로그래밍 언어의 정수 데이터 타입 중 'long'의 크기는?,,1byte,2byte,4byte,8byte,4,"Java에서 정수형 데이터 타입은 크기가 다양합니다.  'long' 타입은 Java에서 가장 큰 정수형 데이터 타입으로,  64비트(bit)를 사용하여 정수 값을 저장합니다.  비트는 컴퓨터가 정보를 저장하는 최소 단위인데, 1바이트(byte)는 8비트로 구성됩니다. 따라서 64비트는 8바이트가 되는 것이죠.  'long' 타입은 매우 큰 범위의 정수 값을 표현할 수 있도록 설계되었기 때문에,  8바이트의 크기를 가지는 것입니다.  예를 들어,  아주 큰 수의 인구를 저장하거나,  복잡한 계산을 수행하는 프로그램에서 'long' 타입이 유용하게 사용됩니다.  다른 정수형 타입인 'int'는 4바이트, 'short'는 2바이트, 'byte'는 1바이트를 사용합니다.  'long' 타입의 크기는 Java 언어의 기본적인 특징이며,  정보처리기사 시험에서 자주 출제되는 기본적인 내용입니다.",80,41
263,1,3,63,Java에서 사용되는 출력 함수가 아닌 것은?,,System.out.print( ),System.out.println( ),System.out.printing( ),System.out.printf( ),3,"Java에서 표준 출력 스트림인 `System.out`을 이용하여 값을 출력하는 방법에는 여러 가지가 있습니다.  `System.out.print()`는 출력하고 커서를 다음 위치로 이동시키지만 줄바꿈을 하지 않습니다.  `System.out.println()`은 출력 후 줄바꿈을 합니다.  `System.out.printf()`는 서식 문자열을 사용하여 출력 형식을 지정할 수 있습니다.  문제에서 제시된 잘못된 출력 함수는  `System.out` 객체에 존재하지 않는 메서드이기 때문에 Java에서 사용되지 않습니다.  마치 컴퓨터에 없는 프로그램을 실행하려는 것과 같습니다.  따라서 정답은 `System.out` 객체에 없는 메서드를 선택하는 것입니다.  Java의 표준 출력 함수는 `print()`, `println()`, `printf()` 세 가지가 주로 사용되며, 이 외의 함수는 Java 표준 라이브러리에 존재하지 않습니다.",87,41
264,1,3,64,운영체제에서 커널의 기능이 아닌 것은?,,"프로세스 생성, 종료",사용자 인터페이스,"기억 장치 할당, 회수",파일 시스템 관리,2,"운영체제(OS)의 커널은 컴퓨터 시스템의 핵심적인 부분으로, 하드웨어와 응용 프로그램 사이에서 중개자 역할을 합니다.  프로세스 생성 및 종료, 기억 장치(메모리) 할당 및 회수, 파일 시스템 관리 등은 모두 커널이 직접 담당하는 중요한 기능입니다.  프로세스는 실행 중인 프로그램을 의미하며, 커널은 이러한 프로세스들을 관리하고 제어합니다. 메모리는 프로그램이 실행되는 공간으로, 커널은 효율적인 메모리 사용을 위해 메모리를 할당하고 필요 없어진 메모리를 회수합니다. 파일 시스템은 하드디스크나 SSD와 같은 저장 장치에 파일을 체계적으로 저장하고 관리하는 시스템이며, 커널은 이를 관리합니다. 반면 사용자 인터페이스(UI)는 사용자가 컴퓨터와 상호 작용하는 방식, 즉 사용자가 보는 화면과 마우스나 키보드를 통해 입력하는 방식을 말합니다.  UI는 운영체제의 일부이지만, 커널 자체의 기능이라기보다는 커널 위에서 동작하는 응용 프로그램에 의해 제공되는 부분입니다.  따라서 커널의 기능이 아닌 것은 사용자 인터페이스입니다.  쉽게 말해, 커널은 컴퓨터의 내부적인 동작을 담당하고, UI는 사용자에게 보이는 겉모습을 담당하는 것이라고 생각하면 이해하기 쉬울 것입니다.",73,44
265,1,3,65,OSI 7계층에서 단말기 사이에 오류 수정과 흐름제어를 수행하여 신뢰성 있고 명확한 데이터를 전달하는 계층은?,,전송 계층,응용 계층,세션 계층,표현 계층,1,"OSI 7계층은 네트워크 통신을 7개의 계층으로 나누어 각 계층이 특정 기능을 담당하도록 설계된 모델입니다.  데이터를 주고받는 과정에서 발생할 수 있는 오류를 수정하고 데이터 흐름을 원활하게 제어하는 것은 매우 중요한데요,  이러한 역할을 담당하는 계층이 바로 전송 계층입니다.  쉽게 말해,  우리가 보내는 데이터가 상대방에게 정확하고 완벽하게 도착하도록 책임지는 계층이라고 생각하면 됩니다.  예를 들어,  A가 B에게 큰 파일을 보낸다고 가정해 봅시다.  전송 계층은 파일이 손상되지 않고,  순서대로,  전부 도착했는지 확인하고,  필요하다면 재전송을 요청하는 등의 역할을 수행합니다.  다른 계층들은 각자 다른 역할을 수행하지만,  데이터의 신뢰성 있는 전달을 보장하는 것은 전송 계층의 주요 기능입니다. 따라서 오류 수정과 흐름 제어를 통해 신뢰성 있고 명확한 데이터 전달을 담당하는 계층은 전송 계층입니다.",85,45
266,1,3,66,다음 쉘 스크립트의 의미로 옳은 것은?,https://www.cbtbank.kr/images/iz/iz20200926/iz20200926m66.gif,wow 사용자가 로그인한 경우에만 반복문을 수행한다.,wow 사용자가 로그인할 때까지 반복문을 수행한다.,wow 문자열을 복사한다.,wow 사용자에 대한 정보를 무한 반복하여 출력한다.,2,"이 쉘 스크립트는 `until` 반복문을 사용하고 있습니다.  `until` 문은 조건이 참이 될 때까지 반복하는 명령어입니다.  스크립트 내부를 살펴보면 `who | grep wow` 명령어가 있습니다. `who` 명령어는 현재 시스템에 로그인한 사용자 목록을 출력하고, `grep wow` 명령어는 그 출력 결과에서 ""wow""라는 문자열을 포함하는 줄만 찾습니다.  즉, ""wow""라는 사용자가 로그인되어 있으면 `grep wow` 명령어는 결과를 출력하고, 그렇지 않으면 아무것도 출력하지 않습니다.  `until` 문은 이 명령어의 결과가 (즉, ""wow"" 사용자가 로그인되어 있으면) 참이 될 때까지 `sleep 5` 명령어(5초간 대기)를 반복합니다.  ""wow"" 사용자가 로그인하면 `grep wow`가 결과를 출력하고, `until` 문의 조건이 참이 되어 반복문이 종료됩니다. 따라서 이 스크립트는 ""wow"" 사용자가 로그인할 때까지 5초 간격으로 계속해서 기다리는 역할을 합니다.",75,44
267,1,3,67,다음 자바 코드를 실행한 결과는?,https://www.cbtbank.kr/images/iz/iz20200926/iz20200926m67.gif,x＝7 y＝0,x＝6 y＝-1,x＝7 y＝-1,Unresolved compilation problem 오류 발생,4,"문제에서 제시된 자바 코드는 컴파일러가 이해할 수 없는 구문을 포함하고 있기 때문에 컴파일 단계에서 오류가 발생합니다.  자바 코드를 실행하기 전에 먼저 컴파일 과정을 거쳐야 하는데,  코드에 오류가 있으면 컴파일이 되지 않고 ""Unresolved compilation problem""과 같은 오류 메시지가 나타납니다.  따라서 코드의 구문 오류를 수정하지 않고 실행하려고 하면 프로그램은 실행되지 않고 컴파일 오류가 발생하는 것입니다.  문제에서 코드 자체가 제시되지 않았지만,  제공된 답변 중 ""Unresolved compilation problem 오류 발생""이라는 선택지가 이러한 상황을 정확하게 나타내고 있습니다.  이는 자바 프로그래밍의 기본적인 컴파일 과정과 오류 처리에 대한 이해를 묻는 문제입니다.  비전공자라도 자바 코드를 실행하려면 먼저 컴파일이 되어야 하고, 컴파일 과정에서 오류가 발생하면 실행되지 않는다는 점을 이해할 수 있을 것입니다.",69,41
268,1,3,68,다음 파이썬으로 구현된 프로그램의 실행 결과로 옳은 것은?,https://www.cbtbank.kr/images/iz/iz20200926/iz20200926m68.gif,"[20, 60]","[60, 20]","[0, 20, 40, 60]","[10, 30, 50, 70]",3,"파이썬 리스트에서 슬라이싱은 `리스트[시작:끝:간격]` 형태로 사용합니다.  `a[:7:2]`는 리스트 `a`의 처음부터 7번째 요소(7은 포함하지 않음)까지 2칸씩 건너뛰면서 요소를 선택하는 것을 의미합니다.  `a` 리스트는 `[0, 10, 20, 30, 40, 50, 60, 70, 80, 90]` 이므로,  처음부터 7번째 요소까지는 `[0, 10, 20, 30, 40, 50, 60]` 입니다. 여기서 2칸씩 건너뛰면서 선택하면 `0`, `20`, `40`, `60` 이 선택됩니다. 따라서 정답은 `[0, 20, 40, 60]` 입니다.  슬라이싱은 파이썬의 강력한 기능으로 리스트나 문자열 등의 시퀀스 자료형에서 특정 부분을 쉽게 추출할 수 있도록 해줍니다.  간격을 지정하지 않으면 기본적으로 1칸씩 건너뜁니다.  시작이나 끝을 생략하면 각각 리스트의 처음 또는 끝까지를 의미합니다.",73,11
269,1,3,69,공통모듈의 재사용 범위에 따른 분류가 아닌 것은?,,컴포넌트 재사용,더미코드 재사용,함수와 객체 재사용,애플리케이션 재사용,2,"이 문제는 공통 모듈의 재사용 범위를 묻고 있습니다.  소프트웨어 개발에서 공통 모듈이란 여러 프로그램에서 반복적으로 사용되는 코드 부분을 말합니다.  재사용성을 높여 개발 시간과 비용을 절감하고, 코드의 일관성을 유지하는 데 중요한 역할을 합니다.  컴포넌트, 함수, 객체, 애플리케이션 등은 모두 재사용 가능한 단위로 볼 수 있습니다.  하지만 '더미코드'는 실제 기능을 수행하지 않고 자리만 차지하는 코드로, 재사용의 목적으로 만들어지는 것이 아닙니다.  더미코드는 테스트나 개발 초기 단계에서 임시적으로 사용될 수 있지만, 다른 프로그램에서 재사용되는 것은 아닙니다. 따라서 공통 모듈의 재사용 범위에 따른 분류에 '더미코드 재사용'은 포함되지 않습니다.  다른 선택지들은 모두 실제로 재사용되는 코드 단위를 나타내고 있기 때문에 정답에서 제외됩니다.",74,6
270,1,3,70,"다음과 같은 프로세스가 차례로 큐에 도착하였을 때, SJF(Shortest Job First) 정책을 사용할 경우 가장 먼저 처리되는 작업은?",https://www.cbtbank.kr/images/iz/iz20200926/iz20200926m70.gif,P1,P2,P3,P4,4,"이 문제는 프로세스 스케줄링 알고리즘 중 하나인 SJF(Shortest Job First) 알고리즘을 이해하고 있는지 묻는 문제입니다. SJF 알고리즘은 가장 짧은 실행 시간을 가진 프로세스부터 먼저 처리하는 방식입니다.  문제에서 주어진 프로세스들의 실행 시간을 보면 P1은 6, P2는 8, P3는 4, P4는 3입니다.  가장 짧은 실행 시간을 가진 프로세스는 P4(3)이므로, SJF 알고리즘을 적용하면 P4가 가장 먼저 처리됩니다.  쉽게 말해, 가장 빨리 끝나는 작업부터 먼저 하는 방식이라고 생각하면 됩니다.  마치 줄이 짧은 계산대부터 이용하는 것과 같은 원리입니다.  따라서 가장 먼저 처리되는 작업은 실행 시간이 3인 프로세스입니다.",86,11
271,1,3,71,"4개의 페이지를 수용할 수 있는 주기억장치가 있으며, 초기에는 모두 비어 있다고 가정한다. 다음의 순서로 페이지 참조가 발생할 때, FIFO 페이지 교체 알고리즘을 사용할 경우 페이지 결함의 발생 횟수는?",https://www.cbtbank.kr/images/iz/iz20200926/iz20200926m71.gif,6회,7회,8회,9회,1,"이 문제는 주기억장치의 페이지 교체 알고리즘 중 FIFO(First-In, First-Out) 알고리즘을 이해하고 적용하는지를 묻는 문제입니다.  주기억장치에 4개의 페이지를 저장할 수 있고, 처음에는 모두 비어 있다고 가정합니다.  페이지 참조 순서대로 (1, 2, 3, 1, 2, 4, 5, 1) 페이지를 참조할 때, FIFO 알고리즘은 가장 먼저 들어온 페이지를 가장 먼저 꺼내는 방식입니다.  하나씩 따라가 보겠습니다.",69,11
272,1,3,72,"TCP 흐름제어기법 중 프레임이 손실되었을 때, 손실된 프레임 1개를 전송하고 수신자의 응답을 기다리는 방식으로 한 번에 프레임 1개만 전송할 수 있는 기법은?",,Slow Start,Sliding Window,Stop and Wait,Congestion Avoidance,3,"이 문제는 TCP 흐름 제어 기법 중에서, 데이터 손실 시 어떻게 재전송하는지 묻고 있습니다.  TCP는 신뢰성 있는 통신을 위해 데이터 전송 시 순서와 정확성을 보장하는데, 만약 데이터(프레임)가 손실되면 이를 감지하고 재전송하는 과정이 필요합니다.  정답으로 제시된 기법은 한 번에 하나의 프레임만 보내고, 그 프레임이 제대로 도착했는지 확인하는 응답을 받은 후에야 다음 프레임을 전송하는 방식입니다.  마치 편지를 부치고 답장이 올 때까지 다음 편지를 부치지 않는 것과 같습니다.  다른 기법들은 여러 개의 프레임을 동시에 보내거나, 손실된 프레임을 감지하고 재전송하는 방식이 더 복잡하고 효율적이지만, 문제에서 요구하는 ""한 번에 프레임 1개만 전송""이라는 조건을 만족하는 것은 이 기법 뿐입니다.  따라서,  손실된 프레임 하나를 보내고 응답을 기다리는 단순하고 직관적인 방식을 사용하는 기법이 정답입니다.  이는 TCP의 기본적인 흐름 제어 방식을 이해하는지를 묻는 문제입니다.",86,45
273,1,3,73,결합도(Coupling)에 대한 설명으로 틀린 것은?,,"데이터 결합도(Data Coupling)는 두 모듈이 매개변수로 자료를 전달할 때, 자료구조 형태로 전달되어 이용될 때 데이터가 결합되어 있다고 한다.",내용 결합도(Content Coupling)는 하나의 모듈이 직접적으로 다른 모듈의 내용을 참조할 때 두 모듈은 내용적으로 결합되어 있다고 한다.,공통 결합도(Common Coupling)는 두 모듈이 동일한 전역 데이터를 접근한다면 공통결합 되어 있다고 한다.,"결합도(Coupling)는 두 모듈간의 상호작용, 또는 의존도 정도를 나타내는 것이다.",1,"이 문제는 소프트웨어 모듈 간의 결합도(Coupling)에 대한 이해도를 묻는 문제입니다.  결합도는 모듈 간의 의존성 정도를 나타내는 중요한 개념으로, 결합도가 높으면 모듈 간의 상호 의존성이 높아져 유지보수 및 변경이 어려워집니다.  반대로 결합도가 낮으면 모듈 간의 독립성이 높아져 유지보수 및 변경이 용이해집니다.  문제에서 틀린 설명을 찾아야 하는데,  잘못된 설명은 모듈 간의 데이터 전달 방식에 대한 설명입니다.  데이터를 자료구조 형태로 전달하는 것은 데이터 결합도가 높은 것이 아니라, 오히려 데이터 결합도를 낮추는 방법 중 하나입니다.  자료구조를 통해 데이터를 캡슐화하고, 모듈 간에 필요한 데이터만 전달함으로써 모듈 간의 의존성을 줄일 수 있기 때문입니다. 다른 선지는 모두 모듈 간의 결합도를 정확하게 설명하고 있습니다.  따라서 자료구조 형태로 데이터를 전달하는 것이 데이터 결합도가 높다고 설명하는 것은 잘못된 것입니다.  결합도를 낮추기 위해서는 데이터를 최소한으로 전달하고, 자료구조를 활용하여 데이터를 캡슐화하는 것이 중요합니다.",56,6
274,1,3,74,"응집도의 종류 중 서로 간에 어떠한 의미 있는 연관관계도 지니지 않은 기능 요소로 구성되는 경우이며, 서로 다른 상위 모듈에 의해 호출되어 처리상의 연관성이 없는 서로 다른 기능을 수행하는 경우의 응집도는?",,Functional Cohesion,Sequential Cohesion,Logical Cohesion,Coincidental Cohesion,4,"이 문제는 소프트웨어 모듈의 응집도(Cohesion) 중 가장 낮은 수준의 응집도를 묻고 있습니다.  응집도란 모듈 내부 요소들의 관련성을 나타내는 척도로, 응집도가 높을수록 모듈은 하나의 목적에 집중하여 기능을 수행하고 유지보수가 용이해집니다. 반대로 응집도가 낮으면 모듈 내부 요소들이 서로 관련이 없어 이해하기 어렵고, 변경 시 예상치 못한 오류가 발생할 가능성이 높아집니다.",64,6
275,1,3,75,자바에서 사용하는 접근제어자의 종류가 아닌 것은?,,internal,private,default,public,1,"자바에서 접근 제어자는 클래스나 클래스 멤버(변수, 메서드)에 대한 접근 권한을 제어하는 역할을 합니다.  `public`, `private`, `default`는 자바에서 실제로 사용하는 접근 제어자입니다.  `public`은 모든 곳에서 접근 가능하고, `private`는 같은 클래스 내부에서만 접근 가능하며, `default` (접근 제어자가 명시적으로 지정되지 않은 경우)는 같은 패키지 내에서만 접근 가능합니다.  하지만 `internal`은 자바의 접근 제어자로 존재하지 않습니다.  `internal`은 C#과 같은 다른 프로그래밍 언어에서 사용되는 접근 제어자로, 같은 어셈블리 내에서만 접근을 허용하는 역할을 합니다. 따라서 자바에서 사용하는 접근 제어자의 종류가 아닌 것은 `internal`입니다.  쉽게 말해, 자바는 자기 집(패키지) 안, 또는 모든 곳(public) 또는 자기 자신만(private) 접근을 허용하는 방식으로 접근 제어를 하지만,  `internal`은 자바의 접근 제어 방식과는 다릅니다.",74,7
276,1,3,76,UDP 특성에 해당되는 것은?,,"데이터 전송 후, ACK를 받는다.",송신 중에 링크를 유지 관리하므로 신뢰성이 높다.,흐름제어나 순서제어가 없어 전송속도가 빠르다.,제어를 위한 오버헤드가 크다.,3,"UDP(User Datagram Protocol)는 TCP와 달리 연결을 설정하지 않고 데이터를 패킷 단위로 전송하는 비연결형 프로토콜입니다.  TCP는 데이터 전송 전에 송수신 측 간의 연결을 확립하고, 데이터 전송 후에 정상적으로 도착했는지 확인하는 ACK(Acknowledgement)를 주고받는 신뢰성 있는 프로토콜입니다.  반면 UDP는 ACK를 사용하지 않고, 흐름 제어나 순서 제어도 하지 않습니다.  따라서 TCP보다 오버헤드가 적고 전송 속도가 빠르다는 장점이 있습니다.  하지만 데이터 전달의 신뢰성은 떨어집니다.  문제에서 제시된 정답은 UDP의 이러한 특성, 즉 흐름 제어나 순서 제어가 없어 전송 속도가 빠르다는 점을 정확하게 나타내고 있습니다.  데이터 전송의 신뢰성을 보장하지 않기 때문에 ACK를 받지 않고, 연결을 유지 관리하지 않아 신뢰성이 높다고 할 수 없습니다.  오버헤드는 TCP에 비해 작습니다. 따라서 UDP의 특성을 가장 잘 나타내는 것은 전송 속도가 빠르다는 것입니다.",74,45
277,1,3,77,"다음과 같은 세그먼트 테이블을 가지는 시스템에서 논리 주소(2, 176)에 대한 물리 주소는?",https://www.cbtbank.kr/images/iz/iz20200926/iz20200926m77.gif,398,400,1928,1930,1,"이 문제는 논리 주소를 물리 주소로 변환하는 과정을 묻고 있습니다.  세그먼트 테이블을 보면 각 세그먼트의 시작 주소와 길이가 나와 있습니다. 문제에서 주어진 논리 주소는 (세그먼트 번호, 논리 주소 내의 오프셋) 형태인 (2, 176)입니다.  이는 2번 세그먼트의 176번째 바이트를 의미합니다.",71,29
278,1,3,78,TCP/IP에서 사용되는 논리주소를 물리주소로 변환시켜 주는 프로토콜은?,,TCP,ARP,FTP,IP,2,"이 문제는 네트워크 통신에서 논리 주소와 물리 주소의 변환 과정을 묻고 있습니다.  컴퓨터는 서로 통신할 때 두 가지 종류의 주소를 사용합니다.  우리가 일반적으로 알고 있는 IP 주소(예: 192.168.1.1)는 논리 주소입니다.  이는 사람이 이해하기 쉽도록 만들어진 주소로, 네트워크 상에서 컴퓨터를 식별하는 데 사용됩니다.  반면에 물리 주소(MAC 주소)는 네트워크 인터페이스 카드(NIC)에 고유하게 할당된 실제 하드웨어 주소입니다.  컴퓨터가 데이터를 보낼 때, 목적지 컴퓨터의 IP 주소를 알고 있더라도, 실제로 데이터를 전송하려면 목적지 컴퓨터의 물리 주소인 MAC 주소가 필요합니다.  이때, IP 주소를 MAC 주소로 변환해주는 역할을 하는 프로토콜이 바로 ARP(Address Resolution Protocol)입니다.  쉽게 말해, ARP는 IP 주소를 가지고 네트워크 상에서 해당 IP 주소를 가진 컴퓨터의 MAC 주소를 찾아주는 '주소록'과 같은 역할을 합니다.  따라서, TCP/IP 환경에서 논리 주소(IP 주소)를 물리 주소(MAC 주소)로 변환하는 프로토콜은 ARP입니다.  TCP, FTP, IP는 모두 네트워크 통신에 사용되는 프로토콜이지만, 주소 변환 기능은 제공하지 않습니다.",76,45
279,1,3,79,C언어에서 구조체를 사용하여 데이터를 처리할 때 사용하는 것은?,,for,scanf,struct,abstract,3,"C언어에서 여러 개의 데이터를 묶어서 하나의 단위로 관리하고 싶을 때 사용하는 것이 바로 구조체(struct)입니다.  예를 들어, 학생의 이름, 학번, 성적 등 여러 가지 정보를 저장해야 한다고 가정해 봅시다.  각 정보를 따로따로 변수로 선언하면 관리가 어렵고 코드도 복잡해집니다.  하지만 구조체를 사용하면 이러한 여러 데이터들을 하나의 틀(구조체)에 담아서 관리할 수 있습니다.  마치 서류철에 여러 장의 서류를 넣어서 보관하는 것과 같습니다.  따라서 학생의 정보를 효율적으로 관리하기 위해서는 구조체를 사용하는 것이 가장 적절합니다.  다른 선택지들은 데이터를 묶어서 관리하는 데 직접적으로 사용되지 않습니다.  `for`문은 반복문이고, `scanf`는 입력 함수이며, `abstract`는 추상적인 개념입니다.  구조체는 C언어에서 데이터를 효율적으로 관리하기 위한 중요한 도구입니다.",83,11
280,1,3,80,PHP에서 사용 가능한 연산자가 아닌 것은?,,@,#,＜＞,===,2,"PHP는 웹 서버 측에서 동작하는 스크립트 언어입니다.  문제에서 제시된 연산자들은 PHP에서 데이터를 처리하거나 비교하는 데 사용되는 기호들입니다.  `@`는 오류 억제 연산자로,  명령어 실행 시 발생할 수 있는 오류 메시지를 무시하는 역할을 합니다. `< >`는 크기 비교 연산자로, 왼쪽 피연산자가 오른쪽 피연산자보다 작은지 큰지 비교합니다. `===`는 일치 연산자로, 값과 자료형까지 완전히 일치하는지 비교합니다.  하지만 `#` 기호는 PHP에서 연산자로 사용되지 않습니다.  `#` 기호는 PHP에서 주석을 나타내는 데 사용됩니다.  즉, `#` 뒤에 오는 내용은 PHP 인터프리터에 의해 무시됩니다. 따라서 PHP에서 연산자로 사용할 수 없는 것은 `#`입니다.  다른 선택지들은 모두 PHP에서 유효한 연산자입니다.",58,41
281,1,3,81,이용자가 인터넷과 같은 공중망에 사설망을 구축하여 마치 전용망을 사용하는 효과를 가지는 보안 솔루션은?,,ZIGBEE,KDD,IDS,VPN,4,"이 문제는 공중망(인터넷)을 통해 사설망과 같은 보안성을 확보하는 기술을 묻고 있습니다.  VPN(Virtual Private Network, 가상 사설망)은 공중망을 통해 두 지점 또는 여러 지점을 안전하게 연결하는 기술입니다.  마치 전용선을 사용하는 것처럼 데이터를 암호화하여 전송하기 때문에, 인터넷과 같은 공용 네트워크를 사용하더라도 개인 정보나 기업의 중요한 데이터를 안전하게 보호할 수 있습니다.  다른 선택지들은 네트워크 보안과 직접적인 관련이 없거나, VPN처럼 공중망을 통해 사설망 효과를 제공하는 기술이 아닙니다.  예를 들어, ZIGBEE는 근거리 무선 통신 기술이고, KDD는 데이터 마이닝 기법, IDS는 침입 탐지 시스템으로, 각각 다른 목적으로 사용됩니다. 따라서 공중망을 통해 사설망과 같은 효과를 제공하는 보안 솔루션은 VPN이 가장 적합합니다.",84,56
282,1,3,82,CMM(Capability Maturity Model) 모델의 레벨로 옳지 않은 것은?,,최적단계,관리단계,계획단계,정의단계,3,"CMM(Capability Maturity Model)은 소프트웨어 개발 조직의 성숙도를 5단계로 평가하는 모델입니다.  각 단계는 소프트웨어 개발 프로세스의 안정성과 예측 가능성을 나타내는 지표로,  낮은 단계일수록 프로세스가 불안정하고 예측이 어렵고, 높은 단계일수록 프로세스가 안정적이고 예측 가능합니다.  CMM의 5단계는 초기, 관리, 정의, 관리, 최적화 단계로 구성됩니다. 문제에서 제시된 선지 중 하나는 실제 CMM 모델의 단계에 해당하지 않습니다.  CMM 모델은 소프트웨어 개발 프로세스의 성숙도를 체계적으로 평가하고 개선하기 위한 프레임워크로, 각 단계는 명확하게 정의된 특징과 목표를 가지고 있습니다. 따라서 제시된 선지 중 CMM 모델의 레벨로 옳지 않은 것은  CMM 모델의 5단계에 포함되지 않은 단계입니다.  이는 소프트웨어 개발 프로세스의 성숙도를 이해하고,  개선 방향을 설정하는 데 중요한 개념입니다.  따라서 정답은 CMM 모델의 단계에 포함되지 않는 선지를 선택해야 합니다.",54,47
283,1,3,83,다음 설명에 해당하는 생명주기 모형으로 가장 옳은 것은?,https://www.cbtbank.kr/images/iz/iz20200926/iz20200926m83.gif,패키지 모형,코코모 모형,폭포수 모형,관계형 모델,3,"문제에서 설명하는 생명주기 모형은 가장 오래된 형태이며, 각 단계가 순차적으로 진행되고 이전 단계가 완료되어야만 다음 단계로 넘어갈 수 있다는 특징을 가지고 있습니다.  이는 마치 폭포가 위에서 아래로 떨어지는 것과 같아서, 한 단계씩 차례대로 진행되는 모습을 보여줍니다. 요구사항 변경이 어렵다는 점 또한 폭포수 모형의 단점으로 잘 알려져 있습니다.  처음 설계 단계에서 모든 요구사항을 명확히 정의해야 하며,  단계 간의 피드백이 제한적이기 때문에 중간에 요구사항 변경이 발생하면 전체 프로젝트에 큰 영향을 미칠 수 있습니다.  반면에 다른 선택지들은 이러한 순차적인 특징을 명확하게 보여주지 않거나,  소프트웨어 개발 생명주기 모델과 직접적인 관련이 없습니다. 따라서 문제의 설명에 가장 적합한 생명주기 모형은 폭포수 모형입니다.  폭포수 모형은 전통적인 소프트웨어 개발 방식으로,  단계별 산출물 검토를 통해 오류를 조기에 발견하고 수정하는 데 초점을 맞추는 방식입니다.",90,47
284,1,3,84,서비스 지향 아키텍처 기반 애플리케이션을 구성하는 층이 아닌 것은?,,표현층,프로세스층,제어 클래스층,비즈니스층,3,"서비스 지향 아키텍처(SOA)는 여러 개의 독립적인 서비스들을 조합하여 애플리케이션을 구성하는 아키텍처 스타일입니다.  마치 레고 블록처럼 각각의 기능을 담당하는 서비스들을 연결하여 복잡한 애플리케이션을 만들 수 있죠.  일반적으로 SOA 기반 애플리케이션은 크게 세 가지 층으로 구성됩니다.  먼저 사용자 인터페이스를 담당하는 **표현층**이 있습니다.  여기서는 사용자가 애플리케이션과 상호작용하는 부분, 즉 화면이나 웹페이지 등을 통해 데이터를 입력하고 결과를 확인하는 역할을 합니다.  다음으로 **비즈니스층**은 애플리케이션의 핵심적인 비즈니스 로직을 처리하는 부분입니다.  실제 데이터 처리, 계산, 비즈니스 규칙 적용 등의 작업이 이 층에서 이루어집니다.  마지막으로 **프로세스층**은 비즈니스 로직을 실행하기 위한 다양한 서비스들을 조정하고 관리하는 역할을 합니다.  서비스 간의 통신, 트랜잭션 관리, 오류 처리 등을 담당하여 비즈니스층이 원활하게 동작하도록 지원합니다.  문제에서 제시된 잘못된 층인 ""제어 클래스층""은 SOA의 표준적인 층 구조에는 포함되지 않습니다.  SOA는 서비스의 재사용성과 유연성을 높이기 위해 각 층이 명확하게 분리되어 있고,  ""제어 클래스층""과 같은 개념은 각 층 내부의 구현 방식에 따라 다르게 나타날 수 있기 때문에 SOA의 일반적인 층으로 보기 어렵습니다. 따라서 SOA 기반 애플리케이션을 구성하는 층이 아닌 것은 ""제어 클래스층""입니다.",48,6
285,1,3,85,다음 내용이 설명하는 스토리지 시스템은?,https://www.cbtbank.kr/images/iz/iz20200926/iz20200926m85.gif,DAS,NAS,N-SCREEN,NFC,1,"문제에서 설명하는 스토리지 시스템은 하드디스크와 같은 저장장치가 호스트 버스 어댑터(HBA)에 직접 연결되는 방식입니다.  네트워크 장비를 거치지 않고 직접 연결되는 것이 핵심입니다.  이러한 특징은 직접 연결 스토리지(Direct Attached Storage, DAS)의 정의와 정확히 일치합니다.  NAS(Network Attached Storage)는 네트워크를 통해 접근하는 저장장치이고, N-SCREEN과 NFC는 저장장치와는 전혀 관련이 없는 기술입니다. 따라서 문제의 설명에 가장 부합하는 것은 DAS입니다.  쉽게 생각하면, 컴퓨터 본체에 직접 연결된 하드디스크가 바로 DAS라고 이해하시면 됩니다.  네트워크를 거치지 않고, 바로 연결되어 속도가 빠르다는 장점이 있지만, 확장성이 떨어지는 단점도 가지고 있습니다.",75,51
286,1,3,86,소프트웨어 개발 프레임워크의 적용 효과로 볼 수 없는 것은?,,공통 컴포넌트 재사용으로 중복 예산 절감,기술종속으로 인한 선행사업자 의존도 증대,표준화된 연계모듈 활용으로 상호 운용성 향상,개발표준에 의한 모듈화로 유지보수 용이,2,"소프트웨어 개발 프레임워크는 마치 레고 블록과 같습니다.  미리 만들어진 블록(컴포넌트)들을 조립하여 소프트웨어를 개발하는 방식이죠.  이렇게 하면 중복되는 작업을 줄이고, 개발 시간과 비용을 절감할 수 있습니다. 또한, 표준화된 블록을 사용하기 때문에 서로 다른 부분들이 잘 맞물려 돌아가는 상호 운용성이 높아지고,  만들어진 소프트웨어를 유지보수하기도 쉬워집니다.  하지만, 특정 프레임워크에 의존하게 되면 그 프레임워크를 제공하는 업체에 종속될 위험이 있습니다.  마치 특정 레고 블록만 사용해야 하는 상황과 같아서, 다른 블록을 사용할 수 없게 되는 것이죠.  따라서 프레임워크를 사용하면 여러 가지 장점이 있지만, 특정 기술에 종속되어 다른 업체에 의존하게 되는 단점도 발생할 수 있습니다. 문제에서 묻고 있는 것은 프레임워크 적용의 *단점*이므로, 특정 기술에 종속되어 선행 사업자에 대한 의존도가 높아지는 것이 정답입니다.",86,48
287,1,3,87,SoftTech사에서 개발된 것으로 구조적 요구 분석을 하기 위해 블록 다이어그램을 채택한 자동화 도구는?,,SREM,PSL/PSA,HIPO,SADT,4,"이 문제는 구조적 요구 분석을 위한 자동화 도구 중 SoftTech사에서 개발된 것을 묻고 있습니다.  소프트웨어 개발 과정에서 요구사항 분석은 매우 중요한 단계인데요,  복잡한 시스템의 요구사항을 효율적으로 파악하고 문서화하기 위해 다양한 기법과 도구들이 사용됩니다.  그 중에서도 구조적 분석 기법은 시스템을 계층적으로 분해하여 이해하기 쉽게 표현하는 방법입니다.  여러 구조적 분석 기법 중 블록 다이어그램을 사용하는 대표적인 자동화 도구가 바로 SADT(Structured Analysis and Design Technique)입니다. SADT는 시스템을 여러 개의 블록으로 나누고, 각 블록의 기능과 상호 관계를 명확하게 보여주는 블록 다이어그램을 사용하여 시스템의 구조를 시각적으로 표현합니다.  따라서 SoftTech사에서 개발된 구조적 요구 분석을 위한 자동화 도구로 블록 다이어그램을 채택한 것은 SADT가 가장 적합합니다. 다른 선택지들은 각각 다른 분석 기법이나 도구를 나타내므로 정답이 될 수 없습니다.  쉽게 말해,  레고 블록을 조립하듯이 시스템을 블록 단위로 나누어 분석하는 도구가 SADT인 것이죠.",55,3
288,1,3,88,익스트림 프로그래밍 (eXtreme Programming)의 5가지 가치에 속하지 않는 것은?,,의사소통,단순성,피드백,고객 배제,4,"익스트림 프로그래밍(XP)은 소프트웨어 개발 방법론 중 하나로, 고객과의 긴밀한 협력과 지속적인 피드백을 통해 빠르고 유연하게 소프트웨어를 개발하는 것을 목표로 합니다.  XP의 핵심 가치는 '의사소통', '단순성', '피드백', '용기', '존중'입니다.  문제에서 제시된 보기 중 '고객 배제'는 XP의 철학과 정반대되는 개념입니다. XP는 고객의 참여를 매우 중요하게 생각하며, 고객과의 지속적인 소통을 통해 요구사항을 명확히 하고, 개발 과정에서 발생하는 문제를 신속하게 해결하는 것을 강조합니다. 고객이 배제된다면, 개발 과정에서 발생하는 오류나 요구사항의 불일치를 빠르게 파악하고 수정할 수 없어 개발의 효율성이 떨어지고, 최종 결과물에 대한 고객 만족도 또한 낮아질 수밖에 없습니다. 따라서 XP의 5가지 가치에 '고객 배제'는 포함되지 않습니다.",90,2
289,1,3,89,다음은 정보의 접근통제 정책에 대한 설명이다. (ㄱ)에 들어갈 내용으로 옳은 것은?,https://www.cbtbank.kr/images/iz/iz20200926/iz20200926m89.gif,NAC,MAC,SDAC,AAC,2,"이 문제는 정보의 접근 통제 정책 중 하나인 MAC(Mandatory Access Control, 강제 접근 제어)에 대한 이해를 묻고 있습니다.  표에서 (ㄱ)에 해당하는 내용은 권한 부여를 시스템이 담당하고, 접근 결정은 보안 등급(Label)에 따라 이루어지며, 정책 변경이 고정적이라는 특징을 보입니다.  이는 바로 MAC의 특징과 일치합니다.  MAC은 시스템 관리자가 미리 정의한 보안 등급에 따라 접근 권한을 부여하고, 사용자의 신분이나 데이터 소유권과는 무관하게 보안 등급에 따라 접근을 허용 또는 거부합니다.  따라서 데이터 소유자가 접근 권한을 결정하는 DAC(Discretionary Access Control, 임의 접근 제어)나 역할에 따라 접근 권한을 부여하는 RBAC(Role-Based Access Control, 역할 기반 접근 제어)와는 다릅니다.  MAC은 중앙 집중적인 관리로 인해 안정적이지만, 정책 변경이 어렵다는 단점도 가지고 있습니다.  표에 제시된 내용은 이러한 MAC의 특징을 명확하게 보여주고 있으므로, 정답은 MAC입니다.  NAC, SDAC, AAC는 접근 제어 방식과 관련된 용어이지만, 표의 내용과는 일치하지 않습니다.",69,55
290,1,3,90,소프트웨어 개발 모델 중 나선형 모델의 4가지 주요 활동이 순서대로 나열된 것은?,https://www.cbtbank.kr/images/iz/iz20200926/iz20200926m90.gif,?-?-?-?순으로 반복,?-?-?-?순으로 반복,?-?-?-?순으로 반복,?-?-?-?순으로 반복,2,"나선형 모델은 소프트웨어 개발의 위험을 줄이고, 고객의 요구사항 변화에 유연하게 대처하기 위해 고안된 모델입니다.  반복적인 개발 과정을 통해 점진적으로 소프트웨어를 완성해 나가는 것이 특징인데요,  각 반복 주기마다 계획 수립, 위험 분석, 개발 및 검증, 고객 평가의 네 가지 주요 활동을 수행합니다.  먼저,  **계획 수립** 단계에서는 개발 목표, 범위, 일정, 예산 등을 정의합니다. 다음으로 **위험 분석** 단계에서는 개발 과정에서 발생할 수 있는 위험 요소들을 파악하고, 그에 대한 대응 방안을 마련합니다.  이후 **개발 및 검증** 단계에서는 실제 소프트웨어를 개발하고, 테스트를 통해 문제점을 찾아 수정합니다. 마지막으로 **고객 평가** 단계에서는 개발된 소프트웨어를 고객에게 보여주고 피드백을 받아 다음 반복 주기의 계획에 반영합니다.  이러한 네 가지 활동은 순차적으로 진행되며,  각 주기가 끝날 때마다 고객의 요구사항 변화나 발견된 위험에 따라 계획을 수정하고 다음 주기를 시작하게 됩니다. 따라서 정답은 계획 수립, 위험 분석, 개발 및 검증, 고객 평가 순서로 반복되는 것입니다.  이 순서는 소프트웨어 개발의 불확실성을 줄이고, 고객 만족도를 높이는 데 효과적입니다.",82,47
291,1,3,91,소프트웨어 비용 추정모형(estimation models)이 아닌 것은?,,COCOMO,Putnam,Function-Point,PERT,4,"이 문제는 소프트웨어 개발 비용을 추정하는 다양한 모델 중에서,  프로젝트 일정 관리에 주로 사용되는 모델을 제외하고 소프트웨어 개발 비용을 추정하는 모델을 묻고 있습니다.  COCOMO, Putnam, Function-Point 모델은 모두 소프트웨어 개발에 필요한 시간과 자원을 예측하는 데 사용되는 대표적인 비용 추정 모델입니다.  COCOMO는 코드의 크기와 개발자의 경험 등을 고려하여 비용을 추정하고, Putnam은 개발 기간과 인력 규모를 기반으로 추정하며, Function-Point는 소프트웨어의 기능 점수를 기준으로 비용을 추정합니다. 반면 PERT(Program Evaluation and Review Technique)는 프로젝트의 일정을 계획하고 관리하는 데 사용되는 기법으로,  작업의 지속 시간과 의존 관계를 고려하여 프로젝트 완료 시점과 비용을 추정하는 데 사용되지만, 소프트웨어 비용 자체를 직접적으로 추정하는 모델은 아닙니다. 따라서 소프트웨어 비용 추정 모델이 아닌 것은 PERT입니다.  PERT는 프로젝트 일정 관리에 초점을 맞춘 기법이지, 소프트웨어 개발 비용을 직접적으로 산정하는 모델은 아니기 때문입니다.",68,47
292,1,3,92,공개키 암호화 방식에 대한 설명으로 틀린 것은?,,공개키로 암호화된 메시지는 반드시 공개키로 복호화 해야 한다.,비대칭 암호기법이라고도 한다.,대표적인 기법은 RSA 기법이 있다.,"키 분배가 용이하고, 관리해야 할 키 개수가 적다.",1,"공개키 암호화 방식은 두 개의 키, 즉 공개키와 개인키를 사용하는 암호화 방식입니다.  공개키는 누구에게나 공개해도 되지만, 개인키는 자신만 알고 있어야 합니다.  메시지를 암호화할 때는 상대방의 공개키를 사용하고, 복호화할 때는 자신의 개인키를 사용합니다.  따라서 공개키로 암호화된 메시지는 반드시 개인키로 복호화해야 합니다. 문제에서 틀린 설명은 공개키로 암호화된 메시지를 공개키로 복호화해야 한다고 주장하는 부분입니다.  이는 공개키 암호화 방식의 원리에 어긋나는 설명입니다.  나머지 설명들은 공개키 암호화 방식의 특징을 잘 나타내고 있습니다. 비대칭 암호화 기법이라는 점, RSA가 대표적인 예시라는 점, 그리고 키 분배가 용이하고 관리해야 할 키 개수가 적다는 점은 모두 공개키 암호화 방식의 장점입니다.  쉽게 말해, 자물쇠(공개키)는 누구나 가지고 있지만, 열쇠(개인키)는 나만 가지고 있어서, 자물쇠로 잠근 편지를 나만 열 수 있는 것과 같습니다.",67,54
293,1,3,93,다음이 설명하는 다중화 기술은?,https://www.cbtbank.kr/images/iz/iz20200926/iz20200926m93.gif,Wavelength Division Multiplexing,Frequency Division Multiplexing,Code Division Multiplexing,Time Division Multiplexing,1,"문제에서 설명하는 다중화 기술은 광섬유를 이용하여 파장이 다른 여러 개의 광신호를 동시에 전송하는 기술입니다.  마치 여러 차선의 도로를 동시에 사용하여 많은 차량을 효율적으로 이동시키는 것과 같습니다.  각 광신호는 서로 다른 파장을 가지고 있기 때문에, 서로 간섭 없이 독립적으로 전송될 수 있습니다.  이러한 특징은 빛의 파장이 서로 다르면 서로 간섭하지 않는다는 물리적 성질을 이용한 것입니다.  따라서 문제에서 제시된 설명과 가장 잘 맞는 다중화 기술은 파장 분할 다중화(Wavelength Division Multiplexing, WDM)입니다.  다른 다중화 기술들은 시간이나 주파수, 코드를 이용하여 신호를 구분하지만, 이 문제에서는 파장을 이용하는 것이 핵심입니다.  따라서 광섬유 통신에서 여러 개의 광신호를 동시에 전송하는 기술인 파장 분할 다중화가 정답입니다.",82,49
294,1,3,94,"웹페이지에 악의적인 스크립트를 포함시켜 사용자 측에서 실행되게 유도함으로써, 정보유출 등의 공격을 유발할 수 있는 취약점은?",,Ransomware,Pharming,Phishing,XSS,4,"웹페이지에 악의적인 스크립트를 삽입하여 사용자의 브라우저에서 실행시키는 공격 방식을 설명하는 문제입니다.  사용자가 악성코드가 포함된 웹페이지를 방문하면,  그 페이지에 숨겨진 악성 스크립트가 사용자의 브라우저에서 실행됩니다. 이 스크립트는 사용자의 개인정보를 훔치거나,  컴퓨터 시스템을 손상시키거나,  다른 악성 행위를 수행할 수 있습니다.  예를 들어, 사용자의 쿠키 정보를 빼내어 개인 계정에 접근하거나,  사용자의 컴퓨터에 악성 프로그램을 설치할 수 있습니다. 이러한 공격은 사용자가 웹페이지의 내용을 직접적으로 조작하지 않더라도,  단순히 웹페이지를 방문하는 것만으로도 발생할 수 있다는 점에서 매우 위험합니다.  따라서 웹페이지에 대한 보안 강화 및 악성 스크립트 차단 기술이 중요합니다.  정답은 사용자 측에서 실행되는 악성 스크립트를 통해 정보 유출 등의 공격을 유발하는 취약점을 정확하게 나타내는 용어입니다.",60,56
295,1,3,95,CBD(Component Based Development) 에 대한 설명으로 틀린 것은?,,개발 기간 단축으로 인한 생산성 향상,새로운 기능 추가가 쉬운 확장성,소프트웨어 재사용이 가능,1960년대까지 가장 많이 적용되었던 소프트웨어 개발 방법,4,"CBD(Component Based Development)는 말 그대로 구성요소(Component) 기반으로 소프트웨어를 개발하는 방법입니다.  미리 만들어 놓은 여러 개의 소프트웨어 부품(Component)들을 조립하듯이 엮어서 새로운 소프트웨어를 만드는 것이죠.  레고 블록을 조립해서 다양한 모형을 만드는 것과 비슷하다고 생각하면 이해하기 쉬울 것입니다.  따라서 개발 시간을 단축하고 생산성을 높일 수 있으며, 필요에 따라 새로운 기능을 추가하거나 변경하기도 용이합니다.  또한, 이미 만들어진 부품들을 재사용할 수 있으므로 개발 비용도 절감할 수 있습니다.  하지만 문제에서 틀렸다고 하는 내용은 CBD가 1960년대에 가장 많이 사용된 방법이라는 것입니다. CBD는 상대적으로 최근에 등장하고 활용도가 높아진 소프트웨어 개발 방법론입니다. 1960년대에는 주로 절차적 프로그래밍 방식이 주류였습니다. 따라서  CBD에 대한 설명 중 틀린 것은 1960년대에 가장 많이 적용되었다는 부분입니다.",83,6
296,1,3,96,소프트웨어 정의 데이터센터(SDDC : Software Defined Data Center)에 대한 설명으로 틀린 것은?,,"컴퓨팅, 네트워킹, 스토리지, 관리 등을 모두 소프트웨어로 정의한다.",인력 개입 없이 소프트웨어 조작만으로 자동 제어 관리한다.,데이터센터 내 모든 자원을 가상화하여 서비스한다.,특정 하드웨어 에 종속되어 특화된 업무를 서비스하기에 적합하다.,4,"소프트웨어 정의 데이터센터(SDDC)는 데이터센터의 컴퓨팅, 네트워킹, 스토리지, 관리 등의 모든 요소를 소프트웨어로 제어하고 관리하는 방식입니다.  이는 하드웨어에 대한 의존성을 줄이고, 자원을 효율적으로 관리하며, 자동화된 운영을 가능하게 합니다.  따라서 데이터센터의 모든 자원을 가상화하여 서비스하고, 인력 개입 없이 소프트웨어 조작만으로 자동 제어 및 관리하는 것이 SDDC의 핵심적인 특징입니다.  하지만 문제에서 틀린 설명으로 제시된 부분은 특정 하드웨어에 종속되어 특화된 업무를 서비스하는 데 적합하다는 것입니다.  SDDC의 목표는 오히려 하드웨어 종속성을 최소화하고, 다양한 애플리케이션과 서비스를 유연하게 지원하는 데 있습니다.  하드웨어에 종속되지 않고 소프트웨어적으로 유연하게 자원을 관리하는 것이 SDDC의 가장 큰 장점이기 때문입니다.  즉, 특정 하드웨어에 종속되는 것은 SDDC의 개념과 정반대되는 특징입니다.",64,51
297,1,3,97,컴퓨터 운영체제의 커널에 보안 기능을 추가한 것으로 운영체제의 보안상 결함으로 인하여 발생 가능한 각종 해킹으로부터 시스템을 보호하기 위하여 사용되는 것은?,,GPIB,CentOS,XSS,Secure OS,4,"컴퓨터 운영체제는 컴퓨터의 모든 하드웨어와 소프트웨어를 관리하는 중추적인 역할을 합니다.  마치 도시의 시장과 같은 존재죠.  그런데 이 운영체제에도 보안상의 허점이 있을 수 있습니다.  마치 도시에 치안의 허점이 있는 것과 같습니다.  해커들은 이러한 허점을 이용하여 시스템에 침입하고 악성코드를 심거나 중요한 정보를 훔칠 수 있습니다.  문제에서 언급하는 것은 바로 이러한 해킹으로부터 시스템을 보호하기 위해 운영체제의 핵심인 커널(도시의 중심부라고 생각하면 됩니다)에 보안 기능을 추가한 운영체제입니다.  이렇게 보안 기능이 강화된 운영체제는  ""보안 운영체제(Secure OS)""라고 부릅니다.  다른 선택지는 특정 통신규약, 리눅스 배포판, 웹 공격 기법 등으로 운영체제의 보안 강화와는 직접적인 관련이 없습니다. 따라서 운영체제의 보안 결함으로 인한 해킹으로부터 시스템을 보호하기 위해 사용되는 것은 보안 운영체제(Secure OS)입니다.",84,51
298,1,3,98,NS(Nassi-Schneiderman) chart에 대한 설명으로 거리가 먼 것은?,,논리의 기술에 중점을 둔 도형식 표현 방법이다.,"연속, 선택 및 다중 선택, 반복 등의 제어논리 구조로 표현한다.",주로 화살표를 사용하여 논리적인 제어구조로 흐름을 표현한다.,조건이 복합되어 있는 곳의 처리를 시각적으로 명확히 식별하는데 적합하다.,3,"NS 차트는 프로그램의 논리 흐름을 도형으로 표현하는 방법입니다.  쉽게 말해, 복잡한 프로그램의 동작 과정을 그림으로 나타내어 이해하기 쉽게 만드는 것이죠.  각각의 도형은 순차 처리, 조건 분기, 반복 등의 제어 구조를 나타내고, 이 도형들을 연결하여 전체 프로그램의 흐름을 보여줍니다.  따라서 논리의 기술에 중점을 두고, 연속, 선택, 반복 등의 제어 논리 구조를 도형으로 표현하는 것은 NS 차트의 핵심적인 특징입니다.  조건이 복잡한 부분도 그림으로 명확하게 표현하여 이해도를 높일 수 있습니다. 하지만 NS 차트는 주로 도형과 연결선을 사용하여 흐름을 나타내지, 화살표만을 사용하지는 않습니다.  화살표는 보조적으로 사용될 수는 있지만,  NS 차트의 핵심적인 표현 요소는 아니기 때문에 문제의 설명으로 거리가 먼 것입니다.  즉,  NS 차트는 도형을 중심으로 논리 흐름을 표현하는 것이지, 화살표를 주로 사용하는 방식이 아니라는 점이 핵심입니다.",64,3
299,1,3,99,다음 내용에 적합한 용어는?,https://www.cbtbank.kr/images/iz/iz20200926/iz20200926m99.gif,MapReduce,SQL,Hijacking,Logs,1,"문제에서 제시된 설명을 보면, ""대용량 데이터를 분산 처리하기 위한 목적으로 개발된 프로그래밍 모델""이라고 명시되어 있습니다.  그리고 ""Google에 의해 고안된 기술""이며 ""임의의 순서로 정렬된 데이터를 분산 처리하고 이를 다시 합치는 과정""을 거친다고 설명하고 있죠. 이러한 특징들은 바로 MapReduce의 핵심 개념을 정확하게 나타냅니다.",74,31
300,1,3,100,소프트웨어 프로세스에 대한 개선 및 능력 측정 기준에 대한 국제 표준은?,,ISO 14001,IEEE 802.5,IEEE 488,SPICE,4,"소프트웨어 프로세스의 개선 및 능력 측정 기준에 대한 국제 표준을 묻는 문제입니다.  소프트웨어 개발 과정을 효율적으로 관리하고, 개발 능력을 객관적으로 평가하기 위한 표준이 필요한데,  SPICE(Software Process Improvement and Capability dEtermination)는 바로 이러한 목적으로 만들어진 국제 표준입니다.  SPICE는 소프트웨어 개발 조직의 프로세스 성숙도를 평가하고 개선하는 데 사용되는 프레임워크로,  개발 프로세스의 다양한 측면을 평가하여 조직의 소프트웨어 개발 능력을 향상시키는 데 도움을 줍니다.  다른 선지들은 소프트웨어 개발과 직접적인 관련이 없거나, 네트워크 또는 계측 장비 관련 표준이기 때문에 정답이 될 수 없습니다.  따라서 소프트웨어 프로세스 개선과 능력 측정에 초점을 맞춘 국제 표준인 SPICE가 정답입니다.",73,47
301,1,4,1,"운영체제 분석을 위해 리눅스에서 버전을 확인하고자 할 때 사용되는 명령어는?(문제 오류로 가답안 발표시 4번으로 발표되었지만 확정답안 발표시 2, 4번이 정답처리 되었습니다. 여기서는 가답안인 4번을 누르시면 정답 처리 됩니다.)",,ls,cat,pwd,uname,4,"리눅스 운영체제의 버전을 확인하는 명령어를 묻는 문제입니다.  컴퓨터는 우리가 직접 보지 못하는 내부 정보들을 다루는데, 이러한 정보들을 확인하기 위해서는 특별한 명령어를 사용해야 합니다.  마치 컴퓨터에게 ""당신의 운영체제 버전이 무엇입니까?""라고 질문하는 것과 같습니다.  여기서 `uname` 명령어는 바로 리눅스에서 운영체제의 커널 버전, 호스트 이름, 시스템 아키텍처 등의 시스템 정보를 보여주는 명령어입니다.  다른 명령어들은 파일 목록을 보여주거나(ls), 파일 내용을 보여주거나(cat), 현재 디렉토리 경로를 보여주는(pwd) 등의 기능을 하므로 운영체제 버전 확인과는 직접적인 관련이 없습니다. 따라서 리눅스 운영체제의 버전을 확인하고자 할 때는 `uname` 명령어를 사용하는 것이 가장 적절합니다.  이는 정보처리기사 공식 교재의 리눅스 명령어 부분에서도 확인할 수 있습니다.",86,1
302,1,4,2,"통신을 위한 프로그램을 생성하여 포트를 할당하고, 클라이언트의 통신 요청 시 클라이언트와 연결하는 내·외부 송·수신 연계기술은?",,DB링크 기술,소켓 기술,스크럼 기술,프로토타입 기술,2,"이 문제는 통신 프로그램을 만들어 포트를 할당하고, 클라이언트의 요청에 따라 연결을 맺는 기술을 묻고 있습니다.  쉽게 말해, 여러 컴퓨터가 서로 정보를 주고받기 위해 필요한 기술을 찾는 문제입니다.  데이터베이스 연결(DB 링크)은 데이터베이스에 접근하는 기술이고, 스크럼이나 프로토타입은 소프트웨어 개발 방법론입니다.  따라서 이 문제와 직접적으로 관련이 없습니다.  소켓 기술은 네트워크 통신에서 클라이언트와 서버가 연결을 맺고 데이터를 주고받는 데 사용되는 기본적인 기술입니다.  프로그램은 특정 포트 번호를 할당받아 클라이언트의 연결 요청을 기다리고, 연결이 수립되면 데이터를 송수신하게 됩니다.  따라서 클라이언트와 서버 간의 내·외부 송수신 연계 기술로 소켓 기술이 가장 적합합니다. 정보처리기사 공식 교재에서 네트워크 프로그래밍 부분을 참고하면 소켓 기술에 대한 자세한 설명을 찾아볼 수 있습니다.  소켓은 서버와 클라이언트 간의 통신을 위한 끝점(endpoint) 역할을 하며, 이를 통해 데이터의 송수신이 이루어집니다.",81,10
303,1,4,3,객체지향 개념에서 연관된 데이터와 함수를 함께 묶어 외부와 경계를 만들고 필요한 인터페이스만을 밖으로 드러내는 과정은?,,메시지(Message),캡슐화(Encapsulation),다형성(Polymorphism),상속(Inheritance),2,"객체지향 프로그래밍에서 중요한 개념 중 하나가 바로 데이터와 함수를 하나로 묶는 것입니다.  마치 보석 상자와 같이,  소중한 보석(데이터)과 보석을 다루는 도구(함수)를 상자 안에 담아 보관하는 것과 비슷합니다. 이 상자는 외부로부터 보석을 직접 건드리거나 함부로 다루는 것을 막아줍니다.  외부에서는 상자에 있는 특정한 구멍(인터페이스)을 통해서만 보석을 사용할 수 있습니다.  이렇게 데이터와 함수를 하나로 묶고, 외부 접근을 제한하여 데이터의 무결성을 보장하고 프로그램의 안정성을 높이는 과정을 캡슐화라고 합니다.  다른 선택지들은 객체지향의 다른 중요한 개념들을 나타내지만, 데이터와 함수를 묶고 외부와의 경계를 만드는 개념을 가장 잘 설명하는 것은 캡슐화입니다.  마치 잘 정돈된 상자처럼, 내부의 복잡한 구조를 숨기고 간결한 인터페이스만을 제공하여 사용 편의성을 높이는 것이 캡슐화의 핵심입니다.",92,7
304,1,4,4,GoF(Gangs of Four) 디자인 패턴의 생성패턴에 속하지 않는 것은?,,추상 팩토리(Abstract Factory),빌더(Builder),어댑터(Adapter),싱글턴(Singleton),3,"GoF 디자인 패턴은 크게 생성 패턴, 구조 패턴, 행위 패턴으로 나뉩니다.  생성 패턴은 객체 생성 과정을 제어하는 패턴들을 의미하며,  객체 생성 방법을 추상화하거나, 객체 생성 시점을 지연시키거나, 객체 생성 과정을 캡슐화하는 등의 역할을 합니다.  문제에서 제시된  추상 팩토리와 빌더, 싱글턴은 모두 객체 생성 과정에 초점을 맞춘 생성 패턴에 속합니다.  반면, 어댑터 패턴은 서로 다른 인터페이스를 가진 클래스들을 호환 가능하게 만들어주는 구조 패턴입니다.  즉, 어댑터 패턴은 객체를 생성하는 방법을 다루는 것이 아니라, 기존 객체들을 연결하고 사용하는 방법을 다루는 것이기 때문에 생성 패턴에 포함되지 않습니다. 따라서 어댑터 패턴이 생성 패턴에 속하지 않는 것이 정답입니다.  쉽게 말해, 생성 패턴은 ""어떻게 객체를 만들까?""에 대한 해답을 제공하는 반면, 어댑터 패턴은 ""기존 객체들을 어떻게 연결해서 쓸까?""에 대한 해답을 제공합니다.",73,7
305,1,4,5,응용프로그램의 프로시저를 사용하여 원격 프로시저를 로컬 프로시저처럼 호출하는 방식의 미들웨어는?,,WAS(Web Application Server),MOM(Message Oriented Middleware),RPC(Remote Procedure Call),ORB(Object Request Broker),3,"이 문제는 응용 프로그램의 프로시저를 마치 로컬에서 실행하는 것처럼 원격으로 호출하는 미들웨어를 묻고 있습니다.  쉽게 말해, 다른 컴퓨터에 있는 프로그램의 기능을 내 컴퓨터에서 직접 호출하여 사용할 수 있도록 해주는 기술입니다. 마치 내 컴퓨터에 있는 함수를 부르는 것처럼 말이죠.  여러가지 미들웨어가 있지만,  RPC(Remote Procedure Call)는 바로 이러한 원격 프로시저 호출을 위한 특화된 미들웨어입니다.  WAS는 웹 애플리케이션을 위한 서버이고, MOM은 메시지를 기반으로 통신하는 미들웨어이며, ORB는 객체 요청을 중개하는 미들웨어입니다.  이들은 원격 프로시저 호출 기능을 제공할 수도 있지만, RPC는 그 목적 자체가 원격 프로시저 호출에 특화되어 있기 때문에 가장 적합한 답변입니다.  정보처리기사 공식 교재에서도 RPC의 정의와 기능을 통해 이러한 점을 확인할 수 있습니다.",83,10
306,1,4,6,바람직한 소프트웨어 설계 지침이 아닌 것은?,,모듈의 기능을 예측할 수 있도록 정의한다.,이식성을 고려한다.,적당한 모듈의 크기를 유지한다.,가능한 모듈을 독립적으로 생성하고 결합도를 최대화한다.,4,"소프트웨어 설계의 목표는 유지보수가 용이하고, 확장성이 좋으며, 오류 발생 가능성을 최소화하는 효율적인 시스템을 만드는 것입니다.  좋은 소프트웨어는 각 기능이 독립적인 모듈로 나뉘어져 있어야 수정이나 추가가 쉬워집니다.  모듈 간의 관계(결합도)는 최소화하고, 각 모듈 내부의 요소들 간의 관계(응집도)는 최대화하는 것이 이상적입니다.  이는 마치 레고 블록처럼, 각 블록(모듈)이 독립적으로 기능하지만, 필요에 따라 조합하여 복잡한 구조물을 만들 수 있도록 하는 것과 같습니다.  문제에서 잘못된 지침은 모듈을 독립적으로 생성하면서 동시에 결합도를 최대화하는 것이라고 말하고 있습니다.  결합도는 모듈 간의 의존성을 나타내는 지표로, 결합도가 높다는 것은 모듈 간의 연관성이 강하다는 의미이며, 이는 수정 시 다른 모듈에도 영향을 미칠 가능성이 높아 유지보수가 어려워집니다. 따라서 모듈은 독립적으로 생성하여 결합도를 최소화해야 유지보수가 용이하고, 시스템의 안정성을 확보할 수 있습니다.  다른 선택지들은 모두 효율적인 소프트웨어 설계를 위한 바람직한 지침입니다.  모듈의 기능을 명확히 정의하고, 이식성을 고려하며, 적절한 크기의 모듈을 유지하는 것은 소프트웨어의 품질을 높이는 데 필수적입니다.",92,6
307,1,4,7,객체지향 분석 방법론 중 Coad-Yourdon 방법에 해당하는 것은?,,E-R 다이어그램을 사용하여 객체의 행위를 데이터 모델링하는데 초점을 둔 방법이다.,"객체, 동적, 기능 모델로 나누어 수행하는 방법이다.",미시적 개발 프로세스와 거시적 개발 프로세스를 모두 사용하는 방법이다.,Use-Case를 강조하여 사용하는 방법이다.,1,"객체지향 분석 방법론 중 Coad-Yourdon 방법은 데이터 모델링에 중점을 두고 객체의 행위를 E-R 다이어그램을 이용하여 표현하는 방식입니다.  쉽게 말해,  우리가 현실 세계의 사물(객체)들을 데이터베이스에 저장하고 관리하는 방법을 설계하는데,  그 사물들의 특징(데이터) 뿐 아니라 그 사물들이 어떤 행동(행위)을 하는지도 함께 고려하여 설계하는 것이죠.  E-R 다이어그램은 데이터베이스 설계에 흔히 사용되는 도구로,  객체와 객체 간의 관계를 시각적으로 표현하여 데이터 모델을 만들 수 있게 해줍니다.  따라서 Coad-Yourdon 방법은 객체의 행위를 데이터 모델링하는 데 초점을 맞춘다는 설명이 가장 정확하게 방법론의 특징을 나타냅니다. 다른 선지는 객체지향 분석의 다른 방법론이나,  객체지향 분석의 전반적인 과정을 설명하는 내용이므로 Coad-Yourdon 방법의 핵심 특징을 정확하게 나타내지 못합니다.",73,7
308,1,4,8,다음은 어떤 프로그램 구조를 나타낸다. 모듈 F에서의 fan-in과 fan-out의 수는 얼마인가?,https://www.cbtbank.kr/images/iz/iz20210307/iz20210307m8.gif,"fan-in : 2, fan-out : 3","fan-in : 3, fan-out : 2","fan-in : 1, fan-out : 2","fan-in : 2, fan-out : 1",2,"문제에서 제시된 그림(텍스트로 변환되지 않아 내용을 알 수 없으나, 모듈 간의 관계를 나타내는 다이어그램으로 추정됨)을 통해 모듈 F의 fan-in과 fan-out을 파악해야 합니다.  fan-in은 특정 모듈로 입력되는 데이터의 흐름(다른 모듈에서 해당 모듈로 들어오는 화살표의 개수)을 나타내고, fan-out은 특정 모듈에서 출력되는 데이터의 흐름(해당 모듈에서 다른 모듈로 나가는 화살표의 개수)을 나타냅니다.  정답은 모듈 F로 들어오는 화살표가 3개이고, 모듈 F에서 나가는 화살표가 2개라는 것을 의미합니다. 따라서 모듈 F의 fan-in은 3, fan-out은 2가 됩니다.  이는 소프트웨어 설계에서 모듈 간의 연결 관계를 분석하는 중요한 개념으로, 모듈의 복잡도와 유지보수성을 평가하는 데 활용됩니다.  다이어그램을 직접 보지 못해 정확한 수치를 확인할 수 없지만, 문제의 맥락과 정답을 고려했을 때, 모듈 F로 3개의 다른 모듈에서 입력이 들어오고, 모듈 F에서 2개의 다른 모듈로 출력이 나가는 구조를 가진다고 추론할 수 있습니다.",88,6
309,1,4,9,현행 시스템 분석에서 고려하지 않아도 되는 항목은?,,DBMS 분석,네트워크 분석,운영체제 분석,인적 자원 분석,4,"현행 시스템 분석은 기존 시스템의 구조와 기능을 파악하는 단계입니다.  DBMS(데이터베이스 관리 시스템), 네트워크, 운영체제는 모두 시스템의 구성 요소이기 때문에 분석 대상이 됩니다.  DBMS는 시스템이 어떤 데이터를 어떻게 관리하는지, 네트워크는 시스템이 다른 시스템과 어떻게 연결되어 정보를 주고받는지, 운영체제는 시스템의 하드웨어와 소프트웨어를 관리하는 방식을 분석해야 합니다. 하지만 인적 자원 분석은 시스템의 *기능*이나 *구조*를 파악하는 데 직접적으로 필요하지 않습니다.  현행 시스템 분석은 시스템 자체의 기술적인 측면에 초점을 맞추기 때문에, 사람(인적 자원)의 능력이나 조직 구조 등은 고려 대상에서 제외됩니다.  즉, 시스템이 어떻게 돌아가는지 기술적인 분석에 집중하는 것이 현행 시스템 분석의 목표이기 때문에, 사람과 관련된 요소는 이 단계에서는 고려하지 않아도 됩니다.",85,1
310,1,4,10,"분산 컴퓨팅 환경에서 서로 다른 기종 간의 하드웨어나 프로토콜, 통신환경 등을 연결하여 응용프로그램과 운영환경 간에 원만한 통신이 이루어질 수 있게 서비스를 제공하는 소프트웨어는?",,미들웨어,하드웨어,오픈허브웨어,그레이웨어,1,"이 문제는 분산 컴퓨팅 환경에서 서로 다른 시스템들이 원활하게 통신할 수 있도록 중간에서 연결 역할을 하는 소프트웨어를 묻고 있습니다.  분산 컴퓨팅 환경에서는 다양한 종류의 하드웨어, 운영체제, 통신 프로토콜이 사용될 수 있습니다. 이러한 이질적인 시스템들을 서로 연결하여 데이터를 주고받고, 응용 프로그램들이 서로 상호 작용할 수 있도록 하는 것이 매우 중요합니다.  마치 여러 나라의 사람들이 서로 다른 언어를 사용하더라도 통역가를 통해 소통하는 것과 같습니다.  이때 통역가의 역할을 하는 것이 바로 미들웨어입니다.  미들웨어는 하드웨어나 운영체제의 차이를 추상화하고, 표준화된 인터페이스를 제공하여 서로 다른 시스템 간의 원활한 통신을 가능하게 합니다.  따라서 서로 다른 기종 간의 하드웨어나 프로토콜, 통신 환경 등을 연결하여 응용 프로그램과 운영 환경 간에 원만한 통신이 이루어질 수 있게 서비스를 제공하는 소프트웨어는 미들웨어가 됩니다. 다른 선지들은 문제의 핵심 내용과 부합하지 않습니다. 하드웨어는 물리적인 장치이고, 오픈허브웨어나 그레이웨어는 일반적인 소프트웨어 용어가 아닙니다.",93,10
311,1,4,11,CASE(Computer Aided Software Engineering)에 대한 설명으로 틀린 것은?,,소프트웨어 모듈의 재사용성이 향상된다.,자동화된 기법을 통해 소프트웨어 품질이 향상된다.,소프트웨어 사용자들에게 사용 방법을 신속히 숙지시키기 위해 사용된다.,소프트웨어 유지보수를 간편하게 수행할 수 있다.,3,"CASE(Computer Aided Software Engineering)는 소프트웨어 개발 과정을 자동화하고 효율화하기 위한 도구와 기법들을 통칭하는 용어입니다.  소프트웨어 개발의 전 과정 또는 특정 단계를 지원하는 다양한 도구들이 CASE 도구에 포함됩니다.  문제에서 틀린 설명은 소프트웨어 사용자들에게 사용 방법을 신속히 숙지시키는 데 사용된다는 것입니다. CASE는 개발자들이 소프트웨어를 더 효율적으로 개발하고 유지보수할 수 있도록 돕는 데 초점을 맞추지, 사용자 교육에는 직접적으로 사용되지 않습니다.  사용자 교육은 별도의 매뉴얼이나 교육 프로그램을 통해 이루어집니다.  나머지 선택지는 모두 CASE가 제공하는 이점들을 정확하게 설명하고 있습니다.  소프트웨어 모듈의 재사용성을 높이고, 자동화된 기법을 통해 품질을 향상시키며, 유지보수를 용이하게 만드는 것이 CASE의 주요 목표이기 때문입니다.  따라서 CASE의 본질적인 목적과는 거리가 먼 설명이 틀린 것입니다.",85,6
312,1,4,12,UML(Unified Modeling Language)에 대한 설명 중 틀린 것은?,,"기능적 모델은 사용자 측면에서 본 시스템 기능이며, UML에서는 Use case Diagram을 사용한다.","정적 모델은 객체, 속성, 연관관계, 오퍼레이션의 시스템의 구조를 나타내며, UML에서는 Class Diagram을 사용한다.","동적 모델은 시스템의 내부 동작을 말하며, UML에서는 Sequence Diagram, State Diagram, Activity Diagram을 사용한다.","State Diagram은 객체들 사이의 메시지 교환을 나타내며, Sequence Diagram은 하나의 객체가 가진 상태와 그 상태의 변화에 의한 동작순서를 나타낸다.",4,"UML은 시스템을 모델링하는 표준 언어입니다.  문제에서 제시된 설명 중 틀린 부분은 객체의 상태 변화와 메시지 교환을 설명하는 다이어그램에 대한 설명입니다.  State Diagram은 하나의 객체가 가질 수 있는 여러 상태와, 각 상태 간의 전이(이동)를 나타내는 다이어그램입니다.  예를 들어, 자동판매기의 ""대기 상태"", ""돈 투입 상태"", ""음료 선택 상태"", ""음료 배출 상태"" 등과 이 상태들 간의 변화를 표현하는 데 사용됩니다. 반면 Sequence Diagram은 여러 객체 간의 상호 작용, 즉 메시지 교환을 시간 순서대로 보여주는 다이어그램입니다.  자동판매기의 예시로는 사용자가 돈을 투입하고, 음료를 선택하고, 자동판매기가 음료를 배출하는 과정을 객체 간 메시지 교환으로 나타낼 수 있습니다. 따라서, 객체 간의 메시지 교환을 나타내는 것은 Sequence Diagram이고, 하나의 객체의 상태 변화를 나타내는 것은 State Diagram입니다. 문제의 설명은 이 두 다이어그램의 역할을 서로 바꿔서 설명하고 있기 때문에 틀린 것입니다.  쉽게 말해,  State Diagram은 ""내부 상태 변화""를, Sequence Diagram은 ""외부와의 상호작용""을 보여주는 다이어그램이라고 생각하면 이해하기 쉽습니다.  정답은 이러한 다이어그램의 역할에 대한 오류를 지적하는 선지입니다.",66,2
313,1,4,13,기본 유스케이스 수행 시 특별한 조건을 만족할 때 수행하는 유스케이스는?,,연관,확장,선택,특화,2,"기본 유스케이스는 시스템의 주요 기능을 나타내는 핵심적인 사용 사례입니다.  하지만,  실제 시스템 운영에서는 예외적인 상황이나 특수한 조건이 발생할 수 있습니다.  예를 들어,  온라인 쇼핑몰에서 상품 주문 유스케이스를 생각해 봅시다.  기본적으로는 상품을 장바구니에 담고 결제하는 과정이지만,  쿠폰을 사용하거나,  포인트를 사용하는 등의 특별한 조건이 추가될 수 있습니다. 이러한 특별한 조건이 추가될 때 수행되는 유스케이스를 바로 '확장 유스케이스'라고 합니다.  확장 유스케이스는 기본 유스케이스의 흐름을 변경하거나 추가적인 기능을 제공하는 역할을 합니다.  따라서 기본 유스케이스 수행 시 특별한 조건을 만족할 때 수행되는 유스케이스는 확장 유스케이스입니다.  다른 선택지는 기본 유스케이스와의 관계를 설명하는 용어이지만, 특정 조건에 따른 추가적인 기능 수행이라는 문제의 핵심을 정확히 나타내지는 않습니다.",63,2
314,1,4,14,다음 중 요구사항 모델링에 활용되지 않는 것은?,,애자일(Agile) 방법,유스케이스 다이어그램(Use Case Diagram),시컨스 다이어그램(Sequence Diagram),단계 다이어그램(Phase Diagram),4,"이 문제는 요구사항 모델링에 사용되는 다이어그램을 묻고 있습니다.  요구사항 모델링이란, 사용자의 요구를 시스템 개발에 반영하기 위해 사용자의 요구를 분석하고 문서화하는 과정입니다.  이 과정에서 시스템의 기능, 성능, 인터페이스 등을 명확하게 정의하고, 개발팀과 사용자 간의 오해를 방지하는 것이 중요합니다.  이를 위해 다양한 모델링 기법이 사용되는데,  유스케이스 다이어그램은 사용자의 시스템 사용 방법을 시각적으로 보여주고, 시퀀스 다이어그램은 시스템 내부의 객체 간 상호작용을 시간 순서대로 보여줍니다.  두 다이어그램 모두 시스템의 기능과 동작을 명확하게 표현하는 데 유용하게 사용됩니다.  반면, 단계 다이어그램은 주로 물리적 시스템의 상태 변화를 나타내는 데 사용되며, 소프트웨어 시스템의 요구사항을 모델링하는 데는 적합하지 않습니다.  애자일 방법론은 소프트웨어 개발 프로세스 전반에 걸쳐 적용되는 방법론으로, 요구사항 모델링 단계에서도 유용하게 활용될 수 있습니다. 따라서 요구사항 모델링에 활용되지 않는 것은 단계 다이어그램입니다.",66,2
315,1,4,15,디자인 패턴을 이용한 소프트웨어 재사용으로 얻어지는 장점이 아닌 것은?,,소프트웨어 코드의 품질을 향상시킬 수 있다.,개발 프로세스를 무시할 수 있다.,개발자들 사이의 의사소통을 원활하게 할 수 있다.,소프트웨어의 품질과 생산성을 향상시킬 수 있다.,2,"디자인 패턴을 소프트웨어 개발에 활용하면 여러 가지 장점이 있습니다.  기존에 검증된 설계를 재사용하므로 코드의 품질을 높이고, 개발 시간을 단축하여 생산성을 향상시킬 수 있습니다. 또한, 디자인 패턴은 개발자들 간의 의사소통을 위한 공통된 언어 역할을 하여 프로젝트 협업을 원활하게 합니다. 하지만 디자인 패턴을 사용한다고 해서 개발 프로세스 자체를 무시할 수 있는 것은 아닙니다.  소프트웨어 개발은 체계적인 프로세스를 거쳐야 하며, 디자인 패턴은 이 프로세스를 보조하는 도구일 뿐, 프로세스 자체를 대체할 수 없습니다.  개발 프로세스는 요구사항 분석, 설계, 구현, 테스트 등의 단계를 포함하며, 각 단계는 엄격하게 준수되어야 합니다. 디자인 패턴은 설계 단계에서 효율성을 높이는 데 기여하지만, 다른 단계의 중요성을 낮추거나 무시할 수 있는 것은 아닙니다. 따라서 디자인 패턴 사용의 장점이 아닌 것은 개발 프로세스를 무시할 수 있다는 것입니다.  마치 레시피가 요리 과정 전체를 대체할 수 없는 것과 같습니다. 레시피는 요리 과정을 효율적으로 돕지만, 재료 준비, 조리, 마무리 등의 과정은 여전히 필요합니다.",94,7
316,1,4,16,"럼바우(Rumbaugh) 분석기법에서 정보모델링이라고도 하며, 시스템에서 요구되는 객체를 찾아내어 속성과 연산 식별 및 객체들 간의 관계를 규정하여 다이어그램을 표시하는 모델링은?",,Object,Dynamic,Function,Static,1,"이 문제는 럼바우 분석 기법에서 사용하는 정보 모델링 기법에 대한 문제입니다.  럼바우 분석 기법은 객체지향 분석 기법의 하나로, 시스템을 구성하는 객체들을 중심으로 분석하는 방법입니다.  문제에서 설명하고 있는 것처럼, 이 기법에서는 시스템에 필요한 객체들을 찾아내고, 각 객체의 속성(데이터)과 연산(행위)을 정의하며, 객체들 간의 관계를 명확히 규정합니다.  그리고 이러한 정보들을 시각적으로 표현하기 위해 다이어그램을 사용하는데, 이 다이어그램을 통해 시스템의 구조와 동작을 명확하게 이해할 수 있도록 합니다.  따라서 문제에서 설명하는 모델링은 객체(Object)를 중심으로 하는 모델링이며, 객체의 속성, 연산, 그리고 객체 간의 관계를 나타내는 것이 핵심입니다.  다른 선택지들은 시스템의 다른 측면을 모델링하는 기법들로, 문제에서 설명하는 객체 중심의 모델링과는 다릅니다.  쉽게 말해, 레고 블록으로 집을 짓는다고 생각해보세요.  각 블록이 객체이고, 블록의 모양과 색깔이 속성, 블록을 조립하는 행위가 연산, 그리고 블록들을 어떻게 연결하는지가 객체 간의 관계입니다.  이 문제는 이러한 객체 중심의 모델링을 다루고 있습니다.",77,3
317,1,4,17,"소프트웨어를 개발하기 위한 비즈니스(업무)를 객체와 속성, 클래스와 멤버, 전체와 부분 등으로 나누어서 분석해 내는 기법은?",,객체지향 분석,구조적 분석,기능적 분석,실시간 분석,1,"소프트웨어 개발은 단순히 코드를 작성하는 것 이상으로, 복잡한 업무를 효율적으로 처리하기 위한 체계적인 분석이 필요합니다.  이 문제에서 묻고 있는 것은,  개발 대상인 비즈니스 업무를  '객체'라는 개념을 중심으로 분석하는 기법입니다.  객체는 속성(데이터)과 행위(동작)을 가진 실체를 의미하며,  클래스는 같은 속성과 행위를 가진 객체들의 집합입니다.  예를 들어, '고객'이라는 객체는 '이름', '주소', '전화번호'와 같은 속성과 '주문하기', '결제하기'와 같은 행위를 가집니다.  '고객' 객체들을 모아놓은 것이 '고객' 클래스가 됩니다.  이러한 객체와 클래스를 이용하여 업무를 분석하는 것이 객체지향 분석의 핵심입니다.  전체 시스템을 객체들의 상호작용으로 표현하고,  부분적인 객체들을 조합하여 전체 시스템을 구성하는 방식으로 분석하는 것이죠.  반면, 구조적 분석은 시스템을 기능적인 단위로 나누어 분석하는 방식이고, 기능적 분석은 시스템의 기능을 중심으로 분석하는 방식입니다.  실시간 분석은 실시간으로 처리해야 하는 시스템에 특화된 분석 기법입니다. 따라서 소프트웨어 개발을 위한 비즈니스 업무를 객체와 속성, 클래스와 멤버, 전체와 부분 등으로 나누어 분석하는 기법은 객체지향 분석입니다.  이는 소프트웨어 개발의 복잡성을 줄이고, 유지보수를 용이하게 하며, 재사용성을 높이는 데 크게 기여합니다.",64,2
318,1,4,18,애자일 소프트웨어 개발 기법의 가치가 아닌 것은?,,프로세스의 도구보다는 개인과 상호작용에 더 가치를 둔다.,계약 협상보다는 고객과의 협업에 더 가치를 둔다.,실제 작동하는 소프트웨어보다는 이해하기 좋은 문서에 더 가치를 둔다.,계획을 따르기보다는 변화에 대응하는 것에 더 가치를 둔다.,3,"애자일(Agile) 소프트웨어 개발 기법은 빠르게 변화하는 요구사항에 유연하게 대처하고, 고객과의 긴밀한 협력을 통해 소프트웨어를 개발하는 방법론입니다.  개발 과정에서 문서보다 실제 작동하는 소프트웨어를 중시하며,  개발자 개인의 역량과 팀워크를 강조합니다.  문제에서 잘못된 선지는  '이해하기 좋은 문서에 더 가치를 둔다'는 내용입니다. 애자일은 문서 작업에 시간을 낭비하기보다는,  실제 작동하는 소프트웨어를 빠르게 만들고,  필요에 따라 수정하며 발전시키는 것을 더 중요하게 생각합니다.  즉,  작동하는 소프트웨어가 최우선이며,  문서는 최소한으로 유지하는 것이 애자일의 핵심 가치입니다.  따라서,  잘 만들어진 문서보다 실제 작동하는 소프트웨어를 더 중요하게 여기는 애자일의 특징과는 반대되는 내용이므로 정답이 됩니다.",90,2
319,1,4,19,"UML 다이어그램 중 시스템 내 클래스의 정적 구조를 표현하고 클래스와 클래스, 클래스의 속성 사이의 관계를 나타내는 것은?",,Activity Diagram,Modea Diagram,State Diagram,Class Diagram,4,"이 문제는 UML 다이어그램 중 시스템의 클래스 구조를 표현하는 다이어그램을 묻고 있습니다.  소프트웨어 시스템을 설계할 때, 시스템을 구성하는 여러 클래스들과 그 클래스들 간의 관계를 명확하게 나타내는 것이 중요합니다. 마치 건물의 설계도처럼 말이죠.  각 클래스는 건물의 방처럼 시스템의 특정 기능을 담당하고, 클래스 간의 관계는 방들 사이의 연결 통로처럼 데이터를 주고받는 방식을 나타냅니다.",81,2
320,1,4,20,소프트웨어 설계시 제일 상위에 있는 main user function에서 시작하여 기능을 하위 기능들로 분할해 가면서 설계하는 방식은?,,객체 지향 설계,데이터 흐름 설계,상향식 설계,하향식 설계,4,"소프트웨어 설계는 큰 문제를 작은 문제로 쪼개서 해결하는 과정입니다.  마치 큰 레고 블록을 작은 블록으로 나누어 원하는 모양을 만드는 것과 같아요.  이 문제에서 제시된 설계 방식은 가장 큰 기능(main user function)에서 시작하여 점차 세부적인 기능으로 나누어 설계하는 방식입니다.  이처럼 위에서 아래로 설계하는 방식을 하향식 설계라고 합니다.  반대로, 작은 기능들을 모아서 큰 기능을 만드는 방식은 상향식 설계입니다.  문제에서 'main user function에서 시작하여 기능을 하위 기능들로 분할'한다는 것은 위에서 아래로 설계하는 하향식 설계의 특징을 명확하게 보여줍니다. 객체 지향 설계나 데이터 흐름 설계는 소프트웨어 설계의 한 방법론이지만, 문제에서 설명하는 '위에서 아래로 분할'하는 방식 자체를 가장 잘 나타내는 것은 하향식 설계입니다. 따라서 정답은 하향식 설계입니다.",88,6
321,1,4,21,구현 단계에서의 작업 절차를 순서에 맞게 나열한 것은?,https://www.cbtbank.kr/images/iz/iz20210307/iz20210307m21.gif,㉠-㉡-㉢-㉣,㉡-㉠-㉣-㉢,㉢-㉠-㉡-㉣,㉣-㉡-㉠-㉢,2,"소프트웨어를 구현하는 과정은 계획, 코딩, 컴파일, 테스트의 단계를 거칩니다.  먼저 무엇을 어떻게 코딩할지 계획을 세우는 단계(코딩작업을 계획한다)가 가장 먼저 와야 합니다.  계획이 세워진 후에 실제로 코드를 작성하는 단계(코딩한다)가 이어집니다.  작성된 코드는 컴퓨터가 이해할 수 있는 기계어로 변환하는 컴파일 과정(컴파일한다)을 거쳐야 실행 가능한 프로그램이 됩니다.  마지막으로 컴파일된 프로그램이 제대로 작동하는지 확인하기 위해 테스트(코드를 테스트한다)를 수행합니다. 따라서, 소프트웨어 구현 단계의 올바른 순서는 계획-코딩-컴파일-테스트입니다.  이 순서를 따르지 않으면 프로그램이 제대로 동작하지 않거나 오류가 발생할 가능성이 높아집니다.  마치 레시피대로 요리를 하는 것과 같습니다.  먼저 요리 계획(레시피)을 세우고, 재료를 준비하여 요리(코딩)하고, 요리가 완성되면 맛을 보고(테스트) 수정하는 과정과 유사합니다.",89,14
322,1,4,22,다음 자료에 대하여 “Selection Sort”를 사용하여 오름차순으로 정렬한 경우 PASS 3의 결과는?,https://www.cbtbank.kr/images/iz/iz20210307/iz20210307m22.gif,"3, 4, 7, 9, 8","3, 4, 8, 9, 7","3, 8, 4, 9, 7","3, 4, 7, 8, 9",1,"이 문제는 선택 정렬(Selection Sort) 알고리즘을 이해하고 있는지를 묻는 문제입니다. 선택 정렬은 주어진 리스트에서 가장 작은(혹은 큰) 값을 찾아서 리스트의 맨 앞(혹은 맨 뒤)으로 이동시키는 과정을 반복하는 정렬 알고리즘입니다.  문제에서 초기 상태는 8, 3, 4, 9, 7이고 오름차순으로 정렬하라고 했습니다.  PASS 1에서는 가장 작은 값인 3을 찾아 맨 앞으로 보냅니다. 그러면 리스트는 3, 8, 4, 9, 7이 됩니다. PASS 2에서는 남은 숫자 중 가장 작은 값인 4를 찾아 3 다음으로 이동시킵니다. 리스트는 3, 4, 8, 9, 7이 됩니다.  PASS 3에서는 남은 숫자 중 가장 작은 값을 찾아야 합니다.  8, 9, 7 중 가장 작은 값은 7입니다. 따라서 7을 4 다음으로 이동시키면 리스트는 3, 4, 7, 9, 8이 됩니다.  이것이 PASS 3의 결과입니다.  따라서 정답은 3, 4, 7, 9, 8 입니다.  선택 정렬은 각 PASS마다 가장 작은 값을 찾아 앞으로 보내는 과정을 반복하므로,  PASS 3까지 진행했을 때는 앞에서부터 세 번째까지의 값이 정렬된 상태가 됩니다.",60,11
323,1,4,23,하향식 통합시험을 위해 일시적으로 필요한 조건만을 가지고 임시로 제공되는 시험용 모듈은?,,Stub,Driver,Procedure,Function,1,"하향식 통합 시험이란, 상위 모듈부터 차례대로 통합하여 시험하는 방법입니다.  이때, 아직 구현되지 않은 하위 모듈을 대신하여 일시적으로 기능을 제공하는 더미(dummy) 모듈이 필요한데, 이를 'Stub'이라고 합니다.  Stub은 하위 모듈이 호출될 때 미리 정의된 값을 반환하거나, 특정 동작을 시뮬레이션하여 상위 모듈의 테스트를 가능하게 합니다.  하향식 통합에서는 상위 모듈의 기능을 먼저 검증하는 것이 중요하기 때문에, 하위 모듈의 완성 여부와 상관없이 상위 모듈의 테스트를 진행할 수 있도록 Stub이 사용됩니다.  반대로, Driver는 하위 모듈을 테스트하기 위해 상위 모듈을 대신하는 더미 모듈입니다.  Procedure와 Function은 일반적인 프로그램 구성 요소이지, 하향식 통합 시험을 위해 특별히 필요한 임시 모듈은 아닙니다. 따라서 하향식 통합 시험에서 일시적으로 필요한 조건만을 가지고 임시로 제공되는 시험용 모듈은 Stub입니다.",83,14
324,1,4,24,다음 전위식(prefix)을 후위식(postfix)으로 옳게 표현한 것은?,https://www.cbtbank.kr/images/iz/iz20210307/iz20210307m24.gif,A B C + D / * E -,A B * C D / + E -,A B * C + D / E -,A B C + * D / E -,4,"이 문제는 전위 표기법(prefix notation)으로 표현된 수식을 후위 표기법(postfix notation)으로 변환하는 문제입니다. 전위 표기법은 연산자가 피연산자 앞에 오는 표기법이고, 후위 표기법은 연산자가 피연산자 뒤에 오는 표기법입니다.  문제의 전위 표기식 ""- / * A + B C D E""를 풀어서 생각해보면,  가장 먼저 처리되는 연산은 가장 안쪽에 있는 연산입니다.  즉, 'A', 'B', 'C'를 더하고, 그 결과에 'D'를 곱한 후, 그 결과를 'E'로 나누고, 마지막으로 그 결과에서 전체 결과를 빼는 것입니다. 이 과정을 후위 표기법으로 나타내면,  먼저 A, B, C를 더해야 하므로 ""A B C +""가 됩니다.  다음으로 이 결과에 D를 곱해야 하므로 ""* D""가 추가되어 ""A B C + * D""가 됩니다.  그 다음 E로 나누어야 하므로 ""/ E""가 추가되어 ""A B C + * D / E""가 됩니다. 마지막으로 전체 결과에서 빼는 연산을 추가하면 ""A B C + * D / E -""가 됩니다. 따라서 정답은  ""A B C + * D / E -"" 입니다.  전위 표기식을 후위 표기식으로 변환하는 방법은 스택을 이용하는 것이 일반적입니다.  하지만 이 문제는 비교적 간단하여 직관적으로 풀이가 가능합니다.  각 연산의 우선순위와 처리 순서를 차근차근 따라가면 후위 표기식을 쉽게 만들 수 있습니다.",65,11
325,1,4,25,"그래프의 특수한 형태로 노드(Node)와 선분(Branch)으로 되어 있고, 정점 사이에 사이클(Cycle)이 형성되어 있지 않으며, 자료 사이의 관계성이 계층 형식으로 나타나는 비선형 구조는?",,tree,network,stack,distributed,1,"문제에서 제시된 조건들을 하나씩 살펴보면, 그래프의 특수한 형태로 노드(Node)와 선분(Branch)으로 이루어져 있다는 점, 정점 사이에 사이클(Cycle)이 없다는 점, 그리고 자료 사이의 관계성이 계층 형식으로 나타나는 비선형 구조라는 점을 알 수 있습니다.  쉽게 말해, 나무처럼 가지가 뻗어나가는 형태를 생각하면 됩니다.  각 노드는 데이터를 저장하고, 선분은 노드 간의 관계를 나타냅니다.  중요한 점은 사이클이 없다는 것인데, 사이클이란 어떤 노드에서 출발하여 다시 그 노드로 돌아오는 경로를 의미합니다.  나무 구조에서는 어떤 가지를 따라가더라도 다시 처음 가지로 돌아올 수 없습니다.  이러한 특징들을 모두 만족하는 자료구조가 바로 트리(Tree)입니다.  네트워크는 사이클이 존재할 수 있고, 스택과 분산 구조는 계층적인 관계를 나타내는 데 적합하지 않습니다. 따라서 문제의 조건에 가장 잘 부합하는 자료구조는 트리입니다.  정보처리기사 공식 교재의 자료구조 단원에서 트리의 정의와 특징에 대한 자세한 설명을 찾아볼 수 있습니다.",86,11
326,1,4,26,스택에 대한 설명으로 틀린 것은?,,입출력이 한쪽 끝으로만 제한된 리스트이다.,Head(front)와 Tail(rear)의 2개 포인터를 갖고 있다.,LIFO 구조이다.,더 이상 삭제할 데이터가 없는 상태에서 데이터를 삭제하면 언더플로(Underflow)가 발생한다.,2,"스택은 데이터를 쌓아 올리는 구조, 즉 마지막에 들어온 데이터가 먼저 나가는 LIFO(Last-In, First-Out) 구조를 가진 자료구조입니다.  마치 접시를 쌓아놓고 위에서부터 하나씩 꺼내는 것과 같다고 생각하면 이해하기 쉽습니다.  문제에서 틀린 설명은 스택이 Head(front)와 Tail(rear)의 두 개 포인터를 갖고 있다는 것입니다.  스택은 데이터의 입출력이 한쪽 끝(보통 꼭대기)에서만 이루어지기 때문에,  Head 또는 Top이라고 부르는 하나의 포인터만으로도 충분히 관리할 수 있습니다.  큐와 같은 자료구조는 Head와 Tail 두 개의 포인터를 사용하지만, 스택은 그렇지 않습니다.  나머지 설명들은 모두 스택의 특징을 정확하게 나타내고 있습니다.  데이터가 없는데 삭제를 시도하면 언더플로우가 발생하는 것도 스택의 중요한 특징입니다.",75,11
327,1,4,27,디지털 저작권 관리(DRM)에 사용되는 기술요소가 아닌 것은?,,키관리,방화벽,암호화,크랙방지,2,"디지털 저작권 관리(DRM)은 디지털 콘텐츠의 저작권을 보호하기 위해 사용되는 기술입니다.  쉽게 말해,  내가 만든 음악이나 영화를 함부로 복사하거나 불법으로 유통하는 것을 막기 위한 기술이죠.  이를 위해서는 콘텐츠를 암호화하거나,  누가 접근할 수 있는지 키를 관리하거나,  불법 복제를 막는 기술(크랙 방지) 등이 필요합니다.  반면, 방화벽은 외부의 불법적인 접근을 차단하는 네트워크 보안 장치입니다.  DRM은 콘텐츠 자체의 보호에 초점을 맞추는 반면, 방화벽은 네트워크 전체의 보안에 초점을 맞춥니다. 따라서 DRM의 기술 요소로 방화벽은 적절하지 않습니다.  DRM은 콘텐츠를 보호하는 데 집중하는 기술이고, 방화벽은 네트워크를 보호하는 데 집중하는 기술이기 때문에 서로 다른 목적을 가지고 있습니다.  DRM 기술은 콘텐츠 자체에 적용되는 반면, 방화벽은 네트워크의 경계에서 작동합니다.",83,16
328,1,4,28,여러 개의 선택 항목 중 하나의 선택만 가능한 경우 사용하는 사용자 인터페이스(UI)요소는?,,토글 버튼,텍스트 박스,라디오 버튼,체크 박스,3,"여러 개의 선택지 중에서 단 하나만 선택할 수 있는 UI 요소를 묻는 문제입니다.  마치 설문조사에서 하나의 답변만 고를 수 있는 것과 같습니다.  '토글 버튼'은 켜짐/꺼짐을 전환하는 기능을 가지고 있고, '텍스트 박스'는 여러 글자를 입력하는 공간이며, '체크 박스'는 여러 항목을 동시에 선택할 수 있습니다.  하지만 문제에서 '하나의 선택만 가능'하다고 명시했으므로, 여러 항목 중 단 하나만 선택할 수 있도록 디자인된 '라디오 버튼'이 정답입니다. 라디오 버튼은 선택지 중 하나를 선택하면 다른 선택지는 자동으로 해제되는 특징이 있습니다.  이는 사용자에게 오직 하나의 옵션만 선택하도록 명확하게 제시하는 역할을 합니다.  따라서 사용자가 단일 선택을 해야 하는 상황에 가장 적합한 UI 요소입니다.",79,4
329,1,4,29,소프트웨어의 일부분을 다른 시스템에서 사용할 수 있는 정도를 의미하는 것은?,,신뢰성(Reliability),유지보수성(Maintainability),가시성(Visibility),재사용성(Reusability),4,"이 문제는 소프트웨어의 특정 부분을 다른 시스템에서 다시 사용할 수 있는 정도를 묻고 있습니다.  마치 레고 블록처럼, 이미 만들어진 블록(소프트웨어의 일부)을 다른 작품(시스템)에 재활용하는 것을 생각해보세요.  이처럼 기존에 개발된 소프트웨어 구성 요소를  새로운 시스템에 효율적으로 통합하여 사용하는 능력을 나타내는 것이 바로 '재사용성'입니다.  신뢰성은 소프트웨어가 얼마나 안정적으로 작동하는지를, 유지보수성은 얼마나 쉽게 수정하고 관리할 수 있는지를, 가시성은 소프트웨어의 내부 동작을 얼마나 쉽게 이해할 수 있는지를 의미합니다.  문제에서 묻는 것은 이러한 특성들 중에서  기존 소프트웨어의 재활용 가능성에 대한 것이므로, 정답은 재사용성입니다.  정보처리기사 공식 교재의 소프트웨어 공학 부분에서 소프트웨어 품질 특성에 대한 설명을 참고하면 더욱 명확하게 이해할 수 있을 것입니다.",86,6
330,1,4,30,자료구조에 대한 설명으로 틀린 것은?,,큐는 비선형구조에 해당한다.,큐는 First In ? First Out 처리를 수행한다.,스택은 Last In ? First out 처리를 수행한다.,"스택은 서브루틴 호출, 인터럽트 처리, 수식 계산 및 수식 표기법에 응용된다.",1,"자료구조는 데이터를 효율적으로 저장하고 관리하는 방법을 연구하는 컴퓨터 과학의 한 분야입니다.  문제에서 틀린 설명을 찾는 것이 목표인데요,  먼저 큐(Queue)는 데이터를 먼저 들어온 순서대로 먼저 나가는(FIFO: First In First Out) 방식으로 처리하는 자료구조입니다.  마치 줄을 서서 기다리는 것과 같다고 생각하면 이해하기 쉽습니다.  반면 스택(Stack)은 먼저 들어온 데이터가 나중에 나가고, 나중에 들어온 데이터가 먼저 나가는(LIFO: Last In First Out) 방식으로 처리됩니다.  이는 쌓아 올린 접시를 생각하면 이해가 쉬운데, 가장 위에 놓인 접시를 먼저 가져가야 하기 때문입니다.  큐는 데이터를 순차적으로 처리하는 선형 자료구조이고, 스택 또한 선형 자료구조입니다.  스택은 함수 호출이나 인터럽트 처리 등에서 순서를 관리하는 데 유용하게 사용됩니다.  따라서 문제에서 큐가 비선형 구조라는 설명은 잘못된 것입니다.  나머지 설명들은 모두 자료구조에 대한 정확한 설명입니다.",80,11
331,1,4,31,다음 중 블랙박스 검사 기법은?,,경계값 분석,조건 검사,기초 경로 검사,루프 검사,1,"이 문제는 소프트웨어 테스트 기법 중 블랙박스 검사에 해당하는 것을 묻고 있습니다. 블랙박스 검사란 소프트웨어의 내부 구조나 동작 원리를 알지 못한 채, 입력값과 출력값만을 가지고 테스트하는 방법입니다.  마치 검은 상자(블랙박스) 안에서 어떤 일이 일어나는지 모르고 외부에서만 동작을 확인하는 것과 같습니다.  제시된 선택지 중에서 경계값 분석은 블랙박스 검사 기법의 대표적인 예시입니다. 경계값 분석은 입력값의 경계선(최소값, 최대값, 그 바로 위, 그 바로 아래)을 중심으로 테스트 케이스를 설계하여, 경계 부근에서 발생할 수 있는 오류를 찾아내는 기법입니다.  반면, 조건 검사, 기초 경로 검사, 루프 검사는 소프트웨어의 내부 구조와 코드를 직접적으로 분석하는 화이트박스 검사 기법에 속합니다. 따라서 블랙박스 검사 기법을 묻는 질문에 대한 정답은 경계값 분석입니다.",78,19
332,1,4,32,이진 검색 알고리즘에 대한 설명으로 틀린 것은?,,탐색 효율이 좋고 탐색 시간이 적게 소요된다.,검색할 데이터가 정렬되어 있어야 한다.,피보나치 수열에 따라 다음에 비교할 대상을 선정하여 검색한다.,비교횟수를 거듭할 때마다 검색 대상이 되는 데이터의 수가 절반으로 줄어든다.,3,"이 문제는 이진 검색 알고리즘의 특징을 묻고 있습니다. 이진 검색은 데이터가 정렬되어 있을 때 매우 효율적으로 특정 값을 찾는 알고리즘입니다.  마치 전화번호부에서 이름을 찾는 것과 같습니다.  전화번호부가 정렬되어 있지 않다면, 처음부터 끝까지 하나하나 확인해야 하지만, 정렬되어 있다면 중간 부분부터 확인하여 찾고자 하는 이름이 앞쪽에 있는지 뒤쪽에 있는지 빠르게 판단할 수 있습니다.  이처럼 이진 검색은 검색 대상의 범위를 절반씩 줄여나가면서 검색하기 때문에 탐색 시간이 매우 짧습니다.  따라서,  데이터가 정렬되어 있어야 한다는 것은 이진 검색의 필수 조건입니다.  그리고 검색 과정에서 매 단계마다 검색 대상의 수가 절반으로 줄어드는 것도 이진 검색의 핵심적인 특징입니다.  하지만 피보나치 수열을 이용하여 다음 비교 대상을 선택하는 것은 이진 검색 알고리즘의 특징이 아닙니다. 피보나치 검색은 이진 검색과 유사하지만 다른 알고리즘입니다.  결론적으로, 이진 검색은 효율적이고 빠르지만, 데이터가 정렬되어 있어야만 작동한다는 점을 이해하는 것이 중요합니다.",67,11
333,1,4,33,소프트웨어 품질목표 중 쉽게 배우고 사용할 수 있는 정도를 나타내는 것은?,,Correctness,Reliability,Usability,Integrity,3,"소프트웨어 품질 목표는 사용자에게 좋은 경험을 제공하기 위한 여러 가지 특성을 나타냅니다.  문제에서 묻고 있는 것은 ""쉽게 배우고 사용할 수 있는 정도""인데, 이는 바로 '사용성(Usability)'을 의미합니다.  정확성(Correctness)은 소프트웨어가 의도한 대로 정확하게 동작하는지를 나타내고, 신뢰성(Reliability)은 소프트웨어가 일정 기간 동안 오류 없이 안정적으로 동작하는지를 나타내며, 무결성(Integrity)은 소프트웨어의 데이터가 정확하고 일관성 있게 유지되는지를 나타냅니다.  하지만 문제에서 요구하는 '쉽게 배우고 사용할 수 있는 정도'와 가장 잘 맞는 것은 소프트웨어의 사용 편의성을 나타내는 사용성(Usability)입니다.  쉽게 이해하고, 배우고, 사용할 수 있는 소프트웨어는 사용자에게 높은 만족도를 제공하며, 생산성 향상에도 기여합니다. 따라서 정답은 사용성(Usability)입니다.",86,17
334,1,4,34,테스트 케이스에 일반적으로 포함되는 항목이 아닌 것은?,,테스트 조건,테스트 데이터,테스트 비용,예상 결과,3,"테스트 케이스는 소프트웨어의 기능을 검증하기 위해 설계된 일련의 입력값, 실행 조건, 그리고 예상 결과를 포함하는 문서입니다.  테스트를 효과적으로 수행하기 위해서는 테스트 조건(어떤 상황에서 테스트할 것인가), 테스트 데이터(어떤 입력값을 사용할 것인가), 그리고 예상 결과(테스트 후 어떤 결과가 나와야 하는가)가 필수적입니다.  하지만 테스트 비용은 테스트를 수행하는 데 드는 비용을 나타내는 것으로, 테스트 케이스 자체에 포함되는 항목이 아닙니다. 테스트 비용은 프로젝트 관리나 예산 계획에 관련된 정보이지, 실제 테스트를 실행하고 결과를 검증하는 데 직접적으로 사용되는 정보는 아니기 때문입니다.  따라서 테스트 케이스에 일반적으로 포함되지 않는 항목은 테스트 비용입니다.  마치 요리 레시피에 재료와 조리법, 완성된 요리의 모습은 적혀있지만, 재료를 사는데 든 돈은 적혀있지 않은 것과 같은 이치입니다.",82,19
335,1,4,35,소프트웨어 설치 매뉴얼에 포함될 항목이 아닌 것은?,,제품 소프트웨어 개요,설치 관련 파일,프로그램 삭제,소프트웨어 개발 기간,4,"소프트웨어 설치 매뉴얼은 사용자가 소프트웨어를 설치하고 사용하는 데 필요한 모든 정보를 제공하는 안내서입니다.  제품 소프트웨어 개요는 소프트웨어의 기능과 특징을 설명하고, 설치 관련 파일은 설치에 필요한 파일 목록과 위치를 알려줍니다. 프로그램 삭제 방법 또한 사용자가 소프트웨어를 제거하는 데 필요한 절차를 안내하는 중요한 정보입니다. 하지만 소프트웨어 개발 기간은 사용자에게 직접적인 도움을 주는 정보가 아니기 때문에 설치 매뉴얼에 포함될 필요가 없습니다.  개발 기간은 개발자 내부 정보이며, 사용자는 소프트웨어를 어떻게 설치하고 사용하는지에만 관심이 있기 때문입니다. 따라서 소프트웨어 설치 매뉴얼에는 소프트웨어의 사용법과 설치, 삭제 방법 등 사용자에게 필요한 정보만 포함되어야 합니다.",89,17
336,1,4,36,소프트웨어 형상관리(Configuration management)에 관한 설명으로 틀린 것은?,,소프트웨어에서 일어나는 수정이나 변경을 알아내고 제어하는 것을 의미한다.,"소프트웨어 개발의 전체 비용을 줄이고, 개발 과정의 여러 방해 요인이 최소화되도록 보증하는 것을 목적으로 한다.",형상관리를 위하여 구성된 팀을 “chief programmer team”이라고 한다.,형상관리의 기능 중 하나는 버전 제어 기술이다.,3,"소프트웨어 형상관리는 소프트웨어 개발 과정에서 발생하는 변경 사항을 추적하고 관리하여 소프트웨어의 무결성과 일관성을 유지하는 중요한 활동입니다.  소프트웨어 개발에서 수정이나 변경을 추적하고 제어하는 것은 형상관리의 핵심 목표이며, 개발 비용 절감과 방해 요인 최소화에도 기여합니다.  형상관리는 버전 관리 시스템 등 다양한 도구와 기술을 활용하여 이루어집니다. 하지만 형상관리에 종사하는 팀을 ""chief programmer team""이라고 부르는 것은 잘못된 표현입니다.  ""chief programmer team""은 소프트웨어 개발 조직의 한 유형으로, 핵심 프로그래머를 중심으로 팀이 구성되는 방식을 말하지만 형상관리 팀과는 직접적인 관련이 없습니다. 따라서 형상관리에 대한 설명 중 틀린 것은 형상관리 팀을 지칭하는 부분입니다.  쉽게 말해, 소프트웨어를 깔끔하게 관리하고 변경 사항을 잘 추적하는 시스템을 ""형상관리""라고 하는데, 이 시스템을 관리하는 팀을 특정 이름으로 부르는 것은 잘못된 정보입니다.",69,15
337,1,4,37,퀵 정렬에 관한 설명으로 옳은 것은?,,레코드의 키 값을 분석하여 같은 값끼리 그 순서에 맞는 버킷에 분배하였다가 버킷의 순서대로 레코드를 꺼내어 정렬한다.,주어진 파일에서 인접한 두 개의 레코드 키 값을 비교하여 그 크기에 따라 레코드 위치를 서로 교환한다.,레코드의 많은 자료 이동을 없애고 하나의 파일을 부분적으로 나누어 가면서 정렬한다.,임의의 레코드 키와 매개변수(h)값만큼 떨어진 곳의 레코드 키를 비교하여 서로 교환해 가면서 정렬한다.,3,"퀵 정렬은 데이터를 정렬하는 효율적인 알고리즘 중 하나입니다.  이 알고리즘의 핵심은 '분할 정복' 전략에 있습니다.  먼저, 정렬해야 할 데이터 중 하나의 값을 '피벗(pivot)'으로 선택합니다.  그리고 피벗보다 작은 값들은 피벗의 왼쪽으로, 큰 값들은 피벗의 오른쪽으로 이동시킵니다. 이 과정을 통해 데이터는 피벗을 기준으로 두 개의 부분집합으로 나뉘게 됩니다.  이후, 각 부분집합에 대해서도 동일한 과정을 반복하여 재귀적으로 정렬을 수행합니다.  결국, 모든 부분집합이 정렬되면 전체 데이터가 정렬된 상태가 됩니다.  문제에서 제시된 정답은 이러한 퀵 정렬의 특징을 잘 나타내고 있습니다.  하나의 파일을 부분적으로 나누어 정렬하는 과정(분할)과, 각 부분집합에 대해 다시 정렬하는 과정(정복)을 통해 전체 데이터의 정렬을 효율적으로 수행하는 것이 퀵 정렬의 핵심 원리이기 때문입니다.  다른 선지들은 버킷 정렬, 버블 정렬, 쉘 정렬 등 다른 정렬 알고리즘의 특징을 설명하고 있습니다.",53,11
338,1,4,38,해싱 함수(Hashing Function)의 종류가 아닌 것은?,,제곱법(mid-square),숫자분석법(digit analysis),개방주소법(open addressing),제산법(division),3,"해싱 함수는 데이터를 효율적으로 저장하고 검색하기 위해 사용하는 함수입니다.  데이터의 키 값을 입력받아 고유한 주소(해시 값)를 생성하여 데이터를 저장하는데,  제곱법, 숫자분석법, 제산법은 모두 해싱 함수의 종류에 해당합니다.  예를 들어 제곱법은 키 값을 제곱하고 중간 부분을 추출하여 해시 값으로 사용하는 방법이고, 제산법은 키 값을 특정 값으로 나눈 나머지를 해시 값으로 사용하는 방법입니다.  반면, 개방주소법은 해시 충돌(서로 다른 키 값이 같은 해시 값을 갖는 경우)이 발생했을 때, 다른 주소를 찾아 데이터를 저장하는 **충돌 해결 기법**입니다.  따라서 해싱 함수 자체의 종류가 아니라, 해싱 함수를 사용할 때 발생하는 충돌을 해결하는 방법 중 하나인 것이죠.  해싱 함수는 데이터를 저장하는 방법이고, 개방주소법은 저장 공간이 이미 차 있을 때 어떻게 처리할지에 대한 방법이기 때문에 서로 다른 개념입니다.  즉, 개방주소법은 해싱 함수의 종류가 아니라 해시 충돌 해결 기법의 한 종류인 것입니다.",65,11
339,1,4,39,필드 테스팅(field testing)이라고도 불리며 개발자 없이 고객의 사용 환경에 소프트웨어를 설치하여 검사를 수행하는 인수검사 기법은?,,베타 검사,알파 검사,형상 검사,복구 검사,1,"이 문제는 소프트웨어의 인수검사 기법 중, 개발자가 아닌 실제 사용자인 고객이 개발된 소프트웨어를 사용 환경에서 직접 테스트하는 방법을 묻고 있습니다.  '필드 테스팅'이라는 다른 이름으로도 불리는 이 기법은 소프트웨어가 실제 사용 환경에서 제대로 작동하는지, 고객의 요구사항을 충족하는지 확인하는 데 매우 중요한 역할을 합니다.  개발 과정에서 내부적으로 진행되는 테스트와 달리, 실제 사용자의 피드백을 직접 얻을 수 있다는 점이 큰 장점입니다.  따라서 고객의 사용 환경에서 소프트웨어를 설치하여 검사하는 인수검사 기법은 바로  고객에게 소프트웨어를 배포하여 사용하게 하고, 그들의 사용 경험과 발견된 문제점을 수집하는  방법입니다. 이를 통해 실제 사용 환경에서 발생할 수 있는 문제점을 미리 파악하고 개선하여 더욱 완성도 높은 소프트웨어를 출시할 수 있습니다.",81,19
340,1,4,40,다음 트리를 Preorder 운행법으로 운행할 경우 다섯 번째로 탐색되는 것은?,https://www.cbtbank.kr/images/iz/iz20210307/iz20210307m40.gif,C,E,G,H,2,"이 문제는 트리 자료구조를 Preorder 방식으로 순회하는 방법을 묻고 있습니다.  Preorder 방식은  ""현재 노드 → 왼쪽 서브트리 → 오른쪽 서브트리"" 순서로 탐색하는 방식입니다.  트리를 그림으로 보면서 따라가 보겠습니다.",87,11
341,1,4,41,결과 값이 아래와 같을 때 SQL 질의로 옳은 것은?,https://www.cbtbank.kr/images/iz/iz20210307/iz20210307m41.gif,SELECT * FROM 공급자 WHERE,공급자명 LIKE '%신%';,SELECT * FROM 공급자 WHERE,공급자명 LIKE '%대%';,1,"문제에서 제시된 결과는 공급자 테이블에서 '신' 또는 '대'자가 포함된 공급자명을 가진 데이터만을 보여줍니다.  SQL 질의문은 데이터베이스에서 원하는 정보를 추출하는 명령어인데,  이 문제에서는  `WHERE` 절을 이용하여 조건에 맞는 데이터만 선택해야 합니다.  `LIKE` 연산자는 문자열 패턴 매칭에 사용되며, `%`는 임의의 문자열을 나타냅니다. 따라서 '%신%'은 '신'자가 포함된 모든 문자열을 의미하고, '%대%'는 '대'자가 포함된 모든 문자열을 의미합니다.  결과 테이블에는 '신촌상사'와 '대신공업사'만 나타나므로,  '신' 또는 '대'자가 포함된 공급자명을 찾는 질의문이 정답입니다.  각각의 질의문은 '신' 또는 '대'자를 포함하는 공급자명을 찾는 조건을 가지고 있지만, 결과 테이블에 나타난 두 행을 모두 포함하는 질의문만이 정답이 될 수 있습니다.",88,26
342,1,4,42,다음에서 설명하는 스키마(Schema)는?,https://www.cbtbank.kr/images/iz/iz20210307/iz20210307m42.gif,개념 스키마,내부 스키마,외부 스키마,내용 스키마,1,"문제에서 설명하는 스키마는 데이터베이스 전체를 정의하는 개념입니다.  데이터 개체, 관계, 제약 조건, 접근 권한, 무결성 규칙 등 데이터베이스의 구조와 규칙을 모두 포함하고 있죠. 마치 건물의 설계도면과 같다고 생각하면 이해하기 쉬울 거예요. 설계도면에는 건물의 전체적인 구조, 각 방의 위치와 크기, 그리고 건물을 안전하게 사용하기 위한 규칙들이 모두 담겨 있잖아요?  이 스키마도 마찬가지로 데이터베이스라는 건물을 설계하는 청사진 역할을 합니다.  문제에서 설명하는 내용은 데이터베이스의 개념적인 설계를 나타내는 것이므로, 데이터베이스 전체를 포괄적으로 정의하는 개념 스키마가 정답입니다.  내부 스키마는 물리적인 저장 구조를, 외부 스키마는 특정 사용자에게 보이는 데이터의 모습을, 내용 스키마는 데이터 자체를 의미하는 것이므로 문제의 설명과는 맞지 않습니다.",78,29
343,1,4,43,"데이터베이스 설계 단계 중 저장 레코드 양식설계, 레코드 집중의 분석 및 설계, 접근 경로 설계와 관계되는 것은?",,논리적 설계,요구 조건 분석,개념적 설계,물리적 설계,4,"데이터베이스 설계는 크게 개념적 설계, 논리적 설계, 물리적 설계의 세 단계로 나뉩니다.  개념적 설계는 사용자의 요구사항을 분석하여 데이터베이스의 전체적인 구조를 개념적으로 정의하는 단계입니다.  논리적 설계는 개념적 설계 단계에서 정의된 데이터베이스 구조를 실제 데이터베이스 시스템에 독립적인 형태로 구체화하는 단계입니다.  반면, 물리적 설계는 논리적 설계 단계에서 정의된 데이터베이스 구조를 특정 데이터베이스 시스템에 맞춰 실제로 구현하는 단계입니다.  문제에서 언급된 '저장 레코드 양식 설계', '레코드 집중의 분석 및 설계', '접근 경로 설계'는 모두 데이터베이스의 실제 구현과 관련된 내용입니다.  저장 레코드 양식은 데이터를 어떻게 저장할지, 레코드 집중은 데이터를 어떻게 효율적으로 배치할지, 접근 경로는 데이터에 어떻게 빠르게 접근할지를 결정하는 단계입니다.  따라서 이러한 설계는 물리적 설계 단계에서 수행됩니다.  물리적 설계 단계에서는 데이터베이스의 실제 저장 방식, 파일 구조, 인덱스, 접근 경로 등을 결정하여 성능과 효율성을 최적화합니다.  따라서 문제의 정답은 물리적 설계입니다.",66,30
344,1,4,44,다음 릴레이션의 카디널리티와 차수가 옳게 나타낸 것은?,https://www.cbtbank.kr/images/iz/iz20210307/iz20210307m44.gif,"카디널리티 : 4, 차수 : 4","카디널리티 : 4, 차수 : 6","카디널리티 : 6, 차수 : 4","카디널리티 : 6, 차수 : 6",2,"이 문제는 관계형 데이터베이스에서 중요한 개념인 카디널리티와 차수를 묻고 있습니다.  먼저, 카디널리티는 릴레이션(테이블)에 있는 튜플(행)의 개수를 의미합니다.  문제에서 주어진 데이터를 보면, 아이디, 성명, 나이, 등급, 적립금, 가입년도라는 6개의 속성(열)을 가지는 테이블에 총 4개의 튜플(행, 각 사람의 정보)이 존재합니다. 따라서 카디널리티는 4입니다.  다음으로, 차수는 릴레이션이 가지는 속성(열)의 개수를 의미합니다.  문제의 테이블은 아이디, 성명, 나이, 등급, 적립금, 가입년도의 총 6개의 속성을 가지고 있으므로, 차수는 6입니다.  따라서 정답은 카디널리티 4, 차수 6이 됩니다.  쉽게 말해, 카디널리티는 테이블의 행 개수이고, 차수는 테이블의 열 개수입니다. 문제에서 주어진 테이블을 잘 살펴보면 행의 개수와 열의 개수를 쉽게 파악할 수 있습니다.",76,29
345,1,4,45,다음과 같은 트랙잭션의 특성은?,https://www.cbtbank.kr/images/iz/iz20210307/iz20210307m45.gif,원자성(atomicity),일관성(consistency),격리성(isolation),영속성(durability),2,"문제에서 제시된 트랜잭션의 특성은 ""시스템이 가지고 있는 고정요소는 트랜잭션 수행 전과 트랜잭션 수행 완료 후의 상태가 같아야 한다"" 입니다.  이는 데이터베이스의 일관성을 유지하는 것을 의미합니다.  트랜잭션이 여러 작업을 수행하더라도, 그 결과는 마치 하나의 작업처럼 데이터베이스의 일관성을 유지해야 합니다.  예를 들어, 계좌 이체 트랜잭션을 생각해봅시다.  A 계좌에서 B 계좌로 1000원을 이체하는 작업은 A 계좌에서 1000원을 빼고 B 계좌에 1000원을 더하는 두 개의 작업으로 이루어집니다.  만약 첫 번째 작업(A 계좌에서 1000원 빼기)만 성공하고 두 번째 작업(B 계좌에 1000원 더하기)이 실패한다면, 전체 시스템의 데이터는 불일치하게 됩니다.  이러한 불일치를 방지하기 위해 트랜잭션은 '일관성'이라는 특성을 가져야 합니다.  트랜잭션이 완료되면 데이터베이스는 일관된 상태를 유지해야 하며, 트랜잭션이 실패하면 원래 상태로 되돌아가야 합니다.  따라서 문제에서 제시된 설명은 트랜잭션의 일관성(consistency)을 정확하게 나타내고 있습니다.",79,27
346,1,4,46,병행제어의 로킹(Locking) 단위에 대한 설명으로 옳지 않은 것은?,,"데이터베이스, 파일, 레코드 등은 로킹 단위가 될 수 있다.",로킹 단위가 작아지면 로킹 오버헤드가 증가한다.,한꺼번에 로킹할 수 있는 단위를 로킹단위라고 한다.,로킹 단위가 작아지면 병행성 수준이 낮아진다.,4,"병행 제어에서 로킹(Locking)은 여러 사용자가 동시에 데이터를 접근하여 데이터의 일관성을 유지하기 위해 사용하는 중요한 기법입니다.  여러 사용자가 동시에 같은 데이터를 변경하려고 시도하면 데이터가 손상될 수 있기 때문에, 로킹을 통해 특정 사용자에게만 데이터에 대한 접근 권한을 일시적으로 부여합니다.  로킹 단위는 한 번에 잠글 수 있는 데이터의 크기를 의미하는데, 이 단위가 작을수록 더 세분화된 제어가 가능해집니다.  예를 들어, 로킹 단위가 데이터베이스 전체라면 한 사용자가 데이터베이스 전체를 잠근 상태에서 작업을 수행하므로 다른 사용자는 아무것도 할 수 없습니다. 반면에 로킹 단위가 레코드 단위라면, 한 사용자가 특정 레코드만 잠그고 작업하므로 다른 사용자는 다른 레코드에 접근하여 작업할 수 있습니다.  따라서 로킹 단위가 작아지면, 더 많은 사용자가 동시에 작업할 수 있게 되어 병행성이 높아집니다.  하지만 로킹 단위가 너무 작으면, 로킹을 관리하는 오버헤드가 증가하여 시스템 성능이 저하될 수 있습니다.  문제에서 옳지 않은 설명은 로킹 단위가 작아지면 병행성 수준이 낮아진다는 것입니다.  오히려 로킹 단위가 작아지면 더 많은 사용자가 동시에 작업할 수 있으므로 병행성 수준이 높아집니다.  즉, 작은 로킹 단위는 더 많은 동시 접근을 허용하지만, 관리 오버헤드 증가라는 단점을 동시에 가지고 있습니다.",83,31
347,1,4,47,뷰(VIEW)에 대한 설명으로 옳지 않은 것은?,,DBA는 보안 측면에서 뷰를 활용할 수 있다.,뷰 위에 또 다른 뷰를 정의할 수 있다.,"뷰에 대한 삽입, 갱신, 삭제 연산 시 제약사항이 따르지 않는다.",독립적인 인덱스를 가질 수 없다.,3,"뷰(VIEW)는 기존 테이블을 기반으로 만들어진 가상 테이블입니다.  쉽게 말해, 복잡한 SQL 쿼리 결과를 미리 저장해 놓은 것처럼 사용할 수 있는 편리한 기능이죠.  DBA(데이터베이스 관리자)는 이 뷰를 이용해 특정 사용자에게는 특정 열만 보이도록 제한하는 등 보안을 강화할 수 있습니다. 또한, 이미 만들어진 뷰를 기반으로 새로운 뷰를 만들 수도 있습니다.  하지만 뷰는 실제 데이터를 저장하는 것이 아니라 기존 테이블의 데이터를 참조하기 때문에, 뷰에 직접 데이터를 삽입하거나 수정, 삭제하는 데에는 제약이 따릅니다.  기존 테이블의 구조나 제약 조건에 따라 뷰에서의 삽입, 갱신, 삭제 연산이 허용되지 않거나 제한될 수 있기 때문입니다.  마지막으로, 뷰는 독립적인 인덱스를 가질 수 없습니다.  인덱스는 데이터 접근 속도를 높이기 위해 사용되는데, 뷰는 실제 데이터를 가지고 있지 않으므로 독립적인 인덱스를 생성할 수 없습니다. 따라서 뷰에 대한 설명 중 옳지 않은 것은 삽입, 갱신, 삭제 연산에 제약이 따르지 않는다는 설명입니다.",79,28
348,1,4,48,다음 정의에서 말하는 기본 정규형은?,https://www.cbtbank.kr/images/iz/iz20210307/iz20210307m48.gif,제1정규형(1NF),제2정규형(2NF),제3정규형(3NF),보이스/코드 정규형(BCNF),1,"문제에서 설명하는 ""어떤 릴레이션 R에 속한 모든 도메인이 원자값(Atomic Value)만으로 되어 있다""는 것은,  데이터베이스 테이블의 각 셀(도메인)에 더 이상 쪼갤 수 없는 단일 값만 저장되어 있다는 의미입니다.  예를 들어, 주소라는 컬럼에 ""서울시 강남구 역삼동 123-45"" 와 같이 여러 값이 합쳐져 있는 것이 아니라, ""서울시"", ""강남구"", ""역삼동"", ""123-45"" 와 같이 각각의 셀에 하나의 값만 저장되어야 한다는 뜻입니다.  이러한 조건을 만족하는 가장 기본적인 정규형이 바로 제1정규형(1NF)입니다.  제2정규형(2NF) 이상의 정규형들은 제1정규형을 만족해야 하는 전제조건을 가지고 있으며, 부분 함수 종속이나 전이 종속 등의 추가적인 조건을 만족해야 합니다. 따라서, 문제에서 제시된 조건은 제1정규형의 정의와 정확하게 일치합니다.  즉, 모든 도메인이 원자값으로 구성되어 있다면, 그 릴레이션은 최소한 제1정규형을 만족한다는 것을 의미합니다.",84,30
349,1,4,49,릴레이션 R1에 속한 애튜리뷰트의 조합인 외래키를 변경하려면 이를 참조하고 있는 릴레이션 R2의 기본키도 변경해야 하는데 이를 무엇이라 하는가?,,정보 무결성,고유 무결성,널 제약성,참조 무결성,4,"릴레이션 R1의 외래키는 R2의 기본키를 참조합니다.  쉽게 말해, R1이라는 테이블에 있는 특정 정보가 R2라는 테이블의 정보와 연결되어 있다는 것을 나타내는 것이 외래키입니다.  예를 들어, R1이 '주문' 테이블이고, R2가 '고객' 테이블이라고 생각해봅시다.  R1의 '고객ID' 컬럼이 외래키라면, 이 값은 R2 테이블의 '고객ID' 컬럼(기본키)에 존재하는 값이어야 합니다.  만약 R2 테이블의 기본키인 '고객ID'를 변경한다면, R1 테이블의 '고객ID' 값도 일관성을 유지하기 위해 함께 변경되어야 합니다.  그렇지 않으면 R1 테이블의 '고객ID'가 R2 테이블에 존재하지 않는 값을 참조하게 되어 데이터의 무결성이 깨지게 됩니다.  이처럼 외래키와 기본키 사이의 참조 관계를 유지하는 무결성을 '참조 무결성'이라고 합니다.  따라서 R1의 외래키를 변경하려면 R2의 기본키도 변경해야 하는데, 이는 데이터베이스의 일관성과 정확성을 유지하기 위한 필수적인 조건입니다.",88,33
350,1,4,50,시스템 카탈로그에 대한 설명으로 틀린 것은?,,시스템 카탈로그의 갱신은 무결성 유지를 위하여 SQL을 이용하여 사용자가 직접 갱신하여야 한다.,데이터베이스에 포함되는 데이터 객체에 대한 정의나 명세에 대한 정보를 유지관리한다.,DBMS가 스스로 생성하고 유지하는 데이터베이스 내의 특별한 테이블의 집합체이다.,카탈로그에 저장된 정보를 메타 데이터라고도 한다.,1,"시스템 카탈로그는 데이터베이스 시스템의 '메타데이터'를 저장하는 특별한 데이터베이스입니다.  메타데이터란 데이터에 대한 정보, 즉 데이터베이스 내의 테이블 구조, 컬럼 정보, 인덱스 정보 등 데이터 자체가 아닌 데이터를 설명하는 정보를 의미합니다.  DBMS(데이터베이스 관리 시스템)는 이러한 메타데이터를 스스로 관리하고 갱신하며, 사용자가 직접 SQL을 이용하여 수정할 필요가 없습니다.  사용자가 직접 수정하게 되면 데이터베이스의 무결성이 깨질 위험이 있기 때문입니다.  따라서 시스템 카탈로그는 DBMS가 자동으로 관리하는 특별한 테이블 집합체이며,  메타데이터를 저장하는 역할을 합니다.  문제에서 틀린 설명은 바로 사용자가 직접 SQL을 이용하여 시스템 카탈로그를 갱신해야 한다는 부분입니다.  이는 DBMS가 자동으로 관리하기 때문에 잘못된 설명입니다.",80,29
351,1,4,51,"조건을 만족하는 릴레이션의 수평적 부분집합으로 구성하며, 연산자의 기호는 그리스 문자 시그마(σ)를 사용하는 관계대수 연산은?",,Select,Project,Join,Division,1,"이 문제는 관계대수라는 데이터베이스 연산에 대한 이해를 묻고 있습니다.  관계대수는 관계형 데이터베이스에서 데이터를 조작하는 방법 중 하나로,  수학적 집합 이론을 기반으로 합니다. 문제에서 ""조건을 만족하는 릴레이션의 수평적 부분집합으로 구성""이라는 표현은 특정 조건에 맞는 행(row)들만 선택한다는 의미입니다.  릴레이션은 데이터베이스의 테이블을 의미하며, 수평적 부분집합은 테이블의 일부 행을 선택하는 것을 말합니다.  그리고 ""연산자의 기호는 그리스 문자 시그마(σ)를 사용한다""는 것은 관계대수에서 선택 연산을 나타내는 기호가 시그마(σ)라는 것을 의미합니다.  관계대수의 선택 연산은 특정 조건을 만족하는 튜플(행)만을 선택하여 새로운 릴레이션을 생성하는 연산입니다.  이러한 특징은 관계형 데이터베이스에서 데이터를 선택하는  Select 연산과 정확히 일치합니다.  Project 연산은 특정 속성(열)만을 선택하는 것이고, Join 연산은 두 개의 릴레이션을 결합하는 것이며, Division 연산은 두 릴레이션의 나눗셈 연산을 수행하는 것으로, 문제에서 제시된 ""조건을 만족하는 릴레이션의 수평적 부분집합""이라는 설명과는 일치하지 않습니다. 따라서 정답은 Select 연산입니다.  쉽게 말해,  엑셀에서 특정 조건에 맞는 행만 필터링하는 기능과 같은 역할을 하는 것이 Select 연산입니다.",75,29
352,1,4,52,"SQL에서 스키마(schema), 도메인(domain), 테이블(table), 뷰(view), 인덱스(index)를 정의하거나 변경 또는 삭제할 때 사용하는 언어는?",,DML(Data Manipulation Language),DDL(Data Definition Language),DCL(Data Control Language),IDL(Interactive Data Language),2,"SQL은 데이터베이스를 관리하는 데 사용되는 언어입니다.  데이터베이스를 구성하는 기본 요소인 스키마(데이터베이스의 구조), 도메인(데이터의 자료형), 테이블(데이터를 저장하는 공간), 뷰(테이블의 특정 부분을 보여주는 가상 테이블), 인덱스(데이터 검색 속도를 높이는 기능) 등을 정의하거나 변경, 삭제하는 작업은 데이터베이스의 구조 자체를 다루는 작업입니다.  이러한 데이터베이스 구조를 정의하고 관리하는 언어를 DDL(Data Definition Language), 즉 데이터 정의 언어라고 합니다. 반면, 데이터를 조작하는 언어는 DML(Data Manipulation Language), 데이터 접근을 제어하는 언어는 DCL(Data Control Language)입니다. IDL(Interactive Data Language)는 문제와 관련이 없는 용어입니다. 따라서 스키마, 도메인, 테이블, 뷰, 인덱스 등을 다루는 작업에는 DDL이 사용됩니다.  마치 건물을 짓는 과정에서 설계도를 그리는 작업이 DDL에 해당한다고 생각하면 이해하기 쉽습니다. 설계도(DDL)가 있어야 건물(데이터베이스)을 지을 수 있고, 그 후에 건물 내부를 사용하고 관리하는 작업(DML, DCL)이 이루어지는 것입니다.",77,27
353,1,4,53,정규화를 거치지 않아 발생하게 되는 이상(anomaly) 현상의 종류에 대한 설명으로 옳지 않은 것은?,,삭제 이상이란 릴레이션에서 한 튜플을 삭제할 때 의도와는 상관없는 값들도 함께 삭제되는 연쇄 삭제 현상이다.,삽입 이상이란 릴레이션에서 데이터를 삽입할 때 의도와는 상관없이 원하지 않는 값들도 함께 삽입되는 현상이다.,갱신 이상이란 릴레이션에서 튜플에 있는 속성값을 갱신할 때 일부 튜플의 정보만 갱신되어 정보에 모순이 생기는 현상이다.,종속 이상이란 하나의 릴레이션에 하나 이상의 함수적 종속성이 존재하는 현상이다.,4,"이 문제는 데이터베이스 정규화 과정에서 발생하는 이상 현상에 대한 이해도를 묻는 문제입니다.  정규화는 데이터 중복을 줄이고 데이터 무결성을 높이기 위한 데이터베이스 설계 기법입니다.  정규화가 제대로 이루어지지 않으면 데이터베이스에 여러 가지 문제가 발생하는데, 이를 이상 현상(anomaly)이라고 합니다.  잘못된 선지는 하나의 릴레이션(테이블)에 여러 함수적 종속성이 존재하는 것을 이상 현상으로 설명하고 있습니다.  하지만 함수적 종속성 자체는 이상 현상이 아닙니다.  함수적 종속성은 데이터베이스의 구조를 나타내는 것이며,  이러한 종속성이 잘못 설계되어 중복이나 불일치를 야기할 때 이상 현상이 발생하는 것입니다.  다른 선지들은 데이터를 삽입, 삭제, 갱신할 때 발생하는 문제점들을 정확하게 설명하고 있습니다.  즉,  잘못된 선지는 정규화의 개념과 이상 현상의 원인을 혼동하고 있는 것입니다.  정규화는 여러 개의 함수적 종속성을 가진 릴레이션을 여러 개의 작은 릴레이션으로 분해하여 이상 현상을 방지하는 기법입니다.  따라서 하나의 릴레이션에 여러 함수적 종속성이 있다는 사실 자체가 이상 현상은 아닙니다.  이상 현상은 잘못된 함수적 종속성으로 인해 발생하는 데이터의 불일치나 중복과 같은 문제를 의미합니다.",73,30
354,1,4,54,관계 데이터 모델에서 릴레이션(relation)에 관한 설명으로 옳은 것은?,,"릴레이션의 각 행을 스키마(schema)라 하며, 예로 도서 릴레이션을 구성하는 스키마에서는 도서번호, 도서명, 저자, 가격 등이 있다.","릴레이션의 각 열을 튜플(tuple)이라 하며, 하나의 튜플은 각 속성에서 정의된 값을 이용하여 구성된다.",도메인(domain)은 하나의 속성이 가질 수 있는 같은 타입의 모든 값의 집합으로 각 속성의 도메인은 원자값을 갖는다.,속성(attribute)은 한 개의 릴레이션의 논리적인 구조를 정의한 것으로 릴레이션의 이름과 릴레이션에 포함된 속성들의 집합을 의미한다.,3,"관계 데이터 모델에서 릴레이션은 데이터를 표 형태로 나타낸 것을 말합니다.  표의 각 행은 하나의 레코드, 즉 특정 개체에 대한 정보를 나타내고, 이를 '튜플'이라고 부릅니다. 예를 들어 '도서'라는 릴레이션이 있다면, 각 행은 하나의 책에 대한 정보(도서번호, 도서명, 저자, 가격 등)를 담고 있는 튜플이 됩니다. 반대로 표의 각 열은 특정 속성(예: 도서번호, 도서명)을 나타내며, 각 속성은 특정 타입의 값(예: 도서번호는 숫자, 도서명은 문자열)만 가질 수 있습니다. 이러한 값들의 집합을 '도메인'이라고 합니다.  '스키마'는 릴레이션의 구조, 즉 어떤 속성들을 가지고 있는지를 정의하는 것이지, 각 행(튜플)을 의미하는 것은 아닙니다. 마지막으로, 속성은 릴레이션의 구조를 정의하는 것이지만, 릴레이션의 이름과 속성들의 집합을 모두 의미하는 것은 아닙니다.  따라서, 도메인이 각 속성이 가질 수 있는 같은 타입의 모든 값의 집합이고, 각 속성의 도메인은 원자값(더 이상 나눌 수 없는 값)을 갖는다는 설명만이 정확합니다.  쉽게 말해,  '도서'라는 표에서 '도서명'이라는 열은 '소설', '수필', '시' 등의 문자열 값을 가질 수 있고, 이러한 문자열 값들의 집합이 '도서명' 속성의 도메인이 되는 것입니다.",66,27
355,1,4,55,3NF에서 BCNF가 되기 위한 조건은?,,이행적 함수 종속 제거,부분적 함수 종속 제거,다치 종속 제거,결정자이면서 후보 키가 아닌 것 제거,4,"BCNF(Boyce-Codd Normal Form)는 3NF보다 더 강력한 정규화 형태입니다.  3NF는 부분 함수 종속을 제거하여 데이터 중복을 최소화하지만,  BCNF는 3NF에서 해결하지 못하는 특정 문제를 해결합니다.  그 문제는 바로 ""결정자이면서 후보 키가 아닌 것""의 존재입니다.  쉽게 설명하자면,  어떤 속성(A)가 다른 속성(B)를 결정하는데(A → B), A가 후보키가 아니라면 데이터 중복이 발생할 가능성이 있습니다.  BCNF는 이러한 상황을 제거하여 데이터 중복을 더욱 완벽하게 방지하고 데이터 무결성을 높입니다.  따라서 3NF에서 BCNF로 가기 위해서는 결정자이면서 후보 키가 아닌 것을 제거해야 합니다.  후보키가 아닌 결정자는 데이터 중복을 야기하는 원인이 되므로, 이를 제거함으로써 데이터베이스의 효율성과 무결성을 향상시킬 수 있습니다.  이는 정보처리기사 공식 교재의 데이터베이스 정규화 부분에서 자세히 설명하고 있습니다.",77,30
356,1,4,56,"데이터베이스 성능에 많은 영향을 주는 DBMS의 구성 요소로 테이블과 클러스터에 연관되어 독립적인 저장 공간을 보유하며, 데이터베이스에 저장된 자료를 더욱 빠르게 조회하기 위하여 사용되는 것은?",,인덱스(Index),트랙잭션(Transaction),역정규화(Denormalization),트리거(Trigger),1,"데이터베이스는 방대한 양의 데이터를 저장하고 관리하는 시스템입니다.  데이터베이스에 저장된 자료를 찾는 작업은 마치 거대한 도서관에서 특정 책을 찾는 것과 같습니다. 책의 제목이나 저자를 알고 있다면 쉽게 찾을 수 있겠지만, 책의 모든 내용을 일일이 확인하며 찾는다면 엄청난 시간이 걸릴 것입니다.  인덱스는 바로 이러한 문제를 해결하기 위해 존재합니다.  인덱스는 책의 목차와 같습니다.  데이터베이스 내 특정 열(컬럼)의 값을 기준으로 데이터의 위치를 미리 저장해 놓은 일종의 '주소록'입니다.  따라서, 특정 데이터를 찾고자 할 때, 인덱스를 이용하면 데이터베이스 전체를 검색할 필요 없이 인덱스를 통해 바로 해당 데이터의 위치를 찾아갈 수 있기 때문에 검색 속도가 훨씬 빨라집니다.  테이블과 클러스터는 데이터가 저장되는 공간을 나타내고, 인덱스는 이러한 공간에 독립적으로 존재하며 데이터 접근 속도를 향상시키는 역할을 합니다.  나머지 선택지들은 데이터베이스의 성능에 영향을 주는 요소이지만, 데이터 조회 속도 향상을 위해 테이블 및 클러스터와 독립적인 저장 공간을 사용하는 것은 인덱스의 주요 특징입니다.",75,28
357,1,4,57,아래의 SQL문을 실행한 결과는?,https://www.cbtbank.kr/images/iz/iz20210307/iz20210307m57.gif,https://www.cbtbank.kr/images/iz/iz20210307/iz20210307m57b1.gif,https://www.cbtbank.kr/images/iz/iz20210307/iz20210307m57b2.gif,https://www.cbtbank.kr/images/iz/iz20210307/iz20210307m57b3.gif,https://www.cbtbank.kr/images/iz/iz20210307/iz20210307m57b4.gif,2,"이 SQL 문은 R2 테이블에서 과목번호가 'C100'인 레코드들의 학번을 먼저 찾습니다.  `SELECT 학번 FROM R2 WHERE 과목번호 = 'C100'` 부분이 이 작업을 수행하는데, R2 테이블을 살펴보면 과목번호가 'C100'인 학번은 1000번과 3000번, 4000번 학생입니다.  이후 `WHERE 학번 IN (...)` 부분은 R1 테이블에서 이렇게 찾은 학번(1000, 3000, 4000)을 가진 학생들의 이름을 가져옵니다. 따라서 최종적으로 출력되는 결과는 학번 1000, 3000, 4000번 학생들의 이름이 됩니다.  R1 테이블에서 해당 학번의 이름을 확인하면 홍길동, 강남길, 오일자임을 알 수 있습니다.  따라서 정답은 홍길동, 강남길, 오일자의 이름을 출력하는 것입니다.  문제에서 오일자의 이름이 오말자로 잘못 기재되었지만, SQL문의 실행 결과는 R1 테이블의 데이터를 기반으로 하므로 오일자로 출력됩니다.",87,28
358,1,4,58,『회원』테이블 생성 후 『주소』 필드(컬럼)가 누락되어 이를 추가하려고 한다. 이에 적합한 SQL명령어는?,,DELETE,RESTORE,ALTER,ACCESS,3,"데이터베이스에 이미 생성된 테이블에 새로운 필드(컬럼)을 추가하려면 `ALTER TABLE` 명령어를 사용합니다.  마치 레고 블록을 조립하듯이, 이미 만들어진 테이블이라는 블록에 새로운 블록(필드)을 추가하는 것이라고 생각하면 쉽습니다.  `DELETE`는 데이터를 삭제하는 명령어이고, `RESTORE`는 백업 데이터를 복구하는 명령어이며, `ACCESS`는 접근 권한과 관련된 명령어이므로 테이블 구조를 변경하는 목적에는 적합하지 않습니다. 따라서 기존 테이블에 '주소' 필드를 추가하기 위해서는 테이블 구조를 변경하는 `ALTER TABLE` 명령어가 가장 적절합니다.  예를 들어,  '회원' 테이블에 '주소'라는 필드를 추가하려면  `ALTER TABLE 회원 ADD COLUMN 주소 VARCHAR(255);` 와 같은 SQL 문을 사용할 수 있습니다.  이는 '회원' 테이블을 변경(ALTER)하여 '주소'라는 컬럼을 추가(ADD COLUMN)하라는 의미입니다.  `VARCHAR(255)`는 주소 필드의 데이터 타입을 문자열로 지정하고, 최대 255자까지 저장할 수 있도록 설정한 것입니다.",88,27
359,1,4,59,트랙잭션을 수행하는 도중 장애로 인해 손상된 데이터베이스를 손상되기 이전에 정상적인 상태로 복구시키는 작업은?,,Recovery,Commit,Abort,Restart,1,"데이터베이스 트랜잭션이란, 데이터베이스에 대한 일련의 작업들을 하나의 논리적 단위로 묶은 것을 말합니다.  예를 들어, 은행 계좌 이체를 생각해보면,  'A 계좌에서 1000원 출금'과 'B 계좌에 1000원 입금'이라는 두 개의 작업이 하나의 트랜잭션으로 이루어집니다.  이 과정에서 문제가 발생하면(예: 시스템 장애)  A 계좌에서만 돈이 빠져나가고 B 계좌에는 입금되지 않는 등 데이터베이스가 불일치 상태에 빠질 수 있습니다.  이러한 불일치 상태를 방지하기 위해 데이터베이스 시스템은 트랜잭션의 모든 작업이 완료되면 'Commit'을 수행하여 변경 사항을 영구적으로 저장하고, 작업 중 오류가 발생하면 'Abort'를 수행하여 변경 사항을 취소하고 이전의 정상적인 상태로 되돌립니다.  문제에서 언급하는 ""손상되기 이전의 정상적인 상태로 복구""는 바로 이 'Abort'와 유사한 작업이며,  데이터베이스 시스템의 'Recovery' 기능을 통해 이루어집니다.  Recovery는 시스템 장애 발생 후 데이터베이스의 일관성을 유지하기 위해 손상된 데이터를 복구하는 과정을 의미합니다.  따라서 트랜잭션 수행 중 장애로 인해 손상된 데이터베이스를 이전의 정상적인 상태로 되돌리는 작업은 'Recovery'라고 할 수 있습니다.",85,27
360,1,4,60,E-R 다이어그램의 표기법으로 옳지 않은 것은?,,개체타입 - 사각형,속성 - 타원,관계집합 - 삼각형,개체타입과 속성을 연결 ? 선,3,"E-R 다이어그램은 데이터베이스 설계에서 개체와 개체 간의 관계를 시각적으로 표현하는 도구입니다.  사각형은 개체(Entity)를, 타원은 속성(Attribute)을, 그리고 선은 개체와 속성 또는 개체 간의 관계를 나타냅니다.  하지만 관계(Relationship)는 다이아몬드 모양으로 표현합니다.  문제에서 삼각형으로 관계를 표현하는 것은 E-R 다이어그램의 표기법과 일치하지 않으므로 옳지 않은 표기법입니다.  쉽게 말해, E-R 다이어그램은 데이터베이스의 설계도와 같은데,  집을 설계할 때 방(개체)과 문(관계), 그리고 방 안의 가구(속성)을 표현하는 도구라고 생각하면 이해하기 쉬울 것입니다.  그런데 집의 설계도에서 방을 표현하는 데는 사각형을, 가구를 표현하는 데는 타원을, 그리고 방과 방 사이의 통로(관계)를 표현하는 데는 삼각형이 아닌 다이아몬드를 사용하는 것과 같습니다. 따라서 삼각형으로 관계를 표현하는 것은 잘못된 표현입니다.",85,30
361,1,4,61,다음 중 응집도가 가장 높은 것은?,,절차적 응집도,순차적 응집도,우연적 응집도,논리적 응집도,2,"소프트웨어 모듈의 응집도는 모듈 내부 요소들의 관련성을 나타내는 척도입니다.  응집도가 높다는 것은 모듈 내부 요소들이 서로 밀접하게 관련되어 하나의 목적을 위해 함께 동작한다는 의미이고, 응집도가 낮다는 것은 모듈 내부 요소들이 서로 관련성이 적거나 아예 무관하다는 것을 의미합니다.  여러 종류의 응집도 중에서 '순차적 응집도'는 하나의 작업을 수행하기 위해 여러 단계의 처리가 순차적으로 이루어지는 경우를 말합니다.  각 단계는 앞 단계의 결과를 이용하여 다음 단계를 수행하는 연속적인 흐름을 가지므로, 요소 간의 관련성이 매우 높습니다.  반면, 다른 응집도 유형들은 순차적 응집도보다 요소 간의 관련성이 상대적으로 낮습니다. 예를 들어, '우연적 응집도'는 모듈 내 요소들이 아무런 관련성 없이 묶여 있는 경우이고, '논리적 응집도'는 여러 기능을 하나의 모듈에 묶어 놓은 경우로, 기능 간의 연관성은 있지만 순차적 응집도처럼 밀접한 관계는 아닙니다. '절차적 응집도'는 여러 기능이 하나의 절차를 수행하기 위해 묶여 있지만, 순차적 응집도처럼 엄격한 순차적 의존성은 없습니다. 따라서, 요소 간의 관련성이 가장 높은 것은 순차적 응집도입니다.  쉽게 말해, 순차적 응집도는 레고 블록을 순서대로 쌓아 올리는 것과 같이, 각 블록(요소)이 다음 블록과 밀접하게 연결되어 하나의 완성된 구조물(모듈)을 만드는 것입니다. 다른 응집도들은 블록들이 제멋대로 섞여 있거나, 기능이 비슷한 블록들이 묶여 있지만, 순차적인 연결성은 부족합니다.",63,6
362,1,4,62,"OSI 7계층에서 물리적 연결을 이용해 신뢰성 있는 정보를 전송하려고 동기화, 오류제어, 흐름제어 등의 전송에러를 제어하는 계층은?",,데이터 링크 계층,물리 계층,응용 계층,표현 계층,1,"OSI 7계층은 네트워크 통신을 7개의 계층으로 나누어 각 계층이 특정 기능을 담당하도록 설계된 모델입니다.  문제에서 ""물리적 연결을 이용해 신뢰성 있는 정보를 전송하려고 동기화, 오류제어, 흐름제어 등의 전송 에러를 제어하는 계층""을 묻고 있습니다.  물리 계층은 가장 하위 계층으로 케이블과 같은 물리적인 매체를 통해 데이터를 전송하는 역할만 수행합니다.  따라서 오류 제어나 흐름 제어와 같은 신뢰성 확보 기능은 담당하지 않습니다.  응용 계층은 사용자에게 직접적인 서비스를 제공하는 계층이며, 표현 계층은 데이터의 형식을 변환하는 역할을 합니다.  반면, 데이터 링크 계층은 물리 계층 위에 위치하며, 물리 계층을 통해 전송되는 데이터의 오류를 검출하고 수정하는 역할을 합니다.  또한, 여러 장비 간의 데이터 전송을 위한 동기화와 흐름 제어를 담당하여 안정적인 데이터 전송을 보장합니다.  즉, 동기화, 오류 제어, 흐름 제어와 같은 기능을 통해 신뢰성 있는 데이터 전송을 담당하는 계층은 데이터 링크 계층입니다.  마치 편지를 부치는 과정에 비유하자면, 물리 계층은 우체국에 편지를 맡기는 행위에 해당하고, 데이터 링크 계층은 편지가 제대로 상대방에게 도착하도록 주소를 확인하고, 분실이나 파손을 방지하는 등의 안전장치를 마련하는 역할에 비유할 수 있습니다.",71,45
363,1,4,63,운영체제를 기능에 따라 분류할 경우 제어 프로그램이 아닌 것은?,,데이터 관리 프로그램,서비스 프로그램,작업 제어 프로그램,감시 프로그램,2,"운영체제는 컴퓨터 시스템의 자원(하드웨어, 소프트웨어)을 관리하고 사용자에게 시스템을 사용할 수 있도록 하는 소프트웨어입니다.  운영체제의 기능을 크게 제어 프로그램과 서비스 프로그램으로 나눌 수 있습니다.  제어 프로그램은 시스템의 자원을 효율적으로 관리하고, 여러 프로그램의 실행을 조율하는 역할을 합니다.  여기에는 데이터 관리, 작업 제어, 감시 등의 프로그램이 포함됩니다.  반면 서비스 프로그램은 사용자에게 직접적인 서비스를 제공하는 프로그램으로,  문서 편집, 계산 등의 응용 프로그램을 실행하는 데 필요한 환경을 제공합니다. 문제에서 제어 프로그램이 아닌 것을 묻고 있으므로, 사용자에게 직접적인 서비스를 제공하는 프로그램, 즉 서비스 프로그램이 정답입니다.  데이터 관리, 작업 제어, 감시 프로그램은 모두 시스템 자원을 관리하고 제어하는 제어 프로그램의 역할에 해당합니다.",68,44
364,1,4,64,IEEE 802.3 LAN에서 사용되는 전송매체 접속제어(MAC) 방식은?,,CSMA/CD,Token Bus,Token Ring,Slotted Ring,1,"이 문제는 IEEE 802.3 LAN, 즉 이더넷(Ethernet)에서 사용되는 네트워크 통신 방식을 묻고 있습니다.  이더넷은 여러 대의 컴퓨터가 하나의 네트워크 케이블을 공유하여 통신하는 방식인데,  여러 컴퓨터가 동시에 데이터를 전송하려고 하면 충돌이 발생할 수 있습니다.  따라서 이러한 충돌을 감지하고 해결하는 메커니즘이 필요한데,  정답으로 제시된 방식은 바로 CSMA/CD(Carrier Sense Multiple Access with Collision Detection)입니다.  CSMA/CD는 데이터를 전송하기 전에 네트워크 케이블이 사용 중인지 감지(Carrier Sense)하고, 만약 사용 중이 아니라면 데이터를 전송합니다.  만약 데이터 전송 중에 충돌이 감지되면(Collision Detection),  일정 시간을 기다린 후 다시 데이터를 전송하는 방식입니다.  다른 선택지들은 토큰(Token)이라는 특별한 제어 신호를 사용하여 네트워크 접근을 제어하는 방식으로, 이더넷에서는 사용되지 않습니다.  즉, 이더넷의 핵심적인 특징인 충돌 감지 및 해결 메커니즘을 가장 잘 설명하는 것이 CSMA/CD이기 때문에 정답입니다.  쉽게 말해, 여러 사람이 한 통로를 사용하는데, 사용 전에 통로가 비어있는지 확인하고, 사용 중이면 기다렸다가 사용하는 방식이라고 생각하면 이해하기 쉬울 것입니다.",66,45
365,1,4,65,"기억공간이 15K, 23K, 22K, 21K 순으로 빈 공간이 있을 때 기억장치 배치 전력으로 “First Fit”을 사용하여 17K의 프로그램을 적재할 경우 내부단편화의 크기는 얼마인가?",,5K,6K,7K,8K,2,"이 문제는 기억장치 배치 전략 중 ""First Fit"" 전략을 이해하고 있는지를 묻는 문제입니다.  First Fit 전략은 빈 공간 중 가장 먼저 발견되는 크기가 충분한 공간에 프로그램을 적재하는 방식입니다.  문제에서 주어진 기억공간은 15K, 23K, 22K, 21K의 크기를 가지고 있으며, 17K 크기의 프로그램을 적재해야 합니다.  First Fit 전략에 따라 가장 먼저 만나는 15K 공간은 17K 프로그램을 적재하기에는 부족합니다.  다음으로 23K 공간을 만나게 되는데, 이 공간은 17K 프로그램을 적재하기에 충분합니다.  따라서 17K 프로그램은 23K 공간에 적재되고, 남는 공간은 23K - 17K = 6K가 됩니다. 이 남는 6K 공간이 바로 내부 단편화입니다. 내부 단편화란 할당된 기억 공간 내에서 사용되지 않고 남는 공간을 의미합니다.  따라서 17K 프로그램 적재 후 발생하는 내부 단편화의 크기는 6K입니다.",82,11
366,1,4,66,교착상태가 발생할 수 있는 조건이 아닌 것은?,,Mutual exclusion,Hold and wait,Non-preemption,Linear wait,4,"교착상태(Deadlock)란 두 개 이상의 프로세스가 서로 상대방이 갖고 있는 자원을 기다리면서 영원히 진행되지 못하는 상황을 말합니다.  교착상태가 발생하기 위해서는 몇 가지 조건이 동시에 만족되어야 하는데, 이 문제에서는 그 조건 중 하나가 아닌 것을 찾는 것입니다.",60,44
367,1,4,67,IPv6에 대한 설명으로 틀린 것은?,,멀티캐스팅(Multicast) 대신 브로드캐스트(Broadcast)를 사용한다.,보안과 인증 확장 헤더를 사용함으로써 인터넷 계층의 보안기능을 강화하였다.,애니캐스트(Anycast)는 하나의 호스트에서 그룹 내의 가장 가까운 곳에 있는 수신자에게 전달하는 방식이다.,128비트 주소체계를 사용한다.,1,"IPv6에 대한 설명 중 틀린 내용을 찾는 문제입니다.  IPv6는 인터넷 프로토콜 버전 6으로, 기존 IPv4의 주소 부족 문제를 해결하기 위해 도입된 차세대 인터넷 프로토콜입니다.  정답은 IPv6가 브로드캐스트 방식을 사용한다는 설명이 틀렸다는 것입니다.  IPv6는 IPv4와 달리 브로드캐스트를 지원하지 않고, 멀티캐스트를 사용하여 효율적인 통신을 수행합니다.  브로드캐스트는 네트워크 상의 모든 장비에 데이터를 전송하는 방식인데, IPv6에서는 네트워크 규모가 커짐에 따라 브로드캐스트의 비효율성과 보안 문제를 해결하기 위해 멀티캐스트를 채택했습니다.  멀티캐스트는 특정 그룹의 장비에만 데이터를 전송하는 방식으로, 브로드캐스트보다 효율적이고 보안성이 높습니다.  나머지 선지는 모두 IPv6의 특징을 정확하게 설명하고 있습니다.  128비트 주소 체계를 사용하여 훨씬 더 많은 주소를 제공하며, 보안과 인증을 강화하기 위해 확장 헤더를 사용합니다. 애니캐스트는 하나의 이름(주소)에 여러 개의 IP 주소가 매핑되어 있어, 요청을 보낸 클라이언트에게 가장 가까운 서버가 응답하는 방식입니다. 따라서, 브로드캐스트를 사용한다는 설명만이 IPv6의 특징과 일치하지 않습니다.",77,45
368,1,4,68,TCP/IP 프로토콜에서 TCP가 해당하는 계층은?,,데이터 링크 계층,네트워크 계층,트랜스포트 계층,세션 계층,3,"TCP/IP 프로토콜은 네트워크 통신을 위한 일종의 규칙 또는 약속과 같은 것입니다.  우리가 편지를 부칠 때 주소를 적고, 우체국을 통해 전달하는 과정과 비슷하게, 컴퓨터끼리 데이터를 주고받을 때도 일정한 절차가 필요합니다. TCP/IP 프로토콜은 이러한 절차를 계층적으로 나누어 관리하는데,  각 계층은 특정한 역할을 담당합니다.  마치 편지를 부치는 과정에서 주소를 적는 단계, 우체국에 맡기는 단계, 배달되는 단계 등이 각각 다른 역할을 하는 것과 같습니다.",60,45
369,1,4,69,C언어에서 변수로 사용할 수 없는 것은?,,data02,int01,_sub,short,4,"C언어에서 변수를 선언할 때는 몇 가지 규칙을 따라야 합니다.  변수 이름은 영문자, 숫자, 밑줄(_)로 시작해야 하며,  숫자로 시작할 수 없습니다.  그리고 C언어의 키워드(예: int, short, float 등)는 변수 이름으로 사용할 수 없습니다.  문제에서 제시된 옵션들을 살펴보면,  'data02'와 '_sub'는 영문자나 밑줄로 시작하므로 변수 이름으로 사용 가능합니다. 'int01'은 숫자로 시작하지만,  'int'가 C언어의 키워드이기 때문에 변수 이름으로 사용할 수 없습니다.  하지만 'int'가 키워드이기 때문에 'int01'은 변수명으로 사용할 수 없습니다. 마지막으로 'short'는 C언어에서 정수형 데이터 타입을 나타내는 키워드이므로 변수 이름으로 사용할 수 없습니다. 따라서 C언어에서 변수로 사용할 수 없는 것은 키워드인 'short'입니다.  쉽게 말해, C언어는 이미 'short'라는 단어를 특별한 의미(데이터 타입)로 사용하고 있기 때문에,  프로그래머가 같은 이름으로 변수를 만들면 컴퓨터가 혼란스러워 할 수 있습니다.  마치 사람 이름과 같은 이름의 도시가 있다면 헷갈리는 것과 같은 이치입니다.",72,41
370,1,4,70,다음 JAVA 코드 출력문의 결과는?,https://www.cbtbank.kr/images/iz/iz20210307/iz20210307m70.gif,5 + 2 = 34<chal>5 + 2 = 34,5 + 2 + 3 + 4<chal>5 + 2 = 7,7 = 7<chal>7 + 7,5 + 2 = 34<chal>5 + 2 = 7,4,"JAVA에서 문자열 연결 연산자 `+`는 왼쪽에서 오른쪽으로 순차적으로 연산됩니다.  첫 번째 `System.out.println(""5 + 2 = "" + 3 + 4);` 에서는  ""5 + 2 = "" + 3 이 먼저 계산되어 ""5 + 2 = 3"" 이라는 문자열이 생성됩니다. 그 후에  ""5 + 2 = 3"" + 4 가 계산되어 최종적으로 ""5 + 2 = 34"" 라는 문자열이 출력됩니다.  두 번째 `System.out.println(""5 + 2 = "" + (3 + 4));` 에서는 괄호 안의 연산이 먼저 계산됩니다.  (3 + 4)는 7이 되고,  ""5 + 2 = "" + 7 이 계산되어 ""5 + 2 = 7"" 이라는 문자열이 출력됩니다. 따라서 두 줄의 출력 결과는 ""5 + 2 = 34"" 와 ""5 + 2 = 7"" 이 됩니다.  JAVA의 문자열 연산의 특징을 잘 이해해야 풀 수 있는 문제입니다.  숫자와 문자열을 함께 사용할 때는 괄호를 이용하여 연산 순서를 명확히 하는 것이 중요합니다.",79,41
371,1,4,71,C언어에서 문자열을 정수형으로 변환하는 라이브러리 함수는?,,atoi( ),atof( ),itoa( ),ceil( ),1,"C언어에서 문자열을 정수형으로 변환하는 함수를 묻는 문제입니다.  프로그래밍을 할 때, 사용자로부터 입력받은 숫자를 나타내는 문자열(""123""과 같은)을 실제 숫자(123과 같은)로 바꿔서 계산에 사용해야 할 경우가 많습니다. 이때 사용하는 것이 바로 문자열을 정수로 변환하는 함수입니다.  제시된 함수들 중에서 문자열을 정수로 변환하는 기능을 제공하는 함수는 `atoi()` 함수입니다.  `atoi()` 함수는 문자열을 입력받아 해당 문자열이 나타내는 정수 값을 반환합니다.  다른 함수들은 각각 다른 기능을 수행합니다. 예를 들어 `atof()`는 문자열을 실수(floating-point number)로 변환하고, `itoa()`는 정수를 문자열로 변환하는 함수입니다. `ceil()` 함수는 실수의 소수점 이하를 올림 처리하는 수학 함수입니다. 따라서 문자열을 정수로 변환하는 목적에 가장 적합한 함수는 `atoi()` 함수입니다.  쉽게 말해, ""123""이라는 문자열을 숫자 123으로 바꿔주는 역할을 하는 함수가 바로 정답인 함수입니다.",76,43
372,1,4,72,운영체제의 가상기억장치 관리에서 프로세스가 일정 시간동안 자주 참조하는 페이지들의 집합을 의미하는 것은?,,Locality,Deadlock,Thrashing,Working Set,4,"운영체제에서 가상기억장치는 실제 물리적인 메모리보다 더 큰 메모리 공간을 제공하는 기술입니다.  프로세스는 실행 중에 필요한 데이터와 명령어를 메모리에 적재하여 사용하는데,  메모리가 부족하면 가상기억장치가 활용됩니다.  가상기억장치는 하드디스크와 같은 보조기억장치를 활용하여 메모리처럼 사용합니다.  하지만 보조기억장치는 메모리보다 훨씬 느리기 때문에, 자주 사용하는 데이터만 메모리에 유지하는 것이 효율적입니다.  바로 이때,  프로세스가 일정 시간 동안 자주 참조하는 페이지들의 집합을 '워킹 셋(Working Set)'이라고 부릅니다.  프로세스가 현재 작업을 수행하는 데 필요한 페이지들이 워킹 셋에 포함되므로, 이들을 메모리에 유지함으로써  페이지 교체(페이지 폴트) 횟수를 줄이고 시스템 성능을 향상시킬 수 있습니다.  다른 선지들은 운영체제의 다른 개념들을 나타냅니다.  Locality는 지역성 원리, Deadlock은 교착상태, Thrashing은 쓰레싱 현상을 의미합니다.  따라서,  일정 시간 동안 자주 참조하는 페이지들의 집합을 의미하는 것은 Working Set입니다.",72,44
373,1,4,73,결합도가 낮은 것부터 높은 순으로 옳게 나열한 것은?,https://www.cbtbank.kr/images/iz/iz20210307/iz20210307m73.gif,(ㄱ) → (ㄴ) → (ㄹ) → (ㅂ) → (ㅁ) → (ㄷ),(ㄴ) → (ㄹ) → (ㅁ) → (ㅂ) → (ㄷ) → (ㄱ),(ㄴ) → (ㄹ) → (ㅂ) → (ㅁ) → (ㄷ) → (ㄱ),(ㄱ) → (ㄴ) → (ㄹ) → (ㅁ) → (ㅂ) → (ㄷ),3,"이 문제는 소프트웨어 공학에서 중요한 개념인 '결합도'의 이해도를 묻는 문제입니다. 결합도는 모듈 간의 상호 의존성을 나타내는 척도로, 결합도가 높다는 것은 모듈 간의 의존성이 강하다는 것을 의미합니다.  결합도가 높으면 모듈을 변경하기 어렵고, 유지보수가 어려워지며, 오류 발생 시 영향 범위가 넓어지는 단점이 있습니다. 반대로 결합도가 낮으면 모듈 간의 독립성이 높아져 유지보수가 용이하고, 변경에 대한 영향이 적습니다.",68,6
374,1,4,74,다음 설명의 ㉠과 ㉡에 들어갈 내용으로 옳은 것은?,https://www.cbtbank.kr/images/iz/iz20210307/iz20210307m74.gif,"㉠ : Paging, ㉡ : Segmentation","㉠ : Segmentation, ㉡ : Allocation","㉠ : Segmentation, ㉡ : Compaction","㉠ : Paging, ㉡ : Linking",1,"가상기억장치는 실제 메모리보다 더 큰 메모리 공간을 사용하는 것처럼 보이게 하는 기술입니다.  이를 구현하는 방법에는 크게 두 가지가 있습니다. 하나는 메모리를 고정된 크기의 블록(페이지)으로 나누어 관리하는 방법이고, 다른 하나는 가변적인 크기의 블록(세그먼트)으로 나누어 관리하는 방법입니다.  문제에서 ㉠은 프로그램을 고정된 크기의 일정한 블록으로 나누는 기법을, ㉡은 가변적인 크기의 블록으로 나누는 기법을 묻고 있습니다.  고정된 크기의 블록으로 나누는 기법은 페이징(Paging)이고, 가변적인 크기의 블록으로 나누는 기법은 세그먼테이션(Segmentation)입니다. 따라서 ㉠에는 Paging, ㉡에는 Segmentation이 들어가는 것이 정답입니다.  Paging은 메모리를 일정한 크기의 페이지로 나누어 관리하기 때문에 메모리 관리가 효율적이고 단편화 문제를 줄일 수 있습니다. 반면 Segmentation은 프로그램의 논리적 구조를 반영하여 가변적인 크기의 세그먼트로 나누어 관리하기 때문에 프로그램의 구조를 잘 반영할 수 있습니다.  두 기법은 각각 장단점을 가지고 있으며, 실제 시스템에서는 두 기법을 결합하여 사용하기도 합니다.",78,11
375,1,4,75,라이브러리의 개념과 구성에 대한 설명 중 틀린 것은?,,라이브러리란 필요할 때 찾아서 쓸 수 있도록 모듈화되어 제공되는 프로그램을 말한다.,"프로그래밍 언어에 따라 일반적으로 도움말, 설치 파일, 샘플 코드 등을 제공한다.","외부 라이브러리는 프로그래밍 언어가 기본적으로 가지고 있는 라이브러리를 의미하며, 표준 라이브러리는 별도의 파일 설치를 필요로 하는 라이브러리를 의미한다.","라이브러리는 모듈과 패키지를 총칭하며, 모듈이 개별 파일이라면 패키지는 파일들을 모아 놓은 폴더라고 볼 수 있다.",3,"이 문제는 라이브러리의 개념과 구성에 대한 이해도를 묻는 문제입니다.  프로그래밍을 할 때, 바퀴를 매번 새로 발명할 필요 없이 이미 만들어진 기능들을 가져다 쓰는 것이 효율적입니다. 이렇게 재사용 가능하도록 만들어진 코드의 집합이 바로 라이브러리입니다.  문제에서 틀린 설명은 외부 라이브러리와 표준 라이브러리에 대한 설명입니다.  일반적으로 프로그래밍 언어는 기본적으로 제공되는 표준 라이브러리를 가지고 있으며,  별도로 설치해야 하는 라이브러리를 외부 라이브러리라고 합니다. 문제의 설명은 이 개념을 정반대로 설명하고 있으므로 틀린 것입니다.  쉽게 말해,  자동차를 예로 들면, 표준 라이브러리는 자동차에 기본적으로 장착된 엔진, 바퀴와 같은 필수 부품이고, 외부 라이브러리는  네비게이션, 후방카메라와 같이 추가로 설치하여 사용하는 선택적 부품에 비유할 수 있습니다.  따라서,  외부 라이브러리와 표준 라이브러리에 대한 설명이 잘못된 것이 문제의 핵심입니다. 다른 선지는 라이브러리의 개념, 제공하는 자료, 모듈과 패키지의 관계를 정확하게 설명하고 있습니다.",84,43
376,1,4,76,C언어에서 산술 연산자가 아닌 것은?,,%,*,/,=,4,"C언어에서 산술 연산자는 숫자를 가지고 계산하는 연산자들을 말합니다.  덧셈(+), 뺄셈(-), 곱셈(*), 나눗셈(/), 나머지(%) 연산자는 모두 산술 연산자에 속합니다.  반면에 ‘=’ 기호는 대입 연산자입니다.  대입 연산자는 어떤 값을 변수에 저장하는 역할을 합니다. 예를 들어, `x = 5;` 라는 코드는 변수 x에 5라는 값을 저장하는 것을 의미합니다.  따라서 숫자를 직접적으로 계산하는 연산자가 아닌 ‘=’ 기호는 산술 연산자가 아닙니다.  다른 선지들은 모두 숫자 연산에 사용되는 기호이므로 산술 연산자에 해당합니다.",80,41
377,1,4,77,UDP 특성에 해당되는 것은?,,양방향 연결형 서비스를 제공한다.,송신중에 링크를 유지관리하므로 신뢰성이 높다.,"순서제어, 오류제어, 흐름제어 기능을 한다.",흐름제어나 순서제어가 없어 전송속도가 빠르다.,4,"UDP(User Datagram Protocol)는 TCP와 달리 연결을 미리 설정하지 않고 데이터를 패킷 단위로 전송하는 비연결형 프로토콜입니다.  TCP는 데이터 전송 전에 송수신자 간의 연결을 확립하고, 데이터 전송 후 연결을 해제하는 과정을 거치며 순서대로 데이터를 전송하고 오류 발생 시 재전송을 합니다. 이러한 과정 때문에 TCP는 신뢰성은 높지만 속도가 느립니다. 반면 UDP는 이러한 연결 설정 및 관리 과정이 없기 때문에 TCP보다 전송 속도가 훨씬 빠릅니다.  하지만 연결을 관리하지 않기 때문에 데이터 전송의 순서가 보장되지 않고, 데이터 손실이나 오류 발생 시 재전송 기능이 없다는 단점이 있습니다. 따라서 흐름 제어나 순서 제어 기능이 없다는 것은 UDP의 특징이며, 이로 인해 전송 속도가 빠른 것입니다.  문제에서 제시된 다른 선택지는 TCP의 특성을 나타내고 있거나 UDP의 특성을 잘못 설명하고 있습니다. 따라서 UDP의 속도를 우선시하는 특성을 가장 잘 나타내는 정답은 흐름제어나 순서제어가 없어 전송속도가 빠르다는 것입니다.  마치 편지를 보낼 때, 등기우편(TCP)은 안전하게 도착하는 것을 보장하지만 시간이 걸리고, 일반 우편(UDP)은 빠르지만 분실될 위험이 있다고 생각하면 이해하기 쉬울 것입니다.",75,45
378,1,4,78,JAVA에서 변수와 자료형에 대한 설명으로 틀린 것은?,,변수는 어떤 값을 주기억 장치에 기억하기 위해서 사용하는 공간이다.,변수의 자료형에 따라 저장할 수 있는 값의 종류와 범위가 달라진다.,char 자료형은 나열된 여러 개의 문자를 저장하고자 할 때 사용한다.,boolean 자료형은 조건이 참인지 거짓인지 판단하고자 할 때 사용한다.,3,"JAVA에서 변수는 프로그램 실행 중에 값을 저장하는 메모리 공간을 의미합니다.  변수를 사용하려면 먼저 어떤 종류의 값을 저장할지 자료형을 지정해야 하는데, 자료형에 따라 저장 가능한 값의 종류와 크기가 달라집니다.  예를 들어, 정수형 변수에는 정수만 저장할 수 있고, 실수형 변수에는 실수만 저장할 수 있습니다.  문제에서 틀린 설명은 'char 자료형은 나열된 여러 개의 문자를 저장하고자 할 때 사용한다'는 부분입니다.  char 자료형은 단 하나의 문자만 저장하는 데 사용됩니다. 여러 개의 문자를 저장하려면 문자열을 나타내는 String 자료형이나 문자 배열을 사용해야 합니다.  boolean 자료형은 참(true) 또는 거짓(false)의 논리 값을 저장하는 데 사용되므로, 조건 판단에 유용하게 쓰입니다. 따라서,  문제의 정답은 char 자료형에 대한 설명이 잘못된 선지입니다.",75,41
379,1,4,79,다음은 파이썬으로 만들어진 반복문 코드이다. 이 코드의 결과는?,https://www.cbtbank.kr/images/iz/iz20210307/iz20210307m79.gif,"A, B, C 출력이 반복된다.","A, B, C 까지만 출력된다.","A, B, C, D 출력이 반복된다.","A, B, C, D 까지만 출력된다.",1,"이 파이썬 코드는 `while(True)` 루프를 사용하여 무한 루프를 만듭니다.  루프 안에서는 'A', 'B', 'C'를 순서대로 출력하는 `print()` 함수가 세 번 호출됩니다.  `continue` 문은 현재 반복을 종료하고 다음 반복으로 넘어가는 역할을 합니다.  `continue` 문 다음에 있는 `print('D')`는 실행되지 않습니다. 따라서 코드는 'A', 'B', 'C'를 무한히 반복해서 출력하게 됩니다.  `continue`문은 반복문의 조건 검사 부분으로 돌아가게 하기 때문에,  'D'를 출력하는 부분은 영원히 실행되지 못하는 것입니다. 마치 빙글빙글 도는 회전목마처럼 'A', 'B', 'C'만 계속해서 출력되는 것이죠.",70,41
380,1,4,80,WAS(Web Application Server)가 아닌 것은?,,JEUS,JVM,Tomcat,WebSphere,2,"이 문제는 웹 애플리케이션 서버(WAS)에 대한 이해도를 묻는 문제입니다.  WAS는 웹 애플리케이션을 실행하고 관리하는 서버 소프트웨어입니다.  쉽게 말해, 웹사이트나 웹 서비스를 동작하게 해주는 중간자 역할을 하는 소프트웨어라고 생각하면 됩니다.  문제에서 제시된 선택지 중 JEUS, Tomcat, WebSphere는 모두 잘 알려진 WAS의 예시입니다.  반면 JVM(Java Virtual Machine)은 자바 프로그램을 실행하는 가상 머신으로, 웹 애플리케이션을 직접 실행하고 관리하는 서버가 아닙니다.  JVM은 자바 코드를 실행하는 환경을 제공하는 것이지, 웹 애플리케이션 자체를 운영하는 서버는 아니라는 점이 중요합니다.  WAS는 웹 애플리케이션을 위한 다양한 기능(웹 서버 기능, 데이터베이스 연결 기능, 보안 기능 등)을 제공하는 반면, JVM은 자바 코드를 실행하는 데 필요한 환경만 제공합니다. 따라서 JVM은 WAS가 아닙니다.  마치 자동차 엔진(JVM)이 자동차(웹 애플리케이션) 자체가 아니고, 자동차를 움직이게 하는 부품 중 하나인 것과 같은 이치입니다.",66,38
381,1,4,81,다음 암호 알고리즘 중 성격이 다른 하나는?,,MD4,MD5,SHA-1,AES,4,"이 문제는 암호 알고리즘의 종류와 그 특징을 이해하고 있는지를 묻는 문제입니다. 제시된 암호 알고리즘 중 세 가지는 해시 함수(Hash Function)이고, 나머지 하나는 대칭키 암호화 알고리즘(Symmetric-key encryption algorithm)입니다.  해시 함수는 임의 길이의 데이터를 고정된 길이의 해시 값으로 변환하는 일방향 함수입니다.  MD4, MD5, SHA-1은 모두 데이터의 무결성을 검증하는 데 사용되는 대표적인 해시 함수입니다.  즉, 입력 데이터가 변경되면 해시 값도 달라지기 때문에 데이터가 변조되었는지 확인할 수 있습니다. 반면, AES(Advanced Encryption Standard)는 대칭키 암호화 알고리즘으로, 데이터를 암호화하고 복호화하는 데 사용됩니다.  암호화는 데이터를 읽을 수 없도록 변환하는 과정이고, 복호화는 암호화된 데이터를 원래 상태로 되돌리는 과정입니다.  AES는 데이터의 기밀성을 보장하기 위해 사용됩니다. 따라서 해시 함수와 대칭키 암호화 알고리즘은 목적과 기능이 다르므로, 성격이 다른 하나는 대칭키 암호화 알고리즘인 AES입니다.  쉽게 말해, 해시 함수는 데이터의 변조 여부를 확인하는 도장과 같고, AES는 데이터를 비밀번호로 잠그는 자물쇠와 같은 역할을 합니다.",71,54
382,1,4,82,"크래커가 침입하여 백도어를 만들어 놓거나, 설정파일을 변경했을 때 분석하는 도구는?",,tripwire,tcpdump,cron,netcat,1,"시스템의 파일이나 설정이 변경되었는지 감시하고, 무단 변경을 감지하는 도구가 필요한 상황입니다.  크래커가 침입하여 백도어를 심거나 설정 파일을 변경하는 것은 시스템의 무결성을 침해하는 행위입니다.  이러한 무단 변경을 탐지하기 위해서는 시스템의 파일 및 설정의 변경 사항을 지속적으로 모니터링하고, 이전 상태와 비교하여 차이가 발생했는지 확인하는 기능이 필요합니다.  제시된 도구 중에서 이러한 기능을 제공하는 것은 Tripwire입니다. Tripwire는 시스템 파일의 체크섬(checksum)을 생성하여 저장하고, 주기적으로 체크섬을 다시 계산하여 이전에 저장된 체크섬과 비교합니다.  만약 체크섬이 다르다면, 파일이 변경되었다는 것을 의미하며, 이를 통해 무단 침입이나 악의적인 변경을 감지할 수 있습니다.  다른 선택지는 네트워크 패킷 분석(tcpdump), 작업 스케줄러(cron), 네트워크 유틸리티(netcat) 등으로 시스템의 무결성 변화 감지를 위한 목적에는 적합하지 않습니다. 따라서 시스템의 무결성을 감시하고 크래커의 침입 흔적을 찾는 데 가장 적합한 도구는 Tripwire입니다.",73,56
383,1,4,83,다음 내용이 설명하는 것은?,https://www.cbtbank.kr/images/iz/iz20210307/iz20210307m83.gif,GRID,TELNET,GPN,MQTT,4,"문제에서 제시된 설명을 보면, 대역폭이 제한된 환경(예를 들어, 사물인터넷 환경)에서 효율적으로 작동하는 경량 메시지 전송 프로토콜임을 알 수 있습니다.  메시지 중개자(Broker)를 통해 송신자와 수신자가 메시지를 주고받는 방식으로, 송신자는 메시지를 '발행'하고, 수신자는 메시지를 '구독'하는 방식입니다. 이러한 특징들은 MQTT(Message Queuing Telemetry Transport) 프로토콜의 핵심적인 특징들입니다. MQTT는 사물인터넷(IoT) 환경에서 많이 사용되는데, 그 이유는 제한된 대역폭에서도 효율적으로 작동하고,  간단한 구조로 구현이 용이하기 때문입니다.  IBM이 주도하여 개발되었다는 점도 문제의 설명과 일치합니다.  다른 선지들은 이러한 특징들과 부합하지 않습니다.  GRID는 분산 컴퓨팅 환경, TELNET은 원격 로그인 프로토콜, GPN은 특정 네트워크 기술을 지칭하는 용어로, 문제에서 설명하는 경량 메시지 전송 프로토콜의 특징과는 거리가 멉니다. 따라서, 문제의 정답은 MQTT가 됩니다.",68,45
384,1,4,84,나선형(Spiral) 모형의 주요 태스크에 해당되지 않는 것은?,,버전 관리,위험 분석,개발,평가,1,"나선형(Spiral) 모형은 소프트웨어 개발 과정에서 위험을 관리하고 점진적으로 개발하는 방법론입니다.  각 단계마다 계획, 위험 분석, 엔지니어링, 평가를 반복하며 진행합니다.  계획 단계에서는 다음 단계를 위한 목표와 작업을 설정하고, 위험 분석 단계에서는 예상되는 위험을 파악하고 대응 방안을 마련합니다. 엔지니어링 단계에서는 실제 소프트웨어를 개발하고, 평가 단계에서는 개발된 소프트웨어를 검토하고 피드백을 받습니다. 이러한 과정을 반복하면서 점차적으로 완성도 높은 소프트웨어를 만들어나가는 것이죠.  문제에서 제시된 선택지 중 '버전 관리'는 소프트웨어 개발 과정에서 중요한 부분이지만, 나선형 모형의 *핵심적인* 단계는 아닙니다. 버전 관리는 각 단계의 결과물을 관리하는 보조적인 활동으로 볼 수 있기 때문에 나선형 모형의 주요 태스크라고 보기 어렵습니다. 나선형 모형의 핵심은 위험 관리와 점진적인 개발이며, 이를 위해 위험 분석, 개발, 평가 단계가 필수적입니다. 따라서 버전 관리는 나선형 모형의 주요 태스크라고 할 수 없습니다.",71,47
385,1,4,85,정보 보안을 위한 접근통제 정책 종류에 해당하지 않는 것은?,,임의적 접근 통제,데이터 전환 접근 통제,강제적 접근 통제,역할 기반 접근 통제,2,"정보 보안에서 접근 통제란, 시스템이나 데이터에 대한 접근을 허용할 사용자와 그들이 수행할 수 있는 작업을 제한하는 정책입니다.  쉽게 말해, 누가 어떤 정보에 접근할 수 있는지, 그리고 그 정보를 어떻게 사용할 수 있는지를 규정하는 규칙이라고 생각하면 됩니다.  문제에서 제시된 선택지들은 대표적인 접근 통제 정책의 종류들입니다.  '임의적 접근 통제'는 관리자가 개별 사용자에게 접근 권한을 부여하는 방식이고, '강제적 접근 통제'는 시스템이 사전에 정의된 보안 규칙에 따라 접근을 자동으로 제어하는 방식이며, '역할 기반 접근 통제'는 사용자의 역할에 따라 접근 권한을 부여하는 방식입니다.  하지만 '데이터 전환 접근 통제'라는 것은 정보 보안 접근 통제 정책의 종류로는 일반적으로 분류되지 않습니다. 데이터 전환은 데이터의 형식이나 위치를 바꾸는 과정을 의미하며, 접근 통제와는 직접적인 관련이 없습니다. 따라서, 정보 보안을 위한 접근 통제 정책 종류에 해당하지 않는 것은 '데이터 전환 접근 통제'입니다.",59,55
386,1,4,86,"LOC기법에 의하여 예측된 총 라인수가 36,000라인, 개발에 참여할 프로그래머가 6명, 프로그래머들의 평균 생산성이 월간 300라인일 때 개발에 소요되는 기간은?",,5개월,10개월,15개월,20개월,4,"이 문제는 소프트웨어 개발에 필요한 시간을 계산하는 문제입니다.  LOC(Lines of Code) 기법은 소프트웨어의 크기를 코드 라인 수로 측정하여 개발 기간을 예측하는 방법입니다. 문제에서 예측된 총 라인 수는 36,000라인이고, 개발에 참여하는 프로그래머는 6명, 프로그래머 한 명의 월간 생산성은 300라인입니다.",88,47
387,1,4,87,"정형화된 분석 절차에 따라 사용자 요구사항을 파악, 문서화하는 체계적 분석방법으로 자료흐름도, 자료사전, 소단위명세서의 특징을 갖는 것은?",,구조적 개발 방법론,객체지향 개발 방법론,정보공학 방법론,CBD 방법론,1,"이 문제는 사용자 요구사항을 체계적으로 분석하고 문서화하는 방법에 대한 질문입니다.  문제에서 제시된 ""자료흐름도, 자료사전, 소단위명세서""는 모두 구조적 분석 방법론의 핵심 산출물입니다.  구조적 분석 방법론은 시스템을 여러 개의 작은 모듈로 나누어 계층적으로 표현하고, 각 모듈의 기능과 데이터 흐름을 명확하게 정의하는 방식입니다. 자료흐름도는 데이터가 시스템 내에서 어떻게 흘러가는지를 시각적으로 보여주는 도구이고, 자료사전은 데이터의 이름, 형태, 의미 등을 정의하는 문서이며, 소단위명세서는 각 모듈의 기능을 상세하게 설명하는 문서입니다.  이러한 산출물들을 통해 시스템의 구조와 기능을 명확하게 이해하고, 요구사항을 정확하게 파악하여 문서화할 수 있습니다.  반면, 객체지향 개발 방법론은 객체와 클래스를 중심으로 시스템을 모델링하는 방식이며, 정보공학 방법론은 데이터 중심의 접근 방식을 사용하고, CBD(Component-Based Development) 방법론은 기존에 개발된 컴포넌트를 재사용하여 시스템을 개발하는 방식입니다. 따라서 문제에서 제시된 특징들을 가장 잘 만족하는 것은 구조적 개발 방법론입니다.  쉽게 말해, 레고 블록을 조립하듯 시스템을 작은 단위로 나누어 설계하고, 각 블록의 역할과 연결 관계를 명확히 하는 방식이라고 생각하면 이해하기 쉬울 것입니다.",61,2
388,1,4,88,정보보호를 위한 암호화에 대한 설명으로 틀린 것은?,,평문 ? 암호화되기 전의 원본 메시지,암호문 ? 암호화가 적용된 메시지,복호화 ? 평문을 암호문으로 바꾸는 작업,키(Key) - 적절한 암호화를 위하여 사용하는 값,3,"정보보호를 위한 암호화 과정을 이해하는 문제입니다.  암호화는 평문(원본 메시지)을 암호문(보안을 위해 변환된 메시지)으로 바꾸는 과정이고, 복호화는 그 반대 과정입니다.  키는 암호화와 복호화에 사용되는 비밀 값입니다.  문제에서 틀린 것은 평문을 암호문으로 바꾸는 작업을 복호화라고 설명한 부분입니다.  복호화는 암호문을 평문으로 바꾸는 작업이지, 평문을 암호문으로 바꾸는 작업이 아닙니다.  따라서 암호화 과정에 대한 정확한 이해를 묻는 문제이며, 암호화와 복호화의 개념을 명확히 구분해야 정답을 고를 수 있습니다.  마치 편지를 봉투에 넣어 잠그는 것이 암호화라면, 봉투를 열어 편지를 꺼내 읽는 것이 복호화라고 생각하면 쉽게 이해할 수 있습니다.",84,54
389,1,4,89,다음 내용이 설명하는 것은?,https://www.cbtbank.kr/images/iz/iz20210307/iz20210307m89.gif,OTT,Baas,SDDC,Wi-SUN,2,"문제에서 제시된 설명은 블록체인 기술을 클라우드 환경에서 손쉽게 이용할 수 있도록 지원하는 서비스에 대한 설명입니다.  블록체인 기술 자체는 복잡하고 구축 및 관리가 어렵지만, 이 서비스를 이용하면 클라우드 상에서 블록체인 네트워크를 간편하게 구축하고 관리할 수 있습니다.  마치 레고 블록처럼 기본적인 블록체인 인프라를 제공하여 사용자는 응용 프로그램 개발에 집중할 수 있도록 지원하는 것이죠.  노드의 추가 및 제거도 용이하다는 점은 클라우드 환경의 장점을 잘 보여줍니다.  따라서 문제에서 설명하는 것은 블록체인을 서비스로 제공하는 Baas(Blockchain as a Service) 개념입니다.  OTT는 동영상 스트리밍 서비스, SDDC는 소프트웨어 정의 데이터센터, Wi-SUN은 저전력 광역 통신 기술을 의미하므로 문제의 설명과는 전혀 관련이 없습니다.",69,38
390,1,4,90,"소프트웨어 비용 산정 기법 중 개발 유형으로 organic, semi-detach, embedded로 구분되는 것은?",,PUTNAM,COCOMO,FP,SLIM,2,"소프트웨어 개발 비용을 산정하는 방법에는 여러 가지가 있습니다.  그 중에서 COCOMO 모델은 소프트웨어의 크기와 개발 유형에 따라 비용을 추정하는 대표적인 방법론입니다.  COCOMO 모델은 개발 유형을 크게 세 가지로 나누는데, 바로 organic(유기적), semi-detached(반분리형), embedded(임베디드)입니다.  organic은 소규모 팀이 잘 이해하는 프로젝트에 적용되고, semi-detached는 중간 규모의 프로젝트, embedded는 하드웨어와 밀접하게 연관된 시스템 개발에 적용되는 등 프로젝트의 특성에 따라 적절한 유형을 선택하여 비용을 산정합니다.  문제에서 제시된 다른 방법론들은 COCOMO와는 다른 방식으로 소프트웨어 비용을 산정합니다. 따라서, 개발 유형을 organic, semi-detached, embedded로 구분하는 소프트웨어 비용 산정 기법은 COCOMO 모델입니다.  정보처리기사 공식 교재의 소프트웨어 공학 파트에서 COCOMO 모델에 대한 자세한 설명을 찾아볼 수 있습니다.",83,47
391,1,4,91,다음 LAN의 네트워크 토폴로지는 어떤 형인가?,https://www.cbtbank.kr/images/iz/iz20210307/iz20210307m91.gif,그물형,십자형,버스형,링형,3,"그림에서 볼 수 있듯이, 모든 스테이션(컴퓨터)들이 하나의 통로(버스)에 연결되어 있습니다.  데이터는 이 버스를 통해 모든 스테이션으로 전송되며, 한 스테이션이 데이터를 전송하면 모든 스테이션이 그 데이터를 수신합니다.  이러한 네트워크 구조는 버스 토폴로지의 특징과 정확히 일치합니다.  반면 그물형은 여러 경로를 통해 데이터가 전송되는 복잡한 구조이고, 십자형은 두 개의 버스가 교차하는 형태이며, 링형은 스테이션들이 원형으로 연결되어 데이터가 순차적으로 전달되는 구조입니다. 문제의 그림은 단일 통로를 통해 모든 스테이션이 연결되어 있으므로 버스형 토폴로지가 가장 적절한 설명입니다.  마치 여러 집에 전기가 하나의 전선을 통해 공급되는 것과 같은 원리라고 생각하면 이해하기 쉬울 것입니다.",88,45
392,1,4,92,"전기 및 정보통신기술을 활용하여 전력망을 지능화, 고도화함으로써 고품질의 전력서비스를 제공하고 에너지 이용효율을 극대화하는 전력망은?",,사물 인터넷,스마트 그리드,디지털 아카이빙,미디어 빅뱅,2,"이 문제는 전기 및 정보통신 기술을 활용하여 전력망을 똑똑하게 만들고, 더욱 발전시켜서 전력 서비스의 질을 높이고 에너지 효율을 최대한으로 높이는 전력망의 종류를 묻고 있습니다.  쉽게 말해, 전력망을 스마트폰처럼 똑똑하게 만들어 관리하고 효율적으로 에너지를 사용하는 시스템을 찾는 문제입니다.  전력망에 센서와 통신 기술을 적용하여 실시간으로 전력 사용량을 모니터링하고,  발전량과 수요를 예측하여 안정적인 전력 공급을 유지하며, 에너지 손실을 줄이는 기술이 바로 정답에 해당하는 개념입니다.  다른 선택지는 전력망과 직접적인 관련이 없습니다. 사물 인터넷은 넓은 개념이고, 디지털 아카이빙은 자료 보관, 미디어 빅뱅은 미디어 환경 변화를 의미하기 때문입니다. 따라서 전력망의 지능화, 고도화를 통해 고품질의 전력 서비스 제공 및 에너지 효율 극대화를 목표로 하는 기술인 정답이 가장 적절합니다.",75,49
393,1,4,93,다음 내용이 설명하는 소프트웨어 개발 모형은?,https://www.cbtbank.kr/images/iz/iz20210307/iz20210307m93.gif,프로토타입 모형,나선형 모형,폭포수 모형,RAD 모형,3,"문제에서 제시된 설명은 소프트웨어 개발 과정을  '타당성 검토 → 계획 → 요구사항 분석 → 설계 → 구현 → 테스트 → 유지보수' 와 같이 순차적으로, 즉 앞 단계가 완료되어야만 다음 단계로 진행되는 방식을 보여줍니다.  마치 폭포가 위에서 아래로 떨어지는 것처럼 한 단계씩 흘러가는 모습을 연상시키기 때문에 이러한 개발 방식을 '폭포수 모형' 이라고 부릅니다.  다른 모형들은 이와 달리 반복적이거나 병렬적인 특징을 가지고 있습니다. 예를 들어 프로토타입 모형은 실제 제품의 일부를 미리 만들어 사용자 피드백을 받고 수정하는 반복적인 과정을 거치고, 나선형 모형은 위험 관리에 초점을 맞춰 반복적으로 개발과 평가를 수행합니다. RAD 모형은 신속한 애플리케이션 개발을 위해 프로토타입과 반복적인 개발을 병행합니다.  문제의 설명이 명확하게 순차적인 단계를 강조하고 있으므로, 폭포수 모형이 가장 적절한 답입니다.  이는 마치 폭포수가 위에서 아래로 떨어지는 것처럼 한 단계씩 흘러가는 모습과 유사하기 때문입니다.",81,47
394,1,4,94,스트림 암호화 방식의 설명으로 옳지 않은 것은?,,비트/바이트/단어들을 순차적으로 암호화한다.,해쉬 함수를 이용한 해쉬 암호화 방식을 사용한다.,RC4는 스트림 암호화 방식에 해당한다.,대칭키 암호화 방식이다.,2,"스트림 암호화 방식은 데이터를 비트, 바이트 또는 단어 단위로 순차적으로 암호화하는 방식입니다.  마치 긴 강물을 끊임없이 흐르는 물줄기처럼, 데이터를 연속적으로 처리하는 것이죠.  따라서 첫 번째 설명은 스트림 암호화 방식의 정확한 특징을 나타냅니다.  세 번째 설명 또한 사실입니다. RC4는 대표적인 스트림 암호화 알고리즘입니다.  네 번째 설명 역시 맞는 말입니다. 스트림 암호화는 대칭키 암호화 방식의 한 종류로, 암호화와 복호화에 동일한 키를 사용합니다.  하지만 잘못된 설명은 해쉬 함수를 이용한다는 것입니다. 해쉬 함수는 데이터의 무결성을 검증하거나 데이터를 요약하는 데 사용되지만, 데이터 자체를 암호화하는 데는 사용되지 않습니다. 해쉬 함수는 일방향 함수이기 때문에, 해쉬 값으로부터 원래 데이터를 복구할 수 없기 때문입니다.  스트림 암호화는 데이터를 순차적으로 처리하여 암호화하기 때문에, 해쉬 함수와는 근본적으로 다른 방식입니다.  따라서 해쉬 함수를 이용한 암호화 방식이라는 설명은 스트림 암호화 방식에 대한 잘못된 설명입니다.",48,54
395,1,4,95,세션 하이재킹을 탐지하는 방법으로 거리가 먼 것은?,,FTP SYN SEGNENT 탐지,비동기화 상태 탐지,ACK STORM 탐지,패킷의 유실 및 재전송 증가 탐지,1,"세션 하이재킹은 이미 인증된 사용자의 세션을 도용하여 권한을 탈취하는 공격입니다.  악의적인 사용자가 다른 사용자의 세션을 가로채면, 마치 그 사용자인 것처럼 시스템에 접근하여 데이터를 훔치거나 시스템을 손상시킬 수 있습니다.  따라서 세션 하이재킹을 탐지하는 것은 시스템 보안에 매우 중요합니다.  문제에서 제시된 탐지 방법들을 살펴보면, 비동기화 상태, ACK STORM, 패킷의 유실 및 재전송 증가는 모두 네트워크 통신의 이상 현상을 나타내는 지표입니다.  세션 하이재킹이 발생하면 네트워크 통신에 이상이 생길 가능성이 높기 때문에 이러한 현상들을 탐지하여 세션 하이재킹을 간접적으로 확인할 수 있습니다.  반면, FTP SYN SEGMENT 탐지는 FTP 프로토콜의 특정 부분을 분석하는 것으로, 세션 하이재킹 자체를 직접적으로 탐지하는 방법이라고 보기 어렵습니다.  세션 하이재킹은 다양한 프로토콜에서 발생할 수 있으며, 특정 프로토콜의 세그먼트만 분석해서는 모든 경우를 포착할 수 없습니다.  따라서 다른 탐지 방법들과 달리 FTP SYN SEGMENT 탐지는 세션 하이재킹 탐지와는 거리가 멉니다.  쉽게 말해, 다른 방법들은 세션 하이재킹으로 인해 발생할 수 있는 네트워크 이상 현상을 감지하는 것이지만, FTP SYN SEGMENT 탐지는 특정 프로토콜에 국한된 방법이기 때문에 세션 하이재킹 탐지에는 효과적이지 않다는 것입니다.",41,53
396,1,4,96,소프트웨어공학에 대한 설명으로 거리가 먼 것은?,,"소프트웨어공학이란 소프트웨어의 개발, 운용, 유지보수 및 파기에 대한 체계적인 접근 방법이다.",소프트웨어공학은 소프트웨어 제품의 품질을 향상시키고 소프트웨어 생산성과 작업 만족도를 증대시키는 것이 목적이다.,소프트웨어공학의 궁극적 목표는 최대의 비용으로 계획된 일정보다 가능한 빠른 시일 내에 소프트웨어를 개발하는 것이다.,소프트웨어공학은 신뢰성 있는 소프트웨어를 경제적인 비용으로 획득하기 위해 공학적 원리를 정립하고 이를 이용하는 것이다.,3,"소프트웨어공학은 소프트웨어 개발의 전 과정을 효율적이고 체계적으로 관리하여 최고의 품질을 최소의 비용으로 달성하는 것을 목표로 합니다.  소프트웨어 개발은 시간과 비용이 많이 드는 작업이기 때문에,  계획된 시간보다 빨리 개발하는 것만이 목표가 될 수는 없습니다.  빠른 개발 속도도 중요하지만,  그보다 더 중요한 것은  소프트웨어의 품질, 안정성, 그리고 유지보수 용이성입니다.  따라서, 최대의 비용으로 계획된 일정보다 빠르게 개발하는 것을 궁극적인 목표로 삼는다는 주장은 소프트웨어공학의 기본 원리와 맞지 않습니다.  소프트웨어공학은 효율성과 품질을 동시에 추구하는 학문이지, 단순히 속도만을 중시하는 학문이 아니라는 점을 명심해야 합니다.  다른 보기들은 모두 소프트웨어공학의 주요 목표와 원칙을 잘 나타내고 있습니다.",87,47
397,1,4,97,소프트웨어 개발 방법론 중 CBD(Component Based Development)에 대한 설명으로 틀린 것은?,,"생산성과 품질을 높이고, 유지보수 비용을 최소화할 수 있다.",컴포넌트 제작 기법을 통해 재사용성을 향상시킨다.,모듈의 분할과 정복에 의한 하향식 설계방식이다.,독립적인 컴포넌트 단위의 관리로 복잡성을 최소화할 수 있다.,3,"CBD(Component Based Development)는 말 그대로 구성요소(컴포넌트) 기반으로 소프트웨어를 개발하는 방법론입니다.  레고 블록을 조립하듯이, 미리 만들어 놓은 여러 컴포넌트들을 조합하여 새로운 소프트웨어를 만드는 것이죠.  따라서 기존에 만들어진 컴포넌트를 재사용할 수 있으므로 생산성과 품질 향상, 유지보수 비용 절감에 효과적입니다. 또한, 각 컴포넌트가 독립적으로 관리되기 때문에 전체 시스템의 복잡성을 줄일 수 있습니다. 하지만 CBD는 하향식 설계 방식이라고 단정 지을 수 없습니다.  하향식 설계는 전체 시스템을 먼저 설계하고 세부적인 부분으로 나누는 방식인데, CBD는 미리 만들어진 컴포넌트를 활용하여 시스템을 구성하는 것이므로 상향식 설계의 특징도 가지고 있습니다.  즉,  미리 만들어진 컴포넌트를 조합하는 방식이기 때문에  항상 하향식 설계만을 따르는 것은 아닙니다.  따라서  모듈의 분할과 정복에 의한 하향식 설계 방식이라는 설명은 CBD의 특징을 완전히 반영하지 못하는 잘못된 설명입니다.  CBD는 하향식과 상향식 설계 방식을 모두 활용할 수 있는 유연한 방법론이라고 이해하는 것이 더 정확합니다.",81,47
398,1,4,98,정보 보안의 3요소에 해당하지 않는 것은?,,기밀성,무결성,가용성,휘발성,4,"정보 보안의 핵심은 정보 자산을 안전하게 보호하는 데 있습니다.  이를 위해서는 정보의 기밀성(비밀 유지), 무결성(데이터의 정확성과 신뢰성 유지), 가용성(필요한 사람이 필요한 때에 정보에 접근할 수 있는 상태 유지)을 확보해야 합니다.  문제에서 제시된 '휘발성'은 정보의 특성을 나타내는 용어로, 전원이 꺼지면 사라지는 데이터의 성질을 의미합니다.  정보 보안과는 직접적인 관련이 없으므로 정보 보안의 3요소에 포함되지 않습니다.  쉽게 말해,  정보 보안은 '누가', '어떻게', '언제' 정보에 접근하는지를 관리하는 것이고, 휘발성은 정보 자체의 특징일 뿐 보안과는 다른 개념입니다. 따라서 정보 보안의 3요소에 해당하지 않는 것은 휘발성입니다.",86,53
399,1,4,99,"소셜 네트워크에서 악의적인 사용자가 지인 또는 특정 유명인으로 가장하여 활동하는 공격 기법은?(문제 오류로 가답안 발표시 1번으로 발표되었지만 확정답안 발표시 1, 2번이 정답처리 되었습니다. 여기서는 가답안인 1번을 누르시면 정답 처리 됩니다.)",,Evil Twin Attack,Phishing,Logic Bomb,Cyberbullying,1,"이 문제는 소셜 네트워크 상에서 발생하는 악의적인 행위 중, 특정인을 사칭하여 활동하는 공격 기법을 묻고 있습니다.  정답은  악의적인 사용자가 다른 사람(지인이나 유명인)의 신원을 가장하여 소셜 네트워크에서 활동하는 것을 의미합니다. 이는 개인 정보 유출이나 명예훼손, 사기 등 다양한 범죄에 악용될 수 있는 위험한 행위입니다.  다른 선택지들은 각각 다른 유형의 사이버 공격을 나타냅니다.  예를 들어 피싱은 악성 링크나 이메일을 통해 개인 정보를 빼내는 공격이고, 로직 봄은 특정 조건이 충족될 때 시스템을 손상시키는 악성 코드이며, 사이버 폭력은 온라인 상에서의 괴롭힘을 의미합니다.  따라서 소셜 네트워크에서의 사칭 행위를 가장 잘 나타내는 용어를 선택하는 것이 중요하며, 이 문제의 맥락에서는  가답안으로 제시된 답변이 가장 적절합니다.  비록 확정 답변에 다른 답변이 포함되었지만, 문제의 의도와 가답안의 의미를 고려했을 때, 가답안이 문제의 질문에 가장 정확하게 부합한다고 볼 수 있습니다.",80,55
400,1,4,100,공개키 암호에 대한 설명으로 틀린 것은?,,10명이 공개키 암호를 사용할 경우 5개의 키가 필요하다.,복호화키는 비공개 되어 있다.,송신자는 수신자의 공개키로 문서를 암호화한다.,공개키 암호로 널리 알려진 알고리즘은 RSA가 있다.,1,"공개키 암호는 두 개의 키, 즉 공개키와 비밀키(개인키)를 사용하는 암호 방식입니다.  공개키는 누구에게나 공개해도 되지만, 비밀키는 자신만 알고 있어야 합니다.  문서를 암호화할 때는 상대방의 공개키를 사용하고, 암호화된 문서를 복호화할 때는 자신의 비밀키를 사용합니다.  따라서 10명이 서로 통신하려면 각자 공개키와 비밀키를 한 쌍씩 가지고 있어야 하므로 총 20개의 키가 필요합니다.  문제에서 5개의 키만 필요하다고 한 것은 잘못된 설명입니다.  나머지 설명들은 공개키 암호의 특징을 정확하게 나타내고 있습니다.  복호화 키는 비밀로 유지되고, 송신자는 수신자의 공개키로 문서를 암호화하며, RSA는 대표적인 공개키 암호 알고리즘입니다.",74,54
401,1,5,1,시스템의 구성요소로 볼 수 없는 것은?,,Process,Feedback,Maintenance,Control,3,"시스템은 특정 목표를 달성하기 위해 상호작용하는 여러 요소들의 집합체입니다.  프로세스(Process)는 시스템 내에서 수행되는 작업 단위이고, 피드백(Feedback)은 시스템의 결과를 바탕으로 시스템을 조정하는 과정이며, 제어(Control)는 시스템의 동작을 감독하고 조절하는 기능입니다.  하지만 유지보수(Maintenance)는 시스템이 이미 구축된 후,  그 시스템의 성능을 유지하고 문제를 해결하기 위해 수행하는 활동입니다.  시스템의 *구성 요소* 자체는 아니죠.  시스템이 제대로 작동하기 위해서는 필수적인 활동이지만, 시스템을 이루는 기본적인 요소는 아닙니다.  마치 자동차의 엔진, 바퀴, 섀시가 자동차의 구성요소인 것처럼, 프로세스, 피드백, 제어는 시스템의 핵심적인 작동 원리를 나타내는 요소입니다.  반면 유지보수는 자동차를 정비하는 행위와 같아서 시스템의 본질적인 구성요소라고 보기 어렵습니다. 따라서 시스템의 구성 요소로 볼 수 없는 것은 유지보수입니다.",67,47
402,1,5,2,유스케이스(Usecase)에 대한 설명 중 옳은 것은?,,유스케이스 다이어그램은 개발자의 요구를 추출하고 분석하기 위해 주로 사용한다.,액터는 대상 시스템과 상호 작용하는 사람이나 다른 시스템에 의한 역할이다.,사용자 액터는 본 시스템과 데이터를 주고받는 연동 시스템을 의미한다.,연동의 개념은 일방적으로 데이터를 파일이나 정해진 형식으로 넘겨주는 것을 의미한다.,2,"이 문제는 유스케이스(Use Case) 다이어그램에서 사용되는 용어와 개념에 대한 이해도를 묻고 있습니다.  유스케이스는 시스템이 사용자나 다른 시스템과 어떻게 상호 작용하는지를 설명하는 하나의 시나리오라고 생각하면 됩니다.  마치 시스템이 제공하는 서비스에 대한 사용 설명서와 같은 것이죠.  정답은 시스템과 상호작용하는 주체, 즉 '액터'에 대한 설명입니다.  액터는 사람일 수도 있고, 다른 시스템일 수도 있습니다.  예를 들어, 온라인 쇼핑몰 시스템에서 '고객'은 액터이고, '결제 시스템'도 액터가 될 수 있습니다.  고객은 상품을 주문하고, 결제 시스템은 결제 정보를 처리하는 역할을 하죠.  다른 선지는 액터의 정의나 연동의 개념을 잘못 설명하고 있습니다. 개발자의 요구를 분석하는 도구는 유스케이스 다이어그램이 아닌 다른 분석 기법들이 사용됩니다. 사용자 액터는 시스템과 데이터를 주고받는 연동 시스템이 아니라 시스템을 사용하는 사람을 의미하며, 연동은 단순히 데이터를 넘겨주는 것 이상으로 양방향 상호작용을 포함하는 개념입니다. 따라서, 액터에 대한 정확한 정의를 제시하는 선지가 정답입니다.",63,2
403,1,5,3,요구사항 개발 프로세스의 순서로 옳은 것은?,https://www.cbtbank.kr/images/iz/iz20210515/iz20210515m3.gif,㉠ - ㉡ - ㉢ - ㉣,㉠ - ㉢ - ㉡ - ㉣,㉠ - ㉣ - ㉡ - ㉢,㉠ - ㉡ - ㉣ - ㉢,1,"요구사항 개발 프로세스는 소프트웨어 개발의 가장 첫 단계로, 사용자의 요구를 정확하게 파악하고 이를 시스템에 반영하는 과정입니다.  먼저 사용자로부터 요구사항을 도출(Elicitation)해야 합니다.  이 과정에서는 인터뷰, 설문조사, 워크숍 등 다양한 방법을 통해 사용자의 니즈를 수집합니다.  다음으로, 수집된 요구사항을 분석(Analysis)하여 중복되거나 모순되는 부분을 제거하고, 우선순위를 정합니다.  분석된 요구사항은 명세(Specification) 단계에서 구체적으로 기술됩니다.  이 단계에서는 요구사항을 명확하고 정확하게 문서화하여 개발팀과 사용자 간의 오해를 방지합니다.  마지막으로, 명세된 요구사항이 실제 사용자의 요구와 일치하는지 확인(Validation)하는 단계를 거칩니다.  이를 통해 요구사항의 정확성과 완전성을 검증하고, 필요한 수정을 진행합니다. 따라서 요구사항 개발 프로세스는 도출, 분석, 명세, 확인 순서로 진행되어야 하며, 이 순서를 바꾸면 요구사항의 오류나 누락이 발생할 가능성이 높아집니다.  이는 소프트웨어 개발의 성공적인 완료를 위해 매우 중요한 단계입니다.  정답은 이러한 요구사항 개발 프로세스의 논리적인 흐름을 정확하게 반영하고 있습니다.",80,2
404,1,5,4,객체지향 기법에서 같은 클래스에 속한 각각의 객체를 의미하는 것은?,,instance,message,method,module,1,"객체지향 프로그래밍에서 '클래스'는 설계도와 같습니다.  자동차를 만드는 설계도가 있다면, 그 설계도를 바탕으로 실제 자동차를 여러 대 만들 수 있죠?  클래스는 이 설계도에 해당하고, 실제로 만들어진 각각의 자동차는 '객체'라고 부릅니다.  문제에서 묻고 있는 것은, 같은 설계도(클래스)로 만들어진 각각의 자동차(객체)를 무엇이라고 부르는가 입니다.  '인스턴스(instance)'는 바로 이렇게 클래스를 바탕으로 생성된 개별 객체를 의미하는 용어입니다.  메시지는 객체 간의 통신 방식, 메소드는 객체가 수행하는 기능, 모듈은 프로그램의 구성 요소를 나타내는 용어이므로 문제의 질문과는 맞지 않습니다.  따라서 클래스로부터 생성된 개별 객체를 의미하는 '인스턴스'가 정답입니다.",77,7
405,1,5,5,"객체지향 설계에서 객체가 가지고 있는 속성과 오퍼레이션의 일부를 감추어서 객체의 외부에서는 접근이 불가능하게 하는 개념은? (문제 오류로 가답안 발표시 3번으로 발표되었지만 확정 답안 발표시 2, 3번이 정답처리 되었습니다. 여기서는 가답안인 3번을 누르면 정답 처리 됩니다.)",,조직화(Organizing),캡슐화(Encapsulation),정보은닉(Infomation Hiding),구조화(Structuralization),3,"객체지향 설계에서 객체는 데이터(속성)와 그 데이터를 처리하는 함수(오퍼레이션)로 구성됩니다.  마치 캡슐처럼 속성과 오퍼레이션을 하나로 묶어놓은 것이죠.  그런데 객체 내부의 모든 속성과 오퍼레이션을 외부에서 마음대로 접근할 수 있다면,  데이터의 무결성이 깨지거나 예상치 못한 오류가 발생할 위험이 있습니다.  예를 들어, 자동차 객체가 있다면 속도를 제어하는 오퍼레이션은 있지만,  외부에서 속도 변수를 직접 바꿀 수 있다면 자동차가 제어 불능 상태가 될 수도 있습니다.  따라서 객체의 내부 데이터를 보호하고 안정적인 시스템을 구축하기 위해 객체의 일부 속성과 오퍼레이션을 외부에서 접근할 수 없도록 감추는 것이 필요합니다. 이러한 개념이 바로 객체의 속성과 오퍼레이션을 외부로부터 보호하는 '정보은닉' 또는 '캡슐화'입니다.  정보은닉은 캡슐화의 한 측면으로, 캡슐화는 정보은닉을 포함하는 더 넓은 개념이라고 이해할 수 있습니다.  문제에서 가답안으로 제시된 '정보은닉'과 정답으로 확정된 '캡슐화'는 모두 객체의 내부 정보를 보호하는 개념을 설명하고 있으므로,  두 답변 모두 정답으로 인정된 것입니다.",88,7
406,1,5,6,GoF (Gangs of Four) 디자인 패턴에 대한 설명으로 틀린 것은?,,"factory method pattern은 상위클래스에서 객체를 생성하는 인터페이스를 정의하고, 하위클래스에서 인스턴스를 생성하도록 하는 방식이다.",prototype pattern은 prototype을 먼저 생성하고 인스턴스를 복제하여 사용하는 구조이다.,bridge pattern은 기존에 구현되어 있는 클래스에 기능 발생 시 기존 클래스를 재사용할 수 있도록 중간에서 맞춰주는 역할을 한다.,mediator pattern은 객체간의 통제와 지시의 역할을 하는 중재자를 두어 객체지향의 목표를 달성하게 해준다.,3,"GoF 디자인 패턴에 대한 문제입니다.  각 디자인 패턴의 개념을 정확히 이해하고 있는지 묻는 문제인데, 틀린 설명을 찾는 것이 핵심입니다.  먼저,  정답이 아닌 선지들을 살펴보면,  '상위 클래스에서 객체 생성 인터페이스를 정의하고 하위 클래스에서 인스턴스를 생성하는 방식'은 Factory Method 패턴의 정확한 설명입니다.  'prototype을 먼저 생성하고 인스턴스를 복제하여 사용하는 구조'는 Prototype 패턴을 잘 설명하고 있습니다. '객체 간의 통제와 지시 역할을 하는 중재자를 두어 객체지향의 목표를 달성하게 해준다'는 Mediator 패턴의 정확한 설명입니다.  하지만 문제의 정답인 선지는 Bridge 패턴에 대한 설명이 잘못되었습니다. Bridge 패턴은 기존 클래스를 재사용하는 것이 목적이지만, 단순히 '기능 발생 시 기존 클래스를 재사용할 수 있도록 중간에서 맞춰주는 역할'이라고 설명하는 것은 너무 단순하고 추상적입니다. Bridge 패턴은 추상화와 구현을 분리하여 각각 독립적으로 변화시킬 수 있도록 하는 패턴입니다.  즉,  기능(추상화)과 구현(구체화)을 분리하여 서로 다른 구현을 하나의 추상화에 연결할 수 있게 해주는 것이지, 단순히 기존 클래스를 '맞춰주는' 역할을 하는 것이 아닙니다.  따라서, Bridge 패턴에 대한 설명이 잘못된 것이 문제의 정답이 되는 것입니다.  쉽게 말해,  Bridge 패턴은 기능과 구현을 분리하여 서로에게 영향을 주지 않고 독립적으로 변경할 수 있도록 설계하는 고급 기법입니다.  단순히 기존 클래스를 재사용하는 것 이상의 의미를 지니고 있습니다.",59,7
407,1,5,7,요구사항 분석이 어려운 이유가 아닌 것은?,,개발자와 사용자 간의 지식이나 표현의 차이가 커서 상호 이해가 쉽지 않다.,사용자의 요구는 예외가 거의 없어 열거와 구조화가 어렵지 않다.,사용자의 요구사항이 모호하고 불명확하다.,소프트웨어 개발 과정 중에 요구사항이 계속 변할 수 있다.,2,"소프트웨어 개발에서 요구사항 분석이 어려운 이유는 크게 사용자와 개발자 간의 의사소통 문제, 요구사항의 불명확성, 그리고 요구사항의 변화 가능성 때문입니다.  사용자는 전문적인 개발 지식이 없어 자신이 원하는 것을 정확하게 표현하기 어렵고, 개발자는 사용자의 의도를 정확하게 파악하는 데 어려움을 겪습니다.  또한, 사용자의 요구사항 자체가 애매모호하거나 불완전한 경우가 많고, 개발 과정 중 사용자의 요구가 변경될 수도 있습니다.  하지만,  사용자의 요구가 예외 없이 명확하고 체계적으로 정리되어 있다면 요구사항 분석은 훨씬 수월해집니다.  따라서, 사용자의 요구가 예외가 거의 없어 열거와 구조화가 어렵지 않다는 것은 요구사항 분석이 어려운 이유가 아닙니다.  다른 선지는 모두 요구사항 분석의 어려움을 잘 나타내는 설명입니다.",89,2
408,1,5,8,소프트웨어 아키텍처 설계에서 시스템 품질속성이 아닌 것은?,,가용성 (Availability),독립성 (Isolation),변경 용이성 (Modifiability),사용성(Usability),2,"소프트웨어 아키텍처 설계에서 시스템의 품질을 평가하는 중요한 요소들을 '품질 속성'이라고 합니다.  가용성은 시스템이 얼마나 오랫동안 작동하는지를 나타내는 지표이고, 변경 용이성은 시스템을 수정하거나 업데이트하기가 얼마나 쉬운지를 나타내는 지표이며, 사용성은 사용자가 시스템을 얼마나 쉽고 효율적으로 사용할 수 있는지를 나타내는 지표입니다.  반면에 '독립성'은 시스템의 품질 속성이라기보다는 시스템 구성 요소 간의 관계를 설명하는 개념입니다.  하나의 구성 요소에 문제가 발생하더라도 다른 구성 요소에 영향을 미치지 않도록 설계하는 것을 의미하는데, 이는 시스템의 안정성이나 신뢰성에 기여하는 요소이긴 하지만,  직접적으로 시스템의 품질을 나타내는 속성이라고 보기는 어렵습니다.  따라서 시스템의 품질을 직접적으로 나타내는 가용성, 변경 용이성, 사용성과는 차이가 있습니다.  독립성은 시스템 설계의 중요한 고려 사항이지만,  가용성, 변경 용이성, 사용성과 같은 품질 속성 자체는 아닙니다.  마치 자동차의 속도, 연비, 안전성이 자동차의 품질 속성이라면,  자동차 부품 간의 분리성은 품질 속성이라기보다는 설계 원칙에 가깝다고 생각하면 이해하기 쉬울 것입니다.",60,6
409,1,5,9,다음 설명에 해당하는 시스템으로 옳은 것은?,https://www.cbtbank.kr/images/iz/iz20210515/iz20210515m9.gif,연계 서버,중계 서버,송신 시스템,수신 시스템,3,"문제에서 설명하는 시스템은 데이터베이스나 애플리케이션으로부터 데이터를 가져와서 다른 시스템으로 보내는 역할을 합니다.  마치 우체국처럼, 데이터를 받아서 목적지로 배달하는 것이죠.  ""연계 테이블 또는 파일 형태로 생성하여 송신한다""는 부분이 중요한데, 이는 데이터를 단순히 전달하는 것이 아니라, 다른 시스템이 이해할 수 있는 형태로 가공하여 보낸다는 의미입니다.  따라서 데이터를 '수신'하는 시스템이 아니라, 데이터를 '송신'하는 시스템이 정답입니다.  '연계 서버'나 '중계 서버'는 데이터를 중간에서 처리하거나 연결하는 역할을 하는데, 문제에서는 데이터를 생성하고 송신하는 기능에 초점을 맞추고 있으므로,  데이터를 직접 생성하고 송신하는 시스템이 가장 적절한 설명이 됩니다.",78,9
410,1,5,10,CASE(Computer-Aided Software Engineering)의 원천 기술이 아닌 것은?,,구조적 기법,프로토타이핑 기술,정보 저장소 기술,일괄처리 기술,4,"CASE(Computer-Aided Software Engineering)는 소프트웨어 개발 과정을 자동화하고 효율성을 높이기 위한 다양한 도구와 기법들을 통칭하는 용어입니다.  구조적 기법은 소프트웨어를 모듈화하고 계층적으로 설계하는 방법론으로 CASE 도구에서 핵심적인 역할을 합니다. 프로토타이핑 기술은 초기 단계에서 시스템의 모형을 빠르게 만들어 사용자 피드백을 받고 설계를 개선하는 데 사용되며, CASE 도구를 통해 프로토타입을 효율적으로 생성하고 관리할 수 있습니다. 정보 저장소 기술은 CASE 도구가 소프트웨어 개발 과정에서 생성되는 다양한 정보(요구사항, 설계 문서, 코드 등)를 효율적으로 저장하고 관리하는 데 필수적입니다. 반면, 일괄처리 기술은 여러 작업을 한꺼번에 처리하는 방식으로, CASE 도구 자체의 동작 방식과는 직접적인 관련이 없습니다. CASE 도구는 대화형으로 사용자가 작업을 지시하고 결과를 즉시 확인하는 방식으로 동작하기 때문입니다. 따라서 CASE의 원천 기술이 아닌 것은 일괄처리 기술입니다.  쉽게 말해, CASE는 소프트웨어 개발을 돕는 여러 도구와 방법들을 모아놓은 것이고, 일괄처리는 그 도구들을 사용하는 방식과는 무관한 개념이라고 생각하시면 됩니다.",57,2
411,1,5,11,객체에게 어떤 행위를 하도록 지시하는 명령은?,,Class,Package,Object,Message,4,"객체지향 프로그래밍에서 객체는 데이터(속성)와 그 데이터를 처리하는 함수(메서드)를 묶어놓은 개념입니다.  마치 레고 블록처럼, 각각의 객체는 특정 기능을 가지고 있고, 우리는 그 객체에게 특정 작업을 요청할 수 있습니다.  이때, 객체에게 어떤 행위를 하도록 지시하는 명령, 즉 객체와 객체 사이의 상호작용을 나타내는 것이 바로 ""메시지""입니다.  예를 들어, ""자동차""라는 객체가 있다면, ""시동을 걸어라"" 또는 ""속도를 높여라"" 와 같은 명령이 메시지에 해당합니다.  객체는 메시지를 받으면 내부적으로 해당 명령을 처리하고 결과를 반환합니다.  따라서 객체에게 행위를 지시하는 명령은 메시지라고 할 수 있습니다.  클래스는 객체의 설계도이고, 패키지는 관련된 클래스들을 묶어놓은 것이며, 객체는 클래스를 바탕으로 만들어진 실제 인스턴스입니다.  이들은 모두 객체지향 프로그래밍의 중요한 개념이지만, 객체에게 직접 행위를 지시하는 것은 메시지입니다.",84,7
412,1,5,12,서브시스템이 입력 데이터를 받아 처리하고 결과를 다른 시스템에 보내는 작업이 반복되는 아키텍처 스타일은?,,클라이언트 서버 구조,계층 구조,MVC 구조,파이프 필터 구조,4,"이 문제는 서브시스템들이 데이터를 순차적으로 처리하는 아키텍처 스타일을 묻고 있습니다.  데이터가 하나의 시스템에서 입력되면, 여러 개의 서브시스템을 거치면서 각 단계별로 처리가 이루어지고, 최종 결과는 다른 시스템으로 전달됩니다. 이러한 과정이 마치 파이프라인처럼 데이터가 흐르는 모습을 연상시키기 때문에 '파이프 필터 구조'라고 부릅니다.  각 서브시스템은 특정 작업(필터)만 담당하고, 이 필터들이 파이프처럼 연결되어 전체적인 처리 과정을 완성합니다.  다른 선택지들은 이러한 순차적이고 단계적인 데이터 처리 방식을 보여주지 않습니다. 클라이언트-서버 구조는 클라이언트의 요청에 서버가 응답하는 구조이고, 계층 구조는 여러 계층으로 나뉘어 있지만 순차적인 데이터 흐름을 강조하지 않습니다. MVC 구조는 모델, 뷰, 컨트롤러의 상호작용을 중시하지만, 데이터가 필터를 거치는 연속적인 처리 과정을 나타내지는 않습니다. 따라서 입력 데이터가 여러 단계의 처리 과정을 거쳐 결과를 출력하는 반복적인 작업 방식을 가장 잘 나타내는 것은 파이프 필터 구조입니다.  마치 공장의 조립라인처럼 생각하면 이해하기 쉬울 것입니다.",75,6
413,1,5,13,럼바우(Rumbaugh)의 객체지향 분석에서 사용하는 분석 활동으로 옳은 것은?,,"객체 모델링, 동적 모델링, 정적 모델링","객체 모델링, 동적 모델링, 기능 모델링","동적 모델링, 기능 모델링, 정적 모델링","정적 모델링, 객체 모델링, 기능 모델링",2,"럼바우의 객체지향 분석은 시스템을 객체들의 상호작용으로 모델링하는 방법입니다.  여기서 객체는 데이터(속성)와 그 데이터를 조작하는 행위(메소드)를 함께 갖는 개념입니다.  럼바우 방법론은 시스템을 이해하고 모델링하기 위해 크게 세 가지 관점을 제시합니다. 첫째, 시스템을 구성하는 객체들과 그들의 관계를 정의하는 **객체 모델링**입니다.  이는 시스템의 정적인 구조를 나타냅니다. 둘째, 객체들 간의 상호작용과 시간에 따른 변화를 보여주는 **동적 모델링**입니다. 이는 시스템의 동적인 행위를 나타냅니다. 마지막으로, 시스템이 수행하는 기능들을 기술하는 **기능 모델링**입니다. 이는 시스템이 무엇을 하는지, 어떤 기능을 제공하는지를 설명합니다. 따라서 시스템을 완벽하게 이해하려면 이 세 가지 관점 모두를 고려해야 하며, 럼바우의 객체지향 분석 활동은 바로 이 세 가지 모델링을 모두 포함합니다.  정적 모델링은 객체 모델링의 일부로 볼 수 있으므로, 객체 모델링, 동적 모델링, 기능 모델링이 럼바우 방법론의 핵심 분석 활동이 됩니다.",90,2
414,1,5,14,UML 다이어그램이 아닌 것은?,,액티비티 다이어그램(Activity diagram),절차 다이어그램(Procedural diagram),클래스 다이어그램(Class diagram),시퀀스 다이어그램(Sequence diagram),2,"UML(Unified Modeling Language)은 소프트웨어 시스템을 시각적으로 모델링하는 표준 언어입니다.  다양한 다이어그램을 제공하여 시스템의 구조, 동작, 상호작용 등을 표현하는데 사용됩니다.  문제에서 제시된 액티비티 다이어그램, 클래스 다이어그램, 시퀀스 다이어그램은 모두 UML의 표준 다이어그램입니다.  액티비티 다이어그램은 시스템의 동작 흐름을 보여주고, 클래스 다이어그램은 시스템의 구성 요소인 클래스들의 관계를 나타내며, 시퀀스 다이어그램은 객체 간의 상호작용을 시간 순서대로 보여줍니다.  하지만 '절차 다이어그램'은 UML 표준에 포함되지 않는 다이어그램입니다.  절차 다이어그램은 일반적으로 순서도와 같은 형태로, 프로그램의 실행 순서를 나타내는 데 사용되는 다이어그램이지 UML의 일부가 아닙니다. 따라서 UML 다이어그램이 아닌 것은 절차 다이어그램입니다.  쉽게 말해, UML은 소프트웨어 설계를 위한 그림 언어인데, 문제에서 틀린 것은 그 언어에 없는 그림이라는 것입니다.",63,2
415,1,5,15,UML 모델에서 한 객체가 다른 객체에게 오퍼레이션을 수행하도록 지정하는 의미적 관계로 옳은 것은?,,Dependency,Realization,Generalization,Association,2,"이 문제는 UML 모델에서 객체 간의 관계를 묻고 있습니다.  객체지향 프로그래밍에서 객체들은 서로 상호작용하며 프로그램을 구성하는데, 이러한 상호작용을 표현하는 방법 중 하나가 UML(Unified Modeling Language)입니다.  UML은 여러 가지 관계를 정의하는데,  문제에서 묻는 것은 한 객체가 다른 객체에게 특정 작업(오퍼레이션)을 요청하는 관계입니다.",47,2
416,1,5,16,다음 중 상위 CASE 도구가 지원하는 주요기능으로 볼 수 없는 것은?,,모델들 사이의 모순검사 기능,전체 소스코드 생성 기능,모델의 오류검증 기능,자료흐름도 작성 기능,2,"CASE(Computer-Aided Software Engineering) 도구는 소프트웨어 개발 과정을 자동화하고 효율성을 높이기 위해 사용되는 도구입니다.  상위 CASE 도구는 시스템 분석 및 설계 단계에서 사용되는 고급 기능을 제공하는데,  모델링, 검증, 분석 등의 기능을 포함합니다.  모델 간의 모순 검사나 모델의 오류 검증은 시스템의 일관성과 정확성을 확보하는 데 필수적인 기능입니다.  또한 자료흐름도 작성 기능도 시스템의 데이터 흐름을 시각적으로 표현하여 이해도를 높이는 데 도움을 줍니다. 하지만 전체 소스코드를 자동으로 생성하는 기능은 상위 CASE 도구의 주요 기능이라고 보기 어렵습니다.  상위 CASE 도구는 설계 단계까지 지원하는 것이지,  실제 동작하는 소스코드를 완벽하게 생성하는 것은 아닙니다.  소스코드 생성은 프로그래밍 단계에서 이루어지는 작업이며, CASE 도구는 설계 단계에서 생성된 모델을 바탕으로 개발자가 소스코드를 작성하는 것을 돕는 역할을 합니다. 따라서 전체 소스코드 생성 기능은 상위 CASE 도구가 지원하는 주요 기능으로 보기 어렵습니다.",72,3
417,1,5,17,요구사항 관리 도구의 필요성으로 틀린 것은?,,요구사항 변경으로 인한 비용 편익 분석,기존 시스템과 신규 시스템의 성능 비교,요구사항 변경의 추적,요구사항 변경에 따른 영향 평가,2,"요구사항 관리 도구는 소프트웨어 개발 과정에서 발생하는 요구사항의 변경을 효율적으로 관리하기 위한 도구입니다.  요구사항 변경은 프로젝트의 예산과 기간에 큰 영향을 미치기 때문에, 이러한 변경을 체계적으로 관리하고 그 영향을 평가하는 것은 매우 중요합니다.  따라서 요구사항 변경에 따른 비용 편익 분석, 변경 추적, 그리고 변경으로 인한 영향 평가는 요구사항 관리 도구의 필수적인 기능입니다.  하지만 기존 시스템과 신규 시스템의 성능 비교는 요구사항 자체의 관리보다는 시스템의 성능 평가에 초점을 맞춘 활동이므로, 요구사항 관리 도구의 필요성과는 직접적인 관련이 없습니다.  요구사항 관리 도구는 요구사항의 변경 및 관리에 집중하며, 시스템 성능 비교는 별도의 성능 테스트 및 분석 도구를 통해 수행됩니다.  결론적으로, 요구사항 관리 도구의 필요성과는 무관한 내용이므로 틀린 선지입니다.",62,3
418,1,5,18,애자일 개발 방법론이 아닌 것은?,,스크럼(Scrum),"익스트림 프로그래밍(XP, eXtreme Programming)","기능 주도 개발(FDD, Feature Driven Development)",하둡(Hadoop),4,"이 문제는 애자일 개발 방법론에 대한 이해도를 묻는 문제입니다. 애자일 개발 방법론은 소프트웨어 개발 과정에서 유연성과 적응력을 강조하는 접근 방식입니다.  스크럼, 익스트림 프로그래밍, 기능 주도 개발은 모두 대표적인 애자일 방법론으로,  짧은 개발 주기(스프린트)를 통해 지속적인 피드백을 받고,  변화하는 요구사항에 빠르게 대응하는 것을 특징으로 합니다. 반면, 하둡은 분산 저장 및 처리를 위한 오픈소스 프레임워크로,  소프트웨어 개발 방법론과는 관련이 없습니다.  하둡은 대용량 데이터를 효율적으로 처리하는 데 사용되는 기술이지, 소프트웨어 개발 프로세스 자체를 정의하는 방법론이 아니기 때문에 정답에서 제외됩니다.  따라서 애자일 개발 방법론이 아닌 것은 하둡입니다.",84,2
419,1,5,19,GoF(Gangs of Four) 디자인 패턴 중 생성패턴으로 옳은 것은?,,singleton pattern,adapter pattern,decorator pattern,state pattern,1,"GoF 디자인 패턴은 객체지향 프로그래밍에서 자주 발생하는 설계 문제에 대한 해결책을 미리 정의해 놓은 일종의 '설계 레시피'입니다.  여기서 생성 패턴은 객체 생성 과정을 제어하는 패턴들을 말하는데,  객체를 어떻게, 언제 생성할지, 어떤 방식으로 생성할지를 다룹니다.  정답으로 제시된 패턴은 객체 생성을 제어하는 대표적인 생성 패턴입니다.  이 패턴은 특정 클래스의 인스턴스가 단 하나만 생성되도록 보장하는 역할을 합니다.  예를 들어, 시스템 전체에서 단 하나만 존재해야 하는 데이터베이스 연결 객체나,  프로그램의 설정 정보를 관리하는 객체 등에 사용하면 유용합니다.  반면 나머지 선지는 객체의 생성보다는 객체의 역할이나 동작에 초점을 맞춘 패턴들입니다.  어댑터 패턴은 서로 다른 인터페이스를 가진 객체들을 연결하는 역할을 하고, 데코레이터 패턴은 객체에 기능을 추가하는 역할을 하며, 상태 패턴은 객체의 상태에 따라 동작을 변경하는 역할을 합니다. 따라서 객체 생성에 초점을 맞춘 생성 패턴 중 하나만이 정답이 됩니다.",76,7
420,1,5,20,사용자 인터페이스(UI)의 특징으로 틀린 것은?,,구현하고자 하는 결과의 오류를 최소화한다.,사용자의 편의성을 높임으로써 작업시간을 증가시킨다.,막연한 작업 기능에 대해 구체적인 방법을 제시하여 준다.,사용자 중심의 상호 작용이 되도록 한다.,2,"사용자 인터페이스(UI)는 사용자가 컴퓨터나 기계와 상호 작용하는 방식을 디자인하는 것을 말합니다. 좋은 UI는 사용자가 원하는 작업을 쉽고 효율적으로 수행할 수 있도록 돕는 것이 목표입니다.  문제에서 틀린 것은 사용자의 편의성을 높여 작업 시간을 증가시킨다는 선지입니다.  UI의 핵심 목표는 사용자의 편의성을 높여 작업 시간을 *단축*하는 것입니다.  더 쉽고 직관적인 인터페이스를 통해 사용자는 더 빠르게 작업을 완료할 수 있습니다.  나머지 선지는 모두 UI의 바람직한 특징을 나타냅니다. 오류를 최소화하고, 막연한 작업을 구체적인 방법으로 제시하며, 사용자 중심의 상호 작용을 제공하는 것은 좋은 UI 디자인의 중요한 요소입니다. 따라서 사용자 편의성 향상으로 작업 시간이 증가한다는 주장은 UI의 기본적인 목적에 반하는 잘못된 설명입니다.",90,4
421,1,5,21,힙 정렬(Heap Sort)에 대한 설명으로 틀린것은?,,정렬할 입력 레코드들로 힙을 구성하고 가장 큰 키 값을 갖는 루트 노드를 제거하는 과정을 반복하여 정렬하는 기법이다.,평균 수행 시간은 O(nlog2n)이다.,완전 이진트리(complete binary tree)로 입력자료의 레코드를 구성한다.,최악의 수행 시간은 O(2n4)이다.,4,"힙 정렬은 데이터를 완전 이진 트리 형태의 힙 자료구조로 만들어 정렬하는 알고리즘입니다.  힙의 특징은 루트 노드가 항상 가장 큰(최대 힙) 또는 가장 작은(최소 힙) 값을 가지는 것입니다.  힙 정렬은 이러한 특징을 이용하여 루트 노드(가장 큰 값)를 반복적으로 제거하고, 남은 데이터를 다시 힙으로 재구성하는 과정을 통해 정렬을 완료합니다.  따라서, 입력 데이터를 힙으로 구성하고, 가장 큰 값을 가진 루트 노드를 제거하는 과정을 반복한다는 설명은 정확합니다. 평균 및 최선의 수행 시간은 O(n log₂n)으로,  n개의 데이터를 정렬하는 데 걸리는 시간이 데이터 개수의 로그에 비례한다는 것을 의미합니다. 완전 이진 트리(complete binary tree)를 이용하는 것도 힙 정렬의 특징입니다.  하지만 최악의 수행 시간이 O(2n⁴)라고 하는 것은 틀린 설명입니다. 힙 정렬의 최악의 수행 시간은 O(n log₂n)이며,  O(2n⁴)는 훨씬 더 비효율적인 알고리즘의 수행 시간에 해당하는 값입니다. 따라서, 최악의 수행 시간에 대한 설명이 잘못된 것입니다.  쉽게 말해, 힙 정렬은 매우 효율적인 정렬 알고리즘이며,  제시된 틀린 설명은 힙 정렬의 성능을 과장되게 나쁘게 표현한 것입니다.",72,11
422,1,5,22,다음 중 단위 테스트를 통해 발견할 수 있는 오류가 아닌 것은?,,알고리즘 오류에 따른 원치 않는 결과,탈출구가 없는 반복문의 사용,모듈 간의 비정상적 상호작용으로 인한 원치 않는 결과,틀린 계산 수식에 의한 잘못된 결과,3,"단위 테스트는 소프트웨어의 가장 작은 단위인 모듈(함수 또는 클래스)을 개별적으로 테스트하는 방법입니다.  각 모듈이 제대로 작동하는지, 예상대로 결과를 내는지 확인하는 것이 목표입니다.  알고리즘 오류나 잘못된 계산 수식으로 인한 오류는 각 모듈 내부의 로직을 검증하는 단위 테스트를 통해 쉽게 발견할 수 있습니다.  탈출구 없는 반복문 역시 모듈 내부의 문제이므로 단위 테스트에서 찾아낼 수 있습니다.  하지만 모듈 간의 상호작용 문제는 단위 테스트의 범위를 벗어납니다. 단위 테스트는 각 모듈을 *독립적으로* 테스트하기 때문입니다.  모듈 간의 통합 및 상호작용은 통합 테스트(Integration Test) 단계에서 확인해야 합니다. 따라서 모듈 간의 비정상적인 상호작용으로 인한 오류는 단위 테스트로는 발견하기 어렵습니다.  단위 테스트는 각 부품이 제대로 작동하는지 확인하는 것이고, 통합 테스트는 부품들을 조립했을 때 제대로 작동하는지 확인하는 것과 같습니다.",65,14
423,1,5,23,다음 설명의 소프트웨어 테스트의 기본원칙은?,https://www.cbtbank.kr/images/iz/iz20210515/iz20210515m23.gif,살충제 패러독스,결함 집중,오류 부재의 궤변,완벽한 테스팅은 불가능,2,"문제에서 제시된 설명은 소프트웨어의 결함이 특정 모듈에 집중되어 있다는 것을 보여줍니다.  파레토 법칙(80/20 법칙)을 소프트웨어 테스트에 적용하면, 소수의 모듈에 대부분의 결함이 존재한다는 것을 알 수 있습니다.  즉,  애플리케이션의 결함은 특정 부분에 집중되어 있고, 그 부분을 집중적으로 테스트하면 효율적으로 결함을 발견할 수 있다는 의미입니다. 이러한 현상을 ""결함 집중""이라고 합니다.  문제에서 제시된 추가 설명은 이러한 결함 집중 현상의 특징을 잘 나타내고 있습니다.  ""살충제 패러독스""는 같은 테스트 방법을 반복하면 새로운 결함을 찾지 못하는 현상이고, ""오류 부재의 궤변""은 테스트를 통해 오류가 발견되지 않았다고 해서 오류가 없다고 단정하는 오류이며, ""완벽한 테스팅은 불가능""은 소프트웨어 테스트의 일반적인 한계를 나타내는 말입니다.  따라서 문제의 설명과 가장 잘 맞는 것은 소프트웨어 결함이 특정 부분에 집중되는 현상을 설명하는 ""결함 집중""입니다.",82,19
424,1,5,24,버전 관리 항목 중 저장소에 새로운 버전의 파일로 갱신하는 것을 의미하는 용어는?,,형상 감사(Configuration Audit),롤백 (Rollback),단위 테스트(Unit Test),체크인(Check-In),4,"버전 관리 시스템은 소프트웨어 개발 과정에서 코드 변경 사항을 추적하고 관리하는 데 사용됩니다.  새로운 코드를 작성하거나 기존 코드를 수정하면, 이러한 변경 사항들을 버전 관리 시스템에 기록하여 나중에 특정 시점의 코드로 되돌아갈 수 있도록 합니다.  문제에서 묻고 있는 것은 저장소에 새로운 버전의 파일을 업데이트하는 행위를 의미하는 용어입니다.  이러한 행위는  새로운 코드를 저장소에 ""저장""하거나 ""등록""하는 것을 의미하며,  버전 관리 시스템에서 일반적으로 사용하는 용어는 ""체크인(Check-In)""입니다.  체크인을 통해 새로운 버전의 파일이 저장소에 업데이트되고, 이전 버전과의 차이점이 기록되어 관리됩니다.  다른 선택지는 버전 관리와 직접적인 관련이 없습니다. 형상 감사는 시스템의 상태를 점검하는 것이고, 롤백은 이전 버전으로 되돌리는 것이며, 단위 테스트는 코드의 일부분을 테스트하는 것입니다. 따라서 저장소에 새로운 버전의 파일로 갱신하는 것을 의미하는 용어는 체크인(Check-In)이 가장 적절합니다.",77,18
425,1,5,25,소프트웨어 테스트와 관련한 설명으로 틀린것은?,,화이트 박스 테스트는 모듈의 논리적인 구조를 체계적으로 점검할 수 있다.,블랙박스 테스트는 프로그램의 구조를 고려하지 않는다.,"테스트 케이스에는 일반적으로 시험 조건,테스트 데이터, 예상 결과가 포함되어야한다.",화이트박스 테스트에서 기본 경로(BasisPath)란 흐름 그래프의 시작 노드에서 종료노드까지의 서로 독립된 경로로 싸이클을 허용하지 않는 경로를 말한다.,4,"소프트웨어 테스트는 프로그램의 오류를 찾아내는 과정입니다.  문제에서 틀린 설명을 찾는 것이 목표인데요,  화이트 박스 테스트는 프로그램의 내부 구조를 알고 테스트하는 방법이고, 블랙 박스 테스트는 내부 구조를 모르고 테스트하는 방법입니다.  테스트 케이스는 테스트를 위한 조건, 데이터, 그리고 예상 결과를 포함해야 효율적인 테스트가 가능하죠.  하지만 기본 경로에 대한 설명은 잘못되었습니다.  기본 경로는 흐름 그래프의 모든 경로를 한 번씩 거치도록 설계된 경로이며,  반드시 시작 노드에서 종료 노드까지의 독립적인 경로일 필요는 없고,  싸이클(순환)을 포함할 수도 있습니다.  따라서 기본 경로에 대한 설명이 틀렸다는 것을 알 수 있습니다.  쉽게 말해,  프로그램의 길을 모두 다 가보는 것이 기본 경로인데,  문제에서는 잘못된 설명으로  '싸이클을 허용하지 않는다'라고 되어있어 틀린 것입니다.",63,19
426,1,5,26,"애플리케이션의 처리량, 응답시간, 경과시간, 자원사용률에 대해 가상의 사용자를 생성하고 테스트를 수행함으로써 성능 목표를 달성하였는지를 확인하는 테스트 자동화 도구는?",,명세 기반 테스트 설계 도구,코드 기반 테스트 설계 도구,기능 테스트 수행 도구,성능 테스트 도구,4,"애플리케이션의 성능을 평가하는 데에는 여러 가지 요소가 고려됩니다.  처리량(얼마나 많은 요청을 처리할 수 있는지), 응답시간(요청에 대한 응답이 얼마나 빨리 돌아오는지), 경과시간(전체 작업이 완료되는 데 걸리는 시간), 그리고 자원 사용률(CPU, 메모리 등 시스템 자원을 얼마나 사용하는지) 등이 중요한 지표입니다.  문제에서 제시된 상황은 바로 이러한 성능 지표들을 측정하고 분석하여 애플리케이션이 목표 성능을 만족하는지 확인하는 과정을 자동화하는 도구를 묻고 있습니다.  가상의 사용자를 생성하여 실제 사용 환경을 모방하고, 다양한 부하 조건에서 애플리케이션을 테스트하여 성능을 측정하는 것은 바로 '성능 테스트'의 핵심적인 방법입니다. 따라서 애플리케이션의 처리량, 응답시간, 경과시간, 자원사용률을 측정하고 테스트하여 성능 목표 달성 여부를 확인하는 자동화 도구는 '성능 테스트 도구'가 됩니다.  다른 선택지는 애플리케이션의 기능이나 코드 자체를 검증하는 데 초점을 맞춘 것이므로, 성능 평가라는 문제의 핵심과는 부합하지 않습니다.",82,20
427,1,5,27,소프트웨어 형상 관리에 대한 설명으로 거리가 먼 것은?,,소프트웨어에 가해지는 변경을 제어하고 관리한다.,"프로젝트 계획, 분석서, 설계서, 프로그램, 테스트 케이스 모두 관리 대상이다.","대표적인 형상관리 도구로 Ant, Maven, Gradle 등이 있다.",유지 보수 단계뿐만 아니라 개발 단계에도 적용할 수 있다.,3,"소프트웨어 형상 관리(Software Configuration Management, SCM)는 소프트웨어 개발 과정에서 발생하는 모든 변경 사항을 체계적으로 관리하고 추적하는 것을 말합니다.  소프트웨어의 변경을 효율적으로 관리하여 버전 충돌을 방지하고, 개발 과정의 투명성을 확보하며, 최종적으로는 소프트웨어 품질을 향상시키는 데 목적이 있습니다.  문제에서 제시된 내용 중 잘못된 것은 형상 관리 도구에 대한 설명입니다. Ant, Maven, Gradle은 소프트웨어 빌드 자동화 도구이지, 소프트웨어 형상 관리 도구가 아닙니다.  형상 관리 도구는 Git, SVN, CVS 등과 같이 소프트웨어의 변경 이력을 관리하고, 여러 개발자의 작업을 통합하는 데 사용되는 도구입니다.  빌드 자동화 도구는 소프트웨어를 컴파일하고, 테스트하고, 배포하는 과정을 자동화하는 데 사용되며, 형상 관리와는 다른 목적을 가지고 있습니다. 따라서 소프트웨어 형상 관리와는 관련이 없는 내용이 포함된 선지가 정답입니다.",67,15
428,1,5,28,디지털 저작권 관리(DRM) 구성 요소가 아닌 것은?,,Dataware house,DRM Controller,Packager,Contents Distributor,1,"디지털 저작권 관리(DRM)은 디지털 콘텐츠의 저작권을 보호하기 위한 기술입니다.  DRM 시스템은 콘텐츠의 복제, 배포, 사용을 제한하여 저작권자의 권리를 보호하는 역할을 합니다.  문제에서 제시된 선지들을 살펴보면, 콘텐츠를 패키징하는 기능(Packager), 콘텐츠를 배포하는 기능(Contents Distributor), 그리고 DRM 시스템의 핵심 요소인 DRM 컨트롤러(DRM Controller)는 모두 DRM 구성 요소로 볼 수 있습니다.  하지만 데이터 웨어하우스(Data warehouse)는  대량의 데이터를 저장하고 분석하는 데 사용되는 시스템으로, DRM과 직접적인 관련이 없습니다.  DRM은 콘텐츠의 저작권 보호에 초점을 맞추는 반면, 데이터 웨어하우스는 데이터 분석 및 활용에 초점을 맞추기 때문입니다. 따라서 데이터 웨어하우스는 DRM 구성 요소가 아닙니다.  쉽게 말해, DRM은 콘텐츠를 지키는 경비 시스템이라면, 데이터 웨어하우스는 데이터를 모아 분석하는 창고와 같은 것입니다.  두 시스템은 서로 다른 목적을 가지고 있으므로, 데이터 웨어하우스는 DRM 구성 요소로 포함될 수 없습니다.",62,16
429,1,5,29,다음 설명의 소프트웨어 버전 관리도구 방식은?,https://www.cbtbank.kr/images/iz/iz20210515/iz20210515m29.gif,단일 저장소 방식,분산 저장소 방식,공유폴더 방식,클라이언트·서버 방식,2,"문제에서 제시된 설명을 보면, 버전 관리 자료가 원격 저장소와 로컬 저장소 모두에 저장되어 관리된다는 점이 중요합니다.  이는 원격 저장소에 문제가 발생하더라도 로컬 저장소의 자료를 이용하여 작업을 계속 진행할 수 있다는 것을 의미합니다.  이러한 특징은 단일 저장소 방식에서는 찾아볼 수 없습니다. 단일 저장소 방식은 중앙 저장소 하나만 존재하기 때문에, 중앙 저장소에 문제가 생기면 모든 작업이 중단될 위험이 있습니다.  반면에, 문제에서 설명하는 방식은  각 개발자의 컴퓨터에 저장소의 복사본이 존재하고, 이들이 서로 독립적으로 작업을 진행하면서 필요에 따라 원격 저장소와 동기화하는 방식입니다.  이처럼 로컬 저장소와 원격 저장소를 모두 사용하는 분산된 구조를 가진 버전 관리 방식을 분산 저장소 방식이라고 합니다. Git은 대표적인 분산 저장소 방식의 버전 관리 도구이며, 문제에서도 언급하고 있습니다. 따라서 문제의 설명에 가장 잘 맞는 답은 분산 저장소 방식입니다.  공유 폴더 방식은 버전 관리 기능이 부족하고, 클라이언트-서버 방식은 중앙 저장소에 의존도가 높아 문제 상황에 대한 대처 능력이 떨어집니다.",78,18
430,1,5,30,블랙박스 테스트를 이용하여 발견할 수 있는 오류가 아닌 것은?,,비정상적인 자료를 입력해도 오류 처리를 수행하지 않는 경우,정상적인 자료를 입력해도 요구된 기능이 제대로 수행되지 않는 경우,반복 조건을 만족하는데도 루프 내의 문장이 수행되지 않는 경우,경계값을 입력할 경우 요구된 출력 결과가 나오지 않는 경우,3,"블랙박스 테스트는 소프트웨어의 내부 구조를 알지 못한 채, 입력값과 출력값만을 가지고 테스트하는 방법입니다.  마치 검은 상자(블랙박스) 안에서 어떤 일이 일어나는지 모르고, 입력과 출력만 확인하는 것과 같습니다.  따라서 블랙박스 테스트를 통해서는 소프트웨어의 내부 로직(예: 루프의 동작 방식)에 대한 오류는 직접적으로 찾기 어렵습니다.  반복 조건을 만족하는데도 루프 내의 문장이 수행되지 않는 오류는 소프트웨어의 내부 코드에 문제가 있는 것이므로, 입력값과 출력값만으로는 확인하기 어렵습니다.  다른 선택지들은 모두 입력값과 출력값을 비교하여 오류를 발견할 수 있는 경우입니다. 예를 들어, 비정상적인 자료를 입력했을 때 오류 처리를 하지 않거나, 정상적인 자료를 입력했는데도 결과가 틀리거나, 경계값(최대값, 최소값 등)을 입력했을 때 예상치 못한 결과가 나오는 경우는 모두 블랙박스 테스트를 통해 쉽게 발견 가능합니다.  하지만 루프 내부의 문장 수행 여부는 블랙박스 테스트의 범위를 벗어납니다.  결론적으로, 블랙박스 테스트는 소프트웨어의 외부 동작을 검증하는 데 초점을 맞추기 때문에, 내부 로직의 오류는 발견하기 어렵습니다.",72,19
431,1,5,31,다음 자료를 버블 정렬을 이용하여 오름차순으로 정렬할 경우 Pass 2의 결과는?,https://www.cbtbank.kr/images/iz/iz20210515/iz20210515m31.gif,"3, 5, 6, 7, 9","6, 7, 3, 5, 9","3, 5, 9, 6, 7","6, 3, 5, 7, 9",4,"버블 정렬은 인접한 두 원소를 비교하여 크기 순서대로 자리를 바꾸는 정렬 알고리즘입니다.  주어진 자료 9, 6, 7, 3, 5를 오름차순으로 정렬하는 과정을 살펴보겠습니다.",66,11
432,1,5,32,정렬된 N개의 데이터를 처리하는 데 O(Nlog2N)의 시간이 소요되는 정렬 알고리즘은?,,합병정렬,버블정렬,선택정렬,삽입정렬,1,"정렬된 N개의 데이터를 처리하는 데 걸리는 시간이 O(Nlog₂N)인 알고리즘을 찾는 문제입니다.  알고리즘의 시간 복잡도는 알고리즘의 효율성을 나타내는 중요한 지표인데요,  O(Nlog₂N)은  데이터의 개수(N)가 증가할 때,  로그 함수의 성장 속도가 선형 함수보다 느리기 때문에 상대적으로 효율적인 정렬 알고리즘임을 의미합니다.  여러 정렬 알고리즘 중에서 합병 정렬은 데이터를 반으로 계속 나누어 정렬한 후 합치는 방식으로,  항상 O(Nlog₂N)의 시간 복잡도를 보장합니다.  반면 버블 정렬, 선택 정렬, 삽입 정렬은 최악의 경우 O(N²)의 시간 복잡도를 가지므로, 데이터의 개수가 많아질수록 처리 시간이 훨씬 오래 걸립니다. 따라서 정렬된 N개의 데이터를 O(Nlog₂N)의 시간 복잡도로 처리하는 알고리즘은 합병 정렬입니다.  쉽게 말해,  데이터가 많아져도 합병 정렬은 다른 정렬 방법들보다 훨씬 빠르게 정렬을 완료할 수 있다는 뜻입니다.",72,11
433,1,5,33,다음 postfix로 표현된 연산식의 연산 결과로 옳은 것은?,https://www.cbtbank.kr/images/iz/iz20210515/iz20210515m33.gif,35,42,81,360,2,"이 문제는 후위 표기법(postfix notation)으로 표현된 연산식을 계산하는 문제입니다. 후위 표기법은 연산자가 피연산자 뒤에 오는 표기법으로, 괄호 없이 연산 순서를 명확하게 나타낼 수 있습니다.  주어진 연산식 ""3 4 * 5 6 * +""는 다음과 같이 계산됩니다.",85,11
434,1,5,34,"EAI(Enterprise Application Integration) 구축 유형에서 애플리케이션 사이에 미들웨어를 두어 처리하는 것은? (문제 오류로 가답안 발표시 1번으로 발표되었지만 확정 답안 발표시 1, 3, 4번이 정답처리 되었습니다. 여기서는 가답안인 1번을 누르면 정답 처리 됩니다.)",,Message Bus,Point-to-point,Hub & Spoke,Hybrid,1,"이 문제는 EAI(Enterprise Application Integration) 구축 유형 중에서 애플리케이션 간의 통신을 어떻게 처리하는지 묻고 있습니다.  EAI는 여러 개의 서로 다른 애플리케이션들이 서로 정보를 주고받으며 효율적으로 협업할 수 있도록 연결해주는 시스템입니다.  마치 여러 부서가 서로 다른 방식으로 일을 하지만, 중간에서 메시지를 전달하고 조정해주는 비서와 같은 역할을 한다고 생각하면 이해하기 쉽습니다.",83,10
435,1,5,35,인터페이스 구현 검증 도구가 아닌 것은?,,Foxbase,STAF,watir,xUnit,1,"이 문제는 인터페이스 구현 검증 도구를 묻고 있습니다.  인터페이스란 서로 다른 시스템이나 모듈 간의 연결고리를 의미하며,  이 연결고리가 제대로 작동하는지 확인하는 도구가 필요합니다.  정답은 Foxbase를 제외한 나머지 도구들입니다.  Foxbase는 데이터베이스 관리 시스템(DBMS)으로,  인터페이스 검증과는 직접적인 관련이 없습니다. 반면 STAF(Software Testing Automation Framework), Watir(Web Application Testing in Ruby), xUnit(단위 테스트 프레임워크)는 모두 소프트웨어 테스트 자동화에 사용되는 도구들입니다.  특히 STAF와 Watir는 다양한 시스템 간의 인터페이스를 테스트하는 데 유용하게 활용될 수 있으며, xUnit은 인터페이스를 구성하는 개별 모듈의 기능 검증에 사용됩니다. 따라서 인터페이스 구현 검증과 관련 없는 것은 Foxbase입니다.  쉽게 말해,  집을 짓는다고 생각해보세요.  Foxbase는 벽돌을 만드는 공장이고, 나머지 도구들은 벽돌들이 제대로 맞물려 집이 잘 지어졌는지 확인하는 도구들입니다.  집의 구조(인터페이스)를 확인하는 데 벽돌 공장은 직접적인 도움이 되지 않죠.",61,24
436,1,5,36,클린코드 작성원칙에 대한 설명으로 틀린 것은?,,코드의 중복을 최소화 한다.,코드가 다른 모듈에 미치는 영향을 최대화하도록 작성한다.,누구든지 코드를 쉽게 읽을 수 있도록 작성한다.,간단하게 코드를 작성한다.,2,"클린 코드 작성 원칙은 코드의 가독성, 유지보수성, 재사용성을 높이기 위한 지침입니다.  코드의 중복을 최소화하고, 간결하고 이해하기 쉽게 작성하는 것은 좋은 코드의 기본적인 요소입니다.  누구나 쉽게 코드를 이해하고 수정할 수 있도록 작성하는 것은 매우 중요한데, 이는 협업이나 유지보수 과정에서 발생할 수 있는 문제를 최소화하기 때문입니다.  하지만 코드가 다른 모듈에 미치는 영향을 최대화하는 것은 오히려 바람직하지 않습니다.  모듈 간의 결합도를 최소화하여 하나의 모듈의 변경이 다른 모듈에 미치는 영향을 최소화하는 것이 클린 코드의 중요한 원칙입니다.  만약 한 모듈의 변경이 다른 많은 모듈에 영향을 미친다면, 유지보수가 어려워지고 예상치 못한 오류가 발생할 가능성이 높아집니다. 따라서 코드는 독립적이고, 다른 모듈과의 의존성을 최소화하도록 작성되어야 합니다.  결론적으로, 다른 모듈에 미치는 영향을 최대화하는 것은 클린 코드 작성 원칙에 어긋나는 내용입니다.",87,7
437,1,5,37,소프트웨어 패키징에 대한 설명으로 틀린 것은?,,패키징은 개발자 중심으로 진행한다.,"신규 및 변경 개발소스를 식별하고, 이를 모듈화하여 상용제품으로 패키징 한다.",고객의 편의성을 위해 매뉴얼 및 버전관리를 지속적으로 한다.,범용 환경에서 사용이 가능하도록 일반적인 배포 형태로 패키징이 진행된다.,1,"소프트웨어 패키징이란 개발이 완료된 소프트웨어를 사용자가 쉽게 설치하고 사용할 수 있도록 포장하는 과정입니다.  여기서 중요한 점은 사용자 중심의 편의성을 제공하는 것이지, 개발자의 편의성을 우선시하는 것이 아니라는 점입니다.  따라서 개발자 중심으로 진행한다는 설명은 잘못된 것입니다.  소프트웨어 패키징은  신규 및 변경된 소스 코드를 모듈화하여 하나의 완성된 제품으로 만드는 과정이며, 고객이 쉽게 사용할 수 있도록 사용 설명서(매뉴얼)를 제공하고, 버전 관리를 통해 업데이트를 제공하는 등 지속적인 관리가 필요합니다. 또한, 다양한 환경에서 사용 가능하도록 일반적인 배포 형태로 패키징하는 것이 중요합니다.  결론적으로, 사용자의 편의성과 호환성을 최우선으로 고려하여 진행되어야 하므로,  개발자 중심으로 진행한다는 주장은 소프트웨어 패키징의 본질과 맞지 않습니다.",87,16
438,1,5,38,공학적으로 잘된 소프트웨어(Well Engineered Software)의 설명 중 틀린 것은?,,소프트웨어는 유지보수가 용이해야 한다.,소프트웨어는 신뢰성이 높아야 한다.,소프트웨어는 사용자 수준에 무관하게 일관된 인터페이스를 제공해야 한다.,소프트웨어는 충분한 테스팅을 거쳐야 한다.,3,"잘 설계된 소프트웨어는 여러 가지 중요한 특징을 가져야 합니다.  유지보수가 용이해야 한다는 것은 소프트웨어의 변경이나 수정이 쉽게 이루어져야 함을 의미하고, 신뢰성이 높다는 것은 오류 없이 안정적으로 동작해야 함을 의미합니다. 충분한 테스팅을 거쳐야 한다는 것은 소프트웨어의 결함을 최소화하기 위해 철저한 검증 과정이 필요함을 의미합니다.  하지만, 모든 사용자에게 일관된 인터페이스를 제공해야 한다는 것은 현실적으로 어려운 부분이 있습니다.  사용자의 연령, 기술 수준, 사용 목적 등에 따라 인터페이스는 다르게 설계될 수 있으며, 오히려 사용자 맞춤형 인터페이스가 더 효율적일 수 있습니다.  예를 들어, 어린이를 위한 게임 소프트웨어와 전문가를 위한 설계 소프트웨어는 인터페이스가 다를 수밖에 없죠. 따라서 모든 사용자에게 완전히 동일한 인터페이스를 제공하는 것은 오히려 비효율적이고 사용자 경험을 저해할 수 있습니다.  결론적으로, 잘 설계된 소프트웨어는 사용자의 특성을 고려하여 최적화된 인터페이스를 제공하는 것이 중요하며,  모든 사용자에게 동일한 인터페이스를 강요하는 것은 잘못된 생각입니다.",90,17
439,1,5,39,테스트와 디버그의 목적으로 옳은 것은?,,테스트는 오류를 찾는 작업이고 디버깅은 오류를 수정하는 작업이다.,테스트는 오류를 수정하는 작업이고 디버깅은 오류를 찾는 작업이다.,둘 다 소프트웨어의 오류를 찾는 작업으로 오류 수정은 하지 않는다.,"둘 다 소프트웨어 오류의 발견, 수정과 무관하다.",1,"소프트웨어 개발 과정에서 테스트와 디버깅은 서로 다른 목적을 가지고 수행되는 작업입니다.  테스트는 개발된 소프트웨어에 오류가 있는지 확인하는 과정입니다.  마치 제품을 출시하기 전에 꼼꼼하게 검사하는 것과 같습니다.  만약 테스트 과정에서 오류가 발견되면, 그 다음 단계인 디버깅을 통해 오류의 원인을 찾고 수정하는 작업을 진행합니다.  즉, 테스트는 오류를 '찾는' 작업이고, 디버깅은 오류를 '수정하는' 작업이라고 할 수 있습니다.  따라서 테스트와 디버깅은 서로 협력하여 소프트웨어의 품질을 높이는 데 기여하는 상호보완적인 과정입니다.  오류를 찾는 것과 수정하는 것은 별개의 작업이며,  테스트는 오류를 발견하는 데 집중하고, 디버깅은 발견된 오류를 해결하는 데 집중하는 것이 효율적입니다.",78,14
440,1,5,40,다음 중 스택을 이용한 연산과 거리가 먼 것은?,,선택정렬,재귀호출,후위표현(Post-fix expression)의 연산,깊이우선탐색,1,"이 문제는 자료구조 중 스택의 특징을 얼마나 잘 이해하고 있는지 묻는 문제입니다. 스택은 '후입선출(LIFO, Last-In-First-Out)' 방식으로 데이터를 관리하는 자료구조입니다.  마지막에 들어온 데이터가 가장 먼저 나가는 특징을 가지죠.  상상해보세요. 접시를 쌓아 올리는 모습을요. 가장 위에 놓은 접시가 가장 먼저 치워지죠? 스택이 바로 그런 구조입니다.",54,11
441,1,5,41,병렬 데이터베이스 환경 중 수평 분할에서 활용되는 분할 기법이 아닌 것은?,,라운드-로빈,범위 분할,예측 분할,해시 분할,3,"병렬 데이터베이스 환경에서 데이터를 여러 서버에 분산 저장하는 수평 분할 기법은 데이터 접근 속도를 높이고 시스템의 확장성을 향상시키는 데 효과적입니다.  여러 가지 수평 분할 기법 중에서  '라운드 로빈', '범위 분할', '해시 분할'은 데이터를 특정 규칙에 따라 서버에 분배하는 대표적인 방법입니다.  '라운드 로빈'은 데이터를 순차적으로 서버에 할당하고, '범위 분할'은 데이터의 특정 범위(예: 고객 ID 1000~2000)를 특정 서버에 할당하며, '해시 분할'은 해시 함수를 이용하여 데이터를 서버에 분산시킵니다.  하지만 문제에서 묻고 있는 것은 수평 분할에서 활용되는 기법이 *아닌* 것을 묻고 있습니다.  '예측 분할'은 데이터의 분포를 미리 예측하여 분할하는 기법으로, 수평 분할 기법으로 분류되지 않습니다.  수평 분할은 데이터의 실제 값이나 특성을 기반으로 분할하는 반면, 예측 분할은 미래의 데이터 분포를 예측하는 데 초점을 맞추기 때문에 수평 분할 기법으로 보기 어렵습니다. 따라서 정답은 '예측 분할'입니다.  쉽게 말해,  수평 분할은 데이터를 나누는 방법을 정해놓고 나누는 것이지만, 예측 분할은 미래를 예측해서 나누는 것이기 때문에 서로 다른 개념입니다.",44,32
442,1,5,42,시스템 카탈로그에 대한 설명으로 옳지 않은 것은?,,사용자가 직접 시스템 카탈로그의 내용을 갱신하여 데이터베이스 무결성을 유지한다.,시스템 자신이 필요로 하는 스키마 및 여러가지 객체에 관한 정보를 포함하고 있는 시스템 데이터베이스이다.,시스템 카탈로그에 저장되는 내용을 메타데이터라고도 한다.,시스템 카탈로그는 DBMS가 스스로 생성하고 유지한다.,1,"시스템 카탈로그는 데이터베이스 관리 시스템(DBMS)이 데이터베이스의 구조와 내용에 대한 정보를 저장하는 곳입니다.  마치 도서관의 카탈로그가 책의 제목, 저자, 위치 등을 알려주는 것처럼, 시스템 카탈로그는 테이블의 이름, 컬럼의 자료형, 인덱스 정보 등 데이터베이스의 메타데이터(데이터에 대한 데이터)를 저장합니다.  따라서 DBMS는 시스템 카탈로그를 이용하여 데이터베이스를 효율적으로 관리하고 사용자의 질의를 처리합니다.  사용자가 직접 시스템 카탈로그의 내용을 수정하는 것은 매우 위험하며, 데이터베이스의 무결성을 심각하게 훼손할 수 있습니다.  DBMS는 시스템 카탈로그를 스스로 생성하고 유지 관리하며, 사용자는 시스템 카탈로그를 직접 변경할 수 없습니다.  시스템 카탈로그에 저장된 정보는 메타데이터라고 부르는 것이 맞습니다.  따라서 사용자가 직접 시스템 카탈로그를 갱신한다는 내용은 잘못된 설명입니다.",73,29
443,1,5,43,SQL 문에서 SELECT에 대한 설명으로 옳지않은 것은?,,FROM 절에는 질의에 의해 검색될 데이터들을 포함하는 테이블명을 기술한다.,검색결과에 중복되는 레코드를 없애기위해서는 WHERE 절에 'DISTINCT'키워드를 사용한다.,"HAVING 절은 GROUP BY 절과 함께 사용되며, 그룹에 대한 조건을 지정한다.",ORDER BY 절은 특정 속성을 기준으로 정렬하여 검색할 때 사용한다.,2,"SQL 문에서 SELECT 문은 데이터베이스에서 원하는 정보를 가져오는 명령어입니다.  문제에서 옳지 않은 설명을 찾는 것이므로, 각 선택지들을 하나씩 살펴보겠습니다.  먼저, 데이터를 가져올 테이블을 지정하는 FROM 절은 필수적인 부분이며, 정확한 설명입니다.  다음으로,  GROUP BY 절을 사용하여 데이터를 그룹화한 후, 각 그룹에 대한 조건을 설정하는 HAVING 절 역시 정확한 설명입니다. 마지막으로, 검색 결과를 특정 속성을 기준으로 정렬하는 ORDER BY 절 또한 정확한 기능을 설명하고 있습니다.  하지만, 검색 결과에서 중복되는 레코드를 제거하기 위해서는 WHERE 절이 아닌 SELECT 절에 DISTINCT 키워드를 사용해야 합니다.  WHERE 절은 행(레코드) 자체를 필터링하는 역할을 하지만, DISTINCT 키워드는 SELECT 절에서 중복된 결과를 제거하는 역할을 합니다. 따라서, 중복 레코드 제거에 대한 설명이 잘못된 것입니다.  쉽게 말해, WHERE 절은 ""조건에 맞는 레코드만 가져와"" 라는 의미이고, DISTINCT 키워드는 ""중복된 레코드는 하나만 가져와"" 라는 의미입니다.  따라서, 중복 레코드 제거에 대한 설명이 잘못된 선택지가 옳지 않은 설명이 됩니다.",70,26
444,1,5,44,SQL에서 VIEW를 삭제할 때 사용하는 명령은?,,ERASE,KILL,DROP,DELETE,3,"SQL에서 VIEW는 테이블처럼 보이는 가상 테이블입니다.  실제 데이터를 저장하는 것이 아니라, 기존 테이블의 데이터를 특정 조건이나 방식으로 보여주는 역할을 합니다.  따라서 VIEW를 삭제한다는 것은 이 가상 테이블 자체를 없애는 것을 의미합니다.  'DROP' 명령어는 데이터베이스 객체(테이블, 뷰, 인덱스 등)를 완전히 삭제하는 데 사용되는 명령어입니다.  다른 선택지들은 데이터베이스 객체 삭제와는 관련이 없습니다. 'ERASE'나 'KILL'은 일반적으로 데이터베이스 시스템에서 사용되지 않는 명령어이며, 'DELETE'는 테이블의 특정 행(row)을 삭제하는 명령어이지, VIEW 전체를 삭제하는 명령어는 아닙니다.  따라서 VIEW를 삭제하기 위해서는 'DROP' 명령어를 사용해야 합니다.  마치 레고로 만든 집을 부수는 것처럼,  DROP 명령어는 VIEW라는 가상의 구조물을 완전히 없애버리는 역할을 하는 것입니다.",80,28
445,1,5,45,"DDL(Data Define Language)의 명령어 중 스키마, 도메인, 인덱스 등을 정의할 때 사용하는 SQL문은?",,ALTER,SELECT,CREATE,INSERT,3,"데이터베이스를 설계하고 관리하는 데 사용되는 SQL(Structured Query Language)은 크게 세 가지 종류로 나눌 수 있습니다. 데이터 정의어(DDL: Data Definition Language), 데이터 조작어(DML: Data Manipulation Language), 데이터 제어어(DCL: Data Control Language)입니다.  문제에서 묻고 있는 것은 스키마, 도메인, 인덱스 등 데이터베이스의 구조를 정의하는 명령어입니다.  스키마는 데이터베이스의 전체적인 구조를, 도메인은 데이터의 자료형과 제약 조건을, 인덱스는 데이터 검색 속도를 높이기 위한 자료구조를 정의합니다. 이러한 데이터베이스의 기본적인 구조를 *만드는* 작업에 해당하는 SQL 명령어는 바로 CREATE입니다.  ALTER는 기존에 생성된 객체를 수정하는 명령어이고, SELECT는 데이터를 조회하는 명령어, INSERT는 데이터를 추가하는 명령어이므로 데이터베이스의 구조를 처음부터 정의하는 목적에는 맞지 않습니다. 따라서 데이터베이스의 스키마, 도메인, 인덱스 등을 정의할 때 사용하는 SQL 문은 CREATE입니다.  마치 건물을 짓는다고 생각해보세요.  CREATE는 건물의 설계도를 그리고 기초를 다지는 것과 같습니다.  ALTER는 이미 지어진 건물을 개조하는 것이고, SELECT는 건물 내부를 살펴보는 것이며, INSERT는 건물에 가구를 들여놓는 것과 같습니다. 문제에서 요구하는 것은 건물의 설계도를 그리는 작업이므로 CREATE가 가장 적절한 명령어입니다.",74,27
446,1,5,46,"테이블 R1, R2에 대하여 다음 SQL문의결과는?",https://www.cbtbank.kr/images/iz/iz20210515/iz20210515m46.gif,https://www.cbtbank.kr/images/iz/iz20210515/iz20210515m46b1.gif,https://www.cbtbank.kr/images/iz/iz20210515/iz20210515m46b2.gif,https://www.cbtbank.kr/images/iz/iz20210515/iz20210515m46b3.gif,https://www.cbtbank.kr/images/iz/iz20210515/iz20210515m46b4.gif,2,"이 문제는 두 개의 테이블, R1과 R2에서 학번이 같은 데이터만을 찾는 문제입니다.  SQL의 집합 연산자 중 `INTERSECT`는 두 개의 SELECT 문의 결과 집합에서 중복되는 데이터만을 반환합니다.  R1 테이블에는 학번 20201111과 20202222가, R2 테이블에는 학번 20202222와 20203333이 있습니다.  `INTERSECT` 연산자는 두 테이블의 학번을 비교하여 공통적으로 존재하는 학번만 결과로 출력합니다. 따라서 두 테이블 모두에 존재하는 학번은 20202222 하나뿐이며, 이것이 문제의 정답입니다.  결과는 학번만을 포함하는 단일 열의 결과 집합이 됩니다. 다른 선택지는 추가적인 정보(학점 수, 과목번호)를 포함하거나,  두 테이블에 있는 모든 학번을 포함하는 등 문제의 조건을 만족하지 않습니다.",62,28
447,1,5,47,데이터베이스 설계 시 물리적 설계 단계에서 수행하는 사항이 아닌 것은?,,레코드 집중의 분석 및 설계,접근 경로 설계,저장 레코드의 양식 설계,목표 DBMS에 맞는 스키마 설계,4,"데이터베이스 설계는 크게 논리적 설계와 물리적 설계로 나뉩니다. 논리적 설계는 데이터베이스의 구조를 정의하는 단계이고, 물리적 설계는 논리적 설계 결과를 바탕으로 실제 데이터베이스 시스템에 구현하는 단계입니다.  문제에서 제시된 선택지들은 물리적 설계 단계에서 고려해야 할 사항들입니다.  레코드 집중 분석, 접근 경로 설계, 저장 레코드 양식 설계는 모두 실제 데이터베이스에 데이터를 어떻게 효율적으로 저장하고 관리할지에 대한 물리적인 구현 방식을 다룹니다. 하지만 목표 DBMS에 맞는 스키마 설계는 논리적 설계 단계에서 이미 결정되어야 할 사항입니다.  물리적 설계는 이미 정의된 논리적 스키마를 어떤 DBMS를 사용하여 어떻게 구현할지에 대한 세부적인 사항을 다루는 것이지, 스키마 자체를 새롭게 설계하는 단계가 아닙니다.  따라서 목표 DBMS에 맞는 스키마 설계는 물리적 설계 단계에서 수행하는 사항이 아닙니다.  마치 건물의 설계도(논리적 설계)가 완성된 후, 어떤 건축 자재를 사용하고 어떻게 배관을 설치할지(물리적 설계)를 결정하는 것과 같습니다.  스키마 설계는 건물의 설계도 자체를 바꾸는 것이므로 물리적 설계의 범주를 벗어납니다.",72,30
448,1,5,48,릴레이션에서 기본 키를 구성하는 속성은　널(Null)값이나 중복 값을 가질 수 없다는　것을 의미하는 제약조건은?,,참조 무결성,보안 무결성,개체 무결성,정보 무결성,3,"릴레이션(관계)에서 기본 키는 테이블의 각 행을 유일하게 식별하는 속성(또는 속성들의 집합)입니다.  예를 들어, 학생 테이블에서 학번이 기본 키라면, 모든 학생은 고유한 학번을 가지고 있어야 하고, 같은 학번을 가진 학생은 존재할 수 없습니다.  또한, 기본 키를 구성하는 속성은 값이 비어있을 수 없습니다(널값 금지).  만약 학번이 기본 키인데 어떤 학생의 학번이 비어있다면, 그 학생을 유일하게 식별할 수 없게 되죠.  따라서 기본 키는 널값과 중복값을 허용하지 않는다는 제약 조건은  데이터의 정확성과 일관성을 유지하기 위한 필수적인 조건이며, 이를 '개체 무결성'이라고 합니다. 개체 무결성은 각 행이 유일하게 식별될 수 있도록 보장하는 데이터베이스 무결성 규칙입니다.  다른 선택지들은 데이터베이스의 무결성과 관련은 있지만, 기본 키의 널값과 중복값 제약 조건을 직접적으로 설명하는 것은 아닙니다.",81,33
449,1,5,49,병행제어 기법의 종류가 아닌 것은?,,로킹 기법,시분할 기법,타임 스탬프 기법,다중 버전 기법,2,"병행 제어 기법은 여러 개의 프로세스가 동시에 공유 자원에 접근할 때 발생할 수 있는 문제(데이터의 일관성 유지, 데드락 등)를 해결하기 위한 기법입니다.  로킹 기법, 타임 스탬프 기법, 다중 버전 기법은 모두 공유 자원에 대한 접근을 제어하여 이러한 문제를 방지하는 대표적인 방법들입니다.  반면, 시분할 기법은 프로세스들에게 CPU 시간을 나누어 할당하는 기법으로,  병행 제어와는 직접적인 관련이 없습니다. 시분할 기법은 여러 프로세스가 동시에 실행되는 *환경*을 제공하지만,  실제로 프로세스들이 공유 자원에 접근하는 방법을 제어하는 것은 아닙니다.  따라서 시분할 기법은 병행 제어 기법의 종류라고 할 수 없습니다.  병행 제어는 공유 자원에 대한 접근을 조절하는 것이고, 시분할은 CPU 시간을 나누어 주는 것이라는 차이점을 이해하면 쉽게 정답을 찾을 수 있습니다.",47,44
450,1,5,50,다음 R1과 R2의 테이블에서 아래의　실행 결과를 얻기 위한 SQL문은?,https://www.cbtbank.kr/images/iz/iz20210515/iz20210515m50.gif,"SELECT 과목번호, 과목이름 FROM RI, R2 WHERE R1.학번 = R2. 학번 AND R1.학과='전자공학' AND R1.이름 = '강남길’;","SELECT 과목번호, 과목이름 FROM RI, R2 WHERE R1.학번 = R2.학번 OR R1.학과='전자공학' OR R1.이름 = '홍길동';","SELECT 과목번호, 과목이름 FROM R1, R2 WHERE R1.학번 = R2.학번 AND R1.학과=‘컴퓨터공학' AND R1.이름 '강남길’;","SELECT 과목번호, 과목이름 FROM R1, R2 WHERE R1.학번 = R2.학번 OR R1.학과='컴퓨터공학' OR R1.이름 = '홍길동';",1,"문제에서 요구하는 실행 결과는 '과목번호'와 '과목이름' 두 개의 열을 가지는 테이블입니다.  그리고 R1 테이블의 '강남길' 학생이 수강한 과목 정보만을 보여줘야 합니다. R1 테이블과 R2 테이블을 조인하여 학생의 정보와 과목 정보를 연결해야 하는데,  '강남길' 학생의 학번은 R1 테이블에서 찾을 수 있습니다.  '강남길' 학생의 학번을 이용하여 R2 테이블에서 해당 학생이 수강한 과목 정보를 찾아야 합니다. 따라서 R1 테이블과 R2 테이블을 학번을 기준으로 조인(JOIN)해야 하며,  조건절(WHERE)에서는 R1 테이블의 '이름'이 '강남길'인 행만 선택하도록 해야 합니다.  정답은 R1 테이블과 R2 테이블을 학번을 기준으로 내부 조인(INNER JOIN)하고, 이름이 '강남길'인 학생의 정보만을 필터링하는 SQL 문입니다. 다른 선지는 조건이 잘못 설정되어 있어 '강남길' 학생의 과목 정보만을 정확하게 추출하지 못합니다.  예를 들어, 다른 선지들은 '홍길동'이나 '컴퓨터공학과' 학생들의 정보까지 포함하거나,  OR 조건을 사용하여 의도치 않은 결과를 가져올 수 있습니다.",72,28
451,1,5,51,다음 관계 대수 중 순수 관계 연산자가 아닌 것은?,,차집합(difference),프로젝트(project),조인(join),디비전 (division),1,"관계 대수는 관계형 데이터베이스를 조작하는 데 사용되는 수학적 언어입니다.  여러 가지 연산자를 통해 데이터베이스의 테이블을 조작하고 새로운 테이블을 생성할 수 있습니다.  문제에서 묻고 있는 것은 순수 관계 연산자, 즉 테이블 자체의 내용만을 가지고 연산을 수행하는 연산자입니다.  차집합, 프로젝트, 디비전은 모두 기존 테이블의 튜플(행)이나 속성(열)을 이용하여 새로운 테이블을 만들지만,  테이블의 내용만을 가지고 연산을 수행합니다.  하지만 조인 연산은 두 개 이상의 테이블을 결합하여 새로운 테이블을 생성하는데, 이때 두 테이블 간의 관계(조건)를 사용합니다.  즉, 조인 연산은 테이블의 내용뿐만 아니라 테이블 간의 관계라는 외부 정보를 필요로 하기 때문에 순수 관계 연산자라고 할 수 없습니다. 따라서, 순수 관계 연산자가 아닌 것은 조인 연산입니다.  쉽게 말해, 차집합, 프로젝트, 디비전은 하나의 테이블만 가지고 놀지만, 조인은 여러 테이블을 합쳐서 새로운 테이블을 만드는 것이라고 생각하면 됩니다.",71,28
452,1,5,52,관계형 데이터 모델의 릴레이션에 대한 설명으로 틀린 것은?,,모든 속성 값은 원자 값을 갖는다.,한 릴레이션에 포함된 튜플은 모두 상이하다.,한 릴레이 션에 포함된 튜플 사이에는 순서가 없다.,한 릴레이션을 구성하는 속성 사이에는 순서가 존재한다.,4,"관계형 데이터베이스에서 릴레이션은 표와 같은 구조를 가지는데요,  각 행은 튜플(tuple), 각 열은 속성(attribute)이라고 부릅니다.  문제에서 틀린 설명을 찾는 것이 목표입니다.  먼저,  데이터베이스의 기본 원칙 중 하나는 각 데이터 값(속성 값)은 하나의 의미있는 단위(원자 값)를 가져야 한다는 것입니다.  예를 들어, 주소를 하나의 속성으로 두는 것이 아니라,  도로명, 건물번호, 우편번호 등으로 나누어 각각 원자 값으로 저장해야 데이터베이스 관리가 효율적입니다.  또한, 같은 사람의 정보가 여러 번 중복되어 저장되는 것을 방지하기 위해,  릴레이션 내의 튜플은 모두 서로 달라야 합니다.  그리고 튜플의 순서는 중요하지 않습니다.  데이터베이스는 튜플의 순서에 의존하지 않고 데이터를 관리합니다.  하지만 속성의 순서는 데이터베이스 내부적으로는 의미를 가질 수 있지만,  사용자에게는 보이지 않고 데이터베이스 시스템이 관리하는 부분이기 때문에 사용자 관점에서는 순서가 없다고 볼 수 있습니다. 따라서 속성의 순서가 존재한다는 설명은 틀린 것입니다.  결론적으로,  릴레이션에서 속성의 순서는 중요하지 않고,  데이터베이스 시스템이 내부적으로 관리하는 부분이기 때문에 틀린 설명입니다.",73,27
453,1,5,53,"릴레이션 R의 차수가 4이고 카디널리티가 5이며, 릴레이션 S의 차수가 6이고 카디널리티가 7일 때, 두 개의 릴레이션을 카티션 프로덕트한 결과의 새로운 릴레이 션의 차수와 카디널리티는 얼마인가?",,"24, 35","24, 12","10, 35","10, 12",3,"이 문제는 관계형 데이터베이스에서 릴레이션(관계)의 연산 중 카티션 프로덕트(Cartesian Product, 데카르트 곱)에 대한 이해를 묻고 있습니다.  카티션 프로덕트는 두 개의 릴레이션을 결합하는 연산으로,  첫 번째 릴레이션의 각 튜플(row)과 두 번째 릴레이션의 모든 튜플을 조합하여 새로운 릴레이션을 생성합니다.",66,29
454,1,5,54,속성(attribute)에 대한 설명으로 틀린 것은?,,속성은 개체의 특성을 기술한다.,속성은 데이터베이스를 구성하는 가장 작은 논리적 단위이다.,속성은 파일 구조상 데이터 항목 또는 데이터 필드에 해당된다.,"속성의 수를 ""cardinality"" 라고 한다.",4,"이 문제는 데이터베이스의 기본 개념인 '속성(attribute)'에 대한 이해도를 묻고 있습니다.  데이터베이스는 여러 개의 테이블로 구성되고, 각 테이블은 여러 개의 행(row, 레코드)으로 이루어져 있습니다.  그리고 각 행은 여러 개의 속성(attribute) 값을 가지는데, 이 속성이 바로 개체(entity)의 특징을 나타내는 가장 작은 논리적 단위입니다. 예를 들어 '학생'이라는 개체가 있다면, '학생 이름', '학번', '학과' 등이 속성이 되는 것이죠.  따라서 '속성은 개체의 특성을 기술한다'와 '속성은 데이터베이스를 구성하는 가장 작은 논리적 단위이다'는 모두 맞는 설명입니다. 또한, 파일 구조에서 속성은 데이터 항목 또는 데이터 필드에 해당합니다.  '학생 정보'라는 파일이 있다면, '학생 이름' 필드, '학번' 필드 등이 속성에 해당하는 것입니다.  하지만 '속성의 수를 cardinality라고 한다'는 잘못된 설명입니다. cardinality는 관계 데이터베이스에서 관계(relation)에 속한 튜플(tuple)의 수 또는 속성의 수가 아닌,  관계 내에서 특정 속성 값에 대응하는 다른 속성 값의 수를 나타내는 용어입니다.  예를 들어 '학생'과 '수강과목'의 관계에서 한 학생이 여러 과목을 수강할 수 있다면,  '학생' 속성의 cardinality는 다대일(many-to-one) 관계가 되는 것이죠.  따라서 틀린 설명은 속성의 수를 나타내는 용어가 cardinality가 아니라는 점입니다.  정리하자면, 속성은 개체의 특징을 나타내는 데이터베이스의 기본 구성 요소이며, cardinality는 속성의 수가 아닌 관계의 특성을 나타내는 용어입니다.",75,29
455,1,5,55,다음 SQL 문에서 ( ) 안에 들어갈 내용으로 옳은 것은?,https://www.cbtbank.kr/images/iz/iz20210515/iz20210515m55.gif,SET,FROM,INTO,IN,1,"SQL의 UPDATE문은 데이터베이스의 테이블에 있는 데이터를 수정하는 명령어입니다.  문제에서 `UPDATE 인사급여 ( ) 호봉=15 WHERE 성명='홍길동';` 라는 SQL 문이 주어졌는데,  괄호 안에는 어떤 값을 넣어야 '홍길동'이라는 사람의 호봉을 15로 변경할 수 있을까요?  `UPDATE` 문의 기본 구조는 `UPDATE 테이블명 SET 변경할컬럼=새로운값 WHERE 조건;` 입니다.  여기서 `SET`은 어떤 컬럼의 값을 변경할지 지정하는 키워드입니다. 따라서 괄호 안에는 '어떤 컬럼의 값을 변경할 것인지'를 명시하는 `SET`이 들어가야 합니다.  `SET 호봉=15`라고 하면 '호봉'이라는 컬럼의 값을 15로 변경하라는 의미가 되는 것이죠. 다른 선택지는 SQL 문의 구조와 맞지 않아서 데이터를 수정하는 데 사용할 수 없습니다.  결론적으로,  '홍길동'의 호봉을 15로 바꾸기 위해서는 `SET` 키워드를 사용해야 합니다.",81,25
456,1,5,56,관계 데이터베이스 모델에서 차수(Degree)의 의미는?,,튜플의 수,테이블의 수,데이터베이스의 수,애트리뷰트의 수,4,"관계 데이터베이스는 데이터를 표(테이블) 형태로 저장하고 관리하는데, 각 표는 여러 개의 열(애트리뷰트)과 행(튜플)으로 구성됩니다.  여기서 '차수(Degree)'는 각 표를 구성하는 열(애트리뷰트)의 개수를 의미합니다.  쉽게 말해, 표의 가로줄 개수, 즉 데이터 항목의 수를 나타내는 것입니다.  예를 들어, '고객'이라는 표에 '고객ID', '이름', '주소', '전화번호' 네 개의 열이 있다면, 이 표의 차수는 4입니다.  따라서 관계 데이터베이스 모델에서 차수는 테이블의 열(애트리뷰트)의 수를 의미하는 것이지, 튜플의 수나 테이블의 수, 데이터베이스의 수를 의미하는 것은 아닙니다.",70,27
457,1,5,57,개체-관계 모델(E-R)의 그래픽 표현으로 옳지 않은 것은?,,개체타입 ? 사각형,속성 - 원형,관계타입 - 마름모,연결 - 삼각형,4,"개체-관계 모델(E-R 모델)은 데이터베이스를 설계할 때 사용하는 도구입니다.  데이터베이스 안의 여러 가지 정보들을 시각적으로 표현하여 이해하기 쉽게 만들어주는 것이죠.  마치 건축 설계도처럼 말이에요.  여기서 사각형은 개체(예를 들어, '고객' 이나 '상품' 같은 것)를, 원은 속성(예를 들어, '고객 이름', '상품 가격' 같은 것)을, 마름모는 관계(예를 들어, '고객이 상품을 구매하다' 같은 것)를 나타냅니다.  그런데 관계를 나타내는 기호가 삼각형이라고 되어 있는데, 이는 E-R 다이어그램의 표준적인 표현과 일치하지 않습니다.  E-R 다이어그램에서 관계는 마름모꼴로 표현하는 것이 일반적이기 때문에 삼각형으로 표현하는 것은 옳지 않습니다.  따라서 정답은 관계를 삼각형으로 표현한 선지입니다.",86,30
458,1,5,58,트랜잭션의 실행이 실패하였음을 알리는 연산자로 트랜잭션이 수행한 결과를 원래의 상태로 원상 복귀 시키는 연산은?,,COMMIT 연산,BACKUP 연산,LOG 연산,ROLLBACK 연산,4,"트랜잭션이란 데이터베이스에서 여러 작업을 하나의 논리적 단위로 묶어서 처리하는 것을 말합니다.  예를 들어, 계좌 이체를 생각해 보면,  'A 계좌에서 1000원 출금'과 'B 계좌에 1000원 입금'이라는 두 가지 작업이 하나의 트랜잭션으로 묶입니다.  이때, 두 작업 중 하나라도 실패하면 전체 트랜잭션이 실패해야 데이터베이스의 일관성을 유지할 수 있습니다.  만약 A 계좌에서 1000원이 출금되었는데, B 계좌에 입금이 실패한다면,  돈이 사라지는 심각한 문제가 발생하겠죠.  이러한 상황을 방지하기 위해 트랜잭션이 실패하면,  이미 수행된 작업들을 모두 취소하고 원래 상태로 되돌리는 기능이 필요합니다.  바로 이 기능을 수행하는 연산자가 문제에서 묻고 있는 연산자인데, 이는 데이터베이스의 일관성을 유지하는 데 매우 중요한 역할을 합니다.  따라서 트랜잭션의 실행이 실패했을 때,  수행된 모든 작업을 원래대로 되돌리는 연산자를 사용해야 데이터베이스의 무결성을 보장할 수 있습니다.",88,27
459,1,5,59,"데이터 속성 간의 종속성에 대한 엄밀한 고려없이 잘못 설계된 데이터베이스에서는 데이터 처리 연산 수행 시 각종 이상 현상이 발생할 수 있는데, 이러한 이상 현상이 아닌 것은?",,검색 이상,삽입 이상,삭제 이상,갱신 이상,1,"데이터베이스는 데이터를 효율적으로 관리하기 위해 설계되는데,  데이터 속성 간의 관계(종속성)를 제대로 고려하지 않으면 여러 문제가 발생합니다.  마치 잘 정리되지 않은 서랍처럼,  데이터를 찾거나 추가하거나 삭제하는 과정에서 혼란이 생기는 것이죠.  예를 들어,  '고객'과 '주문' 정보를 저장하는 데이터베이스를 생각해 봅시다.  만약 고객 정보와 주문 정보가 제대로 연결되지 않으면, 특정 고객의 주문 내역을 찾기 어려워지는(검색 이상) 문제가 발생할 수 있습니다.  또는 새로운 고객을 추가할 때,  그 고객이 아직 주문을 하지 않았다면 주문 정보를 함께 추가할 수 없어(삽입 이상)  데이터베이스에 고객 정보만 단독으로 남게 되는 문제가 발생할 수 있습니다.  반대로,  특정 고객을 삭제할 때,  그 고객의 주문 정보도 함께 삭제되어야 하는데,  이 과정이 제대로 이루어지지 않으면(삭제 이상)  주문 정보만 남게 되는 문제가 발생할 수 있습니다.  마찬가지로,  고객의 주소가 변경되었을 때,  모든 관련 주문 정보의 주소를 일일이 수정해야 하는(갱신 이상) 번거로움이 발생할 수 있습니다.  하지만 문제에서 묻고 있는 것은 이러한 이상 현상이 *아닌* 것 입니다.  따라서 데이터베이스 설계의 부적절함으로 인해 발생하는 문제는 아니지만, 데이터베이스 자체의 문제는 아닌 다른 요인에 의해 발생하는 문제가 정답이 됩니다.",73,29
460,1,5,60,제3정규형 (3NF)에서 BCNF(Boyce-Codd Normal Form)가 되기 위한 조건은?,,결정자가 후보키가 아닌 함수 종속 제거,이행적 함수 종속 제거,부분적 함수 종속 제거,원자값이 아닌 도메인 분해,1,"BCNF는 제3정규형(3NF)보다 더 강력한 정규화 형태입니다.  3NF는 부분 함수 종속을 제거하는 것을 목표로 하지만, BCNF는 한 단계 더 나아가 **결정자가 후보키가 아닌 함수 종속**까지 제거합니다.  쉽게 설명하자면, 데이터베이스의 테이블에 중복된 정보가 없도록 하기 위해 정규화를 하는데, 3NF는 어느 정도 중복을 제거하지만 BCNF는 더욱 완벽하게 중복을 제거하는 것입니다.  데이터베이스의 테이블에서 어떤 속성(열)이 다른 속성에 의해 결정될 때(함수 종속), 그 결정하는 속성(결정자)이 테이블의 후보키(테이블의 모든 행을 유일하게 식별하는 속성 집합)가 아니라면 데이터 중복의 가능성이 존재합니다. BCNF는 이러한 중복을 완전히 제거하여 데이터 무결성을 더욱 높입니다.  다른 선지들은 3NF를 만족시키는 조건들이거나 정규화와 관련은 있지만 BCNF의 핵심 조건은 아닙니다. 따라서 BCNF가 되기 위한 가장 중요한 조건은 결정자가 후보키가 아닌 함수 종속을 제거하는 것입니다.",76,30
461,1,5,61,다음 설명에 해당하는 방식은?,https://www.cbtbank.kr/images/iz/iz20210515/iz20210515m61.gif,STA,Collision Domain,CSMA/CA,CSMA/CD,3,"문제에서 설명하는 방식은 무선랜(Wi-Fi)에서 데이터를 전송할 때, 다른 기기와 데이터 전송이 충돌하는 것을 막기 위한 방법입니다.  먼저, 무선 매체가 비어있는지 확인하고(즉, 다른 기기가 데이터를 전송하고 있지 않은지 확인하고), 비어있다면 데이터를 전송합니다.  하지만 만약 매체가 비어있지 않다면, 즉 다른 기기가 이미 데이터를 전송하고 있다면 충돌이 발생하겠죠.  이 충돌을 피하기 위해 임의의 시간을 기다렸다가 다시 매체가 비어있는지 확인하고 데이터를 전송하는 방식입니다.  또한, 네트워크에 데이터 전송이 없더라도, 만약 다른 기기가 동시에 데이터를 전송하는 경우를 대비하여 확인 신호를 미리 보내는 것도 포함됩니다. 이러한 방식은 바로 CSMA/CA(Carrier Sense Multiple Access with Collision Avoidance) 방식입니다.  CSMA/CD(Carrier Sense Multiple Access with Collision Detection)는 충돌이 발생한 후에야 충돌을 감지하고 재전송을 시도하는 방식이지만, CSMA/CA는 충돌을 미리 예방하는 데 중점을 둡니다.  무선 환경에서는 충돌 감지를 하는 것이 어렵기 때문에 충돌 회피 방식인 CSMA/CA가 더 적합합니다.  따라서 문제의 설명은 CSMA/CA 방식을 정확하게 나타내고 있습니다.",62,45
462,1,5,62,다음 중 가장 약한 결합도(Coupling)는?,,Common Coupling,Content Coupling,External Coupling,Stamp Coupling,4,"소프트웨어 모듈 간의 결합도(Coupling)는 모듈 간의 상호 의존성을 나타내는 척도입니다. 결합도가 높다는 것은 모듈 간의 의존성이 강하다는 의미이며,  결합도가 낮다는 것은 모듈 간의 의존성이 약하다는 의미입니다.  결합도가 높으면 모듈 하나를 변경할 때 다른 모듈에도 영향을 미칠 가능성이 높아져 유지보수가 어려워지고, 오류 발생 가능성도 높아집니다. 반대로 결합도가 낮으면 모듈 간의 독립성이 높아져 유지보수가 용이하고, 오류 발생 가능성도 낮아집니다.",64,6
463,1,5,63,다음 C언어 프로그램이 실행되었을 때의 결과는?,https://www.cbtbank.kr/images/iz/iz20210515/iz20210515m63.gif,3,4,7,10,3,"이 문제는 C언어의 비트 연산자 중 하나인 비트 OR 연산(`|`)을 이해하고 있는지 묻는 문제입니다.  `a | b`는 a와 b의 비트들을 각각 비교하여,  둘 중 하나라도 1인 비트는 결과에서 1이 되고, 둘 다 0인 비트는 결과에서 0이 됩니다.",62,41
464,1,5,64,다음 파이썬(Python) 프로그램이 실행되었을 때의 결과는?,https://www.cbtbank.kr/images/iz/iz20210515/iz20210515m64.gif,0,2,4,6,4,"이 문제는 파이썬을 이용하여 클래스(Class)와 객체(Object)를 다루는 기본적인 객체지향 프로그래밍(OOP) 개념을 묻는 문제입니다.  먼저 `FourCal`이라는 클래스가 정의되어 있는데, 이 클래스는 `setdata` 메서드와 `add` 메서드를 가지고 있습니다. `setdata` 메서드는 객체의 속성인 `fir`과 `sec`에 값을 설정하는 역할을 하고, `add` 메서드는 `fir`과 `sec`의 값을 더하여 결과를 반환합니다.",76,7
465,1,5,65,교착상태의 해결 방법 중 은행원 알고리즘(Banker's Algorithm)이 해당되는 기법은?,,Detection,Avoidance,Recovery,Prevention,2,"이 문제는 교착상태(Deadlock)를 해결하는 방법 중 하나인 은행원 알고리즘(Banker's Algorithm)이 어떤 기법에 속하는지 묻고 있습니다. 교착상태란 두 개 이상의 프로세스가 서로 상대방이 갖고 있는 자원을 기다리면서 무한정 블록되는 현상을 말합니다.  은행원 알고리즘은 교착상태를 *예방*하는 것이 아니라, *회피*(Avoidance)하는 기법입니다.  즉, 미리 교착상태가 발생할 가능성을 검사하고, 안전한 상태라면 자원 할당을 허용하며, 불안전한 상태라면 자원 할당을 거부하여 교착상태 발생을 미연에 방지하는 것입니다.  Detection은 교착상태가 이미 발생했는지 확인하는 기법이고, Recovery는 교착상태가 발생했을 때 이를 해결하는 기법이며, Prevention은 교착상태가 발생하지 않도록 사전에 조건들을 제한하는 기법입니다.  은행원 알고리즘은 자원 할당 요청 시 미래의 상태를 예측하여 교착상태를 회피하기 때문에 '회피' 기법에 속합니다.  마치 은행원이 고객에게 돈을 빌려줄 때, 빌려준 후 고객이 돈을 갚지 못해 은행이 파산할 가능성을 미리 계산하여 대출 여부를 결정하는 것과 유사합니다. 따라서 은행원 알고리즘은 교착상태를 회피하는 기법입니다.",75,44
466,1,5,66,"CIDR(Classless Inter-Domain Routing) 표기로 203.241.132.82/27과 같이 사용되었다면, 해당 주소의 서브넷 마스크(subnet mask)는?",,255.255.255.0,255.255.255.224,255.255.255.240,255.255.255.248,2,"CIDR 표기법에서 `/27`은 서브넷 마스크의 비트 수를 나타냅니다.  IP 주소는 32비트로 구성되는데, `/27`은 앞에서부터 27비트가 네트워크 주소 부분이고, 나머지 5비트가 호스트 주소 부분임을 의미합니다.  따라서 서브넷 마스크는 27개의 1과 5개의 0으로 구성된 32비트 값이 됩니다.  이를 십진수로 표현하면 정답이 되는 값이 나옵니다.  쉽게 생각하면,  `/27`은 2의 5승(32)개의 IP 주소를 하나의 서브넷으로 묶는다는 것을 의미하고, 이때 사용되는 서브넷 마스크는 255.255.255.224가 됩니다.  왜냐하면 255.255.255.224는 이진수로 표현했을 때 앞에서부터 27비트가 1이고 나머지 5비트가 0이기 때문입니다.  이렇게 CIDR 표기법을 이해하면 서브넷 마스크를 쉽게 계산할 수 있습니다.",61,45
467,1,5,67,다음 JAVA 프로그램이 실행되었을 때의 결과는?,https://www.cbtbank.kr/images/iz/iz20210515/iz20210515m67.gif,"5, 5, 5","5, 6, 5","6, 5, 5","5, 6, 4",1,"이 JAVA 프로그램은 변수 x, y, z를 선언하고 초기값을 각각 5, 0, 0으로 설정합니다.  `y = x++;` 라인은 x의 값을 y에 대입한 후 x의 값을 1 증가시키는 후치 증가 연산자를 사용합니다. 따라서 y는 5가 되고 x는 6이 됩니다. 다음 줄 `z = --x;` 는 x의 값을 1 감소시킨 후 그 값을 z에 대입하는 전치 감소 연산자를 사용합니다.  x는 6에서 1 감소하여 5가 되고, 이 5가 z에 대입됩니다.  마지막으로 `System.out.print(x + "","" + y + "","" + z);` 는 x, y, z의 값을 순서대로 출력합니다.  결과적으로 x는 5, y는 5, z는 5가 되어 ""5,5,5""가 출력됩니다.  후치 증가 연산자(++ 후)는 값을 사용한 후 증가시키고, 전치 감소 연산자(-- 전)는 값을 감소시킨 후 사용한다는 점을 정확히 이해하는 것이 중요합니다.  이러한 연산자의 동작 순서를 명확히 파악하면 문제를 쉽게 풀 수 있습니다.",64,41
468,1,5,68,프로세스 적재 정책과 관련한 설명으로 틀린 것은?,,"반복, 스택, 부프로그램은 시간 지역성(Temporal Locality)과 관련이 있다.",공간 지역성(Spatial Locality)은 프로세스가 어떤 페이지를 참조했다면 이후 가상주소공간상 그 페이지와 인접한 페이지들을 참조할 가능성이 높음을 의미한다.,일반적으로 페이지 교환에 보내는 시간보다 프로세스 수행에 보내는 시간이 더 크면 스레싱(Thrashing)이 발생한다.,스레싱(Thrashing) 현상을 방지하기 위해서는 각 프로세스가 필요로 하는 프레임을 제공할 수 있어야 한다.,3,"이 문제는 프로세스의 메모리 관리, 특히 페이지 교체 알고리즘과 관련된 개념들을 얼마나 잘 이해하고 있는지 묻는 문제입니다.  먼저,  프로세스가 실행될 때 필요한 데이터와 명령어는 메모리에 적재되어야 합니다.  하지만 메모리 용량은 한정되어 있으므로, 모든 프로세스를 동시에 메모리에 올릴 수는 없습니다. 따라서 운영체제는 프로세스를 메모리에 적재하고 관리하는 정책을 사용하는데, 이를 프로세스 적재 정책이라고 합니다.",61,44
469,1,5,69,프레임워크(Framework)에 대한 설명으로 옳은 것은?,,소프트웨어 구성에 필요한 기본 구조를 제공함으로써 재사용이 가능하게 해준다,소프트웨어 개발 시 구조가 잡혀 있기 때문에 확장이 불가능하다.,소프트웨어 아키텍처(Architecture)와 동일한 개념이다.,모듈화(Modularity)가 불가능하다.,1,"소프트웨어 개발에서 프레임워크는 건물의 골조와 같습니다.  건물을 지을 때 벽돌이나 기둥을 하나하나 다 만들 필요 없이, 미리 만들어진 골조(프레임워크) 위에 벽돌을 쌓고 내부를 채우는 것처럼, 소프트웨어 개발에서도 프레임워크는 기본적인 구조와 기능을 제공하여 개발자가 반복적인 작업을 줄이고,  더욱 효율적으로 소프트웨어를 만들 수 있도록 도와줍니다.  따라서 소프트웨어 구성에 필요한 기본 구조를 제공하고, 이를 통해 코드 재사용성을 높여 개발 시간과 비용을 절감하는 데 큰 도움이 됩니다.  반면,  프레임워크는 소프트웨어의 확장성을 제한하는 것이 아니라, 오히려  미리 정의된 구조를 바탕으로  필요에 따라 기능을 추가하거나 변경할 수 있도록  유연성을 제공합니다.  프레임워크는 소프트웨어 아키텍처와는  개념적으로 다르며,  모듈화를 통해  소프트웨어를  독립적인 부분으로 나누어 관리하고 재사용성을 높이는 것을  지원합니다.",67,6
470,1,5,70,다음 JAVA 프로그램이 실행되었을 때의 결과는?,https://www.cbtbank.kr/images/iz/iz20210515/iz20210515m70.gif,2,3,4,5,1,"이 JAVA 프로그램은 `cnt`라는 변수를 사용하여 반복문과 조건문을 통해 값을 변경하는 과정을 보여줍니다.  먼저 `do-while` 문이 실행됩니다.  `do-while` 문은 조건을 확인하기 전에 한 번은 무조건 실행되는 특징이 있습니다. 따라서 `cnt`는 0에서 시작하여 `cnt++`에 의해 1로 증가합니다.  `while (cnt < 0)` 조건은 `cnt`가 0보다 작을 때만 반복되는데, `cnt`는 이미 1이므로 이 조건은 거짓이 되어 반복문은 종료됩니다.  다음으로 `if` 문이 실행됩니다. `cnt`는 1이므로 `if (cnt == 1)` 조건이 참이 되어 `cnt++`가 실행되어 `cnt`는 2가 됩니다.  마지막으로 `System.out.printf(""%d"", cnt);`를 통해 `cnt`의 값인 2가 출력됩니다. 따라서 프로그램의 실행 결과는 2입니다.  쉽게 말해, 처음에 cnt가 0인데 do-while문에서 1이 되고, if문에서 1이므로 1을 더해서 2가 되어 출력되는 것입니다.",55,41
471,1,5,71,리눅스 Bash 쉘(Shell)에서 export와 관련한 설명으로 틀린 것은?,,변수를 출력하고자 할 때는 export를 사용해야 한다.,export가 매개변수 없이 쓰일 경우 현재 설정된 환경변수들이 출력된다.,사용자가 생성하는 변수는 export 명령어 표시하지 않는 한 현재 쉘에 국한된다.,변수를 export 시키면 전역(Global)변수처럼 되어 끝까지 기억된다.,1,"리눅스 Bash 쉘에서 변수를 다루는 방법에 대한 문제입니다.  우선,  Bash 쉘에서 변수를 선언하고 값을 할당하는 것은 간단합니다.  예를 들어 `myvar=hello` 라고 하면 `myvar`라는 변수에 ""hello""라는 값이 저장됩니다.  하지만 이렇게 생성된 변수는 현재 쉘(터미널 세션)에서만 유효합니다.  새로운 쉘을 열거나 현재 쉘을 종료하면 이 변수는 사라집니다.  이 변수의 효력 범위를 현재 쉘을 넘어 다른 쉘이나 자식 프로세스에도 적용하고 싶다면 `export` 명령어를 사용해야 합니다. `export myvar`라고 하면 `myvar` 변수는 환경 변수가 되어 다른 쉘에서도 사용할 수 있게 됩니다.  `export` 명령어 없이 변수를 출력하려면 `echo $myvar` 와 같이 변수 이름 앞에 `$` 기호를 붙여 사용하면 됩니다.  `export` 자체는 변수의 값을 출력하는 명령어가 아니고, 변수의 유효 범위를 확장하는 명령어입니다.  `export` 명령어를 매개변수 없이 사용하면 현재 설정된 모든 환경 변수들을 보여줍니다.  마지막으로, `export`로 설정된 변수는 현재 쉘 세션이 종료될 때까지 유지되는 것이 아니라,  쉘 세션이 종료되면 사라집니다.  다만,  자식 프로세스는 부모 프로세스의 환경 변수를 상속받기 때문에,  `export`된 변수는 자식 프로세스에서도 사용 가능합니다. 따라서,  문제에서 틀린 설명은 변수의 유효범위와 `export` 명령어의 기능에 대한 오해를 바탕으로 하고 있습니다.",49,44
472,1,5,72,다음 C언어 프로그램이 실행되었을 때의 결과는?,https://www.cbtbank.kr/images/iz/iz20210515/iz20210515m72.gif,1,11,66,98,3,"이 C언어 코드는 문자 'A'에 1을 더한 값을 출력하는 간단한 프로그램입니다.  컴퓨터는 문자를 내부적으로 숫자로 저장하는데,  ASCII 코드라는 표준을 사용합니다.  'A'의 ASCII 코드 값은 65입니다. 따라서 'A' + 1은 65 + 1 = 66이 되고,  `printf(""%d"", a);` 는 정수형 변수 a의 값을 10진수로 출력하도록 지시합니다.  결과적으로 프로그램은 66을 출력합니다.  C언어에서 문자형 변수에 정수를 더하면 ASCII 코드 값에 해당하는 연산이 이루어집니다.  따라서 문자 'A'에 1을 더하면 다음 문자인 'B'의 ASCII 코드 값인 66이 계산됩니다.  `printf` 함수의 `%d` 형식 지정자는 정수 값을 출력하므로 66이 출력되는 것입니다.",70,41
473,1,5,73,다음 C언어 프로그램이 실행되었을 때의 결과는?,https://www.cbtbank.kr/images/iz/iz20210515/iz20210515m73.gif,55,77,121,132,3,"이 문제는 C언어의 포인터와 2차원 배열을 이용한 연산에 대한 이해도를 묻는 문제입니다.  `int a[2][2] = {{11, 22}, {44, 55}};` 에서 2x2 크기의 정수형 배열 a가 선언되고 초기화됩니다.  `p = a[0];` 에서 포인터 p는 배열 a의 첫 번째 원소(11)의 주소를 가리키도록 설정됩니다.  `for(i = 1; i < 4; i++) sum += *(p + i);` 루프는 p가 가리키는 주소에서부터 i만큼 이동한 주소에 있는 값들을 sum에 더합니다.  즉,  `*(p + 1)`은 a[0][1] (22), `*(p + 2)`는 a[1][0] (44), `*(p + 3)`은 a[1][1] (55)을 의미합니다. 따라서 sum에는 22 + 44 + 55가 더해져 최종적으로 121이 됩니다.  `printf(""%d"", sum);`은 sum의 값(121)을 출력합니다.  따라서 프로그램의 실행 결과는 121입니다.  포인터 연산을 이해하고 배열의 메모리 상의 연속적인 저장 방식을 파악해야 정답을 도출할 수 있는 문제입니다.  비전공자라도 2차원 배열이 메모리에 어떻게 저장되는지 그림으로 그려보면 이해가 쉬울 것입니다.  배열의 각 요소가 메모리 상에 순차적으로 저장되고, 포인터는 이 메모리 주소를 가리키는 역할을 한다는 점을 명심하면 됩니다.",57,11
474,1,5,74,페이징 기법에서 페이지 크기가 작아질수록 발생하는 현상이 아닌 것은?,,기억장소 이용 효율이 증가한다.,입·출력 시간이 늘어난다.,내부 단편화가 감소한다.,페이지 맵 테이블의 크기가 감소한다.,4,"페이징 기법은 메모리에 저장된 프로그램이나 데이터를 일정한 크기의 블록(페이지) 단위로 나누어 관리하는 기법입니다.  페이지 크기가 작아지면,  하나의 프로그램이나 데이터를 저장하는 데 필요한 페이지 수가 증가하게 됩니다.  이로 인해 페이지를 주기억장치와 보조기억장치 사이에 주고받는 입출력 횟수가 늘어나 입출력 시간이 증가하는 현상이 발생합니다. 또한,  페이지 크기가 작아지면 작은 크기의 빈 공간(내부 단편화)이 많이 생기게 되어 메모리 공간을 효율적으로 사용하지 못하게 됩니다.  반대로, 페이지 크기가 작아지면 페이지 맵 테이블의 크기는 증가합니다.  왜냐하면, 페이지 수가 늘어나 각 페이지의 위치 정보를 저장하는 데 필요한 테이블의 크기가 커지기 때문입니다. 따라서 페이지 크기가 작아질수록 발생하지 않는 현상은 페이지 맵 테이블의 크기가 감소하는 것입니다.  쉽게 말해, 작은 조각으로 나눌수록 관리해야 할 조각의 수가 많아져서 관리하는 데 필요한 공간(페이지 맵 테이블)도 더 커지는 것이죠.",54,44
475,1,5,75,다음 중 가장 강한 응집도(Cohesion)는?,,Sequential Cohesion,Procedural Cohesion,Logical Cohesion,Coincidental Cohesion,1,"소프트웨어 모듈 내부의 구성 요소들이 서로 얼마나 밀접하게 관련되어 있는지를 나타내는 척도가 응집도입니다.  응집도가 높다는 것은 모듈 내부의 요소들이 하나의 목적을 위해 긴밀하게 협력한다는 의미이며,  반대로 응집도가 낮다는 것은 요소들이 서로 관련성이 적고,  무관하게 섞여 있다는 것을 의미합니다.  따라서 응집도가 높을수록 모듈의 독립성이 높아지고, 유지보수 및 재사용이 용이해집니다.",56,6
476,1,5,76,TCP 프로토콜과 관련한 설명으로 틀린 것은?,,인접한 노드 사이의 프레임 전송 및 오류를 제어한다.,흐름 제어(Flow Control)의 기능을 수행한다.,전이 중(Full Duplex) 방식의 양방향 가상회선을 제공한다.,전송 데이터와 응답 데이터를 함께 전송할 수 있다.,1,"이 문제는 TCP 프로토콜의 특징을 묻고 있습니다.  TCP는 데이터를 안전하고 신뢰성 있게 전송하기 위해 설계된 프로토콜입니다.  선택지 중 틀린 것은,  인접한 노드 사이의 프레임 전송 및 오류 제어를 담당하는 것은 TCP가 아니라,  더 하위 계층인 데이터 링크 계층(Data Link Layer)의 역할입니다. TCP는  IP 계층 위에서 동작하며,  데이터의 신뢰성 있는 전달을 위해  순서대로 데이터를 전송하고,  오류 검출 및 재전송 기능을 제공합니다.  나머지 선택지는 모두 TCP의 주요 기능을 정확하게 설명하고 있습니다. 흐름 제어는 데이터 송수신 속도를 조절하여 혼잡을 방지하고, 양방향 통신을 지원하며,  데이터와 응답을 순차적으로 주고받는 방식으로 동작합니다. 따라서,  인접 노드 간 프레임 전송 및 오류 제어는 TCP의 역할이 아니라는 점이 틀린 설명입니다.  쉽게 말해, TCP는  데이터를 택배로 보낸다고 생각하면,  택배 회사(TCP)는  물건을 목적지까지 안전하게 배송하는 것을 책임지지만,  집 앞까지 물건을 가져다주는 마지막 단계(프레임 전송 및 오류 제어)는 택배 회사가 아닌 다른 곳에서 담당하는 것과 같습니다.",44,45
477,1,5,77,C언어에서 연산자 우선순위가 높은 것에서 낮은 것으로 바르게 나열된 것은?,https://www.cbtbank.kr/images/iz/iz20210515/iz20210515m77.gif,"㉠, ㉥, ㉣, ㉢, ㉡, ㉤","㉠, ㉣, ㉥, ㉢, ㉡, ㉤","㉠, ㉣, ㉥, ㉢, ㉤, ㉡","㉠, ㉥, ㉣, ㉤, ㉡, ㉢",1,"C언어에서 연산자의 우선순위는 수학과 마찬가지로 계산 순서를 결정하는 중요한 요소입니다.  괄호가 가장 높은 우선순위를 가지며, 괄호 안의 연산이 먼저 수행됩니다.  그 다음으로는 산술 연산자들(곱셈, 나눗셈 등)이 높은 우선순위를 가지고, 그 다음 비교 연산자(같다, 크다 등), 그리고 논리 연산자(그리고, 또는 등) 순으로 우선순위가 낮아집니다.  왼쪽에서 오른쪽으로 순차적으로 계산되는 연산자도 있고, 우선순위가 같다면 왼쪽에서 오른쪽으로 계산됩니다.  문제에서 제시된 연산자들을 우선순위 순서대로 나열하면, 괄호가 가장 먼저 계산되고, 그 다음 곱셈/나눗셈과 같은 산술 연산자, 비교 연산자, 그리고 마지막으로 논리 연산자가 계산됩니다.  따라서 정답은 괄호, 산술 연산자, 비교 연산자, 논리 연산자 순서로 연산자가 나열된 것입니다.  이러한 연산자 우선순위를 정확히 이해하지 못하면, 의도하지 않은 결과가 나올 수 있으므로 C언어 프로그래밍을 할 때 반드시 숙지해야 하는 중요한 내용입니다.  마치 수학에서 곱셈을 덧셈보다 먼저 계산하는 것과 같은 원리입니다.",48,41
478,1,5,78,C언어 라이브러리 중 stdlib.h에 대한설명으로 옳은 것은?,,문자열을 수치 데이터로 바꾸는 문자 변환함수와 수치를 문자열로 바꿔주는 변환함수 등이 있다.,문자열 처리 함수로 strlen()이 포함되어 있다.,표준 입출력 라이브러리이다.,"삼각 함수, 제곱근, 지수 등 수학적인 함수를 내장하고 있다.",1,"C언어에서 stdlib.h는 표준 라이브러리 헤더 파일 중 하나로, 다양한 유용한 함수들을 제공합니다.  문제에서 제시된 보기들을 살펴보면,  문자열을 숫자로, 숫자를 문자열로 변환하는 함수들이 stdlib.h에 포함되어 있다는 내용이 정확한 설명입니다.  예를 들어, 문자열 ""123""을 정수 123으로 변환하거나, 정수 456을 문자열 ""456""으로 변환하는 기능을 제공하는 함수들이 바로 stdlib.h에 정의되어 있습니다.  다른 보기들은 stdlib.h의 기능을 정확하게 나타내지 못합니다.  문자열 처리 함수는 string.h에, 표준 입출력은 stdio.h에, 수학 함수는 math.h에 주로 포함되어 있기 때문입니다. 따라서 문자열과 숫자 간의 변환 함수를 제공하는 stdlib.h에 대한 설명이 가장 정확합니다.",55,43
479,1,5,79,자바스크립트(JavaScript)와 관련한 설명으로 틀린 것은? (문제 오류로 가답안 발표시 2번으로 발표되었지만 확정 답안 발표시 모두 정답처리 되었습니다. 여기서는 가답안인 2번을 누르면 정답 처리 됩니다.),,프로토타입(Prototype)의 개념이 존재한다.,클래스 기반으로 객체 상속을 지원한다.,Prototype Link와 Prototype Object를 활용할 수 있다.,객체지향 언어이다.,2,"자바스크립트는 객체지향 언어이지만, 클래스 기반의 상속을 직접적으로 지원하지 않는다는 점이 이 문제의 핵심입니다.  다른 객체지향 언어들(예: Java, C++)처럼 `class` 키워드를 사용하여 클래스를 정의하고 상속을 구현하는 방식과는 다릅니다. 자바스크립트는 프로토타입 기반의 상속을 사용합니다.  프로토타입이란, 객체를 생성할 때 기본적인 속성과 메서드를 제공하는 객체를 의미하며, 새로운 객체는 이 프로토타입으로부터 속성과 메서드를 상속받습니다.  따라서,  자바스크립트는 프로토타입과 프로토타입 체인(Prototype Link)을 통해 객체의 상속을 구현하며,  클래스 키워드를 사용하는 방식과는 다르게 동작합니다.  문제에서 '클래스 기반으로 객체 상속을 지원한다'는 설명은 자바스크립트의 상속 메커니즘을 잘못 이해한 것입니다.  자바스크립트는 프로토타입을 활용하여 객체지향 프로그래밍의 개념을 구현하지만,  클래스 기반의 상속과는 다른 방식으로 동작합니다.  따라서,  '클래스 기반으로 객체 상속을 지원한다'는 설명이 틀린 것입니다.",83,7
480,1,5,80,OSI 7계층 중 네트워크 계층에 대한 설명으로 틀린 것은?,,패킷을 발신지로부터 최종 목적지까지 전달하는 책임을 진다.,한 노드로부터 다른 노드로 프레임을 전송하는 책임을 진다.,패킷에 발신지와 목적지의 논리 주소를 추가한다.,라우터 또는 교환기는 패킷 전달을 위해 경로를 지정하거나 교환 기능을 제공한다.,2,"OSI 7계층 중 네트워크 계층은 데이터를 전달하는 과정에서 매우 중요한 역할을 합니다.  우리가 인터넷을 통해 친구에게 메시지를 보낸다고 생각해 봅시다.  메시지는 여러 개의 작은 조각(패킷)으로 나뉘어 전송됩니다.  네트워크 계층은 이러한 패킷들이 발신지에서 목적지까지 정확하게 도착하도록 경로를 설정하고 관리하는 역할을 합니다.  마치 우체국에서 편지를 목적지까지 배달하는 것과 같습니다.  그런데, 문제에서 틀린 설명은 패킷이 아닌 프레임을 전송한다는 부분입니다.  프레임은 데이터링크 계층에서 다루는 개념입니다. 네트워크 계층은 데이터링크 계층 위에 위치하며, 데이터링크 계층에서 받은 프레임을 패킷으로 묶어서 논리 주소(IP 주소)를 추가하고, 라우터나 스위치를 통해 최적의 경로를 선택하여 목적지까지 전달합니다. 따라서 패킷을 다루는 네트워크 계층이 프레임을 전송한다는 설명은 잘못된 것입니다.  나머지 설명들은 네트워크 계층의 기능을 정확하게 나타내고 있습니다.  발신지와 목적지의 논리 주소(IP 주소)를 추가하고, 라우터나 스위치는 경로를 설정하고 패킷을 전달하는 역할을 수행합니다.",53,45
481,1,5,81,다음 내용이 설명하는 것은?,https://www.cbtbank.kr/images/iz/iz20210515/iz20210515m81.gif,SAN,MBR,NAC,NIC,1,"문제에서 설명하는 시스템은 네트워크를 통해 여러 기종의 컴퓨터들이 하나의 저장장치를 공유하는 시스템입니다.  여러 대의 저장장치를 하나로 통합하여 관리하는 효율적인 시스템이라고 볼 수 있죠.  특히, ""광채널 스위치의 이점인 고속 전송과 장거리 연결 및 멀티 프로토콜 기능을 활용""한다는 부분은  고성능 네트워크를 기반으로 대용량 데이터를 빠르게 전송하고, 다양한 종류의 저장장치와 호환성을 제공하는 시스템임을 강조하고 있습니다. 이러한 특징들은  SAN(Storage Area Network)의 핵심적인 기능과 정확히 일치합니다. SAN은 고속 네트워크를 통해 여러 서버와 저장장치를 연결하여 데이터를 공유하는 시스템으로,  문제에서 설명하는 ""각기 다른 운영체제를 가진 여러 기종들이 네트워크상에서 동일 저장장치의 데이터를 공유""하는 부분을 완벽하게 충족합니다.  반면 다른 선지들은 네트워크 저장장치 시스템과는 관련이 없습니다. MBR은 마스터 부트 레코드, NAC는 네트워크 접근 제어, NIC는 네트워크 인터페이스 카드를 의미하므로 문제의 설명과는 전혀 부합하지 않습니다. 따라서 문제의 정답은 SAN입니다.",57,51
482,1,5,82,SSH(Secure Shell)에 대한 설명으로 틀린 것은?,,SSH의 기본 네트워크 포트는 220번을 사용한다,전송되는 데이터는 암호화 된다.,키를 통한 인증은 클라이언트의 공개키를 서버에 등록해야 한다.,서로 연결되어 있는 컴퓨터 간 원격 명령실행이나 셀 서비스 등을 수행한다.,1,"SSH는 안전한 원격 접속을 위한 프로토콜입니다.  문제에서 틀린 설명을 찾는 것이므로, 각 설명을 하나씩 살펴보겠습니다.  데이터 암호화는 SSH의 핵심 기능이며, 원격 명령 실행이나 파일 전송 등의 기능도 SSH가 제공하는 중요한 서비스입니다.  키를 이용한 인증 방식에서는 클라이언트의 공개키를 서버에 등록해야 서버가 클라이언트를 인증할 수 있습니다.  하지만 SSH의 기본 포트 번호는 22번입니다. 220번이 아닙니다. 따라서 SSH에 대한 설명 중 틀린 것은 포트 번호에 대한 설명입니다.  쉽게 말해, SSH는 인터넷을 통해 컴퓨터를 안전하게 원격 조작할 때 사용하는 도구인데, 이 도구가 사용하는 기본 통로 번호(포트 번호)가 문제에서 잘못 언급된 것입니다. 마치 집 주소를 잘못 적은 것과 같은 이치입니다.  다른 설명들은 모두 SSH의 기능을 정확하게 설명하고 있습니다.",68,45
483,1,5,83,CBD(Component Based Development) SW개발 표준 산출물 중 분석 단계에 해당하는 것은?,,클래스 설계서,통합시험 결과서,프로그램 코드,사용자 요구사항 정의서,4,"CBD(Component Based Development)는 구성요소 기반 개발 방식으로, 미리 만들어 놓은 소프트웨어 구성요소들을 조립하여 새로운 시스템을 만드는 개발 방법입니다.  문제에서 묻고 있는 것은 분석 단계에 해당하는 산출물입니다. 분석 단계란, 사용자의 요구를 파악하고 시스템의 기능과 성능을 정의하는 단계입니다.  프로그램 코드는 설계 단계 이후 구현 단계의 산출물이고, 클래스 설계서는 설계 단계의 산출물이며, 통합시험 결과서는 테스트 단계의 산출물입니다. 따라서 사용자의 요구사항을 명확하게 정의한 문서인 사용자 요구사항 정의서만이 분석 단계의 산출물이라고 할 수 있습니다.  CBD 개발 방식에서도 가장 먼저 사용자의 요구를 정확히 이해하고 문서화하는 것이 필수적이기 때문에, 사용자 요구사항 정의서는 CBD의 분석 단계에서 가장 중요한 산출물입니다.  다른 선택지는 개발 과정의 후반부에 생성되는 산출물이므로 분석 단계와는 관련이 없습니다.",61,2
484,1,5,84,다음 내용이 설명하는 접근 제어 모델은?,https://www.cbtbank.kr/images/iz/iz20210515/iz20210515m84.gif,Clark-Wilson Integrity Model,PDCA Model,Bell-Lapadula Model,Chinese Wall Model,3,"문제에서 설명하는 접근 제어 모델은 정보의 기밀성에 따라 보안 레벨을 설정하고, 각 레벨에 따라 읽기와 쓰기 권한을 제어하는 모델입니다.  마치 군대의 계급처럼, 높은 보안 레벨을 가진 정보는 낮은 레벨의 사용자가 접근할 수 없도록 제한하는 것이죠.  문제에서 ""자신의 권한보다 낮은 보안 레벨 권한을 가진 경우에는 높은 보안 레벨의 문서를 읽을 수 없고 자신의 권한보다 낮은 수준의 문서만 읽을 수 있다""는 설명은  낮은 레벨에서 높은 레벨로의 정보 접근을 제한하는 '읽기 제한'을 의미합니다.  또한 ""자신의 권한보다 높은 보안 레벨의 문서에는 쓰기가 가능하지만 보안레벨이 낮은 문서의 쓰기 권한은 제한한다""는 설명은 높은 레벨에서 낮은 레벨로의 정보 변경을 제한하는 '쓰기 제한'을 의미합니다. 이러한 읽기와 쓰기 제한을 통해 정보의 기밀성을 보장하는 모델은 바로 Bell-Lapadula 모델입니다.  Bell-Lapadula 모델은  '높은 보안 레벨의 정보는 낮은 보안 레벨로 흘러가서는 안 된다'는 'no read up' 원칙과 '낮은 보안 레벨의 정보는 높은 보안 레벨로 흘러가서는 안 된다'는 'no write down' 원칙을 기본으로 합니다. 문제에서 설명하는 내용이 이 두 가지 원칙과 정확히 일치하기 때문에 정답은 Bell-Lapadula 모델입니다.  다른 모델들은 정보의 무결성이나 접근 제어의 다른 방식을 다루기 때문에 문제 상황과는 맞지 않습니다.",58,31
485,1,5,85,하둡(Hadoop)과 관계형 데이터베이스간에 데이터를 전송할 수 있도록 설계된 도구는?,,Apnic,Topology,Sqoop,SDB.,3,"이 문제는 하둡(Hadoop)과 관계형 데이터베이스(RDBMS) 간의 데이터 전송을 위한 도구를 묻고 있습니다.  하둡은 대량의 데이터를 분산 처리하는 데 특화된 시스템이고, 관계형 데이터베이스는 테이블 형태로 데이터를 구조화하여 관리하는 시스템입니다.  두 시스템은 데이터 저장 방식과 접근 방식이 다르기 때문에, 서로 다른 시스템 간의 데이터 교환을 위해서는 특별한 도구가 필요합니다.  정답으로 제시된 도구는 바로 이러한 역할을 수행하는데,  하둡의 분산 저장소(예: HDFS)에 있는 데이터를 관계형 데이터베이스로 가져오거나, 관계형 데이터베이스의 데이터를 하둡으로 보낼 수 있도록 설계되었습니다.  다른 선지들은 하둡이나 관계형 데이터베이스와 직접적인 데이터 전송 기능을 제공하지 않습니다. 따라서 하둡과 관계형 데이터베이스 간의 데이터 전송을 위한 도구로 가장 적합한 것은 정답입니다.  마치 두 개의 다른 언어를 사용하는 사람들 사이에서 통역을 해주는 역할과 같다고 생각하면 이해하기 쉬울 것입니다.",73,35
486,1,5,86,라우팅 프로토콜인 OSPF(Open Shortest Path First)에 대한 설명으로 옳지 않은 것은?,,네트워크 변화에 신속하게 대처할 수 있다.,거리 벡터 라우팅 프로토콜이라고 한다.,멀티캐스팅을 지원한다.,최단 경로 탐색에 Dijkstra 알고리즘을 사용한다.,2,"OSPF는 링크 상태 라우팅 프로토콜입니다.  링크 상태 라우팅이란, 네트워크의 전체적인 토폴로지(구조)를 파악하여 최단 경로를 계산하는 방식입니다.  반면에 거리 벡터 라우팅은 각 라우터가 이웃 라우터에게 자신의 거리 정보만을 주고받아 경로를 결정합니다.  OSPF는 네트워크의 전체적인 정보를 가지고 있기 때문에 네트워크 변화에 빠르게 대응하고 최적의 경로를 계산할 수 있습니다.  문제에서 잘못된 설명은 OSPF가 거리 벡터 라우팅 프로토콜이라는 것입니다. OSPF는 링크 상태 라우팅 프로토콜이며, 최단 경로를 찾기 위해 Dijkstra 알고리즘을 사용하고, 네트워크의 효율적인 관리를 위해 멀티캐스팅을 지원하는 특징을 가지고 있습니다. 따라서 OSPF에 대한 잘못된 설명을 찾는 문제에서 정답은 OSPF가 거리 벡터 라우팅 프로토콜이라는 선지입니다.",49,49
487,1,5,87,소프트웨어 비용 추정 모형(estimation models)이 아닌 것은?,,COCOMO,Putnam,Function-Point,PERT,4,"소프트웨어 개발 비용을 예측하는 여러 가지 방법들이 존재합니다.  COCOMO, Putnam, Function-Point 모델은 모두 소프트웨어 개발 프로젝트의 규모, 복잡도, 그리고 다른 요소들을 고려하여 개발에 필요한 시간과 비용을 추정하는 데 사용되는 대표적인 모형입니다.  반면 PERT(Program Evaluation and Review Technique)는 프로젝트의 일정 관리를 위한 기법으로, 각 작업의 소요 시간을 추정하고 전체 프로젝트 완료 시간을 예측하는 데 사용됩니다.  PERT는 프로젝트 일정의 불확실성을 고려하여 확률적인 접근 방식을 사용하지만, 소프트웨어 개발 비용 자체를 직접적으로 추정하는 모형은 아닙니다. 따라서 소프트웨어 비용 추정 모형이 아닌 것은 PERT입니다.  쉽게 말해, COCOMO, Putnam, Function-Point는 ""돈 얼마 들까?""를 예측하는 방법이고, PERT는 ""언제 끝날까?""를 예측하는 방법이라고 생각하면 이해하기 쉬울 것입니다.",67,47
488,1,5,88,"코드의 기입 과정에서 원래 '12536‘으로 기입되어야 하는데 ’12936‘으로 표기되었을 경우, 어떤 코드 오류에 해당하는가?",,Addition Error,Omission Error,Sequence Error,Transcription Error,4,"문제에서 '12536'이라는 숫자가 '12936'으로 잘못 기입되었다는 상황입니다.  이는 숫자 '5'가 '9'로 잘못 기록된 것을 의미합니다.  즉, 원래의 정보가 다른 정보로 바뀌어 기록된 오류입니다.  '더하기 오류'는 숫자에 잘못된 값이 더해진 경우이고, '생략 오류'는 숫자 일부가 빠진 경우, '순서 오류'는 숫자의 순서가 바뀐 경우를 의미합니다. 하지만 이 문제의 경우 숫자 자체가 다른 숫자로 잘못 기록되었으므로, '잘못된 기록 오류' 즉, '전사 오류(Transcription Error)'가 가장 적절한 설명입니다.  전사 오류는 데이터를 입력하거나 복사하는 과정에서 발생하는 오류로,  이 문제에서 '12536'을 입력해야 하는데 '12936'으로 잘못 입력한 것이 바로 전사 오류에 해당합니다.  마치 사람이 글씨를 베껴 쓰는 과정에서 실수하는 것과 같은 이치입니다.",57,54
489,1,5,89,ISO 12207 표준의 기본 생명주기의 주요 프로세스에 해당하지 않는 것은?,,획득 프로세스,개발 프로세스,성능평가 프로세스,유지보수 프로세스,3,"ISO 12207은 소프트웨어 생명주기 프로세스를 표준화한 국제 표준입니다.  소프트웨어를 개발하고 유지보수하는 전 과정을 체계적으로 관리하기 위한 가이드라인을 제공하는데,  소프트웨어의 개발, 획득, 유지보수 등의 주요 단계를 다룹니다.  문제에서 제시된 선택지들은 소프트웨어 개발 및 관리에 중요한 프로세스들을 나타냅니다.  '획득 프로세스'는 소프트웨어를 구매하거나 계약하는 과정을, '개발 프로세스'는 소프트웨어를 설계하고 구현하는 과정을, '유지보수 프로세스'는 개발된 소프트웨어를 유지하고 개선하는 과정을 의미합니다.  하지만 '성능평가 프로세스'는 ISO 12207의 기본 생명주기의 주요 프로세스로 명시적으로 분류되지 않습니다.  성능 평가는 소프트웨어 개발 과정 중 여러 단계에서 수행될 수 있는 활동이지,  독립적인 주요 프로세스로 분류되지는 않는다는 점이 중요합니다.  따라서 ISO 12207의 기본 생명주기의 주요 프로세스에 해당하지 않는 것은 성능평가 프로세스입니다.  성능 평가는 개발이나 유지보수 과정에서 중요한 부분이지만,  ISO 12207에서는  개발, 획득, 유지보수 등의 상위 프로세스 내에서 수행되는 활동으로 간주됩니다.",34,47
490,1,5,90,"소프트웨어 비용 산정 기법 중 개발 유형으로 organic, semi-detached, embedded로 구분되는 것은?",,PUTNAM,COCOMO,FP,SLIM,2,"소프트웨어 개발 비용을 산정하는 방법에는 여러 가지가 있습니다.  그 중에서 COCOMO 모델은 개발 규모와 개발 유형에 따라 비용을 추정하는 방식으로 유명합니다.  COCOMO 모델은 개발 프로젝트의 규모를  작은 규모(organic), 중간 규모(semi-detached), 큰 규모(embedded)로 나누어 각 유형에 맞는 비용 산정 공식을 적용합니다.  문제에서 언급된 organic, semi-detached, embedded는 바로 COCOMO 모델에서 사용하는 개발 유형 분류 방식입니다.  다른 선택지들은 각각 다른 소프트웨어 비용 산정 기법을 나타내므로,  개발 유형을 organic, semi-detached, embedded로 구분하는 기법은 COCOMO 모델이라고 할 수 있습니다.  쉽게 말해, COCOMO 모델은 프로젝트의 크기(organic, semi-detached, embedded)에 따라 비용을 다르게 계산하는 방법이라고 생각하면 됩니다.",83,47
491,1,5,91,SPICE 모델의 프로세스 수행능력 수준의 단계별 설명이 틀린 것은?,,수준 7 - 미완성 단계,수준 5 - 최적화 단계,수준 4 - 예측 단계,수준 3 - 확립 단계,1,"SPICE 모델은 소프트웨어 프로세스 개선을 위한 국제 표준 모델입니다.  이 문제는 SPICE 모델의 프로세스 수행능력 수준을 묻고 있는데, 각 수준은 소프트웨어 개발 프로세스의 성숙도를 나타냅니다.  낮은 수준은 프로세스가 제대로 정의되지 않거나, 일관성이 없고, 예측 불가능한 결과를 초래하는 반면, 높은 수준은 프로세스가 잘 정의되고, 관리되며, 예측 가능하고 최적화된 결과를 가져옵니다.  문제에서 틀린 설명을 찾아야 하는데,  '미완성 단계'라는 표현은 SPICE 모델의 수준을 설명하는 데 적절하지 않습니다. SPICE 모델은 각 수준에 대해 명확한 기준과 설명을 제공하며, '미완성'이라는 애매한 표현은 사용하지 않습니다. 다른 선지는 SPICE 모델의 각 수준에 대한 일반적인 설명과 일치합니다.  따라서 '미완성 단계'라는 설명이 포함된 선지가 틀린 것입니다.  쉽게 말해, SPICE 모델은 소프트웨어 개발 과정의 단계를 체계적으로 나누고, 각 단계의 특징을 명확히 정의하는데,  '미완성'이라는 표현은 그 체계적인 분류에 맞지 않기 때문에 틀린 것입니다.",71,47
492,1,5,92,"PC, TV, 휴대폰에서 원하는 콘텐츠를 끊김없이 자유롭게 이용할 수 있는 서비스는?",,Memristor,MEMS,SNMP,N-Screen,4,"이 문제는 여러 기기에서 동일한 콘텐츠를 끊김 없이 이용할 수 있는 서비스에 대한 질문입니다.  PC, TV, 휴대폰 등 다양한 기기에서 동일한 콘텐츠를 이용하는 것을 'N-Screen' 서비스라고 합니다.  N은 여러 개를 의미하는데,  PC, TV, 스마트폰, 태블릿 등 여러 개의 화면(Screen)에서 콘텐츠를 이용할 수 있다는 것을 나타냅니다.  예를 들어, 집에서는 TV로 영화를 보다가, 출퇴근길에는 스마트폰으로 같은 영화를 이어서 볼 수 있는 것이죠.  다른 선택지는 모두 특정 기술이나 프로토콜을 나타내는 용어로,  문제에서 묻고 있는 서비스의 개념과는 직접적인 관련이 없습니다. 따라서 여러 기기에서 콘텐츠를 자유롭게 이용할 수 있는 서비스를 정확하게 나타내는 것은 N-Screen입니다.",71,1
493,1,5,93,해쉬(Hash) 기법에 대한 설명으로 틀린 것은?,,임의의 길이의 입력 데이터를 받아 고정된 길이의 해쉬 값으로 변환한다.,주로 공개키 암호화 방식에서 키 생성을 위해 사용한다.,"대표적인 해쉬 알고리즘으로 HAVAL, SHA-1 등이 있다.",해쉬 함수는 일방향 함수(One-way function)이다.,2,"해쉬(Hash) 기법은 임의의 길이를 가진 데이터를 고정된 길이의 해쉬 값으로 변환하는 일방향 함수입니다.  쉽게 말해, 아무리 긴 글이나 파일이라도 해쉬 함수에 넣으면 특정 길이의 암호 같은 값(해쉬 값)이 나오는 것이죠.  그리고 중요한 점은 이 과정은 일방향이라는 것입니다.  해쉬 값을 가지고 원래 데이터를 알아낼 수 없습니다.  마치 계란을 깨뜨리는 것은 쉽지만, 깨진 계란을 다시 원래대로 조립하는 것은 불가능한 것과 같습니다.  문제에서 틀린 설명은 공개키 암호화 방식에서 키 생성에 해쉬 기법이 주로 사용된다는 것입니다.  공개키 암호화는 해쉬 기법과는 다른 암호화 방식이며, 키 생성에는 다른 알고리즘이 사용됩니다.  해쉬 기법은 데이터 무결성 검증, 디지털 서명 등 다양한 분야에서 활용되지만, 주된 용도는 키 생성이 아닙니다.  HAVAL이나 SHA-1과 같은 알고리즘은 대표적인 해쉬 알고리즘이며, 해쉬 함수가 일방향 함수라는 것도 맞는 설명입니다. 따라서 공개키 암호화 방식에서 키 생성에 해쉬 기법이 주로 사용된다는 설명만이 틀린 것입니다.",50,21
494,1,5,94,IPSec(IP Security)에 대한 설명으로 틀린 것은?,,암호화 수행시 일방향 암호화만 지원한다.,"ESP는 발신지 인증, 데이터 무결성, 기밀성 모두를 보장한다.",운영 모드는 Tunnel 모드와 Transport 모드로 분류된다.,"AH는 발신지 호스트를 인증하고, IP 패킷의 무결성을 보장한다.",1,"IPSec(IP Security)는 IP 패킷을 암호화하고 인증하는 보안 프로토콜입니다.  문제에서 틀린 설명을 찾는 것이 목표인데요,  IPSec은 데이터의 기밀성과 무결성을 보장하기 위해 암호화를 사용합니다.  그리고 이 암호화는 양방향 암호화를 지원합니다.  즉, 데이터를 암호화하여 전송하고, 수신측에서 복호화하여 원래 데이터를 복구하는 과정을 거치죠.  따라서 일방향 암호화만 지원한다는 설명은 사실과 다릅니다.  ESP(Encapsulating Security Payload)는 데이터의 기밀성, 무결성, 발신지 인증을 모두 제공하며, AH(Authentication Header)는 발신지 인증과 데이터 무결성을 보장합니다.  마지막으로 IPSec은 Tunnel 모드와 Transport 모드라는 두 가지 운영 모드를 제공합니다.  따라서 문제에서 제시된 틀린 설명은 바로 암호화 방식에 대한 부분입니다.  IPSec은 데이터의 안전한 전송을 위해 양방향 암호화를 사용하기 때문입니다.",68,45
495,1,5,95,메모리상에서 프로그램의 복귀 주소와 변수 사이에 특정 값을 저장해 두었다가 그 값이 변경되었을 경우 오버플로우 상태로 가정하여 프로그램 실행을 중단하는 기술은?,,Stack Guard,Bridge,ASLR,FIN,1,"이 문제는 프로그램의 안전성을 확보하기 위한 보안 기술 중 하나를 묻고 있습니다.  프로그램이 실행될 때, 메모리에는 프로그램의 실행 순서를 기록하는 '스택'이라는 영역이 존재합니다.  함수를 호출하면 복귀 주소(함수가 끝난 후 돌아갈 위치)가 스택에 저장되고, 함수 내부에서 사용하는 변수들도 스택에 저장됩니다.  만약 악의적인 공격자가 이 스택에 저장된 복귀 주소를 변경하면, 프로그램이 의도하지 않은 위치로 이동하여 실행될 수 있습니다. 이를 '스택 오버플로우 공격'이라고 합니다.",79,11
496,1,5,96,침입차단 시스템(방화벽) 중 다음과 같은 형태의 구축 유형은?,https://www.cbtbank.kr/images/iz/iz20210515/iz20210515m96.gif,Block Host,Tree Host,Screened Subnet,Ring Homed,3,"이 문제는 침입 차단 시스템(방화벽)의 구축 유형에 대한 문제입니다.  네트워크 보안을 위해 방화벽을 설치하는데, 단순히 하나의 방화벽만 설치하는 것보다 더욱 안전하고 효율적인 구조를 만들기 위해 여러 방식이 존재합니다.  정답으로 제시된 구축 유형은 '스크린드 서브넷(Screened Subnet)' 방식입니다.  이 방식은 내부 네트워크를 하나 이상의 방화벽으로 보호하는 구조입니다.  외부 네트워크와 직접 연결되지 않고,  DMZ(Demilitarized Zone, 비무장 지대)라고 불리는 중간 영역을 두어 외부에서 접근 가능한 서버들을 배치합니다.  이 DMZ는 첫 번째 방화벽에 의해 외부 네트워크와 분리되고, DMZ 내부의 서버들은 두 번째 방화벽에 의해 내부 네트워크와 분리됩니다.  만약 외부에서 공격이 들어오더라도 DMZ에서 차단되고, 내부 네트워크는 안전하게 보호될 수 있습니다.  이는 단일 방화벽보다 훨씬 강력한 보안을 제공하며,  외부 공격으로부터 내부 네트워크를 효과적으로 보호하는 다층 방어 시스템을 구축하는 것입니다.  다른 선택지들은 이러한 다층 방어 구조를 갖추지 못하거나,  보안에 취약한 구조를 가지고 있습니다. 따라서, 내부 네트워크를 효과적으로 보호하기 위해서는 스크린드 서브넷 방식과 같은 다중 방화벽 구조가 필수적입니다.",50,49
497,1,5,97,Secure OS의 보안 기능으로 거리가 먼 것은?,,식별 및 인증,임의적 접근 통제,고가용성 지원,강제적 접근 통제,3,"Secure OS(보안 운영체제)는 시스템의 보안을 강화하기 위해 다양한 기능을 제공합니다.  식별 및 인증 기능은 사용자의 신원을 확인하고 시스템 접근을 허용하는 기본적인 보안 기능입니다.  임의적 접근 통제와 강제적 접근 통제는 모두 시스템 자원에 대한 접근을 제어하는 기능으로,  임의적 접근 통제는 사용자나 프로세스가 자원에 대한 접근 권한을 설정하고 관리하는 방식이고, 강제적 접근 통제는 시스템 관리자가 미리 정의한 보안 정책에 따라 접근 권한을 제어하는 방식입니다.  하지만 고가용성 지원은 시스템의 안정적인 운영과 지속적인 서비스 제공을 위한 기능으로,  직접적인 보안 기능이라고 보기는 어렵습니다.  고가용성은 시스템 장애 발생 시에도 서비스를 지속적으로 제공하기 위한 기능이지,  외부의 공격이나 무단 접근으로부터 시스템을 보호하는 기능은 아닙니다. 따라서 Secure OS의 보안 기능과는 거리가 먼 것은 고가용성 지원입니다.  Secure OS는 안전한 시스템 운영을 위해 보안 기능을 중점적으로 제공하지만,  고가용성은 시스템의 안정성을 높이는 부가적인 기능으로,  보안 기능과는 목적이 다릅니다.",75,51
498,1,5,98,서버에 열린 포트 정보를 스캐닝해서 보안취약점을 찾는데 사용하는 도구는?,,type,mkdir,ftp,nmap,4,"서버의 보안 취약점을 찾는 과정에서 가장 중요한 것은 서버가 어떤 포트를 열어놓고 외부와 통신하고 있는지 파악하는 것입니다.  마치 집의 문과 창문이 어디에 있는지 확인하는 것과 같습니다.  열려있는 포트는 외부 공격에 취약한 지점이 될 수 있기 때문입니다.  nmap은 바로 이러한 열린 포트들을 스캐닝하여 확인하는 데 사용되는 도구입니다.  nmap을 사용하면 서버가 어떤 서비스를 제공하고 있는지, 그리고 그 서비스에 보안 취약점이 있는지 여부를 파악할 수 있습니다.  다른 선택지들은 서버의 포트 정보를 스캐닝하는 기능을 제공하지 않습니다. type은 파일의 종류를 확인하고, mkdir은 디렉토리를 생성하며, ftp는 파일 전송 프로토콜입니다. 따라서 서버의 열린 포트 정보를 스캐닝하여 보안 취약점을 찾는 데 사용되는 도구는 nmap입니다.  마치 의사가 환자의 상태를 진단하기 위해 여러 검사를 하는 것처럼, nmap은 서버의 보안 상태를 진단하는 중요한 도구라고 할 수 있습니다.",68,56
499,1,5,99,서로 다른 네트워크 대역에 있는 호스트들 상호간에 통신할 수 있도록 해주는 네트워크 장비는?,,L2 스위치,HIPO,라우터,RAD.,3,"서로 다른 네트워크 대역에 있는 호스트는 서로 직접 통신할 수 없습니다.  마치 다른 나라에 있는 사람들끼리 편지를 주고받으려면 우체국(중간 경유지)을 거쳐야 하는 것과 같습니다.  각 네트워크 대역은 고유한 주소 체계를 가지고 있기 때문에, 이 주소 체계를 이해하고 서로 다른 대역 간의 통신 경로를 설정해주는 장비가 필요합니다.  이 역할을 하는 것이 바로 라우터입니다. 라우터는 여러 네트워크를 연결하여 데이터 패킷이 목적지 호스트에 도착할 수 있도록 경로를 선택하고 전달하는 역할을 합니다.  L2 스위치는 같은 네트워크 내의 호스트 간 통신을 담당하고, HIPO와 RAD는 문제와 관련이 없는 용어입니다. 따라서 서로 다른 네트워크 대역에 있는 호스트 간 통신을 가능하게 하는 장비는 라우터입니다.",79,49
500,1,5,100,암호화 키와 복호화 키가 동일한 암호화 알고리즘은?,,RSA,AES,DSA,ECC,2,"암호화는 정보를 다른 사람이 알아볼 수 없도록 변환하는 기술이고, 복호화는 암호화된 정보를 다시 원래대로 돌리는 기술입니다.  암호화 알고리즘은 암호화와 복호화에 사용하는 방법을 정의하는데,  키는 이 과정에서 정보를 암호화하고 복호화하는 데 사용되는 비밀번호와 같은 특별한 값입니다.  문제에서 묻는 것은 암호화 키와 복호화 키가 같은 알고리즘, 즉 같은 키를 사용하여 암호화와 복호화를 모두 수행하는 알고리즘입니다.  RSA, DSA, ECC 알고리즘은 서로 다른 키를 사용하는 공개키 암호화 방식을 사용합니다.  공개키는 누구나 알 수 있지만, 개인키는 소유자만 알고 있어야 합니다.  반면에 AES는 대칭키 암호화 방식으로, 암호화와 복호화에 동일한 키를 사용합니다.  따라서 암호화 키와 복호화 키가 같은 알고리즘은 AES입니다.  마치 같은 자물쇠와 열쇠를 사용하여 상자를 잠그고 여는 것과 같습니다.",57,54
501,1,6,1,요구사항 검증(Requirements Validation)과 관련한 설명으로 틀린 것은?,,요구사항이 고객이 정말 원하는 시스템을 제대로 정의하고 있는지 점검하는 과정이다.,개발완료 이후에 문제점이 발견될 경우 막대한 재작업 비용이 들 수 있기 때문에 요구사항 검증은 매우 중요하다.,"요구사항이 실제 요구를 반영하는지, 문서상의 요구사항은 서로 상충되지 않는지 등을 점검한다.",요구사항 검증 과정을 통해 모든 요구사항 문제를 발견할 수 있다.,4,"요구사항 검증은 고객이 원하는 시스템을 제대로 만들고 있는지 확인하는 아주 중요한 과정입니다.  마치 건물을 짓기 전에 설계도를 꼼꼼히 검토하는 것과 같습니다.  설계도에 오류가 있으면 건물이 무너질 수도 있듯이, 시스템 요구사항에 문제가 있으면 개발 후에 큰 문제가 발생하고 많은 비용을 들여 다시 작업해야 할 수도 있습니다. 따라서 요구사항이 고객의 실제 요구를 잘 반영하고 있는지, 서로 모순되는 부분은 없는지 등을 꼼꼼하게 검토하는 것이 필수적입니다. 하지만 아무리 검증을 잘해도 모든 문제를 100% 찾아낼 수는 없습니다.  미처 발견하지 못한 작은 오류가 나중에 큰 문제로 이어질 가능성도 항상 존재하기 때문입니다.  완벽한 검증은 어렵지만, 최대한 많은 문제점을 사전에 발견하여  개발 과정의 효율성을 높이고, 최종 결과물의 품질을 높이는 것이 요구사항 검증의 목표입니다.  따라서 모든 요구사항 문제를 발견할 수 있다는 주장은 현실적으로 불가능한 것입니다.",92,2
502,1,6,2,"UML 모델에서 한 사물의 명세가 바뀌면 다른사물에 영향을 주며, 일반적으로 한 클래스가다른 클래스를 오퍼레이션의 매개변수로 사용하는 경우에 나타나는 관계는?",,Association,Dependency,Realization,Generalization,2,"UML 모델에서 한 사물의 명세가 바뀌면 다른 사물에 영향을 미치는 관계를 생각해 봅시다.  예를 들어, 자동차(Car) 클래스가 엔진(Engine) 클래스를 사용한다고 가정해 봅시다.  자동차는 엔진의 성능에 따라 속도가 달라지므로, 엔진의 명세(예: 출력)가 변경되면 자동차의 동작에도 영향을 미칩니다.  이처럼 한 클래스의 변경이 다른 클래스에 직접적인 영향을 주는 관계를 UML에서는 '의존(Dependency)' 관계라고 합니다.  '연관(Association)'은 두 클래스가 서로 연결되어 있음을 나타내지만, 한쪽 클래스의 변경이 다른 쪽에 항상 영향을 주는 것은 아닙니다.  '구현(Realization)'은 인터페이스와 클래스 간의 관계를 나타내고, '일반화(Generalization)'는 상속 관계를 나타냅니다. 따라서, 문제에서 설명하는 상황은 한 클래스가 다른 클래스의 변경에 의존하는 '의존(Dependency)' 관계를 가장 잘 나타냅니다.  오퍼레이션의 매개변수로 사용하는 경우는 특히 의존성이 강하게 나타납니다.  매개변수로 사용되는 클래스의 변경은 오퍼레이션의 동작에 직접적인 영향을 미치기 때문입니다.",65,2
503,1,6,3,익스트림 프로그래밍 (XP)에 대한 설명으로 틀린 것은?,,빠른 개발을 위해 테스트를 수행하지 않는다.,사용자의 요구사항은 언제든지 변할 수있다.,고객과 직접 대면하며 요구사항을 이야기하기 위해 사용자 스토리(User Story)를 활용할 수 있다.,기존의 방법론에 비해 실용성(Pragmatism)을 강조한 것이라고 볼 수있다.,1,"익스트림 프로그래밍(XP)은 소프트웨어 개발 방법론 중 하나로, 빠르고 유연한 개발을 목표로 합니다.  문제에서 틀린 설명은 바로 '빠른 개발을 위해 테스트를 수행하지 않는다'는 부분입니다. XP는 오히려 테스트를 매우 중요하게 생각하고, 개발 과정 전반에 걸쳐 지속적인 테스트를 강조합니다.  '테스트 주도 개발(TDD)'이라는 개념을 적극적으로 활용하여, 코드를 작성하기 전에 먼저 테스트 코드를 작성하고, 그 테스트를 통과하는 코드를 만드는 방식으로 개발의 질을 높이고, 오류를 조기에 발견하여 빠른 개발을 가능하게 합니다.  나머지 설명들은 XP의 핵심적인 특징들을 잘 나타내고 있습니다. 사용자 요구사항의 변화에 유연하게 대처하고, 고객과의 긴밀한 소통을 통해 사용자 스토리를 활용하며, 기존의 복잡한 방법론과 달리 실용성을 중시하는 점 등이 XP의 장점입니다. 따라서, 테스트를 소홀히 한다는 설명은 XP의 본질과 맞지 않아 틀린 설명이 됩니다.",91,2
504,1,6,4,소프트웨어 설계에서 사용되는 대표적인 추상화(Abstraction) 기법이 아닌 것은?,,자료 추상화,제어 추상화,과정 추상화,강도 추상화,4,"소프트웨어 설계에서 추상화는 복잡한 시스템을 단순화하여 이해하고 관리하기 위한 중요한 기법입니다.  자료 추상화는 데이터의 구체적인 표현 방식을 숨기고, 필요한 기능만을 노출시켜 사용하는 방법입니다. 예를 들어, 자동차를 생각해보면, 운전자는 엔진의 내부 작동 원리를 몰라도 운전할 수 있습니다.  운전자에게는 '가속 페달'과 '브레이크 페달'이라는 추상적인 인터페이스만 제공되면 되는 것이죠.  제어 추상화는 복잡한 제어 흐름을 단순화하여 표현하는 기법입니다.  프로그래밍에서 함수나 서브루틴을 사용하는 것이 좋은 예시입니다.  과정 추상화는 복잡한 과정을 단순화하여 표현하는 기법입니다.  예를 들어, ""문서를 인쇄한다""라는 과정은 실제로는 여러 단계의 복잡한 작업을 포함하지만, 사용자에게는 단순한 하나의 명령어로 보이는 것이죠.  반면에 '강도 추상화'라는 용어는 소프트웨어 설계에서 일반적으로 사용되는 추상화 기법이 아닙니다.  '강도'라는 단어 자체가 추상화와 관련된 개념이 아니며, 소프트웨어 설계의 맥락에서 어떤 의미를 갖는지 명확하지 않습니다. 따라서 소프트웨어 설계에서 사용되는 대표적인 추상화 기법이 아닌 것은 '강도 추상화'입니다.  다른 세 가지는 모두 소프트웨어 설계에서 흔히 사용되는 중요한 추상화 기법입니다.",81,6
505,1,6,5,객체지향 설계에서 정보 은닉(Information Hiding)과 관련한 설명으로 틀린 것은?,,필요하지 않은 정보는 접근할 수 없도록 하여 한 모듈 또는 하부시스템이 다른 모듈의 구현에 영향을 받지 않게 설계되는것을 의미한다.,모듈들 사이의 독립성을 유지시키는 데 도움이 된다.,"설계에서 은닉되어야 할 기본 정보로는 IP주소와 같은 물리적 코드, 상세 데이터 구조 등이 있다.",모듈 내부의 자료 구조와 접근 동작들에만 수정을 국한하기 때문에 요구사항 등변화에 따른 수정이 불가능하다.,4,"객체지향 설계에서 정보 은닉(Information Hiding)은 시스템의 내부 구현 방식을 외부에 감추고, 외부에서 필요한 정보만 제한적으로 접근하도록 하는 설계 원칙입니다.  이는 마치 잘 짜여진 기계처럼, 사용자는 기계의 작동 방식을 몰라도 버튼을 눌러 원하는 결과를 얻을 수 있는 것과 같습니다.  외부에서 내부 구현에 접근하지 못하도록 함으로써,  하나의 모듈이 변경되더라도 다른 모듈에 영향을 미치지 않아 시스템의 안정성과 유지보수성을 높일 수 있습니다.  IP 주소나 상세 데이터 구조와 같은 내부 정보는 외부에 노출될 필요가 없으므로 은닉되어야 합니다.  하지만,  모듈 내부 자료 구조와 접근 동작만 수정한다고 해서 모든 요구사항 변경에 대응할 수 없는 것은 아닙니다.  오히려 정보 은닉을 통해 모듈 간의 의존성을 줄임으로써,  변경에 따른 영향을 최소화하고 유연하게 대처할 수 있도록 설계하는 것이 정보 은닉의 목표입니다. 따라서,  모듈 내부의 수정만으로 모든 요구사항 변경에 대응할 수 없다는 주장은 정보 은닉의 장점을 잘못 이해한 것입니다.  정보 은닉은 변경에 대한 영향을 최소화하고,  시스템의 유지보수를 용이하게 하기 위한 설계 원칙입니다.",84,7
506,1,6,6,소프트웨어 공학에서 모델링 (Modeling)과 관련한 설명으로 틀린 것은?,,개발팀이 응용문제를 이해하는 데 도움을 줄 수 있다.,유지보수 단계에서만 모델링 기법을 활용한다.,개발될 시스템에 대하여 여러 분야의 엔지니어들이 공통된 개념을 공유하는 데 도움을 준다.,절차적인 프로그램을 위한 자료흐름도는 프로세스 위주의 모델링 방법이다.,2,"소프트웨어 개발 과정에서 모델링은 매우 중요한 역할을 합니다.  모델링은 시스템을 그림이나 도표 등으로 시각화하여 표현하는 과정인데요, 이를 통해 개발팀은 복잡한 시스템을 쉽게 이해하고,  개발 과정에서 발생할 수 있는 문제점을 미리 파악하여 해결할 수 있습니다.  또한,  다양한 분야의 전문가들이 시스템에 대한 공통된 이해를 갖도록 도와주어 효율적인 협업을 가능하게 합니다.  모델링은 개발 초기 단계부터 유지보수 단계까지 전 과정에서 활용되며,  특히 초기 단계에서는 시스템의 요구사항을 명확히 하고 설계를 검증하는 데 필수적입니다.  따라서,  모델링 기법을 유지보수 단계에서만 활용한다는 주장은 틀린 것입니다.  다른 선지는 모두 소프트웨어 개발 과정에서 모델링이 수행하는 역할을 정확하게 설명하고 있습니다.  자료흐름도는 시스템의 처리 과정을 순차적으로 보여주는 대표적인 모델링 기법으로, 절차적인 프로그램 개발에 유용하게 사용됩니다.",89,3
507,1,6,7,요구 분석(Requirement Analysis)에 대한 설명으로 틀린 것은?,,요구 분석은 소프트웨어 개발의 실제적인 첫 단계로 사용자의 요구에 대해 이해하는 단계라 할 수 있다.,요구 추출(Requirement Elicitation)은 프로젝트 계획 단계에 정의한 문제의 범위 안에 있는 사용자의 요구를 찾는 단계이다.,도메인 분석(Domain Analysis)은 요구에 대한 정보를 수집하고 배경을 분석하여 이를 토대로 모델링을 하게 된다.,"기능적(Functional) 요구에서 시스템 구축에대한 성능, 보안, 품질, 안정 등에 대한 요구사항을 도출한다.",4,"이 문제는 소프트웨어 개발 과정 중 '요구 분석' 단계에 대한 이해도를 묻고 있습니다.  요구 분석은 사용자의 요구를 정확하게 파악하고 문서화하는 매우 중요한 단계입니다.  소프트웨어 개발은 사용자의 요구를 충족시키는 것이 목표이기 때문에, 이 단계에서 사용자의 요구를 제대로 이해하지 못하면 개발 결과물이 사용자의 기대에 부합하지 않을 가능성이 높아집니다.  문제에서 틀린 설명은 시스템 구축에 대한 성능, 보안, 품질, 안정 등의 요구사항을 기능적 요구에서 도출한다는 내용입니다.  기능적 요구는 시스템이 *무엇을* 해야 하는지에 대한 요구사항을 의미하며, 성능, 보안, 품질, 안정성 등은 *어떻게* 해야 하는지에 대한 비기능적 요구사항에 해당합니다.  따라서 시스템의 성능, 보안, 품질, 안정성과 같은 요구사항은 비기능적 요구에서 도출되어야 합니다.  다른 선택지는 모두 요구 분석 단계의 내용을 정확하게 설명하고 있으므로,  비기능적 요구와 기능적 요구의 차이를 명확히 이해하는 것이 중요합니다.  결론적으로, 기능적 요구와 비기능적 요구를 혼동한 설명이 틀린 것입니다.",55,2
508,1,6,8,클래스 다이어그램의 요소로 다음 설명에 해당하는 용어는?,https://www.cbtbank.kr/images/iz/iz20210814/iz20210814m8.gif,Instance,Operation,Item,Hiding,2,"문제에서 설명하는 용어는 클래스의 동작, 즉 클래스에 속한 객체가 수행할 수 있는 행위를 의미합니다.  쉽게 말해, 클래스가 무엇을 할 수 있는지를 나타내는 것이죠. 예를 들어 ""자동차""라는 클래스가 있다면, ""달리다"", ""멈추다"", ""경적을 울리다"" 등이 그 클래스의 동작(Operation)이 될 것입니다.  문제에서 ""클래스에 속하는 객체에 대하여 적용될 메서드를 정의한 것이다""라고 설명하고 있는데, 이는 객체지향 프로그래밍에서 클래스의 동작을 구현하는 방법인 메서드를 정의하는 것을 의미합니다. UML(Unified Modeling Language) 다이어그램에서 이러한 동작은 인터페이스를 통해 표현됩니다.  따라서 클래스의 동작을 나타내는 용어는 ""Operation""이 가장 적절합니다.  ""Instance""는 객체를, ""Item""은 항목을, ""Hiding""은 정보 은닉을 의미하므로 문제의 설명과는 맞지 않습니다.",69,7
509,1,6,9,분산 시스템을 위한 마스터-슬레이브(Master-Slave) 아키텍처에 대한 설명으로 틀린 것은?,,일반적으로 실시간 시스템에서 사용된다.,"마스터 프로세스는 일반적으로 연산, 통신, 조정을 책임진다.",슬레이브 프로세스는 데이터 수집 기능을 수행할 수 없다.,마스터 프로세스는 슬레이브 프로세스들을 제어할 수 있다.,3,"마스터-슬레이브 아키텍처는 하나의 마스터 프로세스가 여러 개의 슬레이브 프로세스를 관리하는 분산 시스템 구조입니다. 마스터는 전체 시스템의 제어와 조정을 담당하고, 슬레이브는 마스터의 지시에 따라 작업을 수행합니다.  문제에서 틀린 설명은 슬레이브 프로세스가 데이터 수집 기능을 수행할 수 없다는 것입니다. 슬레이브는 마스터의 명령에 따라 다양한 작업을 수행할 수 있으며, 데이터 수집 또한 그중 하나입니다. 예를 들어, 여러 개의 센서에서 데이터를 수집하는 시스템에서 각 센서와 연결된 슬레이브 프로세스가 데이터를 수집하고 마스터에게 전달하는 역할을 할 수 있습니다. 따라서 슬레이브 프로세스는 데이터 수집 기능을 수행할 수 있습니다. 다른 선택지들은 마스터-슬레이브 아키텍처의 일반적인 특징을 잘 나타내고 있습니다. 마스터는 시스템의 연산, 통신, 조정을 담당하고, 슬레이브들을 제어하며, 실시간 시스템에서 효율적인 처리를 위해 자주 사용됩니다.",80,9
510,1,6,10,요구 사항 정의 및 분석·설계의 결과물을 표현하기 위한 모델링 과정에서 사용되는 다이어그램(Diagram)이 아닌 것은?,,Data Flow Diagram,UML Diagram,E-R Diagram,AVL Diagram,4,"이 문제는 요구사항 정의 및 분석·설계 단계에서 사용되는 다이어그램을 묻고 있습니다.  소프트웨어 개발 과정에서 요구사항을 시각적으로 표현하고 이해하기 쉽도록 다양한 다이어그램을 사용하는데,  데이터 흐름도(Data Flow Diagram), UML 다이어그램, 그리고 E-R 다이어그램은 모두 요구사항 분석 및 설계에 널리 활용되는 대표적인 모델링 기법입니다.  데이터 흐름도는 시스템 내 데이터의 흐름을, UML 다이어그램은 시스템의 구조와 동작을, E-R 다이어그램은 데이터베이스의 개체와 관계를 시각적으로 표현하는 데 사용됩니다.  반면 AVL 다이어그램은 이진 탐색 트리의 한 종류인 AVL 트리를 나타내는 다이어그램으로,  소프트웨어 개발의 요구사항 정의 및 분석·설계 단계에서는 사용되지 않습니다. AVL 트리는 주로 데이터 구조 및 알고리즘 분야에서 효율적인 탐색, 삽입, 삭제 연산을 위해 사용되는 자료구조를 표현하는 데 사용됩니다. 따라서 요구사항 정의 및 분석·설계의 결과물을 표현하기 위한 모델링 과정에서는 AVL 다이어그램이 사용되지 않습니다.",73,3
511,1,6,11,객체지향의 주요 개념에 대한 설명으로 틀린 것은?,,캡슐화는 상위클래스에서 속성이나 연산을 전달받아 새로운 형태의 클래스로 확장하여 사용하는 것을 의미한다.,객체는 실세계에 존재하거나 생각할 수 있는 것을 말한다.,클래스는 하나 이상의 유사한 객체들을 묶어 공통된 특성을 표현한 것이다.,다형성은 상속받은 여러 개의 하위 객체들이 다른 형태의 특성을 갖는 객체로 이용될 수 있는 성질이다.,1,"객체지향 프로그래밍의 핵심 개념들을 묻는 문제입니다.  잘못된 설명을 찾는 것이 문제의 목표죠.  먼저, 객체는 실제 세상에 존재하거나 상상할 수 있는 모든 것을 의미합니다.  예를 들어, 자동차, 사람, 강아지 등이 객체가 될 수 있죠.  그리고 클래스는 이러한 객체들의 공통적인 특징을 추상화하여 표현한 것입니다.  자동차라는 클래스는 여러 종류의 자동차(객체)들의 공통적인 특징인 바퀴, 엔진, 색깔 등을 가지고 있죠. 다형성은 같은 종류의 객체라도 상황에 따라 다른 행동을 보이는 것을 의미합니다.  예를 들어, ""동물""이라는 클래스를 상속받은 ""강아지""와 ""고양이"" 객체는 모두 ""소리내기""라는 메서드를 가지지만, 강아지는 ""멍멍"", 고양이는 ""야옹""이라는 다른 소리를 내죠. 이것이 다형성입니다.  하지만, 캡슐화는 상위 클래스의 속성이나 연산을 단순히 물려받는 것 이상의 의미를 지닙니다.  캡슐화는 데이터와 그 데이터를 처리하는 함수를 하나로 묶어 외부로부터의 직접적인 접근을 제한하고, 데이터의 무결성을 보장하는 것을 의미합니다.  따라서, 상위 클래스의 기능을 확장하는 것은 상속의 개념에 더 가깝습니다.  문제에서 틀린 설명은 바로 이 캡슐화에 대한 설명입니다.  캡슐화는 상속과는 다른 개념이며, 상위 클래스의 기능을 단순히 확장하는 것이 아닌, 데이터 보호와 안정성을 중시하는 개념입니다.",79,7
512,1,6,12,사용자 인터페이스(User Interface)에 대한 설명으로 틀린 것은?,,사용자와 시스템이 정보를 주고받는 상호작용이 잘 이루어지도록 하는 장치나 소프트웨어를 의미한다.,편리한 유지보수를 위해 개발자 중심으로 설계되어야 한다.,배우기가 용이하고 쉽게 사용할 수 있도록 만들어져야 한다.,사용자 요구사항이 UI에 반영될 수 있도록 구성해야 한다.,2,"사용자 인터페이스(UI)는 사용자가 컴퓨터나 시스템과 상호작용하는 방식을 결정하는 중요한 요소입니다.  좋은 UI는 사용자가 원하는 정보를 쉽고 효율적으로 얻을 수 있도록 돕고, 시스템을 편리하게 사용할 수 있도록 만들어져야 합니다.  따라서 사용자의 요구사항을 반영하고, 배우기 쉽고 사용하기 편리해야 하는 것은 당연합니다.  하지만 UI는 사용자의 편의성을 최우선으로 고려해야 하며, 개발자의 편의성을 위해 설계되어서는 안 됩니다.  유지보수의 편리성은 중요하지만, 그것은 사용자 경험을 희생해서까지 우선시되어서는 안 되는 요소입니다.  결국, 사용자 중심의 디자인이 UI 설계의 핵심이며, 개발 편의성은 부차적인 고려사항이어야 합니다.  따라서 개발자 중심으로 설계되어야 한다는 주장은 잘못된 것입니다.",92,4
513,1,6,13,GoF(Gang of Four) 디자인 패턴과 관련한 설명으로 틀린 것은?,,"디자인 패턴을 목적(Purpose)으로 분류할 때 생성, 구조, 행위로 분류할 수 있다.",Strategy 패턴은 대표적인 구조 패턴으로 인스턴스를 복제하여 사용하는 구조를 말한다.,행위 패턴은 클래스나 객체들이 상호작용하는 방법과 책임을 분산하는 방법을 정의한다.,"Singleton 패턴은 특정 클래스의 인스턴스가 오직 하나임을 보장하고, 이 인스턴스에 대한 접근 방법을 제공한다.",2,"GoF 디자인 패턴은 소프트웨어 설계에서 자주 발생하는 문제에 대한 재사용 가능한 해결책을 제공하는 일종의 템플릿입니다.  문제에서 틀린 설명은 디자인 패턴의 종류와 각 패턴의 특징에 대한 이해 부족에서 비롯됩니다.  디자인 패턴은 크게 생성 패턴, 구조 패턴, 행위 패턴으로 분류되는데,  틀린 선지는 Strategy 패턴을 구조 패턴으로 잘못 분류하고,  그 기능을 인스턴스 복제로 오해하고 있습니다. Strategy 패턴은 알고리즘을 캡슐화하여 상호 교환 가능하게 만드는 행위 패턴입니다.  인스턴스를 복제하는 것은 Strategy 패턴의 주요 기능이 아니며,  이는 다른 패턴(예: Prototype 패턴)에서 다루는 내용입니다.  나머지 설명들은 GoF 디자인 패턴에 대한 정확한 설명입니다.  따라서, Strategy 패턴에 대한 잘못된 분류와 설명이 틀린 부분입니다.  쉽게 말해, 레고 블록을 조립하는 방법을 설명하는 책에서, 특정 블록의 기능을 잘못 설명한 것과 같습니다.  정확한 블록의 기능을 알아야 제대로 조립할 수 있듯이, 디자인 패턴의 정확한 이해가 소프트웨어 설계의 성공에 중요합니다.",67,7
514,1,6,14,애자일 개발 방법론과 관련한 설명으로 틀린 것은?,,빠른 릴리즈를 통해 문제점을 빠르게 파악할 수 있다.,정확한 결과 도출을 위해 계획 수립과 문서화에 중점을 둔다.,고객과의 의사소통을 중요하게 생각한다.,진화하는 요구사항을 수용하는데 적합하다.,2,"애자일 개발 방법론은 소프트웨어 개발의 변화하는 요구사항에 유연하게 대처하고, 빠르게 작동하는 최소 기능 제품(MVP: Minimum Viable Product)을 반복적으로 개발하여 고객 피드백을 통해 개선해 나가는 방식입니다.  문제에서 틀린 설명은 계획 수립과 문서화에 중점을 둔다는 것입니다. 애자일은  철저한 계획과 두꺼운 문서보다는 고객과의 지속적인 소통과 협업, 그리고 빠른 반복 개발을 통해 유연성을 확보하는 데 초점을 맞춥니다.  문서화는 최소한으로 하고, 실제 작동하는 소프트웨어를 빠르게 만들어 고객에게 보여주고 피드백을 받는 것이 핵심입니다.  나머지 선택지는 모두 애자일 개발 방법론의 특징을 잘 나타내고 있습니다. 빠른 릴리즈를 통해 문제점을 신속하게 파악하고, 고객과의 소통을 중시하며, 변화하는 요구사항에 적응하는 것이 애자일의 주요 목표이기 때문입니다. 따라서 계획과 문서화에 지나치게 집중하는 것은 애자일의 원칙에 어긋납니다.",88,2
515,1,6,15,럼바우(Rumbaugh)의 객체지향 분석 기법 중 자료 흐름도(DFD)를 주로 이용하는 것은?,,기능 모델링,동적 모델링,객체 모델링,정적 모델링,1,"럼바우의 객체지향 분석 기법은 시스템을 객체들의 상호작용으로 모델링하는 방법입니다.  여기서 자료 흐름도(DFD)는 시스템 내에서 데이터가 어떻게 흘러가는지를 시각적으로 보여주는 도구입니다.  데이터의 흐름을 중심으로 시스템의 기능을 분석하는 것이죠.  객체 모델링은 객체들의 속성과 관계를 중심으로 시스템을 모델링하는 것이고, 정적 모델링은 시스템의 구조와 구성요소를 시간에 따른 변화 없이 나타내는 것이며, 동적 모델링은 시간에 따른 시스템의 변화를 나타내는 것입니다.  럼바우 기법에서 DFD는 시스템의 기능을 분석하는 데 주로 사용되므로, 시스템의 기능을 모델링하는 '기능 모델링'에 해당합니다.  쉽게 말해, DFD를 이용하여 어떤 기능이 어떤 데이터를 입력받아 어떤 데이터를 출력하는지 파악하는 것이 기능 모델링의 핵심입니다.  따라서 DFD를 주로 사용하는 럼바우의 객체지향 분석 기법은 시스템의 기능을 모델링하는 것입니다.",51,2
516,1,6,16,순차 다이어그램(Sequence Diagram)과 관련한 설명으로 틀린 것은?,,객체들의 상호 작용을 나타내기 위해 사용한다.,시간의 흐름에 따라 객체들이 주고 받는 메시지의 전달 과정을 강조한다.,동적 다이어그램보다는 정적 다이어그램에 가깝다.,교류 다이어그램(Interaction Diagram)의 한 종류로 볼 수 있다.,3,"순차 다이어그램은 시스템 내 객체들의 상호 작용을 시간 순서대로 보여주는 그림입니다. 마치 연극의 대본처럼, 각 객체가 언제 어떤 메시지를 주고받는지 명확하게 나타내죠.  따라서 객체 간의 상호 작용을 표현하고, 시간의 흐름에 따른 메시지 전달 과정을 강조하는 것은 순차 다이어그램의 핵심적인 특징입니다.  하지만 순차 다이어그램은 시스템의 동적인 측면을 보여주는 다이어그램이지, 정적인 측면(예: 클래스 간의 관계)을 보여주는 정적 다이어그램과는 다릅니다.  정적 다이어그램의 대표적인 예로 클래스 다이어그램이 있죠.  순차 다이어그램은 객체들의 상호 작용을 보여주는 다이어그램의 한 종류이며, 이러한 상호 작용을 나타내는 다이어그램을 통틀어 교류 다이어그램이라고 부릅니다. 따라서 틀린 설명은 시스템의 동적인 측면을 보여주는 순차 다이어그램을 정적 다이어그램에 가깝다고 설명한 부분입니다.",77,2
517,1,6,17,객체지향 분석 기법과 관련한 설명으로 틀린것은?,,동적 모델링 기법이 사용될 수 있다.,기능 중심으로 시스템을 파악하며 순차적인처리가 중요시되는 하향식(Top-down)방식으로 볼 수 있다.,데이터와 행위를 하나로 묶어 객체를 정의내리고 추상화시키는 작업이라 할 수 있다.,코드 재사용에 의한 프로그램 생산성 향상 및 요구에 따른 시스템의 쉬운 변경이 가능하다.,2,"객체지향 분석 기법은 시스템을 구성하는 요소들을 '객체'라는 개념으로 묶어서 분석하는 방법입니다.  각 객체는 데이터(속성)와 그 데이터를 처리하는 행위(메소드)를 함께 가지고 있습니다.  마치 레고 블록처럼, 각 객체는 독립적으로 동작하면서 다른 객체와 상호작용하여 전체 시스템을 구현합니다.  따라서 객체를 정의하고, 객체 간의 관계를 정의하는 것이 핵심입니다.  그리고 이러한 객체지향 분석은 시스템의 변경이나 확장이 용이하도록 설계되어 코드 재사용성을 높이고 유지보수를 편리하게 합니다.  문제에서 틀린 설명은 시스템을 기능 중심으로 파악하고 순차적인 처리를 중요시하는 하향식(Top-down) 방식으로 본다는 것입니다. 객체지향 분석은 시스템을 구성하는 객체들을 중심으로 파악하고, 객체 간의 상호작용을 통해 시스템의 동작을 모델링합니다.  이는 기능 중심의 순차적인 처리보다는 객체 간의 상호작용과 데이터 흐름에 초점을 맞춘 분석 방식입니다.  즉, 객체지향 분석은 상향식(Bottom-up) 방식과 더욱 잘 어울립니다.  동적 모델링 기법을 사용할 수 있다는 것은 객체의 상호작용과 시스템의 동작을 시간에 따라 모델링하는 것을 의미하며, 객체지향 분석의 특징 중 하나입니다.  데이터와 행위를 하나로 묶어 객체를 정의하고 추상화하는 것은 객체지향 분석의 기본 개념입니다.  코드 재사용성 향상 및 시스템 변경의 용이성 또한 객체지향 분석의 주요 장점입니다.",71,7
518,1,6,18,"대표적으로 DOS 및 Unix 등의 운영체제에서조작을 위해 사용하던 것으로, 정해진 명령문자열을 입력하여 시스템을 조작하는 사용자인터페이스(User Interface)는?",,GUI(Graphical User Interface),CLI(Command Line Interface),CUI(Cell User Interface),MUI(Mobile User Interface),2,"이 문제는 운영체제를 조작하는 방식에 대한 사용자 인터페이스(UI)를 묻고 있습니다.  선택지 중 하나는 마우스나 아이콘을 이용하는 그래픽 기반의 사용자 인터페이스(GUI)이고, 다른 하나는 텍스트 기반의 명령어를 입력하여 시스템을 제어하는 방식입니다.  DOS나 Unix와 같은 초기 운영체제는 마우스가 없던 시절이었기 때문에, 사용자는 키보드를 통해 명령어를 직접 입력하여 시스템을 제어해야 했습니다.  이러한 텍스트 기반의 명령어 인터페이스가 바로 CLI(Command Line Interface)입니다.  GUI는 직관적인 그래픽을 사용하지만, CLI는 명령어를 정확하게 입력해야 하므로 전문적인 지식이 필요할 수 있습니다.  하지만 CLI는 GUI보다 효율적이고 빠르게 시스템을 제어할 수 있다는 장점이 있습니다. 문제에서 언급된 DOS와 Unix는 대표적인 CLI 기반 운영체제이므로, 정답은 CLI를 사용하는 인터페이스입니다.  따라서 정답은 CLI(Command Line Interface)입니다.",84,44
519,1,6,19,분산 시스템에서의 미들웨어 (Middleware)와 관련한 설명으로 틀린 것은?,,분산 시스템에서 다양한 부분을 관리하고 통신하며 데이터를 교환하게 해주는소프트웨어로 볼 수 있다.,위치 투명성(Location Transparency)을 제공한다.,분산 시스템의 여러 컴포넌트가 요구하는 재사용가능한 서비스의 구현을 제공한다.,애플리케이션과 사용자 사이에서만 분산서비스를 제공한다.,4,"분산 시스템이란 여러 대의 컴퓨터가 네트워크로 연결되어 하나의 시스템처럼 동작하는 것을 말합니다.  미들웨어는 이러한 분산 시스템에서 서로 다른 컴퓨터들 간의 통신과 데이터 교환을 원활하게 해주는 소프트웨어 중간계층입니다. 마치 여러 개의 레고 블록을 연결하여 큰 작품을 만드는 데 필요한 연결 고리와 같다고 생각하면 이해하기 쉽습니다.  따라서 분산 시스템의 다양한 부분을 관리하고 통신하며 데이터를 교환하게 해주는 역할을 한다는 설명은 맞습니다. 또한, 미들웨어는 어떤 컴퓨터에 어떤 프로그램이 있는지 사용자가 신경 쓰지 않아도 되도록 위치 투명성을 제공합니다.  마치 인터넷에서 웹사이트 주소를 입력하면 어떤 서버에 있는지 알 필요 없이 바로 접근하는 것과 같습니다.  그리고 여러 컴포넌트가 공통적으로 필요로 하는 기능을 재사용 가능한 서비스로 제공하여 개발 효율성을 높입니다. 하지만 미들웨어는 애플리케이션과 사용자 사이에서 *만* 서비스를 제공하는 것은 아닙니다.  애플리케이션과 애플리케이션 사이, 혹은 다른 시스템과의 연동에도 미들웨어가 사용됩니다.  즉, 미들웨어는 분산 시스템의 다양한 구성 요소들 사이에서 중개자 역할을 수행하며,  애플리케이션과 사용자 간의 상호작용에만 국한되지 않는다는 점이 틀린 설명입니다.",86,10
520,1,6,20,소프트웨어 아키텍처와 관련한 설명으로 틀린것은?,,"파이프 필터 아키텍처에서 데이터는 파이프를 통해 양방향으로 흐르며, 필터 이동 시 오버헤드가 발생하지 않는다.",외부에서 인식할 수 있는 특성이 담긴 소프트웨어의 골격이 되는 기본 구조로 볼수 있다.,데이터 중심 아키텍처는 공유 데이터저장소를 통해 접근자 간의 통신이 이루어지므로 각 접근자의 수정과 확장이 용이하다.,이해 관계자들의 품질 요구사항을 반영하여 품질 속성을 결정한다.,1,"소프트웨어 아키텍처는 건물의 설계도와 같다고 생각하면 이해하기 쉽습니다.  건물을 짓기 전에 어떤 구조로 지을지, 어떤 재료를 사용할지, 각 부분은 어떻게 연결될지 등을 미리 설계하는 것처럼, 소프트웨어 아키텍처는 소프트웨어를 개발하기 전에 전체적인 구조와 구성 요소, 그리고 그들 간의 상호 작용을 설계하는 것입니다.  문제에서 틀린 설명은 파이프-필터 아키텍처에 대한 설명입니다. 파이프-필터 아키텍처는 데이터가 한 방향으로만 흐르는 구조입니다.  데이터가 파이프를 통해 필터를 거치면서 처리되는데, 필터는 데이터를 변환하거나 필터링하는 역할을 합니다.  데이터가 양방향으로 흐르는 것은 파이프-필터 아키텍처의 특징이 아니며, 필터의 이동은 일반적으로 오버헤드를 발생시킵니다.  나머지 설명들은 소프트웨어 아키텍처의 일반적인 특징을 잘 나타내고 있습니다.  소프트웨어의 기본 구조를 정의하고, 데이터 중심 아키텍처의 장점을 설명하며, 이해관계자의 요구사항을 반영하는 과정을 제시하고 있기 때문입니다. 따라서 파이프-필터 아키텍처에 대한 잘못된 설명이 틀린 선택지가 됩니다.",79,6
521,1,6,21,"테스트를 목적에 따라 분류했을 때,강도(Stress) 테스트에 대한 설명으로 옳은것은?",,시스템에 고의로 실패를 유도하고 시스템이정상적으로 복귀하는지 테스트한다.,시스템에 과다 정보량을 부과하여 과부하 시에도 시스템이 정상적으로 작동되는지를 테스트한다.,"사용자의 이벤트에 시스템이 응답하는 시간,특정 시간 내에 처리하는 업무량, 사용자 요구에 시스템이 반응하는 속도 등을 테스트한다.",부당하고 불법적인 침입을 시도하여 보안시스템이 불법적인 침투를 잘 막아내는지 테스트한다.,2,"시스템 테스트는 시스템의 기능과 성능을 검증하기 위해 다양한 방법으로 수행됩니다.  문제에서 묻고 있는 강도(Stress) 테스트는 시스템의 한계점을 찾기 위한 테스트입니다.  마치 댐의 견고성을 확인하기 위해 물을 엄청나게 흘려보내는 것과 같습니다.  시스템에 과도한 정보량을 주입하여 과부하 상태를 만들고, 그럼에도 불구하고 시스템이 정상적으로 작동하는지, 아니면 어떤 지점에서 오류가 발생하는지 확인하는 것이 바로 강도 테스트의 목적입니다.  다른 선택지들은 시스템의 다른 측면(복구 능력, 응답 속도, 보안성)을 테스트하는 방법을 설명하고 있으므로 강도 테스트와는 다릅니다. 따라서 시스템에 과다한 정보량을 부과하여 과부하 상황에서의 시스템 작동 여부를 확인하는 것이 강도 테스트의 핵심입니다. 정보처리기사 공식 교재에서도 강도 테스트는 시스템의 내구성과 안정성을 평가하기 위한 과부하 테스트로 설명하고 있습니다.",79,19
522,1,6,22,다음 자료를 버블 정렬을 이용하여오름차순으로 정렬할 경우 PASS 3의 결과는?,https://www.cbtbank.kr/images/iz/iz20210814/iz20210814m22.gif,"6, 3, 5, 7, 9","3, 5, 6, 7, 9","6, 7, 3, 5, 9","3, 5, 9, 6, 7",2,"버블 정렬은 인접한 두 원소를 비교하여 크기 순서대로 자리를 바꾸는 정렬 알고리즘입니다.  주어진 자료 9, 6, 7, 3, 5를 오름차순으로 정렬하는 과정을 살펴보겠습니다.",68,11
523,1,6,23,다음 그래프에서 정점 A를 선택하여 깊이우선탐색(DFS)으로 운행한 결과는?,https://www.cbtbank.kr/images/iz/iz20210814/iz20210814m23.gif,ABECDFG,ABECFDG,ABCDEFG,ABEFGCD,4,"이 문제는 그래프 탐색 알고리즘 중 하나인 깊이 우선 탐색(Depth-First Search, DFS)을 이해하고 있는지를 묻는 문제입니다. DFS는 하나의 경로를 최대한 깊이 탐색한 후, 더 이상 진행할 수 없을 때 되돌아가 다른 경로를 탐색하는 방식입니다.  문제에서 주어진 그래프와 정점 A를 시작점으로 DFS를 수행하는 과정을 살펴보겠습니다.",78,11
524,1,6,24,다음 설명에 부합하는 용어로 옳은 것은?,https://www.cbtbank.kr/images/iz/iz20210814/iz20210814m24.gif,통합 프로그램,저장소,모듈,데이터,3,"문제에서 설명하는 용어는 소프트웨어를 구성하는 기본 단위를 의미합니다.  소프트웨어는 매우 복잡한 시스템이기 때문에,  작은 기능 단위들로 나누어 개발하고 관리하는 것이 효율적입니다.  마치 레고 블록처럼, 각각의 블록(기능 단위)은 독립적으로 만들어지고, 여러 블록을 조합하여 완성된 프로그램을 만들 수 있습니다.  문제에서 설명하는 ""독립적인 기능을 갖는 단위"", ""하나 또는 몇 개의 논리적인 기능을 수행하는 명령어들의 집합"", ""서로 모여 하나의 완전한 프로그램으로 만들어질 수 있다""는 특징들은 모두 소프트웨어 개발에서 '모듈'이라는 개념을 정확하게 설명하고 있습니다.  '모듈'은 특정 기능을 수행하는 코드의 집합체로, 다른 모듈과 독립적으로 개발 및 테스트될 수 있으며, 재사용성이 높다는 장점이 있습니다.  따라서 문제의 설명에 가장 적합한 용어는 '모듈'입니다.  다른 선지는 소프트웨어의 전체적인 구조나 데이터, 또는 통합된 프로그램을 의미하는 것이므로 문제의 설명과 정확히 일치하지 않습니다.",86,6
525,1,6,25,테스트 드라이버(Test Driver)에 대한 설명으로 틀린 것은?,,시험대상 모듈을 호출하는 간이 소프트웨어이다.,필요에 따라 매개 변수를 전달하고 모듈을 수행한 후의 결과를 보여줄 수 있다.,상향식 통합 테스트에서 사용된다.,테스트 대상 모듈이 호출하는 하위 모듈의 역할을 한다.,4,"테스트 드라이버는 시험 대상 모듈의 기능을 검증하기 위해 사용하는 간단한 프로그램입니다.  마치 자동차를 시험하는 드라이버처럼,  테스트 드라이버는 시험 대상 모듈에 입력값을 주고, 그 결과를 확인하여 제대로 작동하는지 판단하는 역할을 합니다.  따라서 시험 대상 모듈을 호출하고, 필요한 매개변수를 전달하며, 수행 결과를 확인하는 기능을 가지고 있습니다.  상향식 통합 테스트에서는 아래 단계부터 차례대로 통합하며 테스트하는 방식인데, 이때 테스트 드라이버는 상위 모듈이 하위 모듈을 호출하여 테스트하는 것을 돕습니다.  하지만 테스트 드라이버는 시험 대상 모듈이 *호출하는* 하위 모듈의 역할을 하는 것이 아니라, *시험 대상 모듈을 호출하는* 역할을 합니다.  즉, 테스트 드라이버는 상위 모듈의 역할을 수행하며, 하위 모듈을 시험하는 도구인 것입니다.  틀린 선지는 바로 이 부분을 지적하고 있습니다.",61,20
526,1,6,26,다음 중 선형 구조로만 묶인 것은?,,"스택, 트리","큐, 데크","큐, 그래프","리스트, 그래프",2,"이 문제는 자료구조의 기본적인 개념을 묻고 있습니다.  선형 구조란 데이터가 순차적으로 연결되어 있는 구조를 말합니다.  쉽게 생각하면, 기차 레일처럼 데이터가 일렬로 쭉 이어져 있는 모양이라고 생각하면 됩니다.  반면에 비선형 구조는 데이터가 여러 갈래로 연결되어 있는 구조로, 나무의 가지처럼 여러 방향으로 뻗어나가는 형태입니다.",80,11
527,1,6,27,"다음은 스택의 자료 삭제 알고리즘이다. ⓐ에 들어 갈 내용으로 옳은 것은? (단, Top: 스택포인터, S: 스택의 이름)",https://www.cbtbank.kr/images/iz/iz20210814/iz20210814m27.gif,Overflow,Top = Top + 1,Underflow,Top = Top,3,"이 문제는 스택 자료구조에서 데이터를 삭제하는 과정을 나타내는 코드의 빈칸을 채우는 문제입니다.  스택은 '후입선출(LIFO, Last-In-First-Out)' 방식으로 데이터를 관리하는 자료구조입니다.  마치 접시를 쌓아 올리는 것처럼, 가장 나중에 쌓은 접시를 가장 먼저 꺼낼 수 있습니다.  코드에서 `Top`은 스택의 맨 위를 가리키는 포인터 역할을 합니다.  `Top`이 0이라는 것은 스택이 비어있다는 것을 의미합니다.  비어있는 스택에서 데이터를 삭제하려고 하면 'Underflow' 상태가 발생합니다.  반대로 스택이 가득 차서 더 이상 데이터를 추가할 수 없는 상태를 'Overflow'라고 합니다.  문제의 코드는 `Top`이 0이 아닌 경우에만 스택에서 데이터를 삭제하는 로직을 가지고 있습니다. 따라서 `Top`이 0일 때는 스택이 비어있으므로,  데이터를 삭제할 수 없다는 것을 나타내는 'Underflow'를 처리해야 합니다.  그러므로 빈칸에는 스택이 비어있음을 나타내는 'Underflow' 상황을 처리하는 코드가 들어가야 합니다.",69,11
528,1,6,28,제품 소프트웨어의 사용자 매뉴얼 작성절차로 (가)~(다)와 [보기]의 기호를 바르게 연결한 것은?,https://www.cbtbank.kr/images/iz/iz20210814/iz20210814m28.gif,"(가)-㉠, (나)-㉡, (다)-㉢","(가)-㉢, (나)-㉡, (다)-㉠","(가)-㉠, (나)-㉢, (다)-㉡","(가)-㉢, (나)-㉠, (다)-㉡",2,"제품 소프트웨어의 사용자 매뉴얼 작성 절차는 크게 세 단계로 나눌 수 있습니다.  먼저, 매뉴얼에 포함될 내용을 정의하는 단계가 필요합니다.  이 단계에서는 매뉴얼의 전체적인 구조와 각 구성 요소(예: 목차, 용어집, 각 기능 설명 등)에 대한 세부적인 계획을 수립합니다.  이후에는 각 구성 요소별로 실제 내용을 작성하는 단계가 이어집니다.  이는 앞서 정의된 구성 요소에 맞춰 실제 소프트웨어의 기능을 설명하고, 사용 방법을 자세히 기술하는 과정입니다.  마지막으로 작성된 매뉴얼에 대한 검토 및 수정 단계를 거쳐 완성도를 높입니다.  이 단계에서는 오류 수정, 내용 보완, 가독성 향상 등을 목표로 합니다.  문제에서 제시된 흐름도를 보면,  (가)는 매뉴얼의 구성 요소를 정의하는 단계, (나)는 구성 요소별 내용을 작성하는 단계, (다)는 사용 설명서(매뉴얼)를 검토하는 단계에 해당합니다. 따라서,  (가)에는 구성 요소 정의, (나)에는 구성 요소별 내용 작성, (다)에는 사용 설명서 검토가 순서대로 연결되어야 매뉴얼 작성 절차가 논리적으로 완성됩니다.",82,17
529,1,6,29,"순서가 A, B, C, D로 정해진 입력 자료를 스택에 입력한 후 출력한 결과로 불가능한 것은?",,"D, C, B, A","B, C, D, A","C, B, A, D","D, B, C, A",4,"이 문제는 스택 자료구조의 특징을 이해하고 있는지 묻는 문제입니다. 스택은 '후입선출(LIFO, Last-In-First-Out)' 방식으로 데이터를 관리하는 자료구조입니다.  마지막에 들어온 데이터가 먼저 나가는 것을 생각하면 됩니다.  입력 자료 A, B, C, D가 순서대로 스택에 쌓이면, 스택의 맨 아래에는 A가, 맨 위에는 D가 위치하게 됩니다.  스택에서 데이터를 출력할 때는 항상 맨 위의 데이터부터 출력됩니다. 따라서, 먼저 D가 출력되고, 그 다음 C, B, A 순으로 출력되는 것이 스택의 동작 방식에 맞습니다.  문제에서 제시된 답변들 중 하나는 이러한 스택의 후입선출 특성을 따르지 않고, 따라서 스택을 이용하여 출력할 수 없는 결과입니다.  즉,  입력 순서를 거꾸로 뒤집은 것처럼 보이는 결과는 스택으로는 만들어낼 수 없습니다.  다른 답변들은 모두 스택의 후입선출 특성을 고려하여 가능한 출력 결과입니다.",74,11
530,1,6,30,소프트웨어 테스트에서 검증(Verification)과 확인 (Validation)에 대한 설명으로 틀린 것은?,,소프트웨어 테스트에서 검증과 확인을 구별하면 찾고자 하는 결함 유형을 명확하게 하는 데 도움이 된다.,"검증은 소프트웨어 개발 과정을 테스트하는 것이고, 확인은 소프트웨어 결과를 테스트 하는 것이다.","검증은 작업 제품이 요구 명세의 기능, 비기능 요구사항을 얼마나 잘 준수하는지 측정하는 작업이다.","검증은 작업 제품이 사용자의 요구에 적합한지 측정하며, 확인은 작업 제품이 개발자의 기대를 충족시키는지를 측정한다.",4,"소프트웨어 테스트에서 검증(Verification)과 확인(Validation)은 서로 다른 개념입니다.  쉽게 말해, 검증은 ""제대로 만들었는가?""를 확인하는 것이고, 확인은 ""맞는 것을 만들었는가?""를 확인하는 것입니다.  문제에서 틀린 설명은 개발자의 기대와 사용자의 요구를 검증과 확인에 각각 연결시킨 부분입니다.  검증은 개발 과정에서 정해진 요구사항(명세서)에 따라 소프트웨어가 제대로 만들어졌는지 확인하는 것이지, 개발자의 주관적인 기대를 충족하는지 확인하는 것이 아닙니다.  반대로 확인은 개발된 소프트웨어가 최종 사용자의 요구사항을 충족하는지, 즉 실제로 필요한 기능을 제대로 수행하는지를 검증하는 것입니다.  따라서, 개발자의 기대와 사용자의 요구를 검증과 확인에 연결시킨 설명은 잘못된 것입니다.  검증은 명세서 기반, 확인은 사용자 요구 기반으로 진행된다는 점을 명확히 이해하는 것이 중요합니다.  정리하자면, 검증은 설계대로 만들어졌는지, 확인은 사용자의 요구를 충족하는지 확인하는 과정입니다.  문제의 틀린 선지는 이러한 검증과 확인의 기본적인 개념을 잘못 이해하고 있는 것입니다.",66,19
531,1,6,31,"개별 모듈을 시험하는 것으로 모듈이 정확하게 구현되었는지, 예정한 기능이 제대로 수행되는지를 점검하는 것이 주요 목적인 테스트는?",,통합 테스트(Integration Test),단위 테스트(Unit Test),시스템 테스트(System Test),인수 테스트(Acceptance Test),2,"이 문제는 소프트웨어 개발 과정에서 가장 기본적인 테스트 단계를 묻고 있습니다.  소프트웨어는 여러 개의 작은 모듈(부품)로 구성되는데,  각 모듈이 제대로 작동하는지 확인하는 것이 매우 중요합니다. 마치 자동차를 만드는 과정에서 각 부품(엔진, 브레이크, 타이어 등)을 하나씩 점검하는 것과 같습니다.  이처럼 개별 모듈의 기능이 정상적으로 작동하는지 확인하는 테스트를 '단위 테스트'라고 합니다.  다른 테스트들은 여러 모듈을 통합하거나, 전체 시스템을 대상으로 하거나, 사용자의 요구사항을 충족하는지 확인하는 테스트이기 때문에 개별 모듈의 정확성을 검증하는 단위 테스트와는 목적이 다릅니다. 따라서 개별 모듈을 시험하여 정확성과 기능 수행 여부를 점검하는 주요 목적을 가진 테스트는 단위 테스트가 됩니다. 정보처리기사 공식 교재에서도 단위 테스트는 개별 모듈의 기능을 검증하는 가장 기본적인 테스트 단계로 설명하고 있습니다.",76,14
532,1,6,32,형상 관리의 개념과 절차에 대한 설명으로 틀린 것은?,,형상 식별은 형상 관리 계획을 근거로 형상관리의 대상이 무엇인지 식별하는 과정이다.,형상 관리를 통해 가시성과 추적성을 보장함으로써 소프트웨어의 생산성과 품질을 높일 수 있다.,형상 통제 과정에서는 형상 목록의 변경 요구를 즉시 수용 및 반영해야 한다.,"형상 감사는 형상 관리 계획대로 형상관리가 진행되고 있는지, 형상 항목의 변경이 요구 사항에 맞도록 제대로 이뤄졌는지 등을 살펴보는 활동이다.",3,"형상관리는 소프트웨어 개발 과정에서 변경되는 모든 요소들을 체계적으로 관리하는 것을 말합니다.  문제에서 틀린 설명은 형상 통제 과정에 대한 내용입니다. 형상 목록의 변경 요구는 즉시 수용되고 반영되는 것이 아니라,  엄격한 절차를 거쳐 승인을 받은 후에만 반영됩니다.  이는 무분별한 변경으로 인한 오류나 혼란을 방지하고, 소프트웨어의 안정성과 일관성을 유지하기 위해서입니다.  즉시 변경을 수용하면 버전 관리가 어려워지고,  오류 발생 시 원인 파악과 수정이 어려워져 소프트웨어 품질에 악영향을 미칠 수 있습니다.  다른 선지는 모두 형상 관리의 개념과 절차를 정확하게 설명하고 있습니다. 형상 식별은 관리 대상을 정의하고, 형상 관리를 통해 가시성과 추적성을 확보하여 생산성과 품질 향상을 도모하며, 형상 감사는 관리 계획의 준수 여부와 변경의 적절성을 확인하는 과정입니다. 따라서 형상 통제 과정에서 변경 요구를 즉시 수용하는 것은 형상 관리의 기본 원칙에 어긋나는 잘못된 설명입니다.",81,15
533,1,6,33,소스코드 정적 분석(Static Analysis)에 대한 설명으로 틀린 것은?,,소스 코드를 실행시키지 않고 분석한다.,코드에 있는 오류나 잠재적인 오류를 찾아내기 위한 활동이다.,하드웨어적인 방법으로만 코드 분석이 가능하다.,자료 흐름이나 논리 흐름을 분석하여 비정상적인 패턴을 찾을 수 있다.,3,"소스코드 정적 분석은 프로그램을 실제로 실행하지 않고 코드 자체를 분석하는 기법입니다.  마치 건축 설계도를 보고 건물을 짓기 전에 문제점을 찾는 것과 같습니다.  코드를 실행하지 않고 분석하기 때문에 실행 중 발생하는 오류는 찾을 수 없지만, 문법 오류나 변수 선언 누락, 잠재적인 보안 취약점 등을 미리 발견할 수 있습니다.  따라서 코드에 있는 오류나 잠재적인 오류를 찾는 활동이라는 설명은 정확합니다.  그리고 자료 흐름이나 논리 흐름을 분석하여 비정상적인 패턴을 찾는 것도 정적 분석의 중요한 목표입니다.  하지만 정적 분석은 소스 코드를 분석하는 방법론이지, 하드웨어적인 방법만을 사용하는 것은 아닙니다.  다양한 소프트웨어 도구를 활용하여 분석을 수행합니다.  따라서 '하드웨어적인 방법으로만 코드 분석이 가능하다'는 설명은 틀린 것입니다.",76,21
534,1,6,34,"소프트웨어 개발 활동을 수행함에 있어서 시스템이 고장(Failure)을 일으키게 하며, 오류(Error)가 있는 경우 발생하는 것은?",,Fault,Testcase,Mistake,Inspection,1,"소프트웨어 개발 과정에서 시스템 고장(Failure)은 우리가 눈으로 확인할 수 있는 시스템의 작동 불능 상태를 의미합니다.  이 고장의 근본 원인을 찾아보면,  소스코드 내에 존재하는 잘못된 부분, 즉 '결함(Fault)'이 발견됩니다.  결함은 시스템이 예상치 못한 동작을 하게 만드는 코드의 오류(Error)를 포함하는 더 넓은 개념입니다.  오류는 개발자가 실수(Mistake)로 인해 코드에 발생시킨 잘못된 부분을 의미하고, 이 오류가 시스템에 결함으로 남아 고장을 유발하는 것입니다.  결국, 시스템 고장의 근본 원인이 되는 것은 코드 내에 존재하는 잘못된 부분, 즉 결함(Fault)입니다.  검사(Inspection)는 결함을 찾는 활동이지만, 고장의 직접적인 원인은 아닙니다. 테스트 케이스(Testcase)는 결함을 발견하기 위한 테스트를 설계하는 과정에서 사용되는 것이지 고장의 원인 자체는 아닙니다. 따라서 시스템 고장을 일으키고 오류가 있는 경우 발생하는 것은 바로 소스코드 내의 잘못된 부분, 즉 결함(Fault)입니다.",79,19
535,1,6,35,코드의 간결성을 유지하기 위해 사용되는 지침으로 틀린 것은?,,공백을 이용하여 실행문 그룹과 주석을 명확히 구분한다.,복잡한 논리식과 산술식은 괄호와 들여쓰기(Indentation)를 통해 명확히 표현한다.,빈 줄을 사용하여 선언부와 구현부를 구별한다.,한 줄에 최대한 많은 문장을 코딩한다.,4,"코드의 가독성과 유지보수성을 높이기 위해서는 코드를 명확하고 간결하게 작성하는 것이 중요합니다.  코드가 복잡하면 이해하기 어렵고, 오류를 찾거나 수정하기가 어려워집니다.  따라서 공백을 이용하여 코드 블록을 시각적으로 구분하고, 복잡한 식에는 괄호와 들여쓰기를 사용하여 논리적 구조를 명확히 하는 것은 좋은 코딩 습관입니다.  빈 줄을 사용하여 코드의 기능적 부분을 구분하는 것 또한 가독성을 높이는 데 도움이 됩니다.  하지만 한 줄에 최대한 많은 문장을 코딩하는 것은 가독성을 떨어뜨리고, 오류 발생 가능성을 높이며, 나중에 코드를 수정하거나 유지보수하기 어렵게 만듭니다.  결론적으로, 코드의 간결성을 유지하기 위해서는 코드의 가독성을 높이는 방향으로 작성해야 하며, 한 줄에 많은 문장을 작성하는 것은 이러한 목표와 반대되는 행위입니다.  따라서 정답은 한 줄에 최대한 많은 문장을 코딩하는 것이 잘못된 지침이라는 것입니다.",89,21
536,1,6,36,소프트웨어 품질 목표 중 하나 이상의 하드웨어 환경에서 운용되기 위해 쉽게 수정될 수 있는 시스템 능력을 의미하는 것은?,,Portability,Efficiency,Usability,Correctness,1,"이 문제는 소프트웨어의 품질 목표 중 하나를 묻고 있습니다.  소프트웨어 품질이란, 소프트웨어가 얼마나 잘 만들어졌는지를 나타내는 여러 가지 특성을 말하는데요,  여기서 중요한 것은 '하나 이상의 하드웨어 환경에서 운용되기 위해 쉽게 수정될 수 있는 시스템 능력'입니다.  쉽게 말해,  만약 여러분이 만든 소프트웨어가 윈도우즈 컴퓨터에서만 돌아가는 것이 아니라, 맥북이나 리눅스 컴퓨터에서도 거의 수정 없이 돌아갈 수 있다면,  그 소프트웨어는 이러한 능력을 갖춘 것입니다. 이러한 특성을 나타내는 용어가 바로 '이식성(Portability)'입니다.  '이식성'이 높은 소프트웨어는 다양한 하드웨어나 운영체제 환경에 적응하기 쉽고,  따라서 유지보수 비용을 절감하고,  더 넓은 시장에 소프트웨어를 제공할 수 있는 장점이 있습니다.  다른 선지들은 각각 효율성, 사용성, 정확성을 의미하는데,  문제에서 요구하는 '다양한 하드웨어 환경에서의 쉬운 수정'이라는 조건과는 직접적인 관련이 없습니다.",57,17
537,1,6,37,다음 중 최악의 경우 검색 효율이 가장 나쁜트리 구조는?,,이진 탐색트리,AVL 트리,2-3 트리,레드-블랙 트리,1,"이 문제는 트리 구조의 검색 효율을 비교하는 문제입니다.  트리 구조는 데이터를 계층적으로 저장하여 검색 속도를 높이는 데 사용됩니다.  하지만, 데이터가 트리에 추가되는 순서나 방식에 따라 트리가 한쪽으로 치우쳐져(skew)  균형이 깨질 수 있습니다.  이렇게 되면, 트리의 높이가 과도하게 커지고, 최악의 경우에는  선형 리스트처럼 검색해야 하는 상황이 발생할 수 있습니다.  즉,  데이터 개수에 비례하여 검색 시간이 늘어나 검색 효율이 매우 나빠집니다.",65,11
538,1,6,38,다음 트리에 대한 중위 순회 운행 결과는?,https://www.cbtbank.kr/images/iz/iz20210814/iz20210814m38.gif,ABDCEF,ABCDEF,DBECFA,DBAECF,4,"이 문제는 트리 자료구조에서 중위 순회(Inorder Traversal)의 결과를 묻고 있습니다.  중위 순회란, 트리의 노드를 방문하는 순서가 왼쪽 자식 노드 → 부모 노드 → 오른쪽 자식 노드 순서를 따르는 것을 말합니다.  문제에서 주어진 트리를 살펴보면, 루트 노드 A를 기준으로 왼쪽 자식 B와 오른쪽 자식 C가 있습니다.  먼저 왼쪽 자식 B부터 순회를 시작해야 합니다. B 노드의 왼쪽 자식은 D이므로, D를 먼저 방문합니다.  D를 방문한 후 B 노드를 방문하고, 그 다음 B의 오른쪽 자식이 없으므로 A 노드로 이동합니다. A 노드를 방문한 후, A의 오른쪽 자식 C를 방문합니다. C 노드의 왼쪽 자식 E를 방문하고, E를 방문한 후 C 노드를 방문합니다. 마지막으로 C의 오른쪽 자식 F를 방문합니다. 따라서 최종적인 중위 순회 결과는 D, B, A, E, C, F 순서가 되며, 이를 문자열로 표현하면 DBAECF가 됩니다.",68,11
539,1,6,39,테스트 케이스 자동 생성 도구를 이용하여 테스트 데이터를 찾아내는 방법이 아닌 것은?,,스터브(Stub)와 드라이버(Driver),입력 도메인 분석,랜덤(Random) 테스트,자료 흐름도,1,"테스트 케이스 자동 생성 도구는 소프트웨어의 결함을 효율적으로 찾기 위해 자동으로 테스트 데이터를 생성하는 도구입니다.  여러 가지 방법을 통해 테스트 데이터를 생성하는데,  입력 도메인 분석은 프로그램이 처리해야 하는 입력값의 범위를 분석하여 테스트 데이터를 생성하고, 랜덤 테스트는 무작위로 테스트 데이터를 생성하며, 자료 흐름도는 프로그램의 데이터 흐름을 분석하여 테스트 데이터를 생성하는 데 도움을 줍니다. 하지만 스터브와 드라이버는 테스트 대상 모듈을 독립적으로 테스트하기 위한  보조 프로그램으로, 테스트 데이터 자체를 찾아내는 방법은 아닙니다. 스터브는 테스트 대상 모듈이 호출하는 다른 모듈을 대체하는 가짜 모듈이고, 드라이버는 테스트 대상 모듈을 호출하는 프로그램입니다.  즉, 스터브와 드라이버는 테스트 환경을 구축하는 데 사용되지만, 테스트 데이터를 생성하는 데 직접적으로 사용되지 않습니다. 따라서 테스트 케이스 자동 생성 도구를 이용하여 테스트 데이터를 찾아내는 방법이 아닌 것은 스터브와 드라이버를 이용하는 방법입니다.",47,19
540,1,6,40,저작권 관리 구성 요소 중 패키저(Packager)의 주요 역할로 옳은 것은?,,콘텐츠를 제공하는 저작권자를 의미한다.,콘텐츠를 메타 데이터와 함께 배포 가능한 단위로 묶는다.,라이선스를 발급하고 관리한다.,배포된 콘텐츠의 이용 권한을 통제한다.,2,"저작권 관리 시스템에서 패키저(Packager)는 콘텐츠를 배포하기 위한 준비를 하는 역할을 합니다.  마치 선물 포장을 하는 것처럼,  저작권이 있는 콘텐츠를 사용자에게 제공하기 쉽도록 여러 가지 정보와 함께 묶어주는 것이죠.  콘텐츠 자체만으로는 배포가 어렵기 때문에,  메타데이터(콘텐츠에 대한 부가 정보, 예: 제목, 저자, 설명 등)와 함께 하나의 배포 가능한 단위로 만들어 줍니다.  다른 선택지들은 저작권 관리의 다른 구성 요소들이 하는 역할을 설명하고 있습니다.  예를 들어, 콘텐츠 제공자는 콘텐츠를 만드는 사람이고, 라이선스 발급 및 관리는 권한을 부여하고 관리하는 부분이며, 이용 권한 통제는 배포 후 콘텐츠 접근을 제어하는 부분입니다.  따라서 콘텐츠를 배포 가능한 단위로 묶는 역할은 패키저의 핵심 기능입니다.",78,16
541,1,6,41,데이터베이스의 무결성 규정(Integrity Rule)과 관련한 설명으로 틀린 것은?,,"무결성 규정에는 데이터가 만족해야 될 제약 조건, 규정을 참조할 때 사용하는 식별자 등의 요소가 포함될 수 있다.","무결성 규정의 대상으로는 도메인, 키, 종속성 등이 있다.",정식으로 허가 받은 사용자가 아닌 불법적인 사용자에 의한 갱신으로부터 데이터베이스를 보호하기 위한 규정이다.,릴레이션 무결성 규정(Relation Integrity Rules)은 릴레이 션을 조작하는 과정에서의 의미적 관계(Semantic Relationship)을 명세한 것이다.,3,"데이터베이스의 무결성 규정은 데이터의 정확성과 일관성을 유지하기 위한 규칙들을 말합니다.  데이터가 특정 조건을 만족해야 한다는 제약 조건이나, 데이터를 참조할 때 사용하는 식별자 등이 이러한 규정에 포함될 수 있습니다.  또한, 도메인(데이터의 자료형이나 범위), 키(데이터를 유일하게 식별하는 값), 종속성(데이터 간의 관계) 등도 무결성 규정의 대상이 됩니다.  릴레이션 무결성 규정은 데이터베이스 내 테이블(릴레이션) 간의 관계를 정의하고, 이 관계를 유지하기 위한 규칙을 명시합니다.  하지만, 잘못된 선지는 데이터베이스 무결성 규정의 목적을 잘못 이해하고 있습니다.  무결성 규정은 단순히 불법적인 사용자로부터 데이터를 보호하는 것만을 위한 것이 아닙니다.  그것은 데이터 자체의 정확성과 일관성을 유지하는 데 더 큰 목적이 있습니다.  즉,  허가받지 않은 사용자의 접근을 막는 것은 접근 제어(Access Control)의 영역이며, 데이터베이스 무결성과는 다른 개념입니다.  무결성 규정은 데이터 자체의 신뢰성을 확보하는 데 초점을 맞추고 있습니다. 따라서, 잘못된 선지는 데이터베이스 무결성의 개념을 오해한 것입니다.",60,33
542,1,6,42,데이터베이스에서 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 할 일련의 연산들을 의미하는 것은?,,트랜잭션,뷰,튜플,카디널리티,1,"데이터베이스에서의 트랜잭션은 하나의 논리적 작업 단위를 의미합니다.  예를 들어, 은행 계좌 이체를 생각해 보세요.  돈을 보내는 계좌에서 돈을 빼고, 받는 계좌에 돈을 입금하는 두 가지 작업은 하나의 논리적 작업, 즉 '이체'라는 단일 작업으로 묶여 있습니다.  이처럼 여러 개의 연산이 하나의 트랜잭션으로 묶이면, 모든 연산이 성공적으로 완료되어야만 그 트랜잭션이 성공한 것으로 간주됩니다.  만약 중간에 어떤 연산이 실패하더라도, 이전에 수행된 모든 연산은 취소되어 데이터베이스의 일관성을 유지합니다.  이처럼 트랜잭션은 데이터베이스의 무결성을 보장하는 중요한 역할을 수행하며,  '한꺼번에 모두 수행되어야 할 일련의 연산'이라는 설명과 정확히 일치합니다.  다른 선택지는 데이터베이스의 특정 구성 요소나 개념을 나타내지만, 하나의 논리적 작업 단위를 나타내는 것은 트랜잭션입니다.",81,27
543,1,6,43,다음 두 릴레이션 Rl과 R2의 카티션 프로덕트(cartesian product) 수행 결과는?,https://www.cbtbank.kr/images/iz/iz20210814/iz20210814m43.gif,https://www.cbtbank.kr/images/iz/iz20210814/iz20210814m43b1.gif,https://www.cbtbank.kr/images/iz/iz20210814/iz20210814m43b2.gif,https://www.cbtbank.kr/images/iz/iz20210814/iz20210814m43b3.gif,https://www.cbtbank.kr/images/iz/iz20210814/iz20210814m43b4.gif,4,"이 문제는 두 개의 테이블, R1(학년)과 R2(학과)의 카티션 프로덕트(Cartesian Product)를 구하는 문제입니다.  카티션 프로덕트는 간단히 말해, 두 테이블의 모든 행의 조합을 만들어내는 연산입니다.  R1 테이블에는 학년이 1, 2, 3으로 총 3개의 행이 있고, R2 테이블에는 학과가 컴퓨터, 국문, 수학으로 총 3개의 행이 있습니다.  따라서 카티션 프로덕트의 결과는 R1의 각 행이 R2의 모든 행과 조합된 결과가 됩니다.  즉, 학년 1은 컴퓨터, 국문, 수학 학과와 각각 조합되고, 학년 2와 3도 마찬가지로 모든 학과와 조합됩니다.  결과적으로 총 3(R1의 행 개수) * 3(R2의 행 개수) = 9개의 행을 가지는 새로운 테이블이 생성됩니다.  정답은 이러한 모든 조합을 보여주는 테이블입니다.  마치 학년별로 모든 학과를 나열하는 것과 같다고 생각하면 이해하기 쉬울 것입니다.",78,29
544,1,6,44,물리적 데이터베이스 설계에 대한 설명으로 거리가 먼 것은?,,물리적 설계의 목적은 효율적인 방법으로 데이터를 저장하는 것이다.,"트랜잭션 처리량과 응답시간, 디스크 용량 등을 고려해야 한다.","저장 레코드의 형식, 순서, 접근 경로와 같은 정보를 사용하여 설계한다.","트랜잭션의 인터페이스를 설계하며, 데이터 타입 및 데이터 타입들 간의 관계로 표현한다.",4,"물리적 데이터베이스 설계는 데이터를 실제로 저장하고 관리하는 방법에 대한 설계입니다.  효율적인 저장 방법을 찾는 것이 목표이며,  트랜잭션 처리 속도, 응답 시간, 필요한 저장 공간 등을 고려하여  어떤 형태로 데이터를 저장하고, 어떤 순서로 저장하며, 어떻게 데이터에 접근할지 등을 결정합니다.  반면,  데이터 타입이나 데이터 간의 관계는 논리적 설계 단계에서 다루는 내용입니다.  논리적 설계는 어떤 데이터를 저장할지, 데이터 간의 관계는 어떻게 될지 등 데이터 자체의 구조와 의미를 정의하는 단계이고, 물리적 설계는 논리적 설계 결과를 바탕으로 실제 저장 및 관리 방법을 구체적으로 결정하는 단계입니다. 따라서 트랜잭션 인터페이스와 데이터 타입 및 관계를 설계하는 것은 물리적 설계의 범위를 벗어납니다.  물리적 설계는 논리적 설계가 완료된 후, 실제 저장 매체와 시스템 환경에 맞춰 데이터를 효율적으로 저장하고 관리하는 방법을 결정하는 단계이기 때문입니다.",67,33
545,1,6,45,"다음 중 기본키는 NULL 값을 가져서는 안되며, 릴레이션 내에 오직 하나의 값만 존재해야 한다는 조건을 무엇이라 하는가?",,개체 무결성 제약조건,참조 무결성 제약조건,도메인 무결성 제약조건,속성 무결성 제약조건,1,"데이터베이스에서 기본키(Primary Key)는 테이블의 각 행을 유일하게 식별하는 데 사용되는 특별한 속성입니다.  기본키는 중복된 값을 허용하지 않고,  NULL 값도 허용하지 않습니다.  이는 데이터의 중복을 방지하고, 각 행을 명확하게 구분하기 위해서 필수적인 조건입니다.  문제에서 언급된 ""NULL 값을 가져서는 안되며, 릴레이션 내에 오직 하나의 값만 존재해야 한다""는 조건은 바로 이 기본키의 특징을 정의하는  데이터 무결성(Data Integrity)의 중요한 부분입니다.  데이터 무결성은 데이터의 정확성과 신뢰성을 보장하기 위한 제약 조건들을 의미하며,  기본키에 대한 제약 조건은 그 중 가장 기본적이고 중요한 요소입니다.  따라서 정답은 데이터의 무결성을 유지하기 위한 제약 조건을 의미하는 것입니다.  쉽게 말해,  주민등록번호처럼 사람을 유일하게 식별하는 값이 기본키인데,  주민등록번호가 비어있거나(NULL),  두 사람이 같은 주민등록번호를 가질 수 없다는 것을 생각하면 이해하기 쉽습니다.",80,33
546,1,6,46,SQL문에서 HAVING을 사용할 수 있는 절은?,,LIKE 절,WHERE 절,GROUP BY 절,ORDER BY 절,3,"SQL에서 HAVING 절은 GROUP BY 절과 함께 사용하여 그룹화된 결과에 대한 조건을 설정하는 데 사용됩니다.  쉽게 말해, 여러 데이터를 특정 기준으로 묶은 후(GROUP BY), 그 묶음들 중에서 특정 조건을 만족하는 묶음만을 선택하고 싶을 때 HAVING 절을 사용합니다.  WHERE 절은 개별 레코드(데이터 행)에 대한 조건을 설정하는 반면, HAVING 절은 GROUP BY로 생성된 그룹에 대한 조건을 설정하는 것이죠.  따라서 GROUP BY 절이 있어야만 HAVING 절을 사용할 수 있습니다.  다른 절들은 그룹화와 직접적인 관련이 없으므로 HAVING 절과 함께 사용될 수 없습니다.  예를 들어, 고객별 주문 금액의 합계를 구하고, 그 합계가 100만원 이상인 고객만을 추출하려면 GROUP BY 절로 고객별로 그룹화하고, HAVING 절로 합계가 100만원 이상인 그룹만 선택하면 됩니다.  WHERE 절은 그룹화 *전*에 조건을 적용하는 반면, HAVING 절은 그룹화 *후*에 조건을 적용하는 점이 중요합니다.",77,26
547,1,6,47,관계 데이터베이스에 있어서 관계 대수 연산이 아닌 것은?,,디비전(Division),프로젝트(Project),조인(Join),포크(Fork),4,"관계 데이터베이스에서 데이터를 다루는 방법 중 하나가 관계 대수입니다.  관계 대수는 집합 이론을 기반으로 하여 데이터베이스의 테이블을 집합으로 보고, 이 집합들에 대한 연산을 통해 원하는 정보를 얻는 방법입니다.  문제에서 제시된 '디비전(Division)', '프로젝트(Project)', '조인(Join)'은 모두 관계 대수의 대표적인 연산입니다.  '디비전'은 집합의 나눗셈과 같은 연산이고, '프로젝트'는 특정 속성만 선택하는 연산이며, '조인'은 두 개 이상의 테이블을 특정 조건에 따라 결합하는 연산입니다.  반면 '포크(Fork)'는 관계 대수 연산에 포함되지 않는 용어입니다.  '포크'는 일반적으로 운영체제나 병렬 처리 환경에서 프로세스를 복제하는 것을 의미하며, 데이터베이스 연산과는 직접적인 관련이 없습니다. 따라서 관계 대수 연산이 아닌 것은 '포크'입니다.  쉽게 말해, 관계 대수는 데이터베이스 테이블을 가지고 자르고, 붙이고, 특정 부분만 뽑아내는 작업을 하는데, '포크'는 이런 작업과는 전혀 다른 개념이기 때문입니다.",77,29
548,1,6,48,"학적 테이블에서 전화번호가 Null값이 아닌 학생명을 모두 검색할 때, SQL 구문으로 옳은 것은?",,SELECT FROM 07 WHERE 전화번호 DON'T NULL;,SELECT FROM WHERE 전화번호 != NOT NULL;,SELECT 학생명 FROM 학적 WHERE 전화번호 IS NOT NULL;,SELECT FROM WHERE 전화번호 IS NULL;,3,"학적 테이블에서 전화번호가 Null값이 아닌 학생들의 이름을 모두 검색하는 SQL 구문을 작성하는 문제입니다.  Null 값은 데이터베이스에서 값이 없음을 나타내는 특별한 값입니다.  따라서 전화번호가 Null이 아닌 학생을 찾으려면,  `IS NOT NULL` 조건을 사용해야 합니다.  `!=` 연산자는 일반적인 값 비교에 사용되지만, Null 값과의 비교에는 적합하지 않습니다. Null 값은 어떤 값과도 같지 않고, 또 다르지도 않기 때문입니다.  `DON'T NULL` 과 같은 표현은 SQL 표준 문법이 아니므로 사용할 수 없습니다.  정답은 학생명을 선택하고(`SELECT 학생명`), 학적 테이블에서(`FROM 학적`), 전화번호가 Null이 아닌(`WHERE 전화번호 IS NOT NULL`) 학생들을 검색하는 구문입니다. 이 구문은 명확하고 정확하게 문제의 요구사항을 충족합니다.  다른 선택지들은 Null 값을 다루는 SQL 문법을 제대로 이해하지 못한 경우에 선택될 수 있는 오류가 있는 구문들입니다.",84,25
549,1,6,49,관계형 데이터베이스에서 다음 설명에 해당하는 키(Key)는?,https://www.cbtbank.kr/images/iz/iz20210814/iz20210814m49.gif,후보키,대체키,슈퍼키,외래키,3,"문제에서 설명하는 키는 한 릴레이션(관계형 데이터베이스의 테이블) 내의 속성(컬럼)들의 집합으로, 테이블의 모든 행(튜플)을 유일하게 식별할 수 있는 키입니다.  ""유일성은 만족시키지만 최소성은 만족시키지 못한다""는 것은,  이 키가 테이블의 모든 행을 구분하는 데 필요한 최소한의 속성만으로 구성되어 있지 않다는 의미입니다.  즉,  필요 이상의 속성을 포함하고 있다는 뜻이죠.  예를 들어, 학생 테이블에 학번, 이름, 주소가 있고, 학번만으로도 학생을 유일하게 식별할 수 있다면 학번은 후보키가 됩니다. 하지만 학번, 이름, 주소를 모두 포함하는 키도 모든 학생을 유일하게 식별할 수 있지만,  최소한의 속성으로 구성된 것은 아니므로 최소성을 만족하지 못합니다. 이처럼 최소성을 만족하지 않지만 유일성을 만족하는 키를 우리는 슈퍼키라고 부릅니다.  후보키는 최소성을 만족하는 유일키이고, 대체키는 후보키 중 하나를 주키로 선택했을 때 나머지 후보키들을 의미하며, 외래키는 다른 테이블의 주키를 참조하는 키입니다. 따라서 문제의 설명에 가장 적합한 키는 슈퍼키입니다.",73,33
550,1,6,50,데이터베이스에서 인덱스(Index)와 관련한 설명으로 틀린 것은?,,인덱스의 기본 목적은 검색 성능을 최적화하는 것으로 볼 수 있다.,B-트리 인덱스는 분기를 목적으로 하는 Branch Block을 가지고 있다.,BETWEEN 등 범위(Range) 검색에 활용될 수 있다.,시스템이 자동으로 생성하여 사용자가 변경할 수 없다.,4,"데이터베이스에서 인덱스는 책의 목차와 같다고 생각하면 이해하기 쉽습니다.  책에서 특정 내용을 찾고 싶을 때 목차를 이용하면 훨씬 빠르게 찾을 수 있죠? 인덱스도 마찬가지로 데이터베이스에서 특정 데이터를 빠르게 찾기 위해 사용하는 일종의 '목차'입니다.  따라서 인덱스의 기본 목적은 검색 성능을 향상시키는 것입니다. B-트리 인덱스는 데이터를 효율적으로 검색하기 위해 트리 구조를 사용하는데,  여기서 Branch Block은 트리의 가지 역할을 하여 데이터를 효율적으로 분기하여 검색하는 데 사용됩니다.  BETWEEN과 같은 범위 검색에도 인덱스를 활용하여 검색 속도를 높일 수 있습니다.  하지만 인덱스는 시스템이 자동으로 생성하는 것만 있는 것이 아니라, 사용자가 직접 생성하고 관리할 수도 있습니다.  문제에서 틀린 설명은 바로 이 부분입니다.  인덱스는 항상 시스템이 자동으로 생성하고 사용자가 변경할 수 없는 것이 아니기 때문입니다.  사용자가 필요에 따라 인덱스를 생성하거나 삭제하고, 인덱스의 속성을 변경하는 등의 작업을 수행할 수 있습니다.  따라서 정답은 인덱스가 시스템에 의해 자동 생성되고 사용자가 변경할 수 없다는 설명이 틀린 것입니다.",80,28
551,1,6,51,로킹 단위(Locking Granularity)에 대한 설명으로 옳은 것은?,,로킹 단위가 크면 병행성 수준이 낮아진다.,로킹 단위가 크면 병행 제어 기법이 복잡해진다.,로킹 단위가 작으면 로크(lock)의 수가 적어진다.,"로킹은 파일 단위로 이루어지며, 레코드와 필드는 로킹 단위가 될 수 없다.",1,"데이터베이스나 파일 시스템에서 여러 사용자가 동시에 접근하여 데이터를 변경하는 것을 막기 위해 로킹(Locking)이라는 기법을 사용합니다.  로킹 단위란, 동시 접근을 제어하는 단위를 말하는데,  크기가 클수록 한 번에 더 많은 데이터를 잠그게 됩니다.  예를 들어, 로킹 단위가 '파일 전체'라면, 한 사용자가 파일을 잠그면 다른 사용자는 그 파일 전체에 접근할 수 없습니다. 반대로 로킹 단위가 '레코드'라면, 한 사용자가 특정 레코드만 잠그고 다른 사용자는 다른 레코드를 수정할 수 있습니다.",65,29
552,1,6,52,관계 대수에 대한 설명으로 틀린 것은?,,원하는 릴레이션을 정의하는 방법을 제공하며 비절차적 언어이다.,릴레이션 조작을 위한 연산의 집합으로 피연산자와 결과가 모두 릴레이션이다.,일반 집합 연산과 순수 관계 연산으로 구분된다.,질의에 대한 해를 구하기 위해 수행해야 할 연산의 순서를 명시한다.,1,"관계 대수는 데이터베이스에서 데이터를 조작하는 방법 중 하나입니다.  마치 수학의 대수처럼,  데이터베이스의 테이블(릴레이션)을 가지고 연산을 수행하여 원하는 정보를 얻어내는 방식이죠.  각 선지들을 살펴보면, 데이터베이스 테이블을 가지고 연산을 하여 새로운 테이블을 만들어내는 과정을 설명하고 있습니다.  틀린 것은, 관계 대수는 연산의 순서를 미리 정해놓고 수행하는 것이 아니라,  원하는 결과를 얻기 위한 연산들을 기술하는 방식이지,  어떤 순서로 연산을 해야 하는지를 명시하지는 않습니다.  즉,  결과를 얻는 방법을 제시하지만, 그 방법을 얻기 위한 단계별 절차를 구체적으로 지정하지 않는 비절차적 언어인 것이죠.  마치 ""사과 10개와 배 5개를 합쳐라""라고 하는 것과 ""먼저 사과를 세고, 그 다음 배를 세고, 그 결과를 더하라""라고 하는 것의 차이와 같습니다.  전자는 결과만을 요구하는 비절차적 방식이고, 후자는 절차를 명시하는 절차적 방식입니다. 관계 대수는 전자에 해당합니다. 따라서,  연산 순서를 명시한다는 설명은 관계 대수의 특징과 맞지 않습니다.",65,29
553,1,6,53,데이터의 중복으로 인하여 관계연산을 처리할 때 예기치 못한 곤란한 현상이 발생하는 것을 무엇이라 하는가?,,이상(Anomaly),제한 (Restriction),종속성(Dependency),변환(Translation),1,"데이터베이스에서 데이터의 중복은 여러 가지 문제를 야기합니다.  예를 들어, 같은 사람의 정보가 여러 곳에 저장되어 있다면, 그 사람의 주소를 변경해야 할 때 모든 곳을 일일이 수정해야 하는 번거로움이 발생합니다.  만약 어떤 곳을 수정하지 못했다면 데이터의 불일치가 생겨 시스템 전체의 정확성을 떨어뜨리게 됩니다.  또한, 중복된 데이터는 저장 공간을 낭비하고 데이터 검색 속도를 늦추는 원인이 됩니다. 이러한 데이터 중복으로 인해 예상치 못한 문제, 즉 시스템 오류나 데이터 무결성 위반 등의 곤란한 상황이 발생하는 것을 이상(Anomaly)이라고 합니다.  이는 데이터베이스 설계 단계에서 정규화를 통해 최소화해야 하는 중요한 문제입니다.  정규화는 데이터 중복을 줄이고 데이터 무결성을 유지하기 위한 데이터베이스 설계 기법입니다.",84,29
554,1,6,54,다음 중 SQL에서의 DDL 문이 아닌 것은?,,CREATE,DELETE,ALTER,DROP,2,"SQL(Structured Query Language)은 데이터베이스를 관리하고 조작하는 데 사용되는 표준 언어입니다.  SQL 문은 크게 데이터 정의어(DDL: Data Definition Language), 데이터 조작어(DML: Data Manipulation Language), 데이터 제어어(DCL: Data Control Language)로 나눌 수 있습니다.",76,27
555,1,6,55,정규화에 대한 설명으로 적절하지 않은 것은?,,데이터베이스의 개념적 설계 단계 이전에 수행한다.,데이터 구조의 안정성을 최대화한다.,"중복을 배제하여 삽입, 삭제, 갱신 이상의 발생을 방지한다.",데이터 삽입 시 릴레이션을 재구성할 필요성을 줄인다.,1,"데이터베이스 정규화는 데이터 중복을 최소화하고 데이터 무결성을 유지하기 위한 설계 기법입니다.  데이터베이스를 설계할 때,  데이터 중복이 많으면 데이터를 삽입, 삭제, 수정할 때 여러 곳을 일일이 수정해야 하는 문제가 발생합니다. 이러한 문제를 '이상 현상(Anomaly)'이라고 부르는데,  정규화는 이러한 이상 현상을 방지하여 데이터베이스의 안정성과 신뢰성을 높이는 데 목적이 있습니다.  정규화는 데이터베이스의 개념적 설계 단계에서 수행되는 것이지, 그 이전 단계에서 수행되는 것은 아닙니다.  개념적 설계 단계에서 데이터 모델을 정의하고, 그 후에 정규화 과정을 거쳐 데이터베이스의 논리적 구조를 설계합니다.  따라서 데이터베이스의 개념적 설계 단계 이전에 정규화를 수행한다는 설명은 적절하지 않습니다.  나머지 선택지는 모두 정규화의 목적과 효과를 잘 나타내고 있습니다.  정규화를 통해 데이터 구조의 안정성이 높아지고, 중복이 제거되어 이상 현상이 방지되며, 데이터 삽입 시 릴레이션 재구성의 필요성이 줄어듭니다.",74,30
556,1,6,56,트랜잭션의 주요 특성 중 하나로 둘 이상의 트랜잭션이 동시에 병행 실행되는 경우 어느 하나의 트랜잭션 실행 중에 다른 트랜잭션의 연산이 끼어들 수 없음을 의미하는 것은?,,Log,Consistency,Isolation,Durability,3,"이 문제는 데이터베이스 트랜잭션의 특성에 대한 이해를 묻고 있습니다.  트랜잭션이란 데이터베이스에 대한 일련의 연산들을 하나의 논리적 작업 단위로 묶은 것을 말합니다.  예를 들어 은행 계좌 이체를 생각해보세요.  돈을 보내는 계좌에서 돈을 빼고 받는 계좌에 돈을 더하는 두 가지 연산이 하나의 트랜잭션으로 이루어집니다.  이때, 중요한 것은 이 두 연산이 모두 성공하거나 모두 실패해야 한다는 것입니다.  만약 돈을 보내는 계좌에서만 돈이 빠져나가고 받는 계좌에는 돈이 더해지지 않는다면 데이터베이스의 일관성이 깨지겠죠.",73,27
557,1,6,57,SQL의 논리 연산자가 아닌 것은?,,AND,OTHER,OR,NOT,2,"SQL은 데이터베이스를 관리하고 조작하는 데 사용되는 언어입니다.  데이터베이스에서 여러 조건을 만족하는 데이터를 찾기 위해서는 여러 조건을 연결하는 논리 연산자를 사용합니다.  'AND', 'OR', 'NOT'은 모두 SQL에서 데이터를 검색할 때 조건을 결합하는 데 사용되는 대표적인 논리 연산자입니다.  'AND'는 두 조건을 모두 만족해야 참이 되고, 'OR'은 두 조건 중 하나라도 만족하면 참이 되며, 'NOT'은 조건의 반대를 나타냅니다.  문제에서 제시된 다른 선택지는 SQL의 표준 논리 연산자가 아닙니다. 따라서 SQL에서 사용되지 않는 연산자를 찾는 문제에서 정답은 'OTHER'가 됩니다.  'OTHER'는 SQL에서 정의된 논리 연산자가 아니기 때문입니다.",85,26
558,1,6,58,동시성 제어를 위한 직렬화 기법으로 트랜잭션 간의 처리 순서를 미리 정하는 방법은?,,로킹 기법,타임스탬프 기법,검증 기법,배타 로크 기법,2,"동시성 제어란 여러 사용자가 동시에 데이터베이스를 접근하여 데이터를 변경할 때 발생할 수 있는 문제, 예를 들어 데이터의 불일치나 손실을 막기 위한 기법입니다.  여러 사용자가 동시에 같은 데이터를 변경하려고 하면 데이터의 일관성이 깨질 수 있죠.  이를 방지하기 위해 데이터베이스 시스템에서는 다양한 동시성 제어 기법을 사용하는데, 문제에서 묻고 있는 것은 트랜잭션(데이터베이스 작업의 논리적 단위) 간의 처리 순서를 미리 정하는 방법입니다.",74,27
559,1,6,59,이전 단계의 정규형을 만족하면서 후보키를 통하지 않는 조인 종속(JD : Join Dependency) 제거해야 만족하는 정규형은?,,제3정규형,제4정규형,제5정규형,제6정규형,3,"이 문제는 데이터베이스 정규화의 최종 목표인 데이터 중복 최소화와 무결성 유지를 위해 어떤 정규형까지 도달해야 하는지를 묻고 있습니다.  이전 단계의 정규형을 만족한다는 것은 3정규형까지의 모든 규칙을 충족한다는 의미입니다.  3정규형은 함수적 종속성 문제를 해결하지만, 후보키를 통하지 않는 조인 종속성(Join Dependency) 문제는 해결하지 못합니다.  조인 종속성이란 여러 테이블을 조인했을 때, 그 결과에 중복된 데이터가 발생하는 현상을 의미합니다.  이러한 중복 데이터는 데이터베이스의 무결성을 훼손하고, 데이터 관리의 비효율성을 초래합니다.  따라서, 후보키를 통하지 않는 조인 종속성을 제거하기 위해서는 3정규형 이상의 정규형이 필요하며, 그 중에서도 제5정규형이 바로 조인 종속성 문제를 완벽하게 해결하는 정규형입니다.  제4정규형은 다치 종속성(Multi-valued dependency)을 제거하는 데 초점을 맞추고 있으며, 제6정규형은 이론적으로 존재하지만 실제 데이터베이스 설계에서는 거의 사용되지 않습니다.  결론적으로, 이전 단계의 정규형을 만족하면서 후보키를 통하지 않는 조인 종속성을 제거하기 위해서는 제5정규형까지 정규화 과정을 거쳐야 합니다.",65,30
560,1,6,60,어떤 릴레이션 R에서 X와 Y를 각각 R의 애트리뷰트 집합의 부분 집합이라고 할 경우 애트리뷰트 X의 값 각각에 대해 시간에 관계없이 항상 애트리뷰트 Y의 값이 오직 하나만 연관되어 있을 때 Y는 X에 함수 종속이라고 한다. 이 함수 종속의 표기로 옳은 것은?,,Y → X,Y ⊂ X,X → Y,X ⊂ Y,3,"이 문제는 데이터베이스에서의 함수 종속 개념을 묻고 있습니다.  함수 종속이란 어떤 애트리뷰트(속성)의 값이 정해지면 다른 애트리뷰트의 값이 단 하나로 결정되는 관계를 말합니다.  예를 들어, '주민등록번호'라는 애트리뷰트가 있고, '이름'이라는 애트리뷰트가 있다고 가정해 봅시다.  주민등록번호가 하나로 정해지면 그에 해당하는 이름은 단 하나만 존재합니다. 이 경우 '이름'은 '주민등록번호'에 함수 종속된다고 합니다.  문제에서 X와 Y는 애트리뷰트 집합의 부분집합이고, X의 값이 정해지면 Y의 값이 항상 단 하나로 결정된다고 했습니다. 이를 표기하는 방법은 X → Y 입니다.  즉, X가 Y를 결정한다는 의미입니다.  화살표는 '결정한다' 또는 '함수 종속된다'는 의미로 사용됩니다.  다른 선지는 애트리뷰트 집합 간의 포함 관계를 나타내거나, 반대 방향의 함수 종속을 나타내므로 정답이 될 수 없습니다. 따라서 X가 Y에 함수 종속된다는 것을 나타내는 올바른 표기는 X → Y 입니다.",54,29
561,1,6,61,모듈 내 구성 요소들이 서로 다른 기능을 같은 시간대에 함께 실행하는 경우의 응집도(Cohesion)는?,,Temporal Cohesion,Logical Cohesion,Coincidental Cohesion,Sequential Cohesion,1,"이 문제는 모듈 내 구성 요소들이 동시에 실행되는 상황에서의 응집도를 묻고 있습니다.  응집도란 모듈 내 구성 요소들이 서로 얼마나 관련성이 높은지를 나타내는 척도입니다.  관련성이 높을수록 응집도가 높고,  유지보수 및 재사용성이 좋아집니다.  문제에서 설명하는 상황, 즉 서로 다른 기능을 가진 구성 요소들이 같은 시간에 함께 실행된다는 것은 시간적으로 연관되어 있다는 것을 의미합니다.  따라서 이러한 상황을 가장 잘 나타내는 응집도는 시간적 응집도(Temporal Cohesion)입니다.  다른 선택지는 시간적 연관성보다는 기능적 연관성이나 우연적인 연관성을 나타내므로 적절하지 않습니다.  예를 들어,  ""프로그램 시작 시 초기화 작업""과 같이 시간적으로 묶여서 동시에 실행되는 여러 작업들은 시간적 응집도를 가진다고 볼 수 있습니다.",59,6
562,1,6,62,오류 제어에 사용되는 자동반복 요청방식(ARQ)이 아닌 것은?,,Stop-and-wait ARQ,Go-back-N ARQ,Selective-Repeat ARQ,Non-Acknowledge ARQ,4,"이 문제는 네트워크 통신에서 데이터 전송의 신뢰성을 확보하기 위해 사용되는 오류 제어 방식인 자동 반복 요청(ARQ)에 대한 이해도를 묻고 있습니다.  ARQ는 데이터를 보낸 쪽에서 상대방으로부터 수신 확인(Acknowledgement, ACK)을 받아 전송 성공 여부를 확인하고, 오류 발생 시 재전송하는 방식입니다.  정답으로 제시된 것은 ACK를 사용하지 않는 방식입니다.  즉, 데이터를 보낸 후 상대방으로부터 수신 확인을 기다리지 않고,  오류 발생 여부를 확인하지 않고 계속해서 데이터를 전송하는 방식입니다.  이는 데이터 전송의 신뢰성을 보장할 수 없기 때문에 ARQ 방식이라고 할 수 없습니다. 다른 선택지들은 모두 수신 확인을 기반으로 오류를 제어하는 ARQ의 종류입니다. Stop-and-wait ARQ는 한 번에 하나의 패킷만 전송하고 ACK를 받은 후 다음 패킷을 전송하는 방식이고, Go-back-N ARQ는 여러 개의 패킷을 전송하고 ACK를 받지 못한 패킷부터 다시 전송하는 방식이며, Selective-Repeat ARQ는 오류가 발생한 패킷만 재전송하는 방식입니다. 따라서 ACK를 사용하지 않는 방식은 ARQ의 기본 원리에 부합하지 않으므로 정답입니다.",64,45
563,1,6,63,다음 파이썬(Python) 프로그램이 실행되었을 때의 결과는?,https://www.cbtbank.kr/images/iz/iz20210814/iz20210814m63.gif,45,55,66,78,3,"이 문제는 파이썬 코드의 실행 결과를 묻고 있습니다.  코드를 살펴보면 `cs(n)` 함수는 0부터 n까지의 정수를 모두 더하는 기능을 합니다.  `range(n+1)`은 0부터 n까지의 숫자를 생성하는데, n+1을 사용하는 이유는 range 함수가 n을 포함하지 않기 때문입니다.  함수 내부의 `for` 문은 이 숫자들을 순차적으로 더하여 `s` 변수에 누적하고, 최종적으로 `s`의 값을 반환합니다.  문제에서는 `cs(11)`을 호출하므로, 0부터 11까지의 정수를 모두 더하는 결과를 출력합니다.  즉, 0 + 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 을 계산하면 됩니다. 이 계산 결과는 66입니다. 따라서 정답은 66입니다.  수학적으로는 등차수열의 합 공식을 이용하여 (11 * (11 + 1)) / 2 = 66 으로 간단하게 계산할 수도 있습니다.",66,41
564,1,6,64,다음 C언어 프로그램이 실행되었을 때의 결과는?,https://www.cbtbank.kr/images/iz/iz20210814/iz20210814m64.gif,nation,nationalter,alter,alternation,2,"이 C언어 코드는 문자열을 다루는 함수 `strcat`의 사용을 이해하는지를 묻는 문제입니다.  `strcat` 함수는 첫 번째 인자로 주어진 문자열의 끝에 두 번째 인자로 주어진 문자열을 이어 붙이는 역할을 합니다.  코드에서 `str` 배열에는 ""nation""이라는 문자열이 저장되어 있고, `p2` 포인터는 ""alter""라는 문자열을 가리키고 있습니다.  `strcat(str, p2);` 라인은 `str`의 끝에 `p2`가 가리키는 ""alter""를 붙이라는 명령입니다. 따라서 ""nation"" 뒤에 ""alter""가 붙어 ""nationalter""가 되는 것이죠.  `printf` 함수는 이렇게 합쳐진 문자열 ""nationalter""를 출력하게 됩니다.  따라서 프로그램의 실행 결과는 ""nationalter""입니다.  `strcat` 함수를 사용할 때는 첫 번째 문자열에 충분한 공간이 확보되어 있는지 주의해야 합니다.  만약 첫 번째 문자열의 크기가 부족하면 메모리 오버플로우가 발생할 수 있습니다. 이 코드에서는 `str` 배열의 크기가 50이므로 충분한 공간이 확보되어 있습니다.",75,41
565,1,6,65,JAVA에서 힙(Heap)에 남아있으나 변수가 가지고 있던 참조값을 잃거나 변수 자체가 없어짐으로써 더 이상 사용되지 않는 객체를 제거해주는 역할을 하는 모듈은?,,Heap Collector,Garbage Collector,Memory Collector,Variable Collector,2,"JAVA에서 프로그램을 실행하면, 객체들은 메모리의 힙(Heap) 영역에 저장됩니다.  프로그램이 동작하는 동안 객체들은 변수를 통해 참조되며 사용됩니다.  하지만 프로그램의 흐름에 따라 더 이상 필요없는 객체들이 힙 영역에 남아있게 되는데, 이러한 객체들은 메모리 공간을 불필요하게 차지하게 됩니다.  이때,  메모리 공간을 효율적으로 관리하고,  더 이상 사용되지 않는 객체들이 차지하는 메모리를 해제하여 시스템의 성능 저하를 방지하는 역할을 하는 것이 바로 가비지 컬렉터(Garbage Collector)입니다.  가비지 컬렉터는 힙 영역을 주기적으로 검사하여 참조되지 않는 객체들을 자동으로 찾아내어 제거하는 모듈입니다.  즉,  변수가 참조하는 객체가 없어지거나,  변수 자체가 사라져 더 이상 사용되지 않는 객체를 자동으로 삭제하여 메모리 누수를 방지하는 역할을 수행합니다.  다른 선택지들은 가비지 컬렉터의 기능을 부분적으로 설명하거나,  잘못된 용어를 사용하고 있습니다.",80,7
566,1,6,66,다음 C언어 프로그램이 실행되었을 때의 결과는?,https://www.cbtbank.kr/images/iz/iz20210814/iz20210814m66.gif,0,1,2,3,3,"이 C언어 프로그램은 논리 연산자와 비트 연산자를 사용하여 세 개의 변수 `r1`, `r2`, `r3`에 값을 할당하고, 그 합을 출력하는 간단한 프로그램입니다.  먼저 `r1 = b <= 4 || c == 2;` 에서 `b`는 4이고 `c`는 2이므로, `4 <= 4`는 참(1)이고 `2 == 2`도 참(1)입니다.  `||`는 논리합 연산자이므로, 하나라도 참이면 전체 결과는 참(1)이 됩니다. 따라서 `r1`은 1이 됩니다. 다음으로 `r2 = (a > 0) && (b < 5);` 에서 `a`는 3이고 `b`는 4이므로, `3 > 0`은 참(1)이고 `4 < 5`도 참(1)입니다. `&&`는 논리곱 연산자이므로, 모두 참이어야 전체 결과가 참(1)이 됩니다. 따라서 `r2`는 1이 됩니다. 마지막으로 `r3 = !c;` 에서 `c`는 2이므로, `!c`는 `c`의 논리 부정을 의미합니다.  C언어에서 0은 거짓, 0이 아닌 값은 참으로 취급되므로, 2는 참으로 간주되어 `!2`는 거짓(0)이 됩니다. 따라서 `r3`은 0이 됩니다.  최종적으로 `r1 + r2 + r3`는 `1 + 1 + 0 = 2`가 되어 프로그램은 2를 출력합니다.  따라서 정답은 2입니다.",67,41
567,1,6,67,다음 중 JAVA에서 우선순위가 가장 낮은 연산자는?,,--,%,&,=,4,"JAVA에서 연산자의 우선순위는 수학과 마찬가지로 계산 순서를 결정하는 중요한 요소입니다.  덧셈, 뺄셈보다 곱셈, 나눗셈이 먼저 계산되는 것처럼 JAVA에도 연산자별 우선순위가 정해져 있습니다.  문제에서 제시된 연산자 중 ‘=’는 대입 연산자입니다.  대입 연산자는 오른쪽 피연산자의 값을 왼쪽 피연산자에 할당하는 역할을 합니다.  다른 연산자들(감소 연산자, 모듈러 연산자, 비트 AND 연산자)은 값을 계산하는 연산이지만, 대입 연산자는 값을 할당하는 연산이기 때문에 다른 연산이 모두 끝난 후에 수행됩니다.  따라서 JAVA에서 대입 연산자는 다른 모든 연산자보다 우선순위가 가장 낮습니다.  마치 수학에서 ‘=’ 기호가 계산 결과를 나타내는 것처럼, JAVA에서 ‘=’는 최종 결과를 저장하는 역할을 하므로 가장 나중에 실행됩니다.  다른 연산자들이 먼저 계산된 결과를 바탕으로 대입 연산이 이루어지는 것이죠.  결론적으로, 값을 할당하는 연산의 특성 때문에 대입 연산자의 우선순위가 가장 낮은 것입니다.",70,41
568,1,6,68,"사용자가 요청한 디스크 입·출력 내용이 다음과 같은 순서로 큐에 들어 있을 때 SSTF 스케쥴링을 사용한 경우의 처리 순서는? (단, 현재 헤드 위치는 53 이고, 제일 안쪽이 1번, 바깥쪽이 200번 트랙이다.)",https://www.cbtbank.kr/images/iz/iz20210814/iz20210814m68.gif,53-65-67-37-14-98-122-124-183,53-98-183-37-122-14-124-65-67,53-37-14-65-67-98-122-124-183,53-67-65-124-14-122-37-183-98,1,"이 문제는 디스크 스케줄링 알고리즘 중 하나인 SSTF(Shortest Seek Time First) 알고리즘을 이해하고 적용하는 문제입니다. SSTF 알고리즘은 현재 헤드 위치에서 가장 가까운 트랙에 먼저 접근하는 방식입니다.  문제에서 현재 헤드 위치는 53이고, 큐에는 98, 183, 37, 122, 14, 124, 65, 67 순서로 요청이 들어와 있습니다.",57,11
569,1,6,69,192.168.1.0/24 네트워크를 FLSM 방식을 이용하여 4개의 Subnet으로 나누고 IP Subnet-zero를 적용했다. 이 때 Subnetting 된 네트워크 중 4번째 네트워크의 4번째 사용가능한 IP는 무엇인가?,,192.168.1.192,192.168.1.195,192.168.1.196,192.168.1.198,3,"192.168.1.0/24 네트워크는 총 256개(2<sup>8</sup>)의 IP 주소를 가지고 있습니다.  /24는 네트워크 주소 부분이 24비트라는 것을 의미하며,  호스트 주소 부분은 8비트(256개)가 됩니다.  이 네트워크를 FLSM(Flexible Length Subnet Masking) 방식으로 4개의 서브넷으로 나누려면 호스트 부분의 8비트 중 2비트를 서브넷 마스크에 추가해야 합니다.  2비트를 사용하면 4개의 서브넷(2<sup>2</sup> = 4)을 만들 수 있고, 각 서브넷은 64개(2<sup>6</sup>)의 IP 주소를 갖게 됩니다. (256 / 4 = 64).  각 서브넷의 첫 번째 IP는 네트워크 주소이고, 마지막 IP는 브로드캐스트 주소이므로 사용할 수 없습니다. 따라서 각 서브넷에서 실제 사용 가능한 IP 주소는 62개입니다.",53,45
570,1,6,70,C Class에 속하는 IP address는?,,200.168.30.1,10.3.2.1 4,225.2.4.1,172.16.98.3,1,"IP 주소는 네트워크 상에서 컴퓨터를 식별하는 고유한 주소입니다.  IP 주소는 네트워크 클래스에 따라 구분되는데, 클래스 A, B, C 등으로 나뉩니다.  각 클래스는 IP 주소의 첫 번째 옥텟(8비트)의 값에 따라 결정됩니다.  C 클래스 IP 주소는 첫 번째 옥텟이 192~223 사이의 값을 갖습니다.  문제에서 제시된 IP 주소들을 살펴보면, 첫 번째 옥텟이 192~223 사이의 값을 가지는 주소만이 C 클래스에 속합니다. 따라서 정답은 첫 번째 옥텟이 200인 IP 주소입니다.  쉽게 말해,  IP 주소의 앞부분 숫자가 192부터 223 사이라면 C 클래스에 속하는 IP 주소라고 생각하면 됩니다. 다른 IP 주소들은 각각 다른 클래스에 속합니다.  (A 클래스는 1~126, B 클래스는 128~191, C 클래스는 192~223, D 클래스는 224~239, E 클래스는 240~255)",58,45
571,1,6,71,다음 C언어 프로그램이 실행되었을 때의 결과는?,https://www.cbtbank.kr/images/iz/iz20210814/iz20210814m71.gif,0,4,8,12,3,"이 문제는 C언어의 포인터와 메모리 주소 연산에 대한 이해를 묻는 문제입니다.  `int n = 4;`는 정수형 변수 n을 선언하고 4를 저장합니다. `int* pt = NULL;`는 정수형 포인터 변수 pt를 선언하고 NULL(0)을 저장합니다. `pt = &n;`는 pt에 n의 메모리 주소를 저장합니다.  `printf(""%d"", &n + *pt - &pt + n);`는  n의 주소(&n), n의 값(*pt), pt의 주소(&pt), n의 값(n)을 이용한 연산 결과를 출력합니다.",60,41
572,1,6,72,"귀도 반 로섬(Guido van Rossum)이 발표한 언어로 인터프리터 방식이자 객체지향적이며, 배우기 쉽고 이식성이 좋은 것이 특징인 스크립트 언어는?",,C++,JAVA,C#,Python,4,"이 문제는 프로그래밍 언어의 특징을 묻고 있습니다.  제시된 선택지 중 귀도 반 로섬이 개발한 언어로, 인터프리터 방식을 사용하며 객체지향적인 특징을 가지고, 배우기 쉽고 다양한 플랫폼에서 동작하는(이식성이 좋은) 스크립트 언어는 바로 Python입니다.  C++, JAVA, C#은 모두 컴파일 방식의 언어이거나 Python에 비해 배우는 난이도가 높거나 이식성이 다소 떨어지는 특징을 가지고 있습니다.  Python은 간결한 문법과 풍부한 라이브러리를 제공하여 초보자부터 전문가까지 폭넓게 사용되고 있으며, 웹 개발, 데이터 분석, 인공지능 등 다양한 분야에서 활용되고 있는 점이 특징입니다.  따라서, 문제에서 제시된 모든 조건을 만족하는 언어는 Python입니다.",77,42
573,1,6,73,다음 JAVA 프로그램이 실행되었을 때의 결과를 쓰시오.,https://www.cbtbank.kr/images/iz/iz20210814/iz20210814m73.gif,13,21,34,55,3,"이 JAVA 프로그램은 피보나치 수열을 계산하는 코드입니다. 피보나치 수열은 앞의 두 수를 더하여 다음 수를 만드는 수열로, 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ... 와 같이 진행됩니다.  코드에서 `arr` 배열은 피보나치 수열을 저장하는 용도로 사용됩니다.  `arr[0]`과 `arr[1]`에는 초기값 0과 1이 저장되고, `while` 루프를 통해 `arr[2]`부터 `arr[9]`까지 피보나치 수열의 값들이 순차적으로 계산되어 저장됩니다.  `arr[i+2] = arr[i+1] + arr[i];` 라인이 바로 이 계산을 수행하는 부분입니다.  루프가 8번 반복되면 `arr[9]`에는 피보나치 수열의 9번째 값이 저장되고,  `System.out.println(arr[9]);`를 통해 그 값이 출력됩니다. 따라서 프로그램 실행 결과는 피보나치 수열의 9번째 항인 34가 됩니다.",60,11
574,1,6,74,프로세스와 관련한 설명으로 틀린 것은?,,프로세스가 준비 상태에서 프로세서가 배당되어 실행 상태로 변화하는 것을 디스패치(Dispatch)라고 한다.,"프로세스 제어 블록(PCB, Process Control Block)은 프로세스 식별자, 프로세스 상태 등의 정보로 구성된다.",이전 프로세스의 상태 레지스터 내용을 보관하고 다른 프로세스의 레지스터를 적재하는 과정을 문맥 교환(Context Switching)이라고 한다.,"프로세스는 스레드(Thread) 내에서 실행되는 흐름의 단위이며, 스레드와 달리 주소 공간에 실행 스택(Stack)이 없다.",4,"이 문제는 운영체제에서 중요한 개념인 프로세스에 대한 이해도를 묻는 문제입니다.  프로세스는 컴퓨터가 실행하는 프로그램의 활동적인 인스턴스라고 생각하면 됩니다.  즉, 프로그램 코드 자체가 아니라, 그 코드가 실제로 메모리에 적재되어 실행되고 있는 상태를 의미합니다.  문제에서 틀린 설명을 찾아야 하는데,  정답은 프로세스와 스레드의 관계에 대한 잘못된 설명입니다.  프로세스는 독립적인 메모리 공간(주소 공간)을 가지고 있으며, 각 프로세스는 자신만의 실행 스택을 갖습니다. 반면 스레드는 하나의 프로세스 내에서 실행되는 여러 개의 실행 흐름으로,  같은 프로세스의 주소 공간과 자원들을 공유합니다. 따라서 프로세스가 스레드 안에서 실행되는 것이 아니라,  프로세스는 스레드를 포함하는 상위 개념이며, 스레드는 프로세스 내부에서 실행되는 더 작은 실행 단위입니다.  나머지 설명들은 프로세스의 준비상태에서 실행상태로 전환되는 과정(디스패치), 프로세스의 정보를 담는 제어 블록(PCB), 프로세스 간 전환 과정(문맥 교환)을 정확하게 설명하고 있습니다.",69,44
575,1,6,75,모듈의 독립성을 높이기 위한 결합도(Coupling)와 관련한 설명으로 틀린 것은?,,오류가 발생했을 때 전파되어 다른 오류의 원인이 되는 파문 효과(Ripple Effect)를 최소화해야 한다.,인터페이스가 정확히 설정되어 있지 않을 경우 불필요한 인터페이스가 나타나 모듈 사이의 의존도는 높아지고 결합도가 증가한다.,모듈들이 변수를 공유하여 사용하게 하거나 제어 정보를 교류하게 함으로써 결합도를 낮추어야 한다.,다른 모듈과 데이터 교류가 필요한 경우 전역변수(Global Variable)보다는 매개변수(Parameter)를 사용하는 것이 결합도를 낮추는 데 도움이 된다.,3,"모듈의 독립성을 높이기 위해서는 모듈 간의 결합도를 낮추는 것이 중요합니다.  결합도가 높다는 것은 모듈들이 서로 밀접하게 연결되어 있어, 하나의 모듈에 오류가 발생하면 다른 모듈에도 영향을 미치는 '파문 효과'가 발생할 가능성이 높다는 것을 의미합니다.  따라서 오류 발생 시 영향을 최소화하기 위해서는 모듈 간의 의존성을 줄여야 합니다.  잘못된 선지는 모듈들이 변수를 공유하거나 제어 정보를 교류하는 방식으로 결합도를 낮춰야 한다고 주장하는데, 이는 오히려 모듈 간의 의존성을 높이고 결합도를 증가시키는 행위입니다.  변수 공유는 여러 모듈이 같은 메모리 영역을 사용하기 때문에, 하나의 모듈에서 변수 값을 변경하면 다른 모듈에도 영향을 미쳐 예측 불가능한 오류를 발생시킬 수 있습니다.  반면, 매개변수를 사용하면 데이터 교류가 필요한 모듈 간에 명확한 인터페이스를 제공하여, 데이터 흐름을 명확히 하고 의존성을 줄일 수 있습니다.  전역 변수는 여러 모듈에서 접근 가능하기 때문에, 어떤 모듈에서 값을 변경했는지 추적하기 어렵고, 예상치 못한 부작용을 초래할 수 있습니다.  따라서 전역 변수보다는 매개변수를 사용하는 것이 모듈 간의 결합도를 낮추는 데 효과적입니다.  결론적으로, 모듈 간의 데이터 교류는 매개변수를 통해 명확하게 이루어져야 하며, 변수 공유는 결합도를 높이는 요인이므로 피해야 합니다. 이를 통해 모듈의 독립성을 확보하고, 유지보수 및 재사용성을 높일 수 있습니다.",60,6
576,1,6,76,TCP헤더와 관련한 설명으로 틀린 것은?,,순서번호(Sequence Number)는 전달하는 바이트마다 번호가 부여된다.,수신번호확인(Acknowledgement Number)은 상대편 호스트에서 받으려는 바이트의 번호를 정의한다.,체크섬(Checksum)은 데이터를 포함한 세그먼트의 오류를 검사한다.,윈도우 크기는 송수신 측의 버퍼 크기로 최대크기는 32767bit 이다.,4,"TCP 헤더는 데이터를 효율적으로 전송하기 위해 여러 정보를 담고 있습니다.  그 중 틀린 설명은 윈도우 크기에 대한 부분입니다. 윈도우 크기는 송수신 측의 버퍼 크기를 나타내는 값으로,  데이터 전송의 효율성을 높이기 위해 사용됩니다.  하지만 최대 크기가 32767bit 라는 것은 잘못된 정보입니다.  윈도우 크기는 비트 단위가 아닌 바이트 단위로 표현되며,  최대 크기는 TCP 규약에 따라 다르지만,  32767bit 보다 훨씬 큰 값을 가질 수 있습니다.  나머지 설명들, 즉 순서번호를 이용한 데이터 순서 관리, 수신 확인 번호를 이용한 데이터 수신 확인, 체크섬을 이용한 오류 검출 등은 모두 TCP 헤더의 중요한 기능들을 정확하게 설명하고 있습니다. 따라서 윈도우 크기에 대한 설명이 잘못된 것이므로 이 문제의 정답은 윈도우 크기에 대한 설명이 틀린 선지입니다.",69,45
577,1,6,77,모듈화(Modularity)와 관련한 설명으로 틀린 것은?,,"소프트웨어의 모듈은 프로그래밍 언어에서 Subroutine, Function 등으로 표현될 수 있다.","모듈의 수가 증가하면 상대적으로 각 모듈의 크기가 커지며, 모듈 사이의 상호교류가 감소하여 과부하(Overload) 현상이 나타난다.","모듈화는 시스템을 지능적으로 관리할 수 있도록 해주며, 복잡도 문제를 해결하는 데 도움을 준다.",모듈화는 시스템의 유지보수와 수정을 용이하게 한다.,2,"모듈화는 소프트웨어를 여러 개의 독립적인 모듈로 나누어 개발하는 방법입니다.  각 모듈은 특정 기능을 담당하며, 다른 모듈과의 의존성을 최소화하여 개발 및 유지보수를 효율적으로 합니다. 마치 레고 블록처럼, 각 블록(모듈)은 독립적으로 만들어지고, 조립하여 큰 구조물(소프트웨어)을 만드는 것과 같습니다.  문제에서 틀린 설명은 모듈의 수가 증가하면 각 모듈의 크기가 커지고 모듈 간 상호작용이 감소한다는 내용입니다.  오히려 모듈화는 시스템을 작고 관리하기 쉬운 단위로 나누는 것이 목표이므로, 모듈의 수가 증가하면 각 모듈의 크기는 상대적으로 작아지고, 모듈 간의 상호작용은 명확하게 정의되어 관리가 용이해집니다.  모듈 간의 과부하는 잘못된 설계나 과도한 의존성으로 인해 발생할 수 있지만, 모듈화 자체가 과부하를 유발하는 것은 아닙니다.  나머지 설명들은 모두 모듈화의 장점을 잘 나타내고 있습니다.  소프트웨어의 모듈은 함수나 서브루틴으로 표현될 수 있으며, 시스템 관리 및 복잡도 해결, 유지보수 용이성에 기여합니다.",79,6
578,1,6,78,다음 중 페이지 교체(Page Replacement)알고리즘이 아닌 것은?,,FIFO(First-In-First-Out),LUF(Least Used First),Optimal,LRU(Least Recently Used),2,"페이지 교체 알고리즘은 메모리에 모든 페이지를 적재할 수 없을 때, 어떤 페이지를 메모리에서 꺼내고 새로운 페이지를 가져올지를 결정하는 알고리즘입니다.  FIFO(First-In-First-Out)는 가장 먼저 들어온 페이지를 먼저 꺼내는 방식이고, LRU(Least Recently Used)는 가장 최근에 사용되지 않은 페이지를 꺼내는 방식이며, Optimal 알고리즘은 미래에 가장 늦게 사용될 페이지를 꺼내는 최적의 방식입니다.  하지만 문제에서 제시된 나머지 하나는 페이지 교체 알고리즘이 아닙니다.  LUF(Least Used First)는  ""가장 적게 사용된 페이지를 먼저 교체한다""는 의미를 가지고 있지만,  이는 페이지 교체 알고리즘으로 분류되지 않습니다.  페이지 교체 알고리즘은 주로 최근 사용 빈도나 시간에 기반하여 페이지를 교체하는 반면, LUF는 사용 빈도를 기준으로 하지만,  실제 메모리 관리에서 일반적으로 사용되는 알고리즘은 아닙니다.  따라서 정보처리기사 공식 교재를 참고하여 페이지 교체 알고리즘의 정의와 종류를 확인하면,  정답을 쉽게 찾을 수 있습니다.  결론적으로,  제시된 네 가지 중 하나는 페이지 교체 알고리즘의 범주에 속하지 않습니다.",46,11
579,1,6,79,C언어에서의 변수 선언으로 틀린 것은?,,int else;,int Test2;,int pc;,int True;,1,"C언어에서 변수를 선언할 때는 몇 가지 규칙을 따라야 합니다.  변수 이름은 영문자, 숫자, 밑줄(_)로 시작해야 하며, 예약어를 사용할 수 없습니다.  예약어란 C언어에서 이미 특별한 의미를 가지고 있는 단어들입니다.  문제에서 제시된 옵션 중 하나는 C언어의 예약어를 변수 이름으로 사용하고 있습니다.  예약어를 변수 이름으로 사용하면 컴파일러가 변수 선언인지, 예약어인지 구분하지 못해 오류가 발생합니다. 따라서 예약어를 사용한 변수 선언은 잘못된 것입니다.  다른 옵션들은 모두 올바른 변수 선언 형식을 따르고 있습니다.  변수 이름은 의미를 파악하기 쉽도록 짓는 것이 좋습니다.",71,41
580,1,6,80,파일 디스크립터(File Descriptor)에 대한 설명으로 틀린 것은?,,파일 관리를 위해 시스템이 필요로 하는 정보를 가지고 있다.,보조기억장치에 저장되어 있다가 파일이 개방(open)되면 주기억장치로 이동된다.,사용자가 파일 디스크립터를 직접 참조할 수 있다.,파일 제어 블록(File Control Block)이라고도 한다.,3,"파일 디스크립터는 운영체제가 파일을 관리하기 위해 사용하는 내부적인 정보입니다.  마치 도서관 사서가 책의 위치와 정보를 기록해 책을 쉽게 찾을 수 있도록 하는 것과 같습니다.  사용자가 직접 파일 디스크립터를 보고 조작하는 것은 불가능합니다. 운영체제가 이를 추상화하여 사용자에게는 파일 이름으로 파일을 접근할 수 있도록 제공합니다.  파일이 열리면 운영체제는 파일의 정보를 주기억장치(RAM)에 로드하여 빠르게 접근할 수 있도록 하지만, 파일 디스크립터 자체는 주기억장치에만 존재하는 것이 아니라, 파일 시스템의 메타데이터(파일 정보)를 담고 있는 파일 제어 블록(FCB)과 연관되어 보조기억장치(하드디스크)에도 정보가 저장되어 있습니다.  따라서 파일 디스크립터는 파일 관리에 필요한 정보를 가지고 있고, 파일 제어 블록과 밀접한 관련이 있습니다.  하지만 사용자가 직접 파일 디스크립터를 참조하는 것은 불가능합니다.",72,44
581,1,6,81,침입탐지 시스템(IDS : Intrusion Detection System)과 관련한 설명으로 틀린 것은?,,이상 탐지 기법(Anomaly Detection)은 Signature Base나 Knowledge Base라고도 불리며 이미 발견되고 정립된 공격 패턴을 입력해두었다가 탐지 및 차단한다.,HIDS(Host-Based Intrusion Detection)는 운영체제에 설정된 사용자 계정에 따라 어떤 사용자가 어떤 접근을 시도하고 어떤 작업을 했는지에 대한 기록을 남기고 추적한다.,NIDS(Network-Based Intrusion Detection System)로는 대표적으로 Snort가 있다.,외부 인터넷에 서비스를 제공하는 서버가 위치하는 네트워크인 DMZ(Demilitarized Zone)에는 IDS가 설치될 수 있다.,1,"침입탐지 시스템(IDS)에 대한 문제입니다.  각 선지들을 살펴보면,  잘못된 설명을 찾는 것이 문제의 핵심입니다.  먼저, 이상 탐지 기법은 기존에 알려진 공격 패턴(시그니처)을 기반으로 탐지하는 시그니처 기반 탐지와는 다릅니다. 이상 탐지 기법은 정상적인 시스템 동작 패턴을 학습하여, 이 패턴에서 벗어나는 비정상적인 활동을 탐지하는 방식입니다.  따라서, 이미 발견되고 정립된 공격 패턴을 입력해두었다는 설명은 잘못되었습니다.  나머지 선지들은 모두 침입탐지 시스템의 특징을 정확하게 설명하고 있습니다. HIDS는 호스트(개별 컴퓨터)의 활동을 모니터링하고, NIDS는 네트워크 트래픽을 감시하며, DMZ와 같은 중요한 네트워크 영역에 IDS를 설치하는 것은 일반적인 보안 관행입니다.  결론적으로,  정상적인 시스템 동작 패턴과의 차이를 탐지하는 이상 탐지 기법의 원리를 잘못 이해하고 있는 선지가 틀린 것입니다.",43,55
582,1,6,82,정보 시스템 내에서 어떤 주체가 특정 개체에 접근하려 할 때 양쪽의 보안 레이블(Security Label)에 기초하여 높은 보안 수준을 요구하는 정보(객체)가 낮은 보안 수준의 주체에게 노출되지 않도록 하는 접근 제어 방법은?,,Mandatory Access Control,User Access Control,Discretionary Access Control,Data-Label Access Control,1,"이 문제는 정보 시스템의 접근 제어 방식 중 하나를 묻고 있습니다.  정보 시스템에서는 중요한 데이터를 보호하기 위해 접근 권한을 관리하는데, 여러 가지 방법이 있습니다.  문제에서 설명하는 방식은 높은 보안 수준의 정보가 낮은 보안 수준의 주체에게 절대로 노출되지 않도록 엄격하게 제어하는 방식입니다.  마치 군사 기밀처럼, 정보 자체에 보안 등급이 매겨져 있고, 접근하려는 주체의 보안 등급이 정보의 보안 등급보다 낮으면 접근을 차단하는 것입니다.  예를 들어, '극비' 문서는 '극비' 이상의 보안 등급을 가진 주체만 접근할 수 있고, '비밀' 등급의 주체는 접근 자체가 불가능합니다. 이러한 엄격한 접근 제어는 시스템의 보안 수준을 높이는 데 매우 효과적입니다.  반대로, 다른 접근 제어 방식들은 정보 소유자의 재량에 따라 접근 권한을 부여하거나, 사용자의 권한에 따라 접근을 제어하는 방식으로,  정보의 보안 등급에 따라 접근을 엄격하게 제어하는 방식과는 다릅니다. 따라서 정보의 보안 등급에 따라 접근을 엄격하게 제어하는 방식이 정답입니다.  정보처리기사 공식 교재에서도 이러한 개념을 명확하게 설명하고 있을 것입니다.",45,31
583,1,6,83,구글의 구글 브레인 팀이 제작하여 공개한 기계 학습(Machine Leaming)을 위한 오픈소스 소프트웨어 라이브러리는?,,타조(Tajo),원 세그(One Seg),포스퀘어(Foursquare),텐서플로(TensorFlow),4,"이 문제는 구글에서 개발하여 무료로 배포하는 인공지능(AI) 개발에 사용되는 도구를 묻고 있습니다.  쉽게 말해,  레고 블록처럼 다양한 기능을 가진 블록들을 조합하여 인공지능 프로그램을 만들 수 있도록 돕는 소프트웨어 라이브러리입니다.  '기계 학습(Machine Learning)'이라는 용어는 컴퓨터가 스스로 학습하고 발전하는 기술을 의미하는데, 이 라이브러리는 바로 그 기계 학습을 위한 강력한 도구를 제공합니다.  제시된 선택지 중에서 구글의 구글 브레인 팀이 개발하여 공개한 오픈소스 소프트웨어 라이브러리는 텐서플로(TensorFlow)입니다.  텐서플로는 이미지 인식, 자연어 처리, 음성 인식 등 다양한 분야의 인공지능 개발에 널리 사용되고 있으며, 전 세계 많은 개발자들이 활용하고 있는 매우 유명하고 강력한 도구입니다. 다른 선택지는 인공지능 개발과 직접적인 관련이 없습니다.",71,43
584,1,6,84,"국내 IT 서비스 경쟁력 강화를 목표로 개발되었으며 인프라 제어 및 관리 환경, 실행 환경, 개발 환경, 서비스 환경, 운영환경으로 구성되어 있는 개방형 클라우드 컴퓨팅 플랫폼은?",,N20S,PaaS-TA,KAWS,Metaverse,2,"문제에서 국내 IT 서비스 경쟁력 강화를 목표로 개발되었고, 인프라 제어 및 관리 환경, 실행 환경, 개발 환경, 서비스 환경, 운영 환경으로 구성된 개방형 클라우드 컴퓨팅 플랫폼을 묻고 있습니다.  쉽게 말해, 국내에서 IT 서비스를 더 잘 만들고 운영하기 위해 만든 클라우드 시스템인데,  소프트웨어 개발부터 실행, 관리까지 필요한 모든 환경을 제공하는 종합적인 플랫폼이라는 뜻입니다.  여러 선택지 중에서 이러한 조건을 모두 만족하는 것은 바로 PaaS-TA입니다. PaaS-TA는 Public Platform as a Service - Trusted Architecture의 약자로,  국내에서 개발되어 국내 IT 서비스 경쟁력 강화를 목표로 하는 개방형 클라우드 플랫폼입니다.  다른 선택지는 이러한 조건을 충족하지 못합니다.  따라서 정답은 PaaS-TA입니다.",60,38
585,1,6,85,정보 보안을 위한 접근 제어(Access Control)과 관련한 설명으로 틀린 것은?,,적절한 권한을 가진 인가자만 특정 시스템이나 정보에 접근할 수 있도록 통제하는 것이다.,시스템 및 네트워크에 대한 접근 제어의 가장 기본적인 수단은 IP와 서비스 포트로 볼 수 있다.,DBMS에 보안 정책을 적용하는 도구인 XDMCP를 통해 데이터베이스에 대한 접근제어를 수행할 수 있다.,네트워크 장비에서 수행하는 IP에 대한 접근 제어로는 관리 인터페이스의 접근제어와 ACL(Access Control List) 등 있다.,3,"정보 보안에서 접근 제어는 특정 시스템이나 정보에 대한 접근을 권한이 있는 사용자에게만 허용하는 중요한 보안 기능입니다.  첫 번째 설명처럼,  적절한 권한을 가진 사용자만 접근을 허용하는 것은 접근 제어의 기본 원칙입니다. 네 번째 설명 또한 네트워크 장비에서 IP 기반 접근 제어를 수행하는 방법(관리 인터페이스 제어, ACL 등)을 정확하게 설명하고 있습니다.  하지만,  틀린 설명은 데이터베이스 접근 제어 도구로 XDMCP를 언급한 부분입니다. XDMCP는 X Display Manager Control Protocol의 약자로,  데이터베이스 접근 제어와는 전혀 관련이 없는 원격 X 윈도우 시스템 관리 프로토콜입니다.  데이터베이스 접근 제어는 DBMS 자체의 기능이나,  다른 보안 도구(예:  RBAC,  접근 제어 목록 등)를 통해 이루어집니다. 따라서 XDMCP를 데이터베이스 접근 제어 도구로 언급한 것은 잘못된 정보입니다.  두 번째 설명의 경우, IP와 서비스 포트는 시스템 및 네트워크 접근 제어의 기본적인 수단으로 볼 수 있으므로 틀린 설명이 아닙니다.  결론적으로, 데이터베이스 접근 제어 도구에 대한 잘못된 설명 때문에 문제의 정답이 결정됩니다.",58,31
586,1,6,86,소프트웨어 개발 프레임워크와 관련한 설명으로 틀린 것은?,,반제품 상태의 제품을 토대로 도메인별로 필요한 서비스 컴포넌트를 사용하여 재사용성 확대와 성능을 보장 받을 수 있게하는 개발 소프트웨어이다.,개발해야 할 애플리케이션의 일부분이 이미구현되어 있어 동일한 로직 반복을 줄일 수있다.,라이브러리와 달리 사용자 코드가 직접호출하여 사용하기 때문에 소프트웨어 개발프레임워크가 직접 코드의 흐름을 제어할수 없다.,생산성 향상과 유지보수성 향상 등의장점이 있다.,3,"소프트웨어 개발 프레임워크는 마치 레고 블록과 같습니다.  미리 만들어진 블록(컴포넌트)들을 조립하여 다양한 형태의 제품(애플리케이션)을 만들 수 있도록 도와주는 도구입니다.  따라서, 이미 구현된 부분을 재사용하여 개발 시간을 단축하고, 일관성 있는 코드를 유지하는 데 도움을 줍니다.  틀린 설명은 프레임워크가 사용자 코드의 흐름을 제어하지 못한다는 것입니다.  프레임워크는  사용자 코드를 호출하는 것뿐 아니라,  전체적인 애플리케이션의 흐름을 제어하는 역할을 합니다.  사용자는 프레임워크가 제공하는 틀 안에서 코드를 작성하고, 프레임워크는 이 코드들을 적절한 순서로 실행하여 애플리케이션을 동작시킵니다.  마치 기차 레일 위를 기차가 달리는 것처럼, 사용자 코드는 프레임워크가 제공하는 틀(레일)을 따라 실행됩니다.  따라서 프레임워크는 사용자 코드를 단순히 호출하는 수준을 넘어, 애플리케이션의 전체적인 흐름을 제어하는 역할을 수행합니다.  다른 설명들은 모두 프레임워크의 장점과 특징을 잘 나타내고 있습니다.",82,48
587,1,6,87,물리적 배치와 상관없이 논리적으로 LAN을구성하여 Broadcast Domain을 구분할 수있게 해주는 기술로 접속된 장비들의 성능향상 및 보안성 증대 효과가 있는 것은?,,VLAN,STP,L2AN,ARP,1,"이 문제는 물리적인 위치와 상관없이 논리적으로 네트워크를 분할하여 관리하는 기술을 묻고 있습니다.  쉽게 말해, 같은 건물 안에 있는 컴퓨터들이라도 서로 다른 부서에 속해 있다면,  물리적으로는 같은 네트워크에 연결되어 있더라도,  서로 다른 네트워크처럼 분리하여 관리하고 싶을 것입니다.  이때 사용하는 기술이 바로 VLAN(Virtual LAN)입니다.  VLAN은 스위치 내부에서 논리적으로 네트워크를 분할하는 기술로,  물리적인 케이블 연결과는 무관하게 가상적인 LAN을 여러 개 만들 수 있습니다.  각 VLAN은 브로드캐스트 도메인(Broadcast Domain)이 분리되어 있어,  특정 VLAN 내에서만 브로드캐스트 통신이 이루어지므로,  네트워크 트래픽을 효율적으로 관리하고 보안성을 높일 수 있습니다.  따라서 접속된 장비들의 성능 향상과 보안성 증대 효과를 가져옵니다.  다른 선택지들은 네트워크 구성에 관련된 기술이지만,  물리적 배치와 상관없이 논리적으로 LAN을 구성하고 브로드캐스트 도메인을 구분하는 기능은 VLAN만이 가지고 있습니다.  STP는 네트워크 루프를 방지하고, L2AN은 2계층 네트워크 접근 제어, ARP는 IP 주소와 MAC 주소를 매핑하는 프로토콜로, 문제에서 요구하는 기능과는 다릅니다.",68,49
588,1,6,88,SQL Injection 공격과 관련한 설명으로 틀린것은?,,SQL Injection은 임의로 작성한 SQL 구문을 애플리케이션에 삽입하는 공격방식이다.,SQL Injection 취약점이 발생하는 곳은 주로웹 애플리케이션과 데이터베이스가 연동되는 부분이다.,DBMS의 종류와 관계없이 SQL Injection공격 기법은 모두 동일하다.,로그인과 같이 웹에서 사용자의 입력 값을 받아 데이터베이스 SQL문으로 데이터를요청하는 경우 SQL Injection을 수행할 수 있다.,3,"SQL Injection 공격은 악의적인 사용자가 웹 애플리케이션에 악성 SQL 코드를 입력하여 데이터베이스를 조작하는 공격 방식입니다.  예를 들어, 로그인 페이지에서 사용자 이름과 비밀번호를 입력하는 곳에 특수 문자를 섞어 SQL 문법을 완성하는 형태로 공격이 이루어질 수 있습니다.  이렇게 하면 애플리케이션은 사용자의 입력을 제대로 검증하지 못하고, 악성 SQL 코드를 데이터베이스에 직접 실행하게 되어 데이터 유출, 수정, 삭제 등 심각한 피해를 초래할 수 있습니다.  따라서 웹 애플리케이션과 데이터베이스가 연동되는 부분은 SQL Injection 공격에 취약할 수밖에 없습니다.  하지만, 모든 DBMS(데이터베이스 관리 시스템)의 구조와 SQL 문법이 완전히 동일한 것은 아니기 때문에,  SQL Injection 공격 기법도 DBMS의 종류에 따라 다르게 적용되어야 합니다.  즉, 특정 DBMS에 효과적인 공격 기법이 다른 DBMS에서는 효과가 없을 수도 있습니다.  따라서 모든 DBMS에서 동일한 공격 기법이 적용된다는 주장은 틀린 것입니다.  로그인 페이지와 같이 사용자 입력을 받아 데이터베이스에 SQL 쿼리를 전달하는 모든 지점은 SQL Injection 공격의 위험에 노출될 수 있습니다.",80,53
589,1,6,89,비대칭 암호화 방식으로 소수를 활용한암호화 알고리즘은?,,DES,AES,SMT,RSA,4,"이 문제는 비대칭 암호화 방식 중 소수를 활용하는 알고리즘을 묻고 있습니다.  비대칭 암호화는 두 개의 서로 다른 키, 즉 공개키와 개인키를 사용하는 암호화 방식입니다.  공개키는 누구에게나 공개해도 되지만, 개인키는 소유자만 알고 있어야 합니다.  공개키로 암호화된 데이터는 오직 대응하는 개인키로만 복호화할 수 있고, 개인키로 암호화된 데이터는 오직 대응하는 공개키로만 복호화할 수 있습니다.",67,54
590,1,6,90,다음에서 설명하는 IT 스토리지 기술은?,https://www.cbtbank.kr/images/iz/iz20210814/iz20210814m90.gif,Software Defined Storage,Distribution Oriented Storage,Network Architected Storage,Systematic Network Storage,1,"문제에서 설명하는 IT 스토리지 기술은 소프트웨어 기반으로 스토리지 자원을 가상화하고 관리하는 기술입니다.  마치 서버 가상화처럼 필요한 만큼의 스토리지 공간을 나누어 사용할 수 있도록 하며, 여러 개의 물리적인 스토리지를 하나의 통합된 시스템처럼 관리하는 것이 핵심입니다.  문제에서 제시된 설명을 보면 ""가상화를 적용하며 필요한 공간만큼 나눠 사용할 수 있도록 하여 서버 가상화와 유사함"", ""컴퓨팅 소프트웨어로 구성하는 데이터 스토리지 체계이며, 일정 조직 내 여러 스토리지를 하나처럼 관리하고 운용하는 컴퓨터 이용 환경"", ""스토리지 자원을 효율적으로 나누어 쓰는 방법으로 이해할 수 있음"" 등의 특징이 모두 이러한 소프트웨어 정의 스토리지(Software Defined Storage)의 특징과 정확히 일치합니다.  다른 선택지는 네트워크 구조나 분산 방식 등 스토리지의 물리적인 구성이나 배치 방식에 초점을 맞추고 있지만, 문제에서 강조하는 것은 소프트웨어를 통한 가상화 및 통합 관리라는 점입니다. 따라서 소프트웨어 정의 스토리지가 가장 적절한 답입니다.  쉽게 말해,  레고 블록처럼 여러 개의 스토리지 장치를 소프트웨어로 묶어서 하나의 큰 스토리지처럼 사용하는 기술이라고 생각하면 이해하기 쉬울 것입니다.",47,51
591,1,6,91,"Cocomo model 중 기관 내부에서 개발된 중소규모의 소프트웨어로 일괄 자료 처리나 과학기술계산용, 비즈니스 자료 처리용으로 5만 라인이하의 소프트웨어를 개발하는 유형은?",,Embeded,Organic,Semi-detached,Semi-embeded,2,"COCOMO 모델은 소프트웨어 개발에 필요한 시간과 비용을 예측하는 모델입니다.  문제에서 제시된 상황은 기관 내부에서 개발되는 중소규모의 소프트웨어, 즉 규모가 작고 개발팀의 경험이 풍부하며, 개발 환경이 안정적인 상황을 가정합니다.  COCOMO 모델은 이러한 상황의 특성에 따라  '유기적(Organic)', '반분리적(Semi-detached)', '내장형(Embedded)' 등 여러 유형으로 나뉘는데,  문제에서 제시된 조건(5만 라인 이하, 일괄 자료 처리나 과학기술계산용, 비즈니스 자료 처리용)은  소규모 개발팀이 안정적인 환경에서 개발하는 '유기적(Organic)' 유형의 소프트웨어 개발에 가장 잘 맞습니다.  '유기적' 유형은 개발 규모가 작고, 팀원 간의 의사소통이 원활하며, 개발 환경이 안정적이라는 특징을 가지고 있기 때문입니다.  반면, '반분리적' 유형은 유기적 유형보다 규모가 크고 복잡하며, '내장형' 유형은 특정 하드웨어에 내장되는 소프트웨어를 의미하므로 문제의 조건과는 부합하지 않습니다. 따라서, 문제의 조건에 가장 적합한 COCOMO 모델 유형은 '유기적'입니다.",69,47
592,1,6,92,다음 내용이 설명하는 것은?,https://www.cbtbank.kr/images/iz/iz20210814/iz20210814m92.gif,Format String,Ransomware,Buffer overflow,Adware,2,"문제에서 설명하는 악성 프로그램은 개인, 기업, 국가에 큰 피해를 주는 사이버 범죄의 주요 수단입니다.  시스템을 잠그거나 데이터를 암호화하여 사용할 수 없도록 만든 후, 이를 인질로 삼아 금전을 요구하는 특징을 가지고 있습니다.  이는 바로 랜섬웨어(Ransomware)의 정확한 설명입니다.  랜섬웨어는 사용자의 파일이나 시스템 전체를 암호화하여 접근을 차단하고, 암호 해제를 위해 금전을 요구하는 악성 프로그램입니다.  문제에서 언급된 Snake, Darkside 등은 실제로 존재하는 유명한 랜섬웨어의 예시입니다.  다른 선지들은 랜섬웨어와는 다른 유형의 악성 프로그램이나 보안 취약점을 나타냅니다.  Format String은 특정 형식 문자열을 악용하는 공격 기법이고, Buffer overflow는 버퍼의 크기를 초과하는 데이터를 입력하여 시스템을 공격하는 기법이며, Adware는 광고를 강제로 표시하는 악성 프로그램입니다. 따라서 문제의 설명과 가장 잘 일치하는 것은 랜섬웨어입니다.",86,56
593,1,6,93,"생명주기 모형 중 가장 오래된 모형으로 많은적용 사례가 있지만 요구사항의 변경이어렵고 각 단계의 결과가 확인 되어야 다음단계로 넘어갈 수 있는 선형 순차적, 고전적생명 주기 모형이라고도 하는 것은?",,Waterfall Model,Prototype Model,Cocomo Model,Spiral Model,1,"문제에서 설명하고 있는 생명주기 모형은,  소프트웨어 개발 과정을 여러 단계로 나누어 순차적으로 진행하는 방식입니다.  가장 큰 특징은 각 단계가 완료된 후에만 다음 단계로 넘어갈 수 있다는 점입니다.  마치 폭포수가 위에서 아래로 떨어지는 것처럼 단계별로 흐르기 때문에 '폭포수 모형'이라고 불립니다.  이 모형은 가장 오래된 소프트웨어 개발 방법론 중 하나이며,  단계별 산출물이 명확하고 관리가 용이하다는 장점이 있습니다.  하지만,  한 단계가 완료된 후에 요구사항 변경이 어렵다는 단점이 있습니다.  요구사항 변경이 발생하면 전체 프로젝트 일정에 큰 차질이 생길 수 있기 때문에 유연성이 부족하다는 비판을 받기도 합니다.  하지만,  많은 프로젝트에서 오랫동안 사용되어 왔고,  그만큼 많은 적용 사례가 존재하는 것은 사실입니다.  문제에서 언급된 '선형 순차적, 고전적 생명주기 모형'이라는 설명은 바로 이 폭포수 모형의 특징을 정확하게 나타내고 있습니다.",82,47
594,1,6,94,소프트웨어 생명주기 모형 중 Spiral Model에 대한 설명으로 틀린 것은?,,비교적 대규모 시스템에 적합하다.,"개발 순서는 계획 및 정의, 위험 분석, 공학적 개발, 고객 평가 순으로 진행된다.",소프트웨어를 개발하면서 발생할 수 있는 위험을 관리하고 최소화하는 것을 목적으로 한다.,"계획, 설계, 개발, 평가의 개발 주기가 한번만 수행된다.",4,"소프트웨어 생명주기 모형 중 나선형 모델(Spiral Model)은 위험 관리에 초점을 맞춘 반복적인 모델입니다.  각 단계(계획 및 정의, 위험 분석, 공학적 개발, 고객 평가)를 거치면서 소프트웨어를 점진적으로 개발하고, 각 단계마다 위험을 평가하고 관리하며, 필요에 따라 계획을 수정하는 특징이 있습니다.  따라서 소프트웨어 개발 과정에서 발생할 수 있는 위험을 최소화하는 것을 목표로 하며, 대규모 시스템 개발에 적합합니다.  중요한 점은 이러한 개발 주기가 한 번만 수행되는 것이 아니라, 위험 분석 결과와 고객 평가에 따라 여러 번 반복된다는 것입니다.  문제에서 틀린 설명은 개발 주기가 한 번만 수행된다는 부분입니다. 나선형 모델은 위험을 줄이고 품질을 높이기 위해 반복적인 개발 과정을 거치는 것이 핵심이기 때문입니다.  마치 나선형 계단처럼 위로 올라가면서 점점 완성도 높은 소프트웨어를 만들어가는 방식이라고 생각하면 이해하기 쉬울 것입니다.",79,47
595,1,6,95,"특정 사이트에 매우 많은 ICMP Echo를 보내면, 이에 대한 응답(Respond)을 하기 위해 시스템 자원을 모두 사용해버려 시스템이 정상적으로 동작하지 못하도록 하는 공격방법은?",,Role-Based Access Control,Ping Flood,Brute-Force,Trojan Horses,2,"이 문제는 시스템을 마비시키는 네트워크 공격 방식에 대한 질문입니다.  많은 수의 ICMP Echo 요청, 즉 ping 요청을 특정 사이트에 끊임없이 보내는 것을 생각해 보세요.  ping은 네트워크 연결 상태를 확인하는 데 사용되는 기본적인 네트워크 진단 도구입니다.  ping 요청을 보내면, 목표 시스템은 ICMP Echo Reply(응답) 패킷을 보내 응답합니다.  하지만, 매우 많은 ping 요청이 동시에 쏟아진다면, 시스템은 이 모든 응답 패킷을 처리하기 위해 엄청난 양의 자원(CPU, 메모리, 네트워크 대역폭 등)을 소모하게 됩니다.  마치 한꺼번에 너무 많은 손님이 식당에 몰려와 주문을 폭주시켜 주방이 감당하지 못하는 것과 같습니다.  결국 시스템은 과부하에 걸려 정상적인 서비스를 제공할 수 없게 되고,  결과적으로 시스템이 마비되는 것입니다. 이러한 공격 방식을 ""Ping Flood"" 공격이라고 부릅니다.  다른 선택지들은 시스템 자원을 고갈시키는 방식과는 다르게, 접근 제어(Role-Based Access Control),  비밀번호 무차별 대입 공격(Brute-Force),  트로이 목마(Trojan Horses) 등 다른 유형의 공격 방법을 나타냅니다.",77,55
596,1,6,96,TCP/IP 기반 네트워크에서 동작하는 발행-구독 기반의 메시징 프로토콜로 최근 IoT 환경에서 자주 사용되고 있는 프로토콜은?,,MLFQ,MQTT,Zigbee,MTSP,2,"이 문제는 TCP/IP 기반 네트워크에서 동작하는 발행-구독 방식의 메시징 프로토콜을 묻고 있습니다.  발행-구독 방식이란, 정보를 생산하는 쪽(발행자)이 정보를 특정 대상에게 직접 보내는 것이 아니라,  정보를 주제별로 분류하여 게시판에 올려놓으면, 그 정보에 관심 있는 쪽(구독자)이 알아서 가져가는 방식입니다.  마치 신문 구독과 같은 개념이라고 생각하면 이해하기 쉽습니다.  IoT 환경에서는 수많은 장치들이 서로 정보를 주고받아야 하는데, 이때 발행-구독 방식은 효율적이고 확장성이 뛰어납니다.  문제에서 제시된 답변들 중, MQTT 프로토콜은 경량화된 메시징 프로토콜로 IoT 환경에서  발행-구독 방식을 지원하며,  TCP/IP 네트워크를 기반으로 동작하기 때문에 정답입니다. 다른 선택지는 IoT 환경에서 사용되기는 하지만, 문제에서 요구하는 발행-구독 기반의 메시징 프로토콜이 아니거나, TCP/IP 기반이 아닌 다른 네트워크 기술을 사용합니다. 따라서 MQTT가 가장 적합한 답변입니다.",62,45
597,1,6,97,시스템이 몇 대가 되어도 하나의 시스템에서 인증에 성공하면 다른 시스템에 대한 접근권한도 얻는 시스템을 의미하는 것은?,,SOS,SBO,SSO,SOA,3,"이 문제는 여러 시스템에 접근할 때, 각 시스템마다 별도로 로그인할 필요 없이 한 번의 인증으로 모든 시스템에 접근할 수 있는 시스템을 묻고 있습니다.  마치 여러 개의 문이 있는 건물에 들어갈 때, 첫 번째 문에서 신분증을 확인하면 나머지 문들은 자동으로 열리는 것과 같습니다.  따라서 정답은 하나의 인증으로 여러 시스템에 접근할 수 있도록 하는 'Single Sign-On(SSO)' 시스템입니다.  다른 선택지는 시스템 통합이나 아키텍처와 관련된 용어이지만, 문제에서 묻는 '한 번의 인증으로 여러 시스템 접근'이라는 개념과는 직접적인 관련이 없습니다.  SSO는 사용자 편의성을 높이고, 보안 관리를 효율적으로 할 수 있도록 돕는 중요한 시스템 아키텍처 개념입니다.",67,55
598,1,6,98,시스템에 저장되는 패스워드들은 Hash 또는 암호화 알고리즘의 결과 값으로 저장된다. 이때 암호공격을 막기 위해 똑같은 패스워드들이 다른 암호 값으로 저장되도록 추가되는 값을 의미하는 것은?,,Pass flag,Bucket,Opcode,Salt,4,"시스템에 저장되는 패스워드는 보안상 중요한 정보이기 때문에,  원본 패스워드를 그대로 저장하는 것은 매우 위험합니다.  만약 해커가 시스템에 침입하여 패스워드 데이터베이스에 접근하게 된다면, 모든 사용자의 패스워드를 쉽게 알아낼 수 있기 때문입니다.  따라서, 패스워드는 해시(Hash) 함수나 암호화 알고리즘을 이용하여 변환된 값으로 저장됩니다.  하지만, 같은 패스워드를 사용하는 여러 사용자가 있다면,  그들의 패스워드는 모두 같은 해시 값으로 변환되어 저장될 것입니다.  이 경우, 해커가 해시 값을 하나만 탈취하더라도, 그 해시 값에 해당하는 패스워드를 사용하는 모든 사용자의 계정을 탈취할 수 있습니다.  이러한 공격을 막기 위해,  각 패스워드에 무작위로 생성된 값(Salt)을 추가하여 해시 연산을 수행합니다.  이 Salt 값은 각 사용자마다 다르게 생성되므로, 같은 패스워드라도 Salt 값이 다르면 다른 해시 값을 생성하게 됩니다.  결과적으로,  해커가 하나의 해시 값을 탈취하더라도, 다른 사용자의 계정을 탈취하는 데는 사용할 수 없게 되는 것입니다.  즉, Salt는 같은 패스워드를 다른 암호 값으로 저장되도록 하는 데 필수적인 값입니다.",55,54
599,1,6,99,"S/W 각 기능의 원시 코드 라인수의 비관치, 낙관치, 기대치를 측정하여 예측치를 구하고 이를 이용하여 비용을 산정하는 기법은?",,Effort Per Task기법,전문가 감정 기법,델파이기법,LOC기법,4,"소프트웨어 개발 비용을 산정하는 방법 중 하나는 소프트웨어의 크기를 측정하여 비용을 예측하는 것입니다.  이때 소프트웨어의 크기를 측정하는 가장 직관적인 방법은 원시 코드의 라인 수(Lines of Code, LOC)를 세는 것입니다.  문제에서 제시된 기법은 각 기능의 원시 코드 라인 수를 비관적으로 예측한 값, 낙관적으로 예측한 값, 그리고 가장 현실적인 기대치를 측정하여 이 세 값을 바탕으로 평균적인 예측치를 구하는 방식입니다. 이렇게 얻어진 예측치를 이용하여 개발에 필요한 시간과 비용을 산정하는 것이죠.  다른 방법들(전문가의 주관적인 판단에 의존하는 방법이나, 설문조사를 통해 의견을 수렴하는 방법 등)과 달리, 이 기법은 소프트웨어의 크기를 객관적인 지표인 코드 라인 수를 기반으로 하기 때문에 상대적으로 정확한 비용 산정이 가능합니다.  따라서 원시 코드 라인 수를 이용하여 소프트웨어 개발 비용을 산정하는 기법은 LOC 기법입니다.",66,47
600,1,6,100,"오픈소스 웹 애플리케이션 보안 프로젝트로서 주로 웹을 통한 정보 유출, 악성 파일 및 스크립트, 보안 취약점 등을 연구하는 곳은?",,WWW,OWASP,WBSEC,ITU,2,"문제에서 제시된 오픈소스 웹 애플리케이션 보안 프로젝트는 웹을 통한 정보 유출, 악성 파일 및 스크립트, 보안 취약점 등을 연구하는 곳입니다.  OWASP(Open Web Application Security Project)는 바로 이러한 목표를 가진 대표적인 오픈소스 프로젝트입니다.  웹 애플리케이션의 보안 취약성을 발견하고, 이를 해결하기 위한 가이드라인과 도구를 제공하는 것을 주요 목표로 하죠.  다른 선택지들은 웹과 관련된 기관이나 기술을 나타내지만, 웹 애플리케이션 보안에 특화된 오픈소스 프로젝트로서의 역할을 수행하는 곳은 OWASP입니다.  쉽게 말해, 웹사이트의 보안 구멍을 찾아내고 막는 방법을 연구하는 전 세계 개발자들의 공동 프로젝트라고 생각하시면 됩니다.  따라서 정답은 OWASP입니다.",64,50
601,1,7,1,User Interface 설계 시 오류 메시지나 경고에 관한 지침으로 가장 거리가 먼 것은?,,메시지는 이해하기 쉬워야 한다.,오류로부터 회복을 위한 구체적인 설명이 제공되어야 한다.,오류로 인해 발생 될 수 있는 부정적인 내용을 적극적으로 사용자들에게 알려야 한다.,소리나 색의 사용을 줄이고 텍스트로만 전달하도록 한다.,4,"User Interface(UI) 설계에서 오류 메시지나 경고는 사용자 경험에 직접적인 영향을 미치는 중요한 요소입니다.  사용자가 오류를 쉽게 이해하고 문제를 해결할 수 있도록 명확하고 친절한 안내가 필수적입니다.  따라서 오류 메시지는 간결하고 이해하기 쉬운 언어로 작성되어야 하며,  문제 발생 원인과 해결 방법을 구체적으로 제시해야 합니다.  사용자에게 불안감이나 부정적인 감정을 유발하는 표현은 피해야 하며,  오류 해결을 위한 긍정적인 안내가 중요합니다.  소리나 색상을 과도하게 사용하면 오히려 사용자에게 혼란을 야기할 수 있으므로,  텍스트 기반의 명확한 메시지 전달이 효과적입니다.  반면,  오류 발생 가능성이나 부정적인 결과를 사용자에게 적극적으로 알리는 것은 사용자에게 불필요한 불안감을 줄 수 있고,  UI 디자인의 목표인 사용자 경험을 저해할 수 있습니다.  따라서 오류 메시지 디자인은 사용자 중심적인 접근이 중요하며,  긍정적이고 효율적인 문제 해결을 위한 안내에 초점을 맞춰야 합니다.  문제에서 가장 거리가 먼 것은 바로 이러한 사용자 중심적인 접근과 배치되는 선택지입니다.  즉,  오류에 대한 부정적인 측면을 강조하는 것은 사용자에게 불필요한 스트레스를 주고,  UI의 목표 달성에 방해가 될 수 있습니다.",87,4
602,1,7,2,다음 중 애자일(Agile) 소프트웨어 개발에 대한 설명으로 틀린 것은?,,공정과 도구보다 개인과의 상호작용을 더 가치 있게 여긴다.,동작하는 소프트웨어보다는 포괄적인 문서를 가치 있게 여긴다.,계약 협상보다는 고객과의 협력을 가치 있게 여긴다.,계획을 따르기보다 변화에 대응하기를 가치 있게 여긴다.,2,"애자일(Agile) 소프트웨어 개발 방법론은 빠르게 변화하는 요구사항에 유연하게 대처하고, 고객과의 긴밀한 협력을 통해 소프트웨어를 개발하는 것을 중시하는 접근 방식입니다.  문제에서 틀린 설명은 '동작하는 소프트웨어보다는 포괄적인 문서를 가치 있게 여긴다' 입니다. 애자일은 실제 작동하는 소프트웨어를 빠르게 만들고, 고객의 피드백을 반영하여 지속적으로 개선하는 것을 목표로 합니다.  포괄적인 문서 작성에 많은 시간을 할애하기보다는, 실제 작동하는 소프트웨어를 우선시하여 고객에게 빠르게 가치를 제공하는 데 집중합니다.  다른 선택지들은 모두 애자일의 핵심 가치를 잘 나타내고 있습니다.  개인과의 상호작용, 고객과의 협력, 변화에 대한 적응력을 중시하는 것은 애자일의 기본 원칙입니다. 따라서,  문서보다 작동하는 소프트웨어를 중시하지 않는다는 내용은 애자일의 철학과 배치됩니다.",87,2
603,1,7,3,소프트웨어 설계에서 요구사항 분석에 대한 설명으로 틀린 것은?,,소프트웨어가 무엇을 해야하는가를 추적하여 요구사항 명세를 작성하는 작업이다.,사용자의 요구를 추출하여 목표를 정하고 어떤 방식으로 해결할 것인지 결정하는 단계이다.,소프트웨어 시스템이 사용되는 동안 발견되는 오류를 정리하는 단계이다.,소프트웨어 개발의 출발점이면서 실질적인 첫 번째 단계이다.,3,"소프트웨어 설계의 첫 단계는 사용자가 원하는 소프트웨어의 기능을 정확하게 파악하는 것입니다.  마치 건물을 짓기 전에 설계도를 그리는 것과 같습니다.  설계도에는 건물의 모양, 크기, 기능 등이 자세하게 적혀있듯이, 소프트웨어 요구사항 분석에서는 사용자가 소프트웨어를 통해 무엇을 하고 싶은지, 어떤 기능이 필요한지 등을 상세하게 정의합니다.  따라서 소프트웨어가 어떤 기능을 해야 하는지 명세서에 적는 작업은 요구사항 분석의 핵심입니다.  사용자의 요구를 파악하고 목표를 설정하는 것 또한 요구사항 분석에 포함됩니다.  하지만 소프트웨어가 이미 만들어진 후에 발생하는 오류를 정리하는 것은 소프트웨어 테스트 단계에서 수행되는 작업이며, 요구사항 분석과는 별개입니다.  요구사항 분석은 소프트웨어 개발의 시작점이자 가장 중요한 첫 단계라고 할 수 있습니다.  결론적으로,  소프트웨어가 이미 동작하는 중에 발견되는 오류를 정리하는 것은 요구사항 분석의 목적이 아니므로 틀린 설명입니다.",84,2
604,1,7,4,객체지향 기법에서 상위 클래스의 메소드와 속성을 하위 클래스가 물려받는 것을 의미하는 것은?,,Abstraction,Polymorphism,Encapsulation,Inheritance,4,"객체지향 프로그래밍(OOP)에서 상속(Inheritance)은 부모 클래스(상위 클래스)의 특징(메소드와 속성)을 자식 클래스(하위 클래스)가 물려받아 사용하는 것을 의미합니다.  마치 부모로부터 자식에게 유전형질이 전달되는 것과 같습니다.  예를 들어, ""동물""이라는 상위 클래스가 ""이름""과 ""울음소리""라는 속성과 ""먹다""라는 메소드를 가지고 있다면, ""강아지""라는 하위 클래스는 ""동물"" 클래스의 이러한 특징들을 자동으로 상속받아 ""이름"", ""울음소리"", ""먹다""를 사용할 수 있습니다.  물론 ""강아지""는 ""꼬리흔들다""와 같은 자체적인 메소드를 추가할 수도 있습니다.  따라서 상위 클래스의 기능을 재사용하여 코드의 중복을 줄이고 효율적인 프로그래밍을 가능하게 하는 것이 상속의 핵심적인 개념입니다.  문제에서 제시된 다른 선택지는 객체지향의 다른 중요한 개념이지만, 상위 클래스의 특징을 하위 클래스가 물려받는다는 의미와는 직접적으로 연결되지 않습니다. 추상화(Abstraction)는 복잡한 시스템을 단순화하여 표현하는 것이고, 다형성(Polymorphism)은 하나의 메소드가 여러 가지 형태로 동작하는 것을 의미하며, 캡슐화(Encapsulation)는 데이터와 메소드를 하나로 묶어 외부 접근을 제어하는 것을 의미합니다.",78,7
605,1,7,5,설계 기법 중 하향식 설계 방법과 상향식 설계 방법에 대한 비교 설명으로 가장 옳지 않은 것은?,,하향식 설계에서는 통합 검사 시 인터페이스가 이미 정의되어 있어 통합이 간단하다.,하향식 설계에서 레벨이 낮은 데이터 구조의 세부 사항은 설계초기 단계에서 필요하다.,상향식 설계는 최하위 수준에서 각각의 모듈들을 설계하고 이러한 모듈이 완성되면 이들을 결합하여 검사한다.,상향식 설계에서는 인터페이스가 이미 성립되어 있지 않더라도 기능 추가가 쉽다.,4,"이 문제는 소프트웨어 설계 기법 중 하향식 설계와 상향식 설계의 차이점을 묻고 있습니다.  하향식 설계는 전체 시스템을 큰 모듈로 나누고, 각 모듈을 다시 작은 모듈로 나누는 방식으로, 마치 나무의 가지가 뻗어나가는 것처럼 설계가 진행됩니다. 반면 상향식 설계는 작은 모듈부터 설계하여 이들을 조합하여 큰 시스템을 만드는 방식입니다.  문제에서 틀린 설명을 찾는 것이므로 각 선지들을 비교해 보면, 하향식 설계에서는 최상위 모듈부터 설계하기 때문에 초기 단계에서는 하위 모듈의 세부적인 내용을 알 필요가 없습니다.  또한, 하향식 설계는 상위 모듈의 인터페이스가 먼저 정의되므로 통합 과정이 상대적으로 간편합니다.  상향식 설계는 하위 모듈을 먼저 개발하고 통합하는 방식이므로, 인터페이스가 미리 정의되어 있지 않을 수 있으며, 기능 추가는 상대적으로 어려울 수 있습니다. 따라서 상향식 설계에서 인터페이스가 미리 정의되어 있지 않더라도 기능 추가가 쉽다는 설명은 옳지 않습니다.  하향식 설계는 전체 시스템의 구조를 먼저 파악하고 설계하기 때문에 큰 그림을 먼저 그리는 데 유리하며, 상향식 설계는 작은 부분부터 완성해 나가기 때문에 각 모듈의 검증이 용이하다는 장점이 있습니다.  하지만 상향식 설계는 전체 시스템의 구조를 파악하기 어렵고, 통합 과정에서 문제가 발생할 가능성이 높습니다.  결론적으로, 상향식 설계에서 인터페이스가 미리 정의되지 않아도 기능 추가가 쉽다는 것은 잘못된 설명입니다.",55,6
606,1,7,6,자료흐름도(DFD)의 각 요소별 표기 형태의 연결이 옳지 않은 것은?,,Process : 원,Data Flow : 화살표,Data Store : 삼각형,Terminator : 사각형,3,"자료흐름도(DFD)는 시스템의 자료 흐름을 그림으로 나타내는 기법입니다.  각 요소는 특정한 기호로 표현되는데,  문제에서 제시된 요소 중 하나의 기호가 잘못 연결되어 있습니다.  자료의 처리 과정은 원으로, 자료의 흐름은 화살표로, 자료 저장소는 두 개의 평행한 직선으로 표현됩니다.  그리고 시스템의 외부와 상호작용하는 개체(사용자나 다른 시스템)는 사각형으로 나타냅니다.  따라서 자료 저장소를 삼각형으로 표현한 것은 잘못된 것입니다. 자료 저장소는 일반적으로 평행한 두 개의 수평선으로 표시되거나, 열린 쪽이 위쪽을 향하는 U자 모양으로 표현되기도 합니다.  정보처리기사 공식 교재를 참고하면 자료 저장소의 표기법이 삼각형이 아닌 다른 형태임을 확인할 수 있습니다.  따라서 잘못된 연결을 찾는 문제의 정답은 자료 저장소를 잘못 표현한 선지입니다.",80,3
607,1,7,7,소프트웨어 개발에 이용되는 모델(Model)에 대한 설명 중 거리가 먼 것은?,,모델은 개발 대상을 추상화하고 기호나 그림 등으로 시각적으로 표현한다.,모델을 통해 소프트웨어에 대한 이해도를 향상시킬 수 있다.,모델을 통해 이해 당사자 간의 의사소통이 향상된다.,모델을 통해 향후 개발될 시스템의 유추는 불가능하다.,4,"소프트웨어 개발 과정에서 모델(Model)은 매우 중요한 역할을 합니다.  모델은 복잡한 시스템을 단순화하여 이해하기 쉽게 그림이나 기호로 표현하는 추상화된 표현입니다.  마치 건축 설계도면처럼 말이죠.  설계도면을 통해 건물의 구조와 기능을 미리 파악하고, 건축 과정에서 발생할 수 있는 문제점을 예측할 수 있는 것처럼, 소프트웨어 개발에서도 모델은 개발 대상을 시각적으로 표현하고 이해도를 높여주는 역할을 합니다.  또한, 개발팀 구성원이나 고객과 같은 이해관계자들 간의 의사소통을 원활하게 해줍니다.  모델을 통해 모두가 같은 그림을 보고 이야기할 수 있게 되는 것이죠.  하지만 모델은 미래를 완벽하게 예측하는 '결정체'는 아닙니다.  모델은 개발 대상의 특정 측면을 추상화한 것이기 때문에,  모델만으로 향후 개발될 시스템의 모든 것을 완벽하게 유추하는 것은 불가능합니다.  모델은 개발 과정에서 발생할 수 있는 위험을 줄이고, 효율적인 개발을 돕는 도구일 뿐, 미래를 완벽하게 예측하는 것은 아니라는 점을 명심해야 합니다.  따라서, 모델을 통해 향후 개발될 시스템을 완벽하게 유추할 수 있다는 주장은 잘못된 것입니다.",88,2
608,1,7,8,다음의 설명에 해당하는 언어는?,https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m8.gif,JAVA,C,UML,Python,3,"문제에서 설명하는 언어는 객체지향 시스템 개발 시 산출물을 명세화, 시각화, 문서화하는 데 사용되며, 개발 시스템을 이해하기 쉬운 형태로 표현하여 효율적인 의사소통을 가능하게 하는 표준화된 모델링 언어라고 합니다.  JAVA, C, Python은 모두 프로그래밍 언어로, 시스템의 기능을 구현하는 데 사용됩니다.  반면에 문제에서 설명하는 언어는 시스템을 *설계하고 이해하는 데* 초점을 맞추고 있으며, 시각적인 모델을 통해 분석가, 의뢰인, 설계자 간의 의사소통을 원활하게 합니다. 이러한 특징은 UML(Unified Modeling Language)의 주요 기능과 정확히 일치합니다. UML은 객체지향 시스템 설계에 널리 사용되는 표준 모델링 언어로, 다양한 다이어그램을 통해 시스템의 구조, 동작, 상호작용 등을 시각적으로 표현합니다. 따라서 문제의 설명에 가장 적합한 언어는 UML입니다.  쉽게 말해,  건물을 지을 때 설계도면이 필요하듯이, 소프트웨어를 개발할 때도 UML이라는 설계도면이 필요한 것입니다.  JAVA, C, Python은 건물을 실제로 짓는 데 사용되는 벽돌이나 시멘트와 같은 역할을 한다고 생각하면 이해하기 쉬울 것입니다.",79,2
609,1,7,9,다음 내용이 설명하는 UI설계 도구는?,https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m9.gif,스토리보드(Storyboard),목업(Mockup),프로토타입(Prototype),유스케이스(Usecase),2,"문제에서 설명하는 UI 설계 도구는 디자인, 사용 방법 설명, 평가 등을 위해 실제 화면과 유사하게 만든 정적인 모형이며, 실제로 구현되지는 않는다고 명시하고 있습니다.  이는 마치 건물을 짓기 전에 설계도면을 그리는 것과 같습니다.  설계도면은 건물의 모습을 시각적으로 보여주지만, 실제 건물이 아니죠.  문제에서 설명하는 도구도 이와 같이 실제 작동하는 프로그램이 아니라,  UI의 디자인과 구성 요소 배치를 미리 확인하기 위한 정적인 모형입니다.  프로토타입은 실제로 작동하는 시제품에 가깝고, 스토리보드는 사용자의 흐름을 보여주는 시각적 도구이며, 유스케이스는 사용자의 시스템 사용 방식을 기술하는 문서입니다. 따라서 문제의 설명에 가장 부합하는 것은 실제로 구현되지 않고 시각적으로만 구성 요소를 배치하는 정적인 모형인  '목업'입니다.",67,5
610,1,7,10,애자일(Agile) 기법 중 스크럼(Scrum)과 관련된 용어에 대한 설명이 틀린 것은?,,"스크럼 마스터(Scrum Master)는 스크럼 프로세스를 따르고, 팀이 스크럼을 효과적으로 활용할 수 있도록 보장하는 역할 등을 맡는다.","제품 백로그(Product Backlog)는 스크럼 팀이 해결해야 하는 목록으로 소프트웨어 요구사항, 아키텍처 정의 등이 포함될 수 있다.",스프린트(Sprint)는 하나의 완성된 최종 결과물을 만들기 위한 주기로 3달 이상의 장기간으로 결정된다.,속도(Velocity)는 한 번의 스프린트에서 한 팀이 어느 정도의 제품 백로그를 감당할 수 있는지에 대한 추정치로 볼 수 있다.,3,"애자일 기법 중 스크럼에 대한 설명 중 틀린 내용을 찾는 문제입니다.  스크럼은 소프트웨어 개발 프로젝트를 효율적으로 관리하기 위한 프레임워크로, 짧은 주기(스프린트)를 통해 반복적으로 개발하고 개선하는 것을 특징으로 합니다.  제시된 설명 중 하나는 스프린트의 기간에 대한 설명인데, 스프린트는 일반적으로 1~4주 정도의 짧은 기간으로 설정됩니다. 3개월 이상의 장기간으로 스프린트를 진행하는 것은 스크럼의 원칙에 어긋나며,  개발 과정의 유연성과 빠른 피드백을 저해하기 때문입니다.  스크럼 마스터는 팀이 스크럼 프로세스를 잘 따라갈 수 있도록 돕는 역할을 하고, 제품 백로그는 개발해야 할 목록을 담고 있으며, 속도는 팀의 개발 능력을 추정하는 지표로 사용됩니다. 따라서 스프린트 기간에 대한 설명이 틀린 것입니다.  정보처리기사 공식 교재에서는 스크럼의 각 요소와 그 역할에 대해 자세히 설명하고 있으며, 스프린트의 일반적인 기간이 짧은 주기임을 명시하고 있습니다.  따라서 3개월 이상의 장기간으로 스프린트를 설정한다는 설명은 스크럼의 기본 원칙과 맞지 않아 틀린 설명입니다.",79,2
611,1,7,11,UML 다이어그램 중 정적 다이어그램이 아닌 것은?,,컴포넌트 다이어그램,배치 다이어그램,순차 다이어그램,패키지 다이어그램,3,"UML 다이어그램은 시스템을 시각적으로 표현하는 도구인데, 크게 정적 다이어그램과 동적 다이어그램으로 나뉩니다. 정적 다이어그램은 시스템의 구조나 구성 요소 간의 관계를 보여주는 그림이고, 동적 다이어그램은 시스템이 시간에 따라 어떻게 동작하는지를 보여주는 그림입니다.  문제에서 묻고 있는 것은 정적 다이어그램이 아닌 것을 고르는 것이므로, 시스템의 동작을 나타내는 다이어그램을 찾아야 합니다.  컴포넌트 다이어그램, 배치 다이어그램, 패키지 다이어그램은 모두 시스템의 구성 요소와 그 관계를 나타내는 정적 다이어그램의 종류입니다. 반면에 순차 다이어그램은 시간의 흐름에 따라 객체들이 어떻게 상호 작용하는지를 보여주는 동적 다이어그램입니다. 따라서 정적 다이어그램이 아닌 것은 순차 다이어그램입니다.  쉽게 말해, 사진(정적)과 동영상(동적)의 차이라고 생각하면 이해하기 쉬울 것입니다. 사진은 시스템의 한 순간을 보여주는 것이고, 동영상은 시스템이 시간에 따라 변화하는 모습을 보여주는 것입니다.",66,2
612,1,7,12,"LOC기법에 의하여 예측된 총 라인수가 36000라인, 개발에 참여할 프로그래머가 6명, 프로그래머들의 평균 생산성이 월간 300라인일 때 개발에 소요되는 기간을 계산한 결과로 가장 옳은 것은?",,5개월,10개월,15개월,20개월,4,"이 문제는 소프트웨어 개발에 필요한 시간을 계산하는 문제입니다.  LOC(Lines of Code) 기법은 소프트웨어의 크기를 코드 라인 수로 측정하여 개발 기간을 예측하는 방법입니다. 문제에서 예측된 총 라인 수는 36,000라인이고, 개발에 참여하는 프로그래머는 6명이며, 프로그래머 한 명당 월간 생산성은 300라인입니다.",87,47
613,1,7,13,클래스 설계원칙에 대한 바른 설명은?,,단일 책임원칙 : 하나의 클래스만 변경 가능 해야한다.,개방-폐쇄의 원칙 : 클래스는 확장에 대해 열려 있어야 하며 변경에 대해 닫혀 있어야 한다.,리스코프 교체의 원칙 : 여러 개의 책임을 가진 클래스는 하나의 책임을 가진 클래스로 대체되어야 한다.,의존관계 역전의 원칙 : 클라이언트는 자신이 사용하는 메소드와 의존관계를 갖지 않도록 해야 한다.,2,"클래스 설계 원칙은 소프트웨어를 효율적이고 유지보수하기 쉽게 만들기 위한 중요한 지침입니다.  여러 원칙 중에서 '개방-폐쇄의 원칙'은  소프트웨어의 확장성과 유연성을 보장하는 핵심 원칙입니다.  이 원칙은  기존 코드를 변경하지 않고(변경에 대해 닫힘) 새로운 기능을 추가할 수 있도록(확장에 대해 열림) 설계해야 한다는 것을 의미합니다.  예를 들어,  새로운 기능을 추가하기 위해 기존 클래스의 코드를 수정해야 한다면,  버그가 발생하거나 기존 기능에 문제가 생길 위험이 높아집니다.  하지만 개방-폐쇄의 원칙을 따른다면, 새로운 기능을 추가하기 위해 새로운 클래스를 만들거나 기존 클래스를 상속받아 확장하는 방식으로  기존 코드를 건드리지 않고 기능을 추가할 수 있습니다.  이는 소프트웨어의 유지보수성과 안정성을 크게 향상시키는 중요한 요소입니다. 다른 선지들은 각각 다른 중요한 클래스 설계 원칙들을 설명하고 있지만,  문제에서 묻고 있는 '바른 설명'에 가장 적합한 것은 개방-폐쇄의 원칙입니다.",58,7
614,1,7,14,GoF(Gangs of Four) 디자인 패턴에서 생성(Creational) 패턴에 해당하는 것은?,,컴퍼지트(Composite),어댑터(Adapter),추상 팩토리(Abstract Factory),옵서버(Observer),3,"GoF 디자인 패턴은 소프트웨어 개발에서 자주 발생하는 문제들을 해결하기 위한 디자인 패턴들을 모아놓은 책 ""Design Patterns: Elements of Reusable Object-Oriented Software""에서 제시된 23가지의 디자인 패턴들을 말합니다.  이 패턴들은 크게 생성(Creational), 구조(Structural), 행위(Behavioral) 세 가지 유형으로 분류됩니다.  문제에서 묻고 있는 것은 생성 패턴에 해당하는 것인데요, 생성 패턴은 객체 생성 메커니즘을 처리하여 객체 생성 과정을 추상화하고 유연하게 만드는 패턴입니다.  제시된 선택지 중에서 추상 팩토리 패턴은 서로 관련된 객체들의 집합을 생성하는 인터페이스를 제공하지만, 구체적인 클래스는 지정하지 않습니다.  즉, 어떤 종류의 객체들을 생성할지는 서브클래스에서 결정하도록 하여 객체 생성 과정을 추상화하고, 클라이언트 코드는 구체적인 객체 생성 과정에 의존하지 않고 인터페이스만을 통해 객체를 생성할 수 있도록 합니다.  반면, 나머지 선택지들은 객체 생성과 직접적으로 관련이 없는 구조 또는 행위 패턴들입니다. 컴퍼지트 패턴은 객체들을 트리 구조로 구성하여 부분과 전체를 동일하게 다루도록 하는 패턴이고, 어댑터 패턴은 서로 다른 인터페이스를 가진 객체들을 연결하는 패턴이며, 옵서버 패턴은 객체의 상태 변화를 다른 객체들에게 알리고 업데이트하는 패턴입니다. 따라서 생성 패턴에 해당하는 것은 추상 팩토리 패턴입니다.",65,7
615,1,7,15,아키텍처 설계과정이 올바른 순서로 나열된 것은?,https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m15.gif,㉮ → ㉯ → ㉰ → ㉱ → ㉲,㉲ → ㉮ → ㉯ → ㉱ → ㉰,㉮ → ㉲ → ㉯ → ㉱ → ㉰,㉮ → ㉯ → ㉰ → ㉲ → ㉱,1,"소프트웨어 아키텍처 설계는 건물을 짓는 것과 비슷합니다.  먼저 무엇을 지을지 목표(설계 목표 설정)를 정하고, 어떤 종류의 건물일지(시스템 타입 결정)를 결정해야 합니다.  그 다음 건물의 스타일(스타일 적용 및 커스터마이즈)을 정하고, 각 방의 기능과 연결(서브시스템의 기능, 인터페이스 동작 작성)을 설계합니다.  마지막으로 설계에 문제가 없는지 검토(아키텍처 설계 검토)하는 과정을 거치게 됩니다. 따라서 설계 목표 설정부터 시작하여 시스템 타입 결정, 스타일 적용 및 커스터마이즈, 서브시스템 기능 및 인터페이스 동작 작성, 그리고 마지막으로 아키텍처 설계 검토 순서로 진행되는 것이 가장 논리적이고 효율적인 아키텍처 설계 과정입니다.  다른 순서들은 이러한 논리적인 흐름을 따르지 않아 설계 과정에서 혼란을 야기하거나 비효율적인 결과를 초래할 수 있습니다.  정보처리기사 공식 교재의 소프트웨어 개발 프로세스에 대한 설명을 참고하면 이러한 순서가 가장 적절함을 확인할 수 있습니다.",62,6
616,1,7,16,사용자 인터페이스를 설계할 경우 고려해야 할 가이드라인과 가장 거리가 먼 것은?,,심미성을 사용성보다 우선하여 설계해야 한다.,효율성을 높이게 설계해야 한다.,발생하는 오류를 쉽게 수정할 수 있어야 한다.,사용자에게 피드백을 제공해야 한다.,1,"사용자 인터페이스(UI)를 설계할 때 가장 중요한 것은 사용자가 쉽고 편리하게 시스템을 이용할 수 있도록 하는 것입니다.  이는 사용성(Usability)을 높이는 것을 의미하며, 효율성, 오류 수정 용이성, 피드백 제공 등이 모두 사용성을 높이는 요소들입니다.  하지만,  심미성(미적인 아름다움)은 사용성을 뒷받침하는 요소일 수는 있지만, 사용성보다 우선시되어서는 안 됩니다. 아무리 예쁘게 디자인된 인터페이스라도 사용하기 불편하다면 좋은 인터페이스라고 할 수 없습니다.  사용자의 편의성과 효율성을 최우선으로 고려하여 설계해야 하며, 심미성은 사용성을 저해하지 않는 범위 내에서 고려해야 합니다.  따라서 사용자 인터페이스 설계에서 심미성을 사용성보다 우선시하는 것은 적절하지 않은 가이드라인입니다.  정보처리기사 공식 교재에서도 사용자 중심 설계의 중요성을 강조하며, 사용성을 극대화하는 방향으로 UI 설계 가이드라인을 제시하고 있을 것입니다.",85,5
617,1,7,17,소프트웨어 설계에서 자주 발생하는 문제에 대한 일반적이고 반복적인 해결 방법을 무엇이라고 하는가?,,모듈 분해,디자인 패턴,연관 관계,클래스 도출,2,"소프트웨어를 설계하다 보면, 비슷한 문제 상황이 반복적으로 발생하는 경우가 많습니다. 예를 들어, 사용자의 로그인 기능을 구현할 때,  다양한 시스템에서 동일한 방식으로 로그인을 처리해야 할 필요가 있을 수 있습니다. 이런 경우, 매번 처음부터 새롭게 코드를 작성하는 대신, 이미 검증되고 효율적인 해결 방법을 재사용하는 것이 좋습니다.  이러한 일반적이고 반복적인 문제에 대한 미리 만들어진 해결책, 즉 디자인 패턴을 사용하면 코드의 재사용성을 높이고, 개발 시간을 단축하며, 코드의 품질을 향상시킬 수 있습니다. 디자인 패턴은 여러 개발자들이 공통적으로 이해하고 사용할 수 있는 표준화된 방법이기 때문에, 유지보수 및 협업에도 매우 효율적입니다.  따라서 소프트웨어 설계에서 자주 발생하는 문제에 대한 일반적이고 반복적인 해결 방법은 디자인 패턴이라고 할 수 있습니다.  마치 레고 블록처럼, 이미 만들어진 블록(디자인 패턴)을 조립하여 복잡한 시스템을 효율적으로 구축하는 것과 같은 원리입니다.",68,7
618,1,7,18,"객체지향 분석기법의 하나로 객체 모형, 동적 모형, 기능 모형의 3개 모형을 생성하는 방법은?",,Wirfs-Block Method,Rumbaugh Method,Booch Method,Jacobson Method,2,"객체지향 분석 기법은 소프트웨어를 객체라는 개념을 중심으로 분석하고 설계하는 방법입니다.  여러 가지 객체지향 분석 기법이 존재하는데, 그 중 하나가 객체 모형, 동적 모형, 기능 모형의 세 가지 모형을 생성하는 방법입니다.  객체 모형은 시스템을 구성하는 객체들과 그들의 관계를 나타내고, 동적 모형은 객체들 간의 상호 작용과 시간에 따른 변화를 보여줍니다. 기능 모형은 시스템의 기능을 계층적으로 표현합니다. 이 세 가지 모형을 모두 사용하여 시스템을 종합적으로 분석하는 기법이 문제에서 제시된 기법입니다.  정답으로 제시된 방법은 바로 이 세 가지 모형(객체 모형, 동적 모형, 기능 모형)을 모두 사용하여 시스템을 분석하는 접근 방식을 취하는 객체지향 분석 기법입니다. 다른 선지들은 각각 다른 객체지향 분석 기법을 나타내지만, 문제에서 요구하는 세 가지 모형을 모두 사용하는 특징을 가지고 있지는 않습니다. 따라서 문제의 조건에 가장 잘 부합하는 정답입니다.",80,7
619,1,7,19,입력되는 데이터를 컴퓨터의 프로세서가 처리하기 전에 미리 처리하여 프로세서가 처리하는 시간을 줄여주는 프로그램이나 하드웨어를 말하는 것은?,,EAI,FEP,GPL,Duplexing,2,"컴퓨터의 프로세서는 입력받은 데이터를 바로 처리하지 않습니다.  마치 요리사가 요리하기 전에 재료 손질을 하는 것처럼, 프로세서가 데이터를 효율적으로 처리하기 위해서는 전처리가 필요합니다.  이 전처리 과정을 통해 데이터의 형식을 바꾸거나, 불필요한 부분을 제거하거나, 프로세서가 이해할 수 있는 형태로 변환하는 등의 작업을 수행합니다.  이러한 전처리 작업을 담당하는 프로그램이나 하드웨어가 바로 문제에서 묻고 있는 것입니다.  프로세서의 처리 시간을 단축시켜 전체적인 시스템 성능을 향상시키는 역할을 하죠.  따라서 입력 데이터를 미리 처리하여 프로세서의 부담을 줄여주는 프로그램이나 하드웨어를 사용하는 것은 매우 중요합니다.  이는 마치 공장에서 제품을 생산하기 전에 원재료를 가공하는 것과 같아서 효율성을 높이는 데 크게 기여합니다.",45,21
620,1,7,20,객체 지향 개념 중 하나 이상의 유사한 객체들을 묶어 공통된 특성을 표현한 데이터 추상화를 의미하는 것은?,,Method,Class,Field,Message,2,"객체 지향 프로그래밍(OOP)에서 '클래스'는 여러 개의 비슷한 객체들을 묶어서 표현하는 개념입니다.  마치 '사람'이라는 클래스가 있으면, '김철수', '이영희'와 같은 개별 사람 객체들이 이 클래스에 속하는 것과 같습니다.  각 객체는 이름, 나이, 주소 등의 특징(속성, field)을 가지고 있고, 행동(메소드, method)을 할 수 있습니다.  클래스는 이러한 공통된 특징과 행동을 정의하는 설계도와 같은 역할을 합니다.  문제에서 '하나 이상의 유사한 객체들을 묶어 공통된 특성을 표현한 데이터 추상화'라고 설명하고 있는데, 이는 바로 클래스가 하는 일을 정확하게 나타내고 있습니다.  '데이터 추상화'는 복잡한 내부 구현을 숨기고, 객체의 중요한 특징만을 드러내어 사용하기 편리하게 만드는 것을 의미하는데, 클래스는 이러한 추상화를 가능하게 해줍니다.  따라서, 여러 유사한 객체들의 공통된 특성을 표현하는 데이터 추상화를 의미하는 것은 클래스입니다.  다른 선택지는 객체의 특징(field)이나 행동(method), 객체 간의 통신(message)을 나타내는 것이지, 유사한 객체들을 묶어 공통 특성을 표현하는 개념은 아닙니다.",82,7
621,1,7,21,클린 코드(Clean Code)를 작성하기 위한 원칙으로 틀린 것은?,,"추상화 : 하위 클래스/메소드/함수를 통해 애플리케이션의 특성을 간략하게 나타내고, 상세 내용은 상위 클래스/메소드/함수에서 구현한다.",의존성 : 다른 모듈에 미치는 영향을 최소화하도록 작성한다.,가독성 : 누구든지 읽기 쉽게 코드를 작성한다.,중복성 : 중복을 최소화 할 수 있는 코드를 작성한다.,1,"클린 코드(Clean Code)를 작성하는 것은 소프트웨어 개발에서 매우 중요합니다.  코드의 품질은 유지보수성, 확장성, 그리고 개발팀의 생산성에 직접적인 영향을 미치기 때문이죠.  문제에서 제시된 네 가지 원칙 중 잘못된 것은 바로 첫 번째 원칙입니다.  추상화는 복잡한 시스템을 단순화하여 이해하기 쉽게 만드는 기법입니다.  하지만,  상위 클래스/메소드/함수에서 하위 클래스/메소드/함수의 상세 내용을 구현하는 것은 추상화의 개념과 정반대입니다.  추상화는 상위 레벨에서 일반적인 기능을 정의하고, 하위 레벨에서 구체적인 구현을 담당하는 방식으로 동작합니다.  즉, 상위에서 하위의 상세 내용을 구현하는 것이 아니라, 하위에서 상위의 추상적인 기능을 구체화하는 것이 올바른 추상화의 개념입니다.  나머지 원칙들은 모두 클린 코드를 작성하기 위한 필수적인 요소들입니다.  의존성을 최소화하고, 가독성을 높이며, 중복을 줄이는 것은 코드의 유지보수성과 확장성을 높이는 데 크게 기여합니다. 따라서, 첫 번째 원칙이 클린 코드 작성 원칙으로서 잘못된 설명입니다.",73,7
622,1,7,22,"단위 테스트에서 테스트의 대상이 되는 하위 모듈을 호출하고, 파라미터를 전달하는 가상의 모듈로 상향식 테스트에 필요한 것은?",,테스트 스텁(Test Stub),테스트 드라이버(Test Driver),테스트 슈트(Test Suites),테스트 케이스(Test Case),2,"단위 테스트는 소프트웨어의 가장 작은 단위인 모듈(함수 또는 클래스)을 개별적으로 테스트하는 방법입니다.  상향식 테스트는 하위 모듈부터 테스트를 시작하여 점차 상위 모듈로 통합해 나가는 방식인데요, 이때 하위 모듈이 아직 완성되지 않았거나 다른 모듈에 의존적인 경우,  그 기능을 대신하는 가상의 모듈이 필요합니다.  바로 이 가상의 모듈이 문제에서 묻고 있는 것입니다.  하위 모듈을 호출하고 파라미터를 전달하는 역할을 하는 이 가상 모듈은 상위 모듈의 테스트를 가능하게 해줍니다.  반대로, 상위 모듈의 기능을 대신하는 가상의 모듈은 하향식 테스트에서 필요합니다. 따라서 상향식 테스트에 필요한 것은 하위 모듈을 호출하는 가상의 모듈, 즉 테스트 드라이버입니다.  테스트 드라이버는 상위 모듈의 관점에서 하위 모듈을 테스트하기 위한 환경을 제공하는 역할을 합니다.",61,14
623,1,7,23,스택(Stack)에 대한 옳은 내용으로만 나열된 것은?,https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m23.gif,"㉠, ㉡","㉡, ㉢",㉣,"㉠, ㉡, ㉢, ㉣",3,"스택(Stack)은 데이터를 쌓아 올리는 방식으로, 가장 나중에 쌓은 데이터를 가장 먼저 꺼내는 LIFO(Last-In, First-Out) 방식의 자료구조입니다.  마치 접시를 쌓아놓고 가장 위에 있는 접시부터 꺼내는 것과 같습니다.  문제에서 제시된 선지들을 살펴보면,  FIFO(First-In, First-Out) 방식은 큐(Queue)의 특징이므로 스택과는 다릅니다.  순서 리스트의 뒤에서 삽입하고 앞에서 제거하는 것은 큐의 동작 방식이며, 스택은 한쪽 끝에서만 삽입과 삭제가 이루어집니다.  선형 리스트의 양쪽 끝에서 삽입과 삭제가 가능한 자료구조는 양방향 큐(Deque)입니다.  반면, 인터럽트 처리나 서브루틴 호출은 스택의 대표적인 응용 분야입니다.  프로그램 실행 중 발생하는 인터럽트나 함수 호출 시,  스택에 정보를 저장하여 순서대로 처리하고, 작업이 끝나면 스택에서 정보를 꺼내는 방식으로 동작하기 때문입니다. 따라서 정답은 인터럽트 처리, 서브루틴 호출 작업 등에 응용된다는 내용만 스택에 대한 올바른 설명입니다.",67,11
624,1,7,24,소프트웨어 모듈화의 장점이 아닌 것은?,,오류의 파급 효과를 최소화한다.,기능의 분리가 가능하여 인터페이스가 복잡하다.,모듈의 재사용 가능으로 개발과 유지보수가 용이하다.,프로그램의 효율적인 관리가 가능하다.,2,"소프트웨어 모듈화는 큰 프로그램을 작고 독립적인 여러 개의 모듈로 나누는 것을 말합니다.  마치 레고 블록처럼 각각의 모듈은 특정 기능을 담당하고, 이러한 모듈들을 조립하여 전체 프로그램을 완성하는 방식이죠.  이렇게 하면 각 모듈을 개별적으로 개발하고 테스트할 수 있기 때문에 오류가 발생하더라도 그 영향이 전체 프로그램으로 퍼져나가는 것을 막을 수 있습니다.  또한, 한번 개발된 모듈은 다른 프로그램에서도 재사용할 수 있어 개발 시간과 비용을 절약하고 유지보수도 용이해집니다.  프로그램 관리도 모듈 단위로 하기 때문에 효율적입니다.  하지만 모듈화를 한다고 해서 무조건 인터페이스가 복잡해지는 것은 아닙니다.  오히려 잘 설계된 모듈화는 모듈 간의 인터페이스를 명확하고 간결하게 만들어 전체 시스템의 복잡도를 줄이는 효과를 가져옵니다.  문제에서 잘못된 선지는 모듈화가 인터페이스를 복잡하게 만든다는 것이고, 이는 모듈화의 장점이 아닌, 잘못된 설계나 구현으로 인해 발생할 수 있는 단점을 말하는 것입니다.  따라서 모듈화의 장점이 아닌 것은 인터페이스의 복잡성입니다.",85,6
625,1,7,25,소프트웨어 프로젝트 관리에 대한 설명으로 가장 옳은 것은?,,개발에 따른 산출물 관리,소요인력은 최대화하되 정책 결정은 신속하게 처리,주어진 기간은 연장하되 최소의 비용으로 시스템을 개발,주어진 기간 내에 최소의 비용으로 사용자를 만족시키는 시스템을 개발,4,소프트웨어 프로젝트는 시간과 비용이라는 제약 하에 진행됩니다.  프로젝트의 성공은 단순히 시스템을 개발하는 것만으로 판단할 수 없습니다. 사용자의 요구를 충족하는 시스템을 만들어야 비로소 성공적인 프로젝트라고 할 수 있습니다. 따라서 주어진 기간과 비용 안에서 사용자의 만족도를 최대화하는 것이 소프트웨어 프로젝트 관리의 핵심 목표입니다. 다른 선지들은 기간 연장이나 인력 최대화 등 비용 증가 또는 효율성 저하를 고려하지 않아 프로젝트 관리의 기본 원칙에 부합하지 않습니다.  정답은 주어진 제약 조건 내에서 사용자 만족도를 최우선으로 고려하는 방향으로 프로젝트를 관리해야 함을 명확히 보여줍니다.  이는 정보처리기사 공식 교재에서 소프트웨어 프로젝트 관리의 목표와 원칙을 설명하는 부분과 일치합니다.,73,47
626,1,7,26,정형 기술 검토(FTR)의 지침으로 틀린 것은?,,의제를 제한한다.,논쟁과 반박을 제한한다.,문제 영역을 명확히 표현한다.,참가자의 수를 제한하지 않는다.,4,"정형 기술 검토(Formal Technical Review, FTR)는 소프트웨어 개발 과정에서 발생할 수 있는 결함을 조기에 발견하고 수정하기 위한 중요한 활동입니다.  FTR은 여러 전문가가 모여 개발 산출물을 체계적으로 검토하는 과정인데, 효과적인 검토를 위해서는 몇 가지 지침을 따라야 합니다.  문제에서 틀린 지침은 참가자 수를 제한하지 않는다는 것입니다.  FTR은 효율적인 검토를 위해 참가자 수를 적절히 제한하는 것이 중요합니다.  참가자가 너무 많으면 검토 시간이 길어지고 집중력이 떨어져 오히려 검토의 효율성이 낮아질 수 있습니다.  반면에 참가자가 너무 적으면 다양한 관점에서의 검토가 부족해져 결함 발견율이 낮아질 수 있습니다. 따라서 최적의 참가자 수를 유지하는 것이 중요하며, 무제한으로 참가자를 받는 것은 FTR의 목표 달성에 방해가 됩니다.  나머지 지침들은 모두 FTR의 효율성을 높이기 위한 필수적인 요소들입니다. 의제를 제한하고, 논쟁과 반박보다는 객관적인 검토에 집중하며, 문제 영역을 명확히 함으로써 검토의 초점을 맞추고 효율성을 높일 수 있습니다.",65,2
627,1,7,27,소프트웨어 재공학의 주요 활동 중 기존 소프트웨어 시스템을 새로운 기술 또는 하드웨어 환경에서 사용할 수 있도록 변환하는 작업을 의미하는 것은?,,Analysis,Migration,Restructuring,Reverse Engineering,2,"소프트웨어 재공학은 기존 소프트웨어 시스템을 개선하거나 현대화하는 과정입니다.  문제에서 제시된 것은 기존 시스템을 새로운 기술이나 하드웨어 환경에서 작동하도록 바꾸는 작업입니다.  마치 낡은 집을 허물고 새 집을 짓는 대신,  기존 집의 구조를 그대로 유지하면서 전기 배선이나 수도 시설을 최신식으로 바꾸는 것과 같습니다.  이러한 작업을 '마이그레이션(Migration)'이라고 합니다.  다른 선택지는 소프트웨어 재공학의 다른 활동들을 나타내지만,  기존 시스템을 새로운 환경에 적응시키는 것과는 직접적인 관련이 없습니다.  '리버스 엔지니어링(Reverse Engineering)'은 기존 소프트웨어의 내부 구조를 분석하는 것이고, '리스트럭처링(Restructuring)'은 소프트웨어의 내부 구조를 재구성하는 것이며, '애널리시스(Analysis)'는 분석 단계를 의미합니다. 따라서 기존 소프트웨어를 새로운 환경에서 사용할 수 있도록 변환하는 작업은 '마이그레이션'이 가장 적절한 표현입니다.",48,47
628,1,7,28,정보시스템 개발 단계에서 프로그래밍 언어 선택 시 고려할 사항으로 가장 거리가 먼 것은?,,개발 정보시스템의 특성,사용자의 요구사항,컴파일러의 가용성,컴파일러의 독창성,4,"정보시스템을 개발할 때 프로그래밍 언어를 선택하는 것은 매우 중요한 결정입니다.  개발하려는 시스템의 특성에 맞는 언어를 선택해야 효율적이고 안정적인 시스템을 구축할 수 있고, 사용자의 요구사항을 충족하는 언어를 선택해야 사용자 친화적인 시스템을 만들 수 있습니다. 또한, 해당 언어를 위한 컴파일러(프로그램 코드를 컴퓨터가 이해하는 기계어로 변환하는 프로그램)의 가용성도 중요한 고려 사항입니다.  컴파일러가 없다면 아무리 좋은 언어라도 사용할 수 없기 때문이죠. 하지만 컴파일러의 '독창성'은 프로그래밍 언어 선택 기준으로 적절하지 않습니다.  컴파일러는 프로그램 코드를 기계어로 변환하는 도구일 뿐, 그 자체가 시스템 개발의 성공 여부를 좌우하는 요소는 아니기 때문입니다.  컴파일러의 성능, 안정성, 지원 등은 중요하지만, '독창성'은 개발에 직접적인 영향을 미치는 요소가 아니므로 가장 거리가 먼 선택지입니다.  결국, 시스템의 특성, 사용자 요구사항, 그리고 컴파일러의 가용성 등 실질적인 요소들을 고려하여 프로그래밍 언어를 신중하게 선택해야 합니다.",78,47
629,1,7,29,소프트웨어 패키징에 대한 설명으로 틀린 것은?,,패키징은 개발자 중심으로 진행한다.,"신규 및 변경 개발소스를 식별하고, 이를 모듈화하여 상용제품으로 패키징한다.",고객의 편의성을 위해 매뉴얼 및 버전관리를 지속적으로 한다.,범용 환경에서 사용이 가능하도록 일반적인 배포 형태로 패키징이 진행된다.,1,"소프트웨어 패키징이란 개발이 완료된 소프트웨어를 사용자가 쉽게 설치하고 사용할 수 있도록 포장하는 과정입니다.  이는 단순히 프로그램 파일만 모아놓는 것이 아니라, 사용 설명서, 설치 프로그램, 필요한 라이브러리 등을 포함하여 하나의 완성된 제품으로 만드는 것을 의미합니다.  따라서 고객의 편의성을 고려하여 매뉴얼을 제공하고 버전 관리를 하는 것은 매우 중요한 부분입니다. 또한, 다양한 환경에서 사용할 수 있도록 일반적인 배포 형태로 패키징하는 것도 필수적입니다.  하지만 소프트웨어 패키징은 개발자 중심으로 진행되는 것이 아니라, 사용자의 요구사항과 편의성을 최우선으로 고려하여 진행되어야 합니다.  개발자의 편의성만 고려한다면 사용자는 불편을 겪을 수 있고, 결과적으로 제품의 성공 가능성을 낮출 수 있기 때문입니다.  따라서 개발자 중심으로 진행한다는 설명은 잘못된 것입니다. 신규 및 변경 개발 소스를 식별하고 모듈화하여 상용 제품으로 패키징하는 것은 소프트웨어 패키징의 핵심적인 과정입니다.",82,16
630,1,7,30,자료 구조의 분류 중 선형 구조가 아닌 것은?,,트리,리스트,스택,데크,1,"자료구조는 데이터를 효율적으로 저장하고 관리하는 방법을 연구하는 컴퓨터 과학의 한 분야입니다.  자료구조는 크게 선형 구조와 비선형 구조로 나뉘는데요. 선형 구조는 데이터가 순차적으로 연결되어 있는 구조를 말합니다.  예를 들어, 리스트는 데이터들이 일렬로 나열되어 있고, 스택은 쌓아 올리는 형태로 데이터를 추가하고 제거하며, 큐는 줄을 서서 기다리는 것처럼 데이터를 추가하고 제거하는 구조입니다.  반면에 비선형 구조는 데이터가 계층적이거나 그물망처럼 연결되어 있는 구조입니다.  트리는 계층적인 구조로, 하나의 루트 노드에서 여러 개의 자식 노드로 가지를 뻗어나가는 형태를 가지고 있습니다.  문제에서 제시된 자료구조 중 트리는 계층적인 구조를 가지므로 선형 구조가 아니라고 할 수 있습니다.  나머지 리스트, 스택, 데크는 모두 데이터가 순차적으로 연결되어 있으므로 선형 구조에 속합니다. 따라서 선형 구조가 아닌 것은 트리입니다.",73,11
631,1,7,31,아주 오래되거나 참고문서 또는 개발자가 없어 유지보수 작업이 아주 어려운 프로그램을 의미하는 것은?,,Title Code,Source Code,Object Code,Alien Code,4,"오래되어서 참고문서나 개발자가 없어 유지보수가 어려운 프로그램을 묘사하는 용어는 ""Alien Code""입니다.  Alien Code는 마치 외계인이 만든 코드처럼 이해하기 어렵고 수정하기 힘든 코드를 의미합니다.  프로그램의 소스코드 자체가 오래되어 현대적인 프로그래밍 방식과 다르거나, 주석이 부족하거나, 코드의 구조가 복잡하게 얽혀있어서 어떤 기능을 하는지 파악하기 어려운 경우가 이에 해당합니다.  개발자가 없다면 코드를 이해하고 수정하는 데 필요한 지식을 얻을 수 없으므로 유지보수는 더욱 어려워집니다.  따라서,  유지보수가 매우 어려운 프로그램을 가장 잘 나타내는 용어는 Alien Code입니다. 다른 선택지는 프로그램의 특정 단계나 형태를 나타내는 용어일 뿐, 유지보수의 어려움을 직접적으로 표현하지는 않습니다.",84,18
632,1,7,32,소프트웨어를 재사용함으로써 얻을 수 있는 이점으로 가장 거리가 먼 것은?,,생산성 증가,프로젝트 문서 공유,소프트웨어 품질 향상,새로운 개발 방법론 도입 용이,4,"소프트웨어 재사용의 이점은 개발 시간 단축과 비용 절감, 그리고 이미 검증된 코드를 사용하기 때문에 품질 향상에 기여한다는 점입니다.  생산성이 증가하고,  기존 소프트웨어의 문서를 활용할 수 있다는 것도 장점입니다. 하지만 소프트웨어 재사용 자체가 새로운 개발 방법론의 도입을 용이하게 만드는 것은 아닙니다.  새로운 방법론 도입은 개발 프로세스나 조직 문화, 기술적인 요소 등 여러 가지 요인에 따라 결정되는 별개의 문제이기 때문입니다.  소프트웨어 재사용은 개발 효율성을 높이는 데 도움을 주지만,  개발 방법론 선택에는 직접적인 영향을 미치지 않습니다. 따라서 소프트웨어 재사용과 새로운 개발 방법론 도입의 용이성 사이에는 직접적인 연관성이 없다고 볼 수 있습니다.",72,6
633,1,7,33,인터페이스 간의 통신을 위해 이용되는 데이터 포맷이 아닌 것은?,,AJTML,JSON,XML,YAML,1,"이 문제는 인터페이스 간의 통신에 사용되는 데이터 포맷을 묻고 있습니다.  JSON, XML, YAML은 모두 인터페이스 간 데이터 교환을 위해 널리 사용되는 표준화된 데이터 포맷입니다.  JSON(JavaScript Object Notation)은 웹 애플리케이션에서 많이 사용되는 경량의 데이터 교환 포맷이고, XML(Extensible Markup Language)은 다양한 애플리케이션에서 데이터를 구조화하고 교환하는 데 사용되는 범용적인 마크업 언어입니다. YAML(YAML Ain't Markup Language)은 사람이 읽기 쉽도록 설계된 데이터 직렬화 언어로, 설정 파일이나 데이터 교환에 사용됩니다.  하지만 문제에서 제시된 나머지 하나는 데이터 포맷으로 사용되지 않습니다.  따라서 인터페이스 간 통신에 사용되지 않는 것이 정답입니다.  쉽게 말해,  JSON, XML, YAML은 서로 다른 시스템이나 프로그램이 데이터를 주고받을 때 사용하는 '언어'와 같은 것이고, 정답은 그런 '언어'가 아닌 것입니다.  마치 사람과 사람이 영어, 스페인어, 중국어로 소통하듯이, 컴퓨터 시스템들도 이러한 데이터 포맷을 통해 서로 소통하는 것입니다.",43,8
634,1,7,34,프로그램 설계도의 하나인 NS Chart에 대한 설명으로 가장 거리가 먼 것은?,,논리의 기술에 중점을 두고 도형을 이용한 표현 방법이다.,이해하기 쉽고 코드 변환이 용이하다.,화살표나 GOTO를 사용하여 이해하기 쉽다.,"연속, 선택, 반복 등의 제어 논리 구조를 표현한다.",3,"NS 차트는 프로그램의 논리적인 흐름을 그림으로 나타내는 설계 도구입니다.  쉽게 말해, 프로그램이 어떤 순서로 동작하는지 시각적으로 보여주는 '설계도'와 같은 역할을 합니다.  문제에서 가장 거리가 먼 설명은 화살표나 GOTO문을 사용하여 이해하기 쉽다는 것입니다.  NS 차트는 GOTO문과 같은 무조건 분기(jump)를 지양하고,  순차, 선택, 반복 등의 구조적인 제어 흐름을 표현하는 데 중점을 둡니다. GOTO문은 프로그램의 흐름을 복잡하게 만들어 가독성을 떨어뜨리기 때문에,  NS 차트의 목표인 '이해하기 쉽고 코드 변환이 용이함'과는 상반되는 개념입니다.  NS 차트는 명확하고 체계적인 논리 흐름을 보여주기 위해  구조적인 프로그래밍 원칙을 따르도록 설계되었기 때문입니다. 따라서 GOTO문을 사용하는 것은 NS 차트의 기본 원칙에 어긋납니다. 다른 선지는 모두 NS 차트의 특징을 잘 나타내고 있습니다.  논리 흐름을 도형으로 표현하고, 이해하기 쉽게 설계되어 코드로의 변환이 용이하며,  프로그램의 기본 제어 구조를 명확하게 표현합니다.",55,6
635,1,7,35,"순서가 A, B, C, D로 정해진 입력자료를 push, push, pop, push, push, pop, pop, pop 순서로 스택연산을 수행하는 경우 출력 결과는?",,B D C A,A B C D,B A C D,A B D C,1,"이 문제는 스택 자료구조의 동작 원리를 이해하고 있는지 묻는 문제입니다. 스택은 '후입선출(LIFO, Last-In-First-Out)' 방식으로 데이터를 관리하는 자료구조입니다.  마치 쌓아올린 접시처럼, 가장 나중에 쌓은 접시를 가장 먼저 꺼낼 수 있습니다.  'push' 연산은 데이터를 스택에 쌓는 것을, 'pop' 연산은 스택에서 데이터를 꺼내는 것을 의미합니다.",68,11
636,1,7,36,분할 정복(Divide and Conquer)에 기반한 알고리즘으로 피벗(pivot)을 사용하며 최악의 경우 회의 비교를 수행해야 하는 정렬(Sort)은?,https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m36m1.gif,Selection Sort,Bubble Sort,Insert Sort,Quick Sort,4,"이 문제는 정렬 알고리즘 중 분할 정복 전략을 사용하는 알고리즘을 묻고 있습니다.  분할 정복이란, 큰 문제를 작은 여러 개의 부분 문제로 나누어 각 부분 문제를 해결한 후, 그 결과를 합쳐 원래 문제의 해답을 얻는 전략입니다.  퀵 정렬(Quick Sort)은 대표적인 분할 정복 기반 정렬 알고리즘으로,  피벗(pivot)이라는 기준 값을 정하고, 이 피벗보다 작은 값들은 왼쪽, 큰 값들은 오른쪽으로 나누는 과정을 반복합니다.  이 과정에서 최악의 경우(이미 정렬되어 있거나 거의 정렬되어 있는 경우)에는 n(n-1)/2 번의 비교 연산이 필요합니다.  선택 정렬, 버블 정렬, 삽입 정렬은 분할 정복 전략을 사용하지 않고, 다른 방식으로 정렬을 수행합니다. 따라서, 피벗을 사용하고 분할 정복 전략을 사용하며 최악의 경우 n(n-1)/2 회의 비교 연산을 수행하는 정렬 알고리즘은 퀵 정렬입니다.",53,11
637,1,7,37,화이트 박스 검사 기법에 해당하는 것으로만 짝지어진 것은?,https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m37.gif,"㉠, ㉡","㉠, ㉣","㉡, ㉤","㉢, ㉥",1,"이 문제는 화이트 박스 검사 기법에 대한 이해도를 묻는 문제입니다. 화이트 박스 검사는 소프트웨어의 내부 구조와 동작 방식을 알고 있는 상태에서 수행하는 검사 기법입니다.  소스 코드를 직접 확인하며 테스트를 설계하고 실행하므로, 코드의 모든 경로를 검증할 수 있다는 장점이 있습니다.  문제에서 제시된 몇몇 항목들은 소스 코드의 내부 구조를 직접적으로 파악하지 않고, 입력값과 출력값의 관계를 통해 검사하는 블랙박스 검사 기법에 해당합니다.  정답으로 제시된 두 가지 기법은 모두 소스 코드를 직접 분석하여 테스트 케이스를 설계하고 실행하는 화이트 박스 검사 기법입니다.  하나는 데이터가 프로그램 내부에서 어떻게 흐르는지 추적하는 기법이고, 다른 하나는 반복문(루프)의 동작을 철저히 검증하는 기법입니다.  따라서 소스 코드의 내부 구조를 직접적으로 분석하는 화이트 박스 검사 기법에 해당하는 두 가지 항목을 선택하는 것이 정답입니다.  블랙박스 검사 기법은 소프트웨어의 내부 동작을 모르는 상태에서 입력값과 출력값만을 가지고 검사하는 방법이기 때문에, 이 문제의 맥락에서는 정답에서 제외되어야 합니다.",67,19
638,1,7,38,소프트웨어 품질 관련 국제 표준인 ISO/IEC 25000에 관한 설명으로 옳지 않은 것은?,,소프트웨어 품질 평가를 위한 소프트웨어 품질평가 통합모델 표준이다.,System and Software Quality Requirements and Evaluation으로 줄여서 SQuaRE라고도 한다.,"ISO/IEC 2501n에서는 소프트웨어의 내부 측정, 외부측정, 사용품질 측정, 품질 측정 요소 등을 다룬다.",기존 소프트웨어 품질 평가 모델과 소프트웨어 평가 절차 모델인 ISO/IEC 9126과 ISO/IEC 14598을 통합하였다.,3,"이 문제는 소프트웨어 품질에 대한 국제 표준인 ISO/IEC 25000에 대한 이해도를 묻고 있습니다.  ISO/IEC 25000은 소프트웨어 품질 평가를 위한 종합적인 표준으로,  기존의 여러 소프트웨어 품질 평가 모델들을 통합하여 하나의 체계적인 프레임워크를 제공합니다.  SQuaRE(System and Software Quality Requirements and Evaluation)라는 약칭으로도 불리며, 소프트웨어의 품질을 다양한 측면에서 평가할 수 있는 기준과 방법론을 제시합니다.  소프트웨어의 내부 품질, 외부 품질, 사용성 품질 등을 포괄적으로 다루는 것이 특징입니다.  문제에서 옳지 않은 설명은,  ISO/IEC 25000이  특정 번호의 하위 표준(예: ISO/IEC 2501n)에서 소프트웨어의 내부 측정, 외부 측정 등을 구체적으로 다룬다는 내용입니다. ISO/IEC 25000은 여러 개의 하위 표준으로 구성되어 있지만,  하나의 하위 표준에서 모든 측정 요소를 다루는 것은 아닙니다.  각 하위 표준은 소프트웨어 품질의 특정 측면에 초점을 맞추어 상세한 지침을 제공합니다. 따라서,  모든 측정 요소를 특정 하위 표준에서 다룬다는 주장은 사실과 다릅니다.  ISO/IEC 25000은  기존의 ISO/IEC 9126(소프트웨어 품질 모델)과 ISO/IEC 14598(소프트웨어 품질 평가 절차)을 통합하여 만들어졌다는 사실은 맞는 설명입니다.  결론적으로,  하나의 하위 표준에서 소프트웨어 품질의 모든 측정 요소를 다룬다는 설명이 잘못된 것이므로, 이것이 옳지 않은 설명이 됩니다.",47,17
639,1,7,39,코드 인스펙션과 관련한 설명으로 틀린 것은?,,프로그램을 수행시켜보는 것 대신에 읽어보고 눈으로 확인하는 방법으로 볼 수 있다.,코드 품질 향상 기법 중 하나이다.,동적 테스트 시에만 활용하는 기법이다.,"결함과 함께 코딩 표준 준수 여부, 효율성 등의 다른 품질 이슈를 검사하기도 한다.",3,"코드 인스펙션은 프로그램을 직접 실행시키지 않고 코드를 읽어서 오류나 문제점을 찾는 정적 테스트 기법입니다.  마치 소설을 읽으면서 문장의 오류나 흐름의 문제를 찾는 것과 비슷하다고 생각하면 이해하기 쉽습니다.  따라서 프로그램을 실행시켜 보는 대신 읽어보고 눈으로 확인하는 방법이라는 설명은 맞는 말입니다. 또한, 코드 인스펙션은 코드의 품질을 높이기 위한 활동이므로 코드 품질 향상 기법 중 하나라는 설명도 정확합니다.  코드 인스펙션에서는 단순히 오류만 찾는 것이 아니라 코딩 표준 준수 여부, 코드의 효율성 등 다양한 측면을 검토합니다.  하지만 코드 인스펙션은 프로그램을 실행하지 않고 코드 자체를 검토하는 정적 테스트이기 때문에 동적 테스트 시에만 활용하는 기법이라는 설명은 틀렸습니다.  따라서 틀린 설명을 고르는 문제에서 정답은 동적 테스트 시에만 활용하는 기법이라는 선지입니다.",69,13
640,1,7,40,"프로젝트에 내재된 위험 요소를 인식하고 그 영향을 분석하여 이를 관리하는 활동으로서, 프로젝트를 성공시키기 위하여 위험 요소를 사전에 예측, 대비하는 모든 기술과 활동을 포함하는 것은?",,Critical Path Method,Risk Analysis,Work Breakdown Structure,Waterfall Model,2,"프로젝트를 진행하다 보면 예상치 못한 문제들이 발생할 수 있습니다. 예를 들어, 개발에 필요한 특정 부품의 수급이 어려워지거나, 예상보다 많은 비용이 소요될 수도 있고, 개발 기간이 지연될 수도 있습니다. 이러한 예상치 못한 문제들을 '위험 요소'라고 부릅니다.  '위험 분석(Risk Analysis)'이란 이러한 위험 요소들을 미리 파악하고, 각 위험 요소가 프로젝트에 미칠 영향을 분석하여,  발생 가능성과 그 영향을 줄이기 위한 대책을 세우는 활동을 말합니다.  프로젝트의 성공적인 완료를 위해서는 이러한 위험 요소들을 사전에 예측하고 대비하는 것이 매우 중요하며, 이를 위한 모든 기술과 활동을 포함하는 것이 바로 위험 분석입니다.  문제에서 제시된 다른 선택지들은 프로젝트 관리에 필요한 다른 요소들을 나타내지만, 위험 요소를 직접적으로 다루는 활동은 위험 분석입니다.  Critical Path Method는 프로젝트 일정 관리 기법이고, Work Breakdown Structure는 프로젝트 작업 분할 구조이며, Waterfall Model은 소프트웨어 개발 방법론입니다.  따라서 프로젝트에 내재된 위험 요소를 인식하고 관리하는 활동을 가장 잘 나타내는 용어는 위험 분석입니다.",78,47
641,1,7,41,데이터베이스 설계 단계 중 물리적 설계 시 고려 사항으로 적절하지 않은 것은?,,스키마의 평가 및 정제,응답 시간,저장 공간의 효율화,트랜잭션 처리량,1,"데이터베이스 물리적 설계는 논리적 설계 단계에서 만들어진 데이터베이스 모델을 실제 구현 가능하도록 구체화하는 단계입니다.  저장 공간 효율화나 트랜잭션 처리량, 응답 시간은 실제 데이터베이스 시스템이 얼마나 효율적이고 빠르게 동작할지를 결정하는 중요한 요소이기 때문에 물리적 설계에서 반드시 고려해야 할 사항입니다.  반면, 스키마의 평가 및 정제는 논리적 설계 단계에서 주로 이루어집니다.  논리적 설계는 데이터베이스의 구조와 관계를 정의하는 단계이며, 이 단계에서 데이터 모델의 정확성과 무결성을 검증하고 개선하는 작업이 이루어집니다.  물리적 설계는 이미 검증된 논리적 설계를 바탕으로 실제 구현에 필요한 세부적인 사항들을 결정하는 단계이므로, 스키마의 평가 및 정제는 물리적 설계의 범주를 벗어납니다.  따라서 물리적 설계 단계에서 고려 사항으로 적절하지 않은 것은 스키마의 평가 및 정제입니다.  마치 건물을 짓는 과정에 비유하자면, 논리적 설계는 건물의 설계도를 그리는 단계이고, 물리적 설계는 설계도를 바탕으로 실제 건축 자재를 선택하고 배치하는 단계입니다.  설계도 자체를 수정하는 작업은 건축 단계가 아닌 설계 단계에서 이루어져야 하는 것과 같은 이치입니다.",69,34
642,1,7,42,DELETE 명령에 대한 설명으로 틀린 것은?,,테이블의 행을 삭제할 때 사용한다.,WHERE 조건절이 없는 DELETE 명령을 수행하면 DROP TABLE 명령을 수행했을 때와 동일한 효과를 얻을 수 있다.,SQL을 사용 용도에 따라 분류할 경우 DML에 해당한다.,기본 사용 형식은 “DELETE FROM 테이블 [WHERE 조건];” 이다.,2,"DELETE 명령어는 데이터베이스에서 테이블의 행(데이터)을 삭제하는 데 사용하는 SQL 명령어입니다.  WHERE 조건절을 사용하면 특정 조건에 맞는 행만 삭제하고,  WHERE 조건절 없이 DELETE FROM 테이블명; 만 사용하면 테이블에 있는 모든 행이 삭제됩니다.  이는 마치 테이블 자체를 삭제하는 DROP TABLE 명령어와 결과적으로는 같은 효과를 내지만,  DROP TABLE은 테이블 자체를 완전히 없애는 것이고, DELETE는 테이블 구조는 유지한 채 데이터만 삭제하는 점에서 차이가 있습니다.  따라서 WHERE 조건절이 없는 DELETE 명령어는 DROP TABLE 명령어와 완전히 동일한 효과를 내는 것은 아닙니다. DELETE 명령어는 데이터 조작 언어(DML)에 속하며,  일반적인 사용 형식은 ""DELETE FROM 테이블명 WHERE 조건;"" 입니다.  [WHERE 조건] 부분은 선택적이며, 생략하면 모든 행이 삭제됩니다.",70,26
643,1,7,43,"어떤 릴레이션 R의 모든 조인 종속성의 만족이 R의 후보 키를 통해서만 만족될 때, 이 릴레이션 R이 해당하는 정규형은?",,제5정규형,제4정규형,제3정규형,제1정규형,1,"릴레이션 R의 모든 조인 종속성이 후보 키를 통해서만 만족된다는 것은,  데이터 중복이 최소화되었다는 것을 의미합니다.  좀 더 쉽게 설명하자면,  데이터베이스 테이블(릴레이션)에 불필요한 정보가 없고,  각 데이터가 오직 하나의 의미만 가지도록 잘 정리되어 있다는 뜻입니다.  이러한 상태는 데이터베이스 설계에서 가장 이상적인 형태 중 하나이며,  바로 제5정규형에 해당합니다.  제5정규형은 조인 종속성을 제거하여 데이터 중복을 최소화하고 데이터 무결성을 보장하는 가장 높은 수준의 정규형입니다.  낮은 정규형(예: 제3정규형, 제4정규형)에서는 여전히 어느 정도의 데이터 중복이나 무결성 문제가 남아있을 수 있지만, 제5정규형에서는 이러한 문제가 완전히 해결됩니다.  따라서 문제에서 제시된 조건을 만족하는 릴레이션은 제5정규형을 따른다고 할 수 있습니다.",61,29
644,1,7,44,E-R 모델에서 다중값 속성의 표기법은?,,https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m44b1.gif,https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m44b2.gif,https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m44b3.gif,https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m44b4.gif,3,"E-R 모델은 데이터베이스 설계에 사용되는 개체-관계 모델입니다.  데이터베이스를 설계할 때,  실제 세계의 개체(Entity)와 그 개체들 간의 관계(Relationship)를 도식적으로 표현하는 방법이죠.  여기서 중요한 것은 각 개체가 가지는 속성(Attribute)인데,  어떤 개체가 여러 개의 값을 가질 수 있는 경우가 있습니다. 예를 들어,  '학생'이라는 개체가 있다면,  '전화번호' 속성은 집 전화번호와 휴대전화번호 두 개를 가질 수 있겠죠. 이처럼 하나의 속성에 여러 개의 값을 가질 수 있는 속성을 다중값 속성(Multi-valued Attribute)이라고 합니다.  E-R 모델에서는 이러한 다중값 속성을 특별한 기호나 표기법으로 나타내는데,  일반적으로 { } 중괄호를 사용하여 표현합니다.  따라서 다중값 속성을 표기하는 방법은 중괄호를 이용하는 것입니다.  다른 선지들은 다중값 속성을 표현하는 방법이 아니므로 정답이 아닙니다.",78,30
645,1,7,45,다른 릴레이션의 기본키를 참조하는 키를 의미하는 것은?,,필드키,슈퍼키,외래키,후보키,3,"다른 테이블의 기본키를 참조하는 키를 묻는 문제입니다.  데이터베이스는 여러 개의 테이블로 구성되는데,  서로 다른 테이블 간의 관계를 맺어주는 중요한 역할을 하는 것이 바로 '외래키'입니다. 예를 들어, '고객' 테이블과 '주문' 테이블이 있다고 가정해 봅시다. '고객' 테이블에는 고객의 고유한 번호(기본키)가 있고, '주문' 테이블에는 주문 정보와 함께 해당 주문을 한 고객의 고객 번호가 있습니다. 이때 '주문' 테이블에 있는 '고객 번호'가 바로 '고객' 테이블의 기본키를 참조하는 외래키입니다.  외래키를 통해 두 테이블 간의 관계를 효율적으로 관리하고 데이터 중복을 방지할 수 있습니다.  다른 선택지들은 데이터베이스의 키 개념과 관련은 있지만, 다른 테이블의 기본키를 참조하는 특징을 가지고 있지 않습니다. 따라서 정답은 외래키입니다.",74,29
646,1,7,46,관계해석에서 '모든 것에 대하여'의 의미를 나타내는 논리 기호는?,,∃,∈,∀,⊂,3,"이 문제는 관계 해석에서 사용하는 논리 기호 중 '모든 것에 대하여'를 나타내는 기호를 묻고 있습니다.  수학이나 논리학에서 '모든' 이라는 말은 전칭(universal quantification)을 의미하며, 이를 나타내는 기호가 바로 ∀ 입니다.  예를 들어, ""모든 사람은 죽는다"" 라는 명제를 관계 해석의 논리 기호로 표현한다면,  ∀x (사람(x) → 죽는다(x)) 와 같이 표현할 수 있습니다. 여기서 ∀x 는 '모든 x에 대해서' 라는 의미를 가지고,  x는 사람을 나타내는 변수입니다.  다른 선지들은 각각 존재 기호(∃), 집합의 원소 기호(∈), 부분집합 기호(⊂)를 나타내므로 문제의 질문과는 맞지 않습니다. 따라서 '모든 것에 대하여'를 의미하는 논리 기호는 ∀ 입니다.",67,29
647,1,7,47,다음 릴레이션의 Degree와 Cardinality는?,https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m47.gif,"Degree : 4, Cardinality : 3","Degree : 3, Cardinality : 4","Degree : 3, Cardinality : 12","Degree : 12, Cardinality : 3",1,"이 문제는 관계형 데이터베이스에서 사용하는 용어인 Degree(차수)와 Cardinality(카디널리티)를 묻고 있습니다.  먼저, Degree는 릴레이션(테이블)에서 속성(컬럼)의 개수를 의미합니다.  문제에서 주어진 테이블은 '학번', '이름', '학년', '학과'의 네 개의 속성을 가지고 있으므로 Degree는 4입니다.  다음으로, Cardinality는 릴레이션에 있는 튜플(행)의 개수를 의미합니다.  문제의 테이블에는 홍길동, 이순신, 강감찬 세 명의 학생 정보가 있으므로 튜플의 개수는 3개이며, 따라서 Cardinality는 3입니다.  따라서 정답은 Degree가 4이고 Cardinality가 3인 것입니다.  쉽게 말해, Degree는 테이블의 열(column) 개수이고, Cardinality는 테이블의 행(row) 개수입니다.",64,29
648,1,7,48,뷰(View)에 대한 설명으로 틀린 것은?,,뷰 위에 또 다른 뷰를 정의할 수 있다.,DBA는 보안성 측면에서 뷰를 활용할 수 있다.,사용자가 필요한 정보를 요구에 맞게 가공하여 뷰로 만들 수 있다.,"SQL을 사용하면 뷰에 대한 삽입, 갱신, 삭제 연산 시 제약 사항이 없다.",4,"뷰(View)는 데이터베이스에 저장된 데이터의 특정 부분을 사용자에게 보여주는 가상 테이블입니다.  마치 실제 테이블처럼 보이지만, 실제로는 데이터를 저장하지 않고 기존 테이블의 데이터를 특정 조건에 따라 가공하여 보여주는 역할을 합니다. 따라서 사용자는 복잡한 SQL 문장을 사용하지 않고도 필요한 정보만 간편하게 얻을 수 있습니다.  문제에서 틀린 설명은 뷰에 대한 삽입, 갱신, 삭제 연산 시 제약 사항이 없다는 것입니다.  뷰는 기본 테이블에 대한 쿼리로 정의되기 때문에, 뷰를 통해 데이터를 삽입, 갱신, 삭제하려 할 때,  원본 테이블의 구조와 제약 조건에 따라 제한이 발생할 수 있습니다. 예를 들어, 뷰가 특정 조건을 만족하는 행만 보여주도록 정의되었다면, 그 조건을 만족하지 않는 데이터는 뷰를 통해 삽입할 수 없습니다.  또한, 뷰가 여러 테이블을 조인하여 만들어진 경우, 데이터 갱신 시 데이터 무결성 문제가 발생할 수 있어 제약이 생길 수 있습니다.  따라서 뷰를 통해 데이터를 조작할 때는 원본 테이블의 구조와 제약 조건을 고려해야 하며,  무조건적인 삽입, 갱신, 삭제가 가능한 것은 아닙니다.  다른 선택지는 모두 뷰의 특징을 잘 나타내고 있습니다. 뷰 위에 또 다른 뷰를 만들 수 있으며, DBA는 뷰를 이용해 특정 사용자에게는 특정 데이터만 보이도록 제한하여 보안성을 높일 수 있습니다.  또한 사용자는 원하는 정보만 추출하여 뷰를 생성할 수 있습니다.",77,28
649,1,7,49,관계 대수식을 SQL 질의로 옳게 표현한 것은?,https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m49.gif,SELECT 학생 FROM 이름 WHERE 학과='교육';,SELECT 이름 FROM 학생 WHERE 학과='교육';,SELECT 교육 FROM 학과 WHERE 이름='학생';,SELECT 학과 FROM 학생 WHERE 이름='교육';,2,"문제에서 주어진 관계 대수식 \( \Pi_{\text{이름}}(\sigma_{\text{학과} = \text{'교육'}}(\text{학생})) \)는 학생 테이블에서 학과가 '교육'인 학생들만 선택한 후(σ 연산자), 그 중에서 이름만 출력하라는(Π 연산자) 의미입니다.  쉽게 말해, '학생' 테이블에서 '학과'가 '교육'인 학생들의 '이름'만 골라서 보여달라는 뜻이죠.  SQL 질의문은 데이터베이스에 이러한 요청을 전달하는 명령어인데, 정답은  '학생' 테이블에서 '학과'가 '교육'인 레코드들을 선택하고, 그 레코드들 중 '이름' 필드만 선택하여 결과를 보여주는 질의문입니다. 다른 선택지는 테이블이나 필드 이름을 잘못 사용하거나, 조건을 잘못 설정하여 원하는 결과를 얻을 수 없습니다. 따라서,  '학생' 테이블에서 '학과'가 '교육'인 레코드의 '이름'을 선택하는 질의문만이 관계 대수식을 정확하게 표현한 것입니다.",67,29
650,1,7,50,정규화 과정에서 함수 종속이 A→B 이고 B→C 일 때 A→C인 관계를 제거하는 단계는?,,1NF → 2NF,2NF → 3NF,3NF → BCNF,BCNF → 4NF,2,"정규화는 데이터베이스의 중복을 제거하고 데이터 무결성을 높이기 위한 과정입니다.  함수 종속이란 어떤 속성의 값이 결정되면 다른 속성의 값도 결정되는 관계를 말합니다.  문제에서 A→B, B→C 라는 함수 종속이 있다는 것은 A의 값이 정해지면 B의 값이 정해지고, B의 값이 정해지면 C의 값도 정해진다는 뜻입니다.  결국 A의 값만 알면 B와 C의 값을 모두 알 수 있게 되죠. 이처럼 A가 B와 C를 결정하는 관계를  A→C 라고 표현합니다.  이러한  A→C  관계는  A→B 와 B→C 라는 함수 종속으로부터  자연스럽게 유도되는 것이므로,  중복된 정보를 가지고 있다고 볼 수 있습니다.  2NF에서 3NF로 넘어가는 과정은 바로 이러한 이행적 함수 종속(transitive dependency)을 제거하는 단계입니다. 이행적 함수 종속이란 A→B, B→C 와 같이 간접적으로 다른 속성을 결정하는 함수 종속을 말합니다.  따라서  A→C  관계를 제거하여 데이터 중복을 줄이고 데이터베이스의 효율성을 높이는 것이 2NF에서 3NF로 정규화하는 주요 목표입니다.",58,30
651,1,7,51,CREATE TABLE문에 포함되지 않는 기능은?,,속성 타입 변경,속성의 NOT NULL 여부 지정,기본키를 구성하는 속성 지정,CHECK 제약조건의 정의,1,"CREATE TABLE 문은 데이터베이스에 새로운 테이블을 생성하는 SQL 명령어입니다.  테이블을 만들 때는 테이블의 이름과 각 속성(컬럼)의 이름, 데이터 타입, 그리고 추가적인 제약 조건들을 정의합니다.  예를 들어,  '고객' 이라는 테이블을 만들고,  '고객ID', '이름', '전화번호' 라는 속성을 정의할 수 있습니다.  각 속성에는 문자열, 숫자 등의 데이터 타입을 지정하고,  '고객ID'는 중복을 허용하지 않는 기본키로 설정할 수도 있으며,  '전화번호'는 반드시 입력해야 하는 필수 항목으로 지정할 수도 있습니다.  또한, 전화번호 형식에 대한 제약 조건(CHECK 제약 조건)을 추가하여 데이터 무결성을 확보할 수 있습니다.  하지만 CREATE TABLE 문을 사용해서는 이미 생성된 테이블의 속성 타입을 변경할 수 없습니다.  테이블의 구조를 변경하려면 ALTER TABLE 문을 사용해야 합니다.  따라서 CREATE TABLE 문에 포함되지 않는 기능은 속성 타입 변경입니다.  다른 선택지들은 모두 CREATE TABLE 문을 통해 설정 가능합니다.  기본키 지정, NOT NULL 제약 조건, CHECK 제약 조건 등은 테이블 생성 시점에 함께 정의할 수 있는 중요한 기능들입니다.",57,27
652,1,7,52,SQL과 관련한 설명으로 틀린 것은?,,REVOKE 키워드를 사용하여 열 이름을 다시 부여할 수 있다.,"데이터 정의어는 기본 테이블, 뷰 테이블, 또는 인덱스 등을 생성, 변경, 제거하는데 사용되는 명령어이다.",DISTINCT를 활용하여 중복 값을 제거할 수 있다.,JOIN을 통해 여러 테이블의 레코드를 조합하여 표현할 수 있다.,1,"SQL은 데이터베이스를 관리하고 조작하는 데 사용되는 언어입니다. 문제에서 제시된 보기 중 틀린 내용은  열 이름을 다시 부여하는 작업에 REVOKE 키워드를 사용한다는 것입니다. REVOKE는 사용자의 권한을 취소하는 데 사용되는 키워드이지, 열 이름을 변경하는 데 사용되는 키워드가 아닙니다.  열 이름을 변경하려면 ALTER TABLE 명령어를 사용해야 합니다.  다른 보기들은 모두 SQL의 기본적인 기능들을 정확하게 설명하고 있습니다. 데이터 정의어(DDL)는 테이블, 뷰, 인덱스 등 데이터베이스의 구조를 정의하는 명령어이고, DISTINCT는 중복된 값을 제거하는 데 사용되며, JOIN은 여러 테이블의 데이터를 결합하여 사용하는 데 사용됩니다. 따라서 SQL의 기본적인 기능과 명령어에 대한 이해도를 묻는 문제이며, REVOKE 키워드의 용도를 정확하게 알고 있는지 확인하는 문제입니다.",67,27
653,1,7,53,다음 SQL문의 실행결과로 생성되는 튜플 수는?,https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m53.gif,1,3,4,5,4,"문제에서 주어진 SQL 문은 `SELECT 급여 FROM 사원;` 입니다. 이 문은 '사원' 테이블에서 '급여' 컬럼의 모든 값을 선택하라는 명령입니다.  '사원' 테이블의 내용을 살펴보면, 박철수, 한나라, 김감동, 이구수, 최초록 총 5명의 사원의 급여 정보가 각각 한 줄씩 기록되어 있습니다.  따라서, 이 SQL 문을 실행하면 '사원' 테이블에 있는 모든 사원의 급여 정보가 결과로 출력되고, 그 결과는 5개의 튜플(행)을 포함하게 됩니다.  각 튜플은 한 명의 사원의 급여를 나타내는 것이죠.  결과적으로,  SQL 문의 실행 결과로 생성되는 튜플의 수는 사원 테이블의 행의 수와 같습니다.",75,25
654,1,7,54,다음 SQL문에서 사용된 BETWEEN 연산의 의미와 동일한 것은?,https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m54.gif,점수 ＞= 90 AND 점수 ＜= 95,점수 ＞ 90 AND 점수 ＜ 95,점수 ＞ 90 AND 점수 ＜= 95,점수 ＞= 90 AND 점수 ＜ 95,1,"문제에서 제시된 SQL 문은 `WHERE (점수 BETWEEN 90 AND 95)` 조건을 사용하여 점수가 90점 이상 95점 이하인 레코드만 선택합니다.  `BETWEEN` 연산자는  ""이상""과 ""이하""를 동시에 포함하는 범위를 지정하는 연산자입니다. 따라서 점수가 90점 또는 95점을 포함하여 그 사이에 있는 모든 점수를 의미합니다.  제시된 보기 중에서 이와 동일한 의미를 갖는 것은 점수가 90 이상이고 95 이하인 조건을 나타내는  `점수 >= 90 AND 점수 <= 95` 입니다. 다른 보기들은 90점이나 95점을 포함하지 않거나, 범위를 잘못 표현하고 있습니다. 예를 들어, `점수 > 90 AND 점수 < 95` 는 90점과 95점을 제외한 91점부터 94점까지의 점수만을 나타냅니다.  따라서 `BETWEEN` 연산자의 의미를 정확하게 이해하고,  수치 범위를 포함하는 조건을  논리 연산자(`AND`, `OR`)를 사용하여 정확하게 표현하는 것이 중요합니다. 이 문제는 SQL의 기본적인 연산자 사용법을 묻는 문제로, 데이터베이스를 다루는 데 필수적인 이해를 요구합니다.",73,26
655,1,7,55,트랜잭션의 상태 중 트랜잭션의 수행이 실패하여 Rollback 연산을 실행한 상태는?,,철회(Aborted),부분 완료(Partially Committed),완료(Commit),실패(Fail),1,"트랜잭션이란 데이터베이스에서 여러 작업을 하나의 논리적 단위로 묶어서 처리하는 것을 말합니다.  예를 들어, 계좌 이체를 생각해보면, 출금 계좌에서 돈을 빼고, 입금 계좌에 돈을 더하는 두 가지 작업이 하나의 트랜잭션으로 묶입니다.  이때, 두 작업 중 하나라도 실패하면 전체 작업이 취소되어야 데이터베이스의 일관성을 유지할 수 있습니다.  문제에서 묻고 있는 것은 트랜잭션 수행이 실패했을 때의 상태인데, 이 경우 데이터베이스는 이전 상태로 되돌리는 작업, 즉 Rollback을 수행합니다. 이 상태를  ""철회(Aborted)""라고 합니다.  ""완료(Commit)""는 트랜잭션이 성공적으로 완료된 상태이고, ""부분 완료(Partially Committed)""는 일부 작업만 완료된 상태로, 데이터베이스의 일관성을 위협하기 때문에 적절하지 않습니다. ""실패(Fail)""는 트랜잭션의 수행 자체가 실패한 것을 의미하지, Rollback을 실행한 상태를 명확하게 나타내지는 않습니다. 따라서 트랜잭션의 수행이 실패하여 Rollback 연산을 실행한 상태는 ""철회(Aborted)""가 가장 정확한 표현입니다.  Rollback은 마치 잘못된 작업을 ""취소""하는 것과 같다고 생각하면 이해하기 쉽습니다.",69,27
656,1,7,56,데이터 제어어(DCL)에 대한 설명으로 옳은 것은?,,ROLLBACK : 데이터의 보안과 무결성을 정의한다.,COMMIT : 데이터베이스 사용자의 사용 권한을 취소한다.,GRANT : 데이터베이스 사용자의 사용 권한을 부여한다.,REVOKE : 데이터베이스 조작 작업이 비정상적으로 종료되었을 때 원래 상태로 복구한다.,3,"데이터 제어어(DCL, Data Control Language)는 데이터베이스 시스템에서 사용자의 접근 권한을 관리하는 데 사용되는 명령어 집합입니다.  데이터베이스는 중요한 정보를 담고 있으므로, 누구나 마음대로 접근하고 변경할 수 없도록 보호하는 것이 중요합니다.  마치 건물의 출입문처럼, 데이터베이스에도 접근 권한을 부여하고 제한하는 시스템이 필요한데, 이 역할을 DCL이 수행합니다.  문제에서 제시된 옵션들을 살펴보면,  데이터베이스 사용자에게 특정 작업에 대한 권한을 부여하는 명령어가 정답입니다.  예를 들어, 특정 테이블의 데이터를 조회하거나 수정할 수 있는 권한을 특정 사용자에게 부여하는 것이죠. 다른 옵션들은 데이터의 무결성이나 트랜잭션 관리, 혹은 권한의 취소와 관련된 다른 SQL 명령어들을 설명하고 있습니다. 따라서 데이터베이스 사용자의 권한을 부여하는 기능을 가진 명령어가 DCL의 핵심 기능을 가장 잘 나타내는 정답입니다.",76,26
657,1,7,57,"테이블 R과 S에 대한 SQL에 대한 SQL문이 실행되었을 때, 실행결과로 옳은 것은?",https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m57.gif,https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m57b1.gif,https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m57b2.gif,https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m57b3.gif,https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m57b4.gif,4,"이 문제는 SQL의 집합 연산자 중 `UNION ALL`의 동작을 이해하고 있는지를 묻는 문제입니다.  `UNION ALL` 연산자는 두 개 이상의 SELECT 문의 결과를 하나로 합쳐줍니다.  중복되는 행도 모두 포함하여 결과를 출력하는 것이 특징입니다.  문제에서 주어진 SQL 문을 살펴보면, 먼저 테이블 R에서 열 A의 값을 선택하고, 그 다음 테이블 S에서 열 A의 값을 선택하여 `UNION ALL`로 합치는 것을 알 수 있습니다.  테이블 R의 A 열에는 1과 3이, 테이블 S의 A 열에는 1과 2가 있습니다.  `UNION ALL`은 중복을 허용하므로, 최종 결과는 1, 3, 1, 2 순서대로 출력됩니다. 따라서 정답은 1, 3, 1, 2를 순서대로 나열한 것입니다.  쉽게 말해, 두 테이블의 A열에 있는 모든 값들을 순서대로 쌓아 올리는 연산이라고 생각하면 됩니다.  중복된 값(1)도 그대로 유지됩니다.",73,25
658,1,7,58,분산 데이터베이스 시스템(Distributed Database System)에 대한 설명으로 틀린 것은?,,분산 데이터베이스는 논리적으로는 하나의 시스템에 속하지만 물리적으로는 여러 개의 컴퓨터 사이트에 분산되어 있다.,"위치 투명성, 중복 투명성, 병행 투명성, 장애 투명성을 목표로 한다.","데이터베이스의 설계가 비교적 어렵고, 개발 비용과 처리 비용이 증가한다는 단점이 있다.","분산 데이터베이스 시스템의 주요 구성 요소는 분산 처리기, P2P 시스템, 단일 데이터베이스 등이 있다.",4,"분산 데이터베이스 시스템은 여러 대의 컴퓨터에 데이터를 나누어 저장하고 관리하는 시스템입니다.  마치 여러 개의 서랍장에 물건을 나누어 정리하는 것과 비슷하다고 생각하면 이해하기 쉽습니다.  문제에서 틀린 설명은 분산 데이터베이스 시스템의 주요 구성 요소에 대한 설명입니다.  분산 처리기는 물론 중요한 요소이지만, P2P 시스템이나 단일 데이터베이스는 분산 데이터베이스 시스템의 *주요* 구성 요소라고 보기 어렵습니다.  P2P 시스템은 분산된 환경에서 데이터를 공유하는 방식 중 하나일 뿐이며, 단일 데이터베이스는 여러 대의 컴퓨터에 분산된 데이터베이스 시스템의 개념과는 정반대입니다.  분산 데이터베이스 시스템은 여러 개의 데이터베이스를 통합적으로 관리하는 시스템이지, 단일 데이터베이스를 여러 곳에 복제하는 시스템이 아닙니다. 따라서,  분산 데이터베이스 시스템의 주요 구성 요소를 잘못 설명한 선지가 틀린 것입니다.  다른 선지는 분산 데이터베이스 시스템의 특징과 장단점을 정확하게 설명하고 있습니다.  즉, 논리적으로 하나의 시스템이지만 물리적으로는 여러 곳에 분산되어 있고, 사용자에게는 마치 하나의 시스템처럼 보이도록 투명성을 제공하며, 설계 및 관리의 어려움과 비용 증가라는 단점도 가지고 있다는 점을 정확히 나타내고 있습니다.",49,31
659,1,7,59,"테이블 두 개를 조인하여 뷰 V_1을 정의하고, V_1을 이용하여 뷰 V_2를 정의하였다. 다음 명령 수행 후 결과로 옳은 것은?",https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m59.gif,V_1만 삭제된다.,V_2만 삭제된다.,V_1과 V_2 모두 삭제된다.,V_1과 V_2 모두 삭제되지 않는다.,3,"이 문제는 데이터베이스에서 뷰(View)의 CASCADE 옵션에 대한 이해를 묻고 있습니다.  뷰는 기존 테이블을 기반으로 만들어진 가상 테이블입니다.  문제에서 V_1이라는 뷰는 두 개의 테이블을 조인하여 만들어졌고, V_2라는 뷰는 V_1을 이용하여 만들어졌다고 합니다.  즉, V_2는 V_1에 의존적인 관계에 있습니다.  `DROP VIEW V_1 CASCADE;` 명령어는 V_1 뷰를 삭제하는 명령어인데, 여기서 중요한 것은 `CASCADE` 옵션입니다.  CASCADE 옵션은 V_1 뷰에 의존하는 다른 객체들(이 경우 V_2 뷰)도 함께 삭제한다는 의미입니다.  따라서 V_1을 삭제하면 V_1에 의존하는 V_2도 자동으로 삭제됩니다.  마치 레고 블록을 쌓아 올린 것처럼, 아래쪽 블록(V_1)을 제거하면 위쪽 블록(V_2)도 함께 무너지는 것과 같은 원리입니다.  결론적으로, V_1을 삭제하는 명령어를 실행하면 V_1과 V_2 모두 삭제됩니다.",73,28
660,1,7,60,데이터베이스에서 병행제어의 목적으로 틀린 것은?,,시스템 활용도 최대화,사용자에 대한 응답시간 최소화,데이터베이스 공유 최소화,데이터베이스 일관성 유지,3,"데이터베이스 병행 제어의 목적은 여러 사용자가 동시에 데이터베이스를 접근하고 수정하더라도 데이터의 일관성을 유지하는 데 있습니다.  마치 여러 사람이 동시에 같은 문서를 편집할 때, 서로의 수정 내용이 엉키지 않고 최종적으로 하나의 일관된 문서가 완성되는 것과 같습니다.  따라서 데이터베이스의 일관성 유지는 병행 제어의 가장 중요한 목표입니다.  반면, 데이터베이스 공유를 최소화하는 것은 병행 제어의 목적이라기보다는 오히려 병행 제어를 통해 해결해야 하는 문제입니다.  데이터베이스를 공유하지 않으면 병행 제어가 필요 없겠지만, 데이터베이스의 활용도를 극대화하고 사용자 응답 시간을 최소화하려면 여러 사용자가 동시에 데이터베이스를 접근해야 하므로 공유는 필수적입니다.  따라서 데이터베이스 공유를 최소화하는 것은 병행 제어의 목표와 상반됩니다. 시스템 활용도 최대화와 사용자 응답시간 최소화는 병행 제어를 통해 달성할 수 있는 부수적인 효과이지, 병행 제어의 근본적인 목적은 아닙니다.",70,29
661,1,7,61,IP 주소체계와 관련한 설명으로 틀린 것은?,,IPv6의 패킷 헤더는 32 octet의 고정된 길이를 가진다.,IPv6는 주소 자동설정(Auto Configuration) 기능을 통해 손쉽게 이용자의 단말을 네트워크에 접속시킬 수 있다.,IPv4는 호스트 주소를 자동으로 설정하며 유니캐스트(Unicast)를 지원한다.,IPv4는 클래스별로 네트워크와 호스트 주소의 길이가 다르다.,1,"이 문제는 IP 주소 체계, 특히 IPv4와 IPv6의 특징을 얼마나 잘 이해하고 있는지 묻는 문제입니다.  정답은 IPv6 패킷 헤더의 길이에 대한 잘못된 설명입니다. IPv6 패킷 헤더는 고정 길이가 아니고, 기본 헤더는 40 바이트(octet)이지만, 옵션 헤더가 추가될 수 있기 때문에 가변적인 길이를 갖습니다.  32바이트라고 명시한 것은 잘못된 정보입니다.  나머지 선택지는 모두 IP 주소 체계의 특징을 정확하게 설명하고 있습니다. IPv6는 자동 주소 설정 기능을 통해 네트워크에 쉽게 연결될 수 있으며, IPv4는 클래스별로 네트워크와 호스트 주소의 길이가 다르다는 점도 사실입니다. IPv4가 호스트 주소를 자동으로 설정하는 기능은 DHCP(Dynamic Host Configuration Protocol)와 같은 프로토콜을 통해 이루어지며, 유니캐스트를 지원하는 것 또한 맞는 설명입니다. 따라서, IPv6 패킷 헤더의 길이에 대한 오류를 파악하는 것이 문제를 정확하게 푸는 핵심입니다.  쉽게 말해, IPv6는 더 유연하고 확장성이 뛰어나도록 설계되었기 때문에 헤더의 길이가 고정되어 있지 않다는 점을 기억하면 됩니다.",57,45
662,1,7,62,"다음 C언어 프로그램이 실행되었을 때, 실행 결과는?",https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m62.gif,"7, 5","8, 5","8, 9","7, 9",3,"이 문제는 C언어를 이용하여 2차원 배열을 다루는 방법과 포인터의 활용에 대한 이해도를 묻는 문제입니다.  먼저 `int arr[2][3] = {1, 2, 3, 4, 5, 6};`는 2행 3열의 2차원 정수형 배열 `arr`을 선언하고 초기화하는 부분입니다.  `arr` 배열은 다음과 같이 메모리에 저장됩니다.",42,11
663,1,7,63,OSI 7계층 중 데이터링크 계층에 해당되는 프로토콜이 아닌 것은?,,HTTP,HDLC,PPP,LLC,1,"이 문제는 OSI 7계층 중 데이터링크 계층에 속하는 프로토콜을 묻고 있습니다.  OSI 7계층은 네트워크 통신을 7개의 계층으로 나누어 각 계층이 특정 기능을 담당하도록 설계된 모델입니다.  데이터링크 계층은 물리적으로 연결된 두 장치 간의 신뢰할 수 있는 데이터 전송을 담당하는 계층입니다.  즉, 데이터를 실제로 전송하는 물리적인 연결을 관리하고, 오류 검출 및 재전송 등의 기능을 제공합니다.  문제에서 제시된 프로토콜 중 HDLC, PPP, LLC는 모두 데이터링크 계층에서 동작하는 프로토콜입니다. HDLC(High-Level Data Link Control)는 비동기식 및 동기식 통신 모두를 지원하는 표준 데이터링크 계층 프로토콜이고, PPP(Point-to-Point Protocol)는 두 지점 간의 직접 연결을 위한 프로토콜이며, LLC(Logical Link Control)는 데이터링크 계층의 하위 계층으로, MAC 주소를 사용하여 데이터를 전달하는 역할을 합니다. 반면, HTTP(Hypertext Transfer Protocol)는 애플리케이션 계층 프로토콜로, 웹 브라우저와 웹 서버 간의 통신을 담당합니다. 따라서 데이터링크 계층에 해당되지 않는 프로토콜은 HTTP입니다.  쉽게 말해, HTTP는 웹페이지를 주고받는 일을 하는 프로토콜이고, 나머지는 컴퓨터들이 서로 물리적으로 연결되어 데이터를 주고받을 수 있도록 돕는 프로토콜들입니다.  HTTP는 데이터를 실제로 전송하는 물리적인 부분과는 거리가 멀기 때문에 데이터링크 계층에 속하지 않습니다.",62,45
664,1,7,64,"C언어에서 두 개의 논리 값 중 하나라도 참이면 1을, 모두 거짓이면 0을 반환하는 연산자는?",,||,&&,**,!=,1,"C언어에서 논리 연산자는 두 개의 논리 값(참 또는 거짓)을 입력받아 하나의 논리 값을 반환합니다.  문제에서 설명하는 연산자는 두 논리 값 중 하나라도 참이면 참(1)을, 모두 거짓일 때만 거짓(0)을 반환하는 것을 의미합니다.  쉽게 생각하면,  ""A 또는 B"" 와 같은 조건을 표현하는 연산자인데, A가 참이거나 B가 참이면 전체 조건은 참이 되는 것이죠.  만약 A와 B 모두 거짓이라면 전체 조건은 거짓이 됩니다.  이러한 ""또는"" 조건을 C언어에서 표현하는 연산자가 바로 || 입니다.  반대로, 두 값이 모두 참일 때만 참을 반환하는 연산자는 && (그리고) 입니다.  !=는 같지 않다는 의미의 비교 연산자이고, **는 거듭제곱 연산자이므로 문제의 조건과 일치하지 않습니다. 따라서 두 값 중 하나라도 참이면 참을 반환하는 연산자는 || 입니다.",73,41
665,1,7,65,IPv6에 대한 특성으로 틀린 것은?,,표시방법은 8비트씩 4부분의 10진수로 표시한다.,2128개의 주소를 표현할 수 있다.,"등급별, 서비스별로 패킷을 구분할 수 있어 품질보장이 용이하다.",확장기능을 통해 보안기능을 제공한다.,1,"IPv6는 인터넷 프로토콜 버전 6으로, 기존 IPv4의 주소 부족 문제를 해결하기 위해 개발된 차세대 인터넷 프로토콜입니다.  문제에서 틀린 것은 IPv6 주소의 표시 방법에 대한 설명입니다. IPv6 주소는 128비트(16바이트)로 구성되며, 16진수로 표현됩니다.  각 16진수는 4비트를 나타내므로, 128비트는 32개의 16진수로 표현됩니다.  이 32개의 16진수는 보통 콜론(:)으로 구분하여 표기합니다. 예를 들어, `2001:0db8:85a3:0000:0000:8a2e:0370:7334` 와 같이 표현됩니다.  문제에서 제시된 '8비트씩 4부분의 10진수로 표시한다'는 IPv4의 표현 방식이며, IPv6와는 다릅니다.  나머지 선지는 IPv6의 특징을 정확하게 설명하고 있습니다. 2128개의 주소는 2의 128승으로 IPv6이 제공하는 방대한 주소 공간을 나타내고, 등급별 서비스 품질 보장 및 확장 기능을 통한 보안 기능 제공은 IPv6의 주요 장점입니다. 따라서, IPv6 주소 표현 방식에 대한 설명이 잘못된 것이 문제의 정답입니다.",69,45
666,1,7,66,JAVA의 예외(exception)와 관련한 설명으로 틀린 것은?,,문법 오류로 인해 발생한 것,오동작이나 결과에 악영향을 미칠 수 있는 실행 시간 동안에 발생한 오류,배열의 인덱스가 그 범위를 넘어서는 경우 발생하는 오류,존재하지 않는 파일을 읽으려고 하는 경우에 발생하는 오류,1,"JAVA에서 예외(exception)란 프로그램 실행 중 발생하는 오류를 말합니다.  프로그램의 문법적인 오류는 컴파일 단계에서 잡히므로 실행 중에 발생하는 오류가 아닙니다.  따라서 문법 오류는 예외의 원인이 될 수 없습니다.  반면에, 실행 중에 발생하는 오류는 다양한 원인으로 나타날 수 있습니다. 예를 들어, 프로그램이 잘못된 데이터를 처리하려고 하거나, 존재하지 않는 파일을 열려고 시도하거나, 배열의 범위를 벗어난 인덱스에 접근하려고 할 때 등이 있습니다. 이러한 상황들은 모두 프로그램의 오동작이나 결과에 악영향을 미칠 수 있는 실행시간 오류이며, JAVA에서는 예외로 처리됩니다.  따라서 실행시간 동안 발생하는 오류, 배열 인덱스 범위 초과, 존재하지 않는 파일 접근 시 발생하는 오류는 모두 JAVA 예외의 예시입니다.",55,43
667,1,7,67,TCP/IP 계층 구조에서 IP의 동작 과정에서의 전송 오류가 발생하는 경우에 대비해 오류 정보를 전송하는 목적으로 사용하는 프로토콜은?,,ECP(Error Checking Protocol),ARP(Address Resolution Protocol),ICMP(Internet Control Message Protocol),PPP(Point-to-Point Protocol),3,"TCP/IP 계층 구조에서 IP는 데이터를 목적지까지 전달하는 역할을 합니다.  하지만 네트워크 환경은 예측 불가능한 요소들이 많아 데이터 전송 중 오류가 발생할 수 있습니다.  예를 들어, 네트워크 장비의 고장이나 경로 상의 문제로 데이터 패킷이 손실되거나 잘못 전달될 수 있죠.  이러한 오류 상황을  알려주고, 필요한 조치를 취하기 위해 사용되는 프로토콜이 바로 ICMP입니다.  ICMP는 IP 계층에서 동작하며,  데이터 전송 오류 발생 시 오류 정보를 담은 메시지를 보내는 역할을 합니다.  예를 들어, 목적지에 도달하지 못한 패킷에 대한 '목적지 도달 불가' 메시지나, 네트워크 혼잡을 알리는 메시지 등을 전송합니다.  다른 선택지들은 각각 다른 목적으로 사용되는 프로토콜이기 때문에, 전송 오류 정보를 전달하는 목적과는 맞지 않습니다. 따라서, 네트워크에서 발생하는 전송 오류에 대한 정보를 전달하는 프로토콜은 ICMP가 정답입니다.",42,45
668,1,7,68,좋은 소프트웨어 설계를 위한 소프트웨어의 모듈간의 결합도(Coupling)와 모듈 내 요소 간 응집도(Cohesion)에 대한 설명으로 옳은 것은?,,응집도는 낮게 결합도는 높게 설계한다.,응집도는 높게 결합도는 낮게 설계한다.,양쪽 모두 낮게 설계한다.,양쪽 모두 높게 설계한다.,2,"좋은 소프트웨어는 마치 잘 정돈된 레고처럼, 각 부분(모듈)이 제 역할을 명확히 하고(응집도), 다른 부분과는 불필요하게 복잡하게 연결되지 않아야(결합도) 합니다.  응집도가 높다는 것은 각 모듈이 하나의 목적에 집중하여 기능을 수행한다는 의미이고, 결합도가 낮다는 것은 모듈 간의 의존성이 적어서, 한 모듈의 변경이 다른 모듈에 미치는 영향이 최소화된다는 것을 의미합니다.  만약 응집도가 낮다면, 모듈이 여러 가지 일을 동시에 하려고 하니 복잡하고 유지보수가 어려워지고, 결합도가 높다면, 모듈 간의 의존성이 높아서 한 모듈의 변경이 다른 여러 모듈에 영향을 미쳐서 전체 시스템에 문제가 발생할 가능성이 높아집니다. 따라서 좋은 소프트웨어를 만들기 위해서는 각 모듈은 하나의 목적에 집중하고(높은 응집도), 서로 간의 의존성은 최소화해야(낮은 결합도) 합니다.  이를 통해 소프트웨어의 유지보수성, 확장성, 재사용성을 높일 수 있습니다.  마치 잘 정돈된 레고처럼, 각 부분이 제 역할에 충실하고, 서로 간섭 없이 조립될 수 있도록 설계하는 것이 중요합니다.",71,6
669,1,7,69,다음과 같은 형태로 임계 구역의 접근을 제어하는 상호배제 기법은?,https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m69.gif,Dekker Algorithm,Lamport Algorithm,Peterson Algorithm,Semaphore,4,"문제에서 제시된 코드는 세마포어(Semaphore)의 동작을 보여줍니다.  세마포어는 임계 구역(Critical Section)에 대한 접근을 제어하는 상호 배제 기법 중 하나로,  정수형 변수 S를 이용하여 여러 프로세스가 동시에 임계 구역에 접근하는 것을 막습니다.  P(S) 연산은 세마포어 S의 값을 1 감소시키는 연산인데, S의 값이 0보다 작거나 같으면(즉, 임계 구역이 사용 중이면)  `while S <= 0 do skip;` 부분에서  S가 양수가 될 때까지 기다립니다.  즉, 다른 프로세스가 임계 구역을 빠져나가 S의 값을 증가시킬 때까지 대기하는 것입니다.  S의 값이 양수가 되면(임계 구역이 사용 가능해지면) S를 1 감소시키고 임계 구역에 진입합니다.  V(S) 연산은 세마포어 S의 값을 1 증가시키는 연산으로, 임계 구역을 빠져나갈 때 실행되어 다른 프로세스가 임계 구역에 접근할 수 있도록 합니다.  따라서 제시된 코드는 세마포어를 이용하여 임계 구역의 접근을 제어하는 방식을 명확하게 보여주고 있습니다.  Dekker 알고리즘, Lamport 알고리즘, Peterson 알고리즘은 세마포어와 달리  더 복잡한 구조를 가지고 있으며,  세마포어처럼 간결하게 표현되지 않습니다.",47,11
670,1,7,70,소프트웨어 개발에서 모듈(Module)이 되기 위한 주요 특징에 해당하지 않는 것은?,,다른 것들과 구별될 수 있는 독립적인 기능을 가진 단위(Unit)이다.,독립적인 컴파일이 가능하다.,유일한 이름을 가져야 한다.,다른 모듈에서의 접근이 불가능해야 한다.,4,"소프트웨어 개발에서 모듈은 독립적으로 개발, 테스트, 유지보수가 가능하도록 설계된 코드의 단위입니다.  마치 레고 블록처럼, 각각의 블록(모듈)은 특정 기능을 수행하고 다른 블록과 연결되어 큰 구조물(소프트웨어)을 만듭니다.  따라서 모듈은 다른 모듈과 구분되는 독립적인 기능을 가져야 하고(첫 번째 특징),  개별적으로 컴파일될 수 있어야 효율적인 개발이 가능합니다(두 번째 특징). 또한,  프로그래밍에서 모듈을 식별하고 호출하기 위해서는 고유한 이름이 필요합니다(세 번째 특징).  하지만,  모듈이 다른 모듈과 완전히 접근 불가능하다면(네 번째 특징),  소프트웨어의 각 부분이 서로 협력하여 기능을 수행할 수 없게 되어 전체 시스템이 제대로 작동하지 않을 것입니다.  모듈 간의 적절한 상호작용은 소프트웨어 개발의 핵심이며,  정보를 주고받고 협력하는 것이 필수적입니다. 따라서 다른 모듈에서의 접근이 완전히 불가능한 것은 모듈의 주요 특징이 아닙니다.  레고 블록이 서로 연결되어야 의미있는 구조물이 되는 것과 같은 이치입니다.",73,6
671,1,7,71,"빈 기억공간의 크기가 20KB, 16KB, 8KB, 40KB 일 때 기억장치 배치 전략으로 “Best Fit""을 사용하여 17KB의 프로그램을 적재할 경우 내부단편화의 크기는 얼마인가?",,3KB,23KB,64KB,67KB,1,"이 문제는 기억장치 배치 전략 중 ""Best Fit"" 전략을 이해하고 있는지를 묻는 문제입니다.  Best Fit 전략은 빈 기억 공간 중에서 프로그램 크기와 가장 가까운(즉, 가장 적합한) 크기의 공간에 프로그램을 적재하는 전략입니다.  문제에서 17KB의 프로그램을 적재해야 하고, 빈 기억 공간의 크기가 20KB, 16KB, 8KB, 40KB로 주어졌습니다.",73,11
672,1,7,72,"다음 C언어프로그램이 실행되었을 때, 실행 결과는?",https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m72.gif,i = 0,i = 1,i = 3,i = 4,4,"이 C언어 프로그램은 `while(1)` 루프를 사용하여 무한 루프를 만듭니다.  루프 안에서는 변수 `i`의 값이 4가 될 때까지 `++i`를 통해 1씩 증가시키고, `i`가 4가 되면 `break`문을 통해 루프를 빠져나옵니다. 따라서 루프가 종료될 때 `i`의 값은 4가 됩니다.  `printf` 함수는 `i`의 값을 출력하므로, 프로그램의 실행 결과는 `i = 4`가 되는 것입니다.  쉽게 말해, 0부터 시작해서 4가 될 때까지 1씩 계속 더하는 것이고, 4가 되는 순간 멈추기 때문에 최종적으로 i의 값은 4가 되는 것입니다.",68,41
673,1,7,73,"다음 JAVA 프로그램이 실행되었을 때, 실행 결과는?",https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m73.gif,BCDABCA,BCDABCC,CDDACCC,CDDACCA,2,"이 JAVA 프로그램은 문자열을 처리하는 과정을 보여줍니다.  처음에 문자열 ""BCDABC""가 있습니다.  프로그램은 이 문자열을 반복문을 통해 처리하는데,  각 반복마다 문자열의 첫 번째 문자를 떼어내어 새로운 문자열에 추가하고, 원래 문자열에서 첫 번째 문자를 제거합니다.  이 과정을 반복하면서 새로운 문자열이 만들어지는데,  원래 문자열의 문자가 순서대로 새로운 문자열에 추가되는 것을 확인할 수 있습니다.  따라서 최종적으로 만들어지는 새로운 문자열은 원래 문자열과 동일한 문자를 가지지만, 마지막 문자 'C'가 한 번 더 추가된 형태가 됩니다.  이는 마지막 반복에서 'C'가 추가되고,  원래 문자열이 비어 있더라도,  마지막 'C'는 새로운 문자열에 추가되기 때문입니다.  따라서 정답은 원래 문자열 ""BCDABC""에 마지막 문자 'C'가 추가된 ""BCDABCC""가 됩니다.  쉽게 말해,  문자열을 앞에서부터 하나씩 떼어서 새로운 문자열에 붙이는데,  마지막 문자는 두 번 붙게 되는 것입니다.",54,41
674,1,7,74,개발 환경 구성을 위한 빌드(Build) 도구에 해당하지 않는 것은?,,Ant,Kerberos,Maven,Gradle,2,"이 문제는 소프트웨어 개발 과정에서 프로젝트를 빌드(Build)하는 데 사용되는 도구들을 묻고 있습니다.  빌드란 소스 코드를 컴파일하고, 라이브러리를 연결하고, 실행 가능한 파일이나 배포 패키지를 생성하는 과정을 말합니다.  Ant, Maven, Gradle은 모두 이러한 빌드 과정을 자동화하고 관리하는 데 사용되는 도구입니다.  반면 Kerberos는 인증 시스템으로, 사용자의 신원을 확인하고 네트워크 자원에 대한 접근을 제어하는 보안 프로토콜입니다.  따라서 소프트웨어 개발 환경 구성을 위한 빌드 도구가 아닌 것은 Kerberos입니다.  쉽게 말해, Ant, Maven, Gradle은 건물을 짓는 데 필요한 여러 도구(망치, 드라이버 등)라면 Kerberos는 건물의 보안 시스템(경비 시스템, 출입 통제 시스템 등)에 해당한다고 생각하면 이해하기 쉬울 것입니다.  빌드 도구는 소스 코드를 가지고 실행 가능한 프로그램을 만드는 데 사용되지만, Kerberos는 프로그램의 실행과는 직접적인 관련이 없고, 보안에 초점을 맞춘 별개의 시스템입니다.",63,18
675,1,7,75,"3개의 페이지 프레임을 갖는 시스템에서 페이지 참조 순서가 1, 2, 1, 0, 4, 1, 3 일 경우 FIFO 알고리즘에 의한 페이지 교체의 경우 프레임의 최종 상태는?",,"1, 2, 0","2, 4, 3","1, 4, 2","4, 1, 3",4,"이 문제는 페이지 교체 알고리즘 중 FIFO(First-In, First-Out) 알고리즘을 이해하고 있는지 묻는 문제입니다. FIFO 알고리즘은 가장 먼저 들어온 페이지를 가장 먼저 교체하는 방식입니다.  문제에서 페이지 참조 순서가 1, 2, 1, 0, 4, 1, 3 이고, 페이지 프레임이 3개라고 했으니, 하나씩 차례대로 따라가 보겠습니다.",66,11
676,1,7,76,"다음 C언어 프로그램이 실행되었을 때, 실행 결과는?",https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m76.gif,E,V,R,O,3,"이 C언어 프로그램은 문자열을 조작하는 과정을 보여줍니다.  먼저 `str1`에는 ""KOREA"", `str2`에는 ""LOVE""가 저장됩니다.  `p1`과 `p2`는 각각 `str1`과 `str2`를 가리키는 포인터 변수입니다.",47,41
677,1,7,77,"다음 Python 프로그램이 실행되었을 때, 실행 결과는?",https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m77.gif,https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m77b1.gif,https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m77b2.gif,https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m77b3.gif,https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m77b4.gif,1,"이 Python 코드는 두 가지 데이터 구조, 리스트(list)와 딕셔너리(dictionary)를 사용하고 있습니다.  `list_data`는 문자열 'a', 'b', 'c'를 원소로 가지는 리스트이고, `dict_data`는 키가 문자열이고 값이 숫자인 딕셔너리입니다.  `print(list_data[0])`는 리스트 `list_data`의 첫 번째 원소(인덱스 0)를 출력하는 명령어입니다. 리스트의 인덱싱은 0부터 시작하므로, 첫 번째 원소는 'a'가 됩니다.  `print(dict_data['a'])`는 딕셔너리 `dict_data`에서 키 'a'에 해당하는 값을 출력하는 명령어입니다.  'a' 키에 해당하는 값은 90이므로, 90이 출력됩니다. 따라서 프로그램의 실행 결과는 'a'와 90을 줄바꿈하여 출력하는 것입니다.  변수 a에 100이라는 값이 할당되어 있지만, 코드에서는 이 변수를 사용하지 않으므로 실행 결과에는 영향을 미치지 않습니다.",74,11
678,1,7,78,"C언어에서 정수 변수 a, b에 각각 1, 2가 저장되어 있을 때 다음 식의 연산 결과로 옳은 것은?",https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m78.gif,0,1,3,5,2,"문제에서 주어진 C언어 식 `a < b + 2 && a << 1 <= b` 를 차례대로 풀어보겠습니다.  먼저 `a`는 1이고 `b`는 2입니다.  식의 왼쪽 부분 `a < b + 2`는 `1 < 2 + 2` 즉 `1 < 4`가 되어 참(true)이 됩니다.  다음으로 오른쪽 부분 `a << 1 <= b`를 살펴보겠습니다. `a << 1`은 `a`를 왼쪽으로 1비트 이동시키는 연산입니다.  정수 1은 이진수로 0001이고, 왼쪽으로 한 비트 이동하면 0010이 되는데, 이는 십진수로 2입니다. 따라서 `a << 1 <= b`는 `2 <= 2`가 되어 참(true)이 됩니다.  `&&` 연산자는 두 조건이 모두 참일 때만 참을 반환하므로,  결과적으로 전체 식은 참(true)이 됩니다. C언어에서 참은 1로, 거짓은 0으로 표현되므로, 최종 결과는 1입니다.",53,41
679,1,7,79,"다음 Python 프로그램이 실행되었을 때, 실행 결과는?",https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m79.gif,https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m79b1.gif,https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m79b2.gif,https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m79b3.gif,https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m79b4.gif,2,"이 Python 코드는 리스트 `a`에 저장된 문자열들을 순차적으로 출력하는 간단한 반복문을 사용하고 있습니다.  `for i in a:` 문은 리스트 `a`의 각 요소를 `i` 변수에 할당하면서 반복합니다.  `print(i)` 문은 각 반복마다 `i` 변수에 할당된 문자열을 화면에 출력합니다. 따라서 리스트 `a`에 ""대"", ""한"", ""민"", ""국"" 이라는 문자열이 순서대로 들어있으므로,  코드 실행 결과는 각 문자열이 한 줄씩 출력되는 것입니다.  마치 리스트의 내용물을 하나씩 꺼내 보여주는 것과 같습니다.  비전공자도 쉽게 이해할 수 있도록 예를 들면,  과자 상자(리스트 `a`)에 여러 종류의 과자(문자열)가 들어있고,  코드는 상자를 열어 과자를 하나씩 꺼내 이름을 말해주는(출력하는) 역할을 하는 것입니다.",62,11
680,1,7,80,UNIX 시스템의 쉘(shell)의 주요 기능에 대한 설명이 아닌 것은?,,사용자 명령을 해석하고 커널로 전달하는 기능을 제공한다.,반복적인 명령 프로그램을 만드는 프로그래밍 기능을 제공한다.,쉘 프로그램 실행을 위해 프로세스와 메모리를 관리한다.,초기화 파일을 이용해 사용자 환경을 설정하는 기능을 제공한다.,3,"UNIX 시스템에서 쉘(shell)은 사용자가 명령어를 입력하고 시스템과 상호작용하는 인터페이스 역할을 합니다.  사용자가 입력한 명령어를 해석하여 운영체제의 커널에게 전달하는 것은 쉘의 가장 기본적인 기능입니다.  또한, 반복적인 작업을 자동화하기 위해 쉘 스크립트를 작성할 수 있는 프로그래밍 기능도 제공합니다.  그리고 초기화 파일을 통해 사용자 환경(예: 디렉토리, 환경 변수 등)을 설정할 수 있도록 지원합니다. 하지만 쉘 자체는 프로세스와 메모리를 직접 관리하지 않습니다. 프로세스와 메모리 관리는 운영체제 커널의 역할입니다. 쉘은 커널에게 프로세스 생성이나 메모리 할당을 요청하는 역할만 수행합니다.  따라서 쉘이 프로세스와 메모리를 직접 관리한다는 설명은 쉘의 기능을 잘못 이해한 것입니다.  쉘은 커널과 사용자 사이의 중개자 역할을 하며, 커널의 기능을 이용하여 사용자의 명령을 수행하는 것입니다.",42,44
681,1,7,81,소프트웨어 생명주기 모델 중 나선형 모델(Spiral Model)과 관련한 설명으로 틀린 것은??,,소프트웨어 개발 프로세스를 위험 관리(Risk Management) 측면에서 본 모델이다.,위험 분석(Risk Analysis)은 반복적인 개발 진행 후 주기의 마지막 단계에서 최종적으로 한 번 수행해야 한다.,시스템을 여러 부분으로 나누어 여러 번의 개발 주기를 거치면서 시스템이 완성된다.,요구사항이나 아키텍처를 이해하기 어렵다거나 중심이 되는 기술에 문제가 있는 경우 적합한 모델이다.,2,"소프트웨어 생명주기 모델 중 나선형 모델은 위험 관리에 초점을 맞춘 반복적인 개발 모델입니다.  각 주기마다 계획, 위험 분석, 엔지니어링, 평가 단계를 거치며, 위험 분석은 각 주기의 초기에 수행되어 해당 주기의 개발 방향을 결정하는 데 중요한 역할을 합니다.  따라서 위험 분석을 반복적인 개발 진행 후 주기의 마지막 단계에서 최종적으로 한 번만 수행한다는 설명은 나선형 모델의 특징과 맞지 않습니다. 나선형 모델은 위험을 조기에 발견하고 관리하여 개발 과정에서 발생할 수 있는 문제를 최소화하는 것을 목표로 하기 때문입니다.  다른 선지는 나선형 모델의 특징을 잘 나타내고 있습니다. 시스템을 여러 부분으로 나누어 반복적인 개발 주기를 거치며, 요구사항이나 기술적인 문제가 있을 때 위험을 관리하며 점진적으로 시스템을 완성해 나가는 방식이 나선형 모델의 핵심입니다.",68,47
682,1,7,82,정보시스템과 관련한 다음 설명에 해당하는 것은?,https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m82.gif,고가용성 솔루션(HACMP),점대점 연결 방식(Point-to-Point Mode),스턱스넷(Stuxnet),루팅(Rooting),1,"문제에서 제시된 설명은 여러 시스템을 하나로 묶어(클러스터링) 동시에 작동하게 함으로써 시스템의 안정성을 높이는 기술을 설명하고 있습니다.  특히 기간 업무 서버의 안정성을 강조하고 있는데, 이는 시스템 중 하나에 장애가 발생하더라도 다른 시스템이 업무를 계속 처리하여 서비스 중단을 최소화하는 고가용성(High Availability)을 의미합니다.  공유 디스크를 중심으로 시스템을 연결하는 방식은 여러 고가용성 솔루션에서 사용되는 일반적인 기법입니다.  2개의 서버를 연결하여 각각 업무를 수행하는 설명 또한 고가용성 솔루션의 대표적인 구현 방식 중 하나입니다.  반면, 다른 선지들은 시스템의 안정성이나 여러 시스템의 동시 연결과는 직접적인 관련이 없습니다.  따라서 문제의 설명에 가장 적합한 것은 고가용성을 제공하는 솔루션입니다.  쉽게 말해, 하나의 서버가 고장 나도 다른 서버가 바로 업무를 이어받아 서비스가 끊기지 않도록 하는 기술이라고 생각하면 됩니다.",47,51
683,1,7,83,"위조된 매체 접근 제어(MAC) 주소를 지속적으로 네트워크로 흘려보내, 스위치 MAC 주소 테이블의 저장 기능을 혼란시켜 더미 허브(Dummy Hub)처럼 작동하게 하는 공격은?",,Parsing,LAN Tapping,Switch Jamming,FTP Flooding,3,"이 문제는 스위치의 정상적인 동작을 방해하는 공격에 대한 문제입니다.  네트워크 스위치는 MAC 주소를 이용하여 통신하는 장비들을 구분하고, 효율적인 통신을 위해 MAC 주소 테이블을 유지합니다.  이 테이블에는 연결된 장비의 MAC 주소와 연결된 포트 정보가 저장되어 있습니다.  문제에서 설명하는 공격은 위조된 MAC 주소를 끊임없이 스위치에 보내, 스위치가 이 잘못된 정보들을 처리하도록 만듭니다.  결과적으로 스위치의 MAC 주소 테이블은 혼란에 빠지고,  정상적인 MAC 주소 매핑을 할 수 없게 됩니다.  마치 모든 장비들이 하나의 허브에 연결된 것처럼 동작하게 되어, 네트워크 성능이 저하되고,  보안에 취약한 상태가 됩니다.  이는 스위치의 기능을 마비시키는 공격이므로, 스위치 재밍(Switch Jamming)이라고 부릅니다.  다른 선택지들은 네트워크 공격이지만, 스위치의 MAC 주소 테이블을 혼란시키는 방식과는 다릅니다.",54,55
684,1,7,84,다음 내용이 설명하는 스토리지 시스템은?,https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m84.gif,DAS,NAS,BSA,NFC,1,"문제에서 설명하는 스토리지 시스템은 하드디스크와 같은 저장장치가 호스트 버스 어댑터(HBA)에 직접 연결되고, 저장장치와 호스트 기기(서버 등) 사이에 네트워크 장비가 개입하지 않는다는 특징을 가지고 있습니다.  쉽게 말해, 서버와 저장장치가 마치 컴퓨터 본체와 내장 하드디스크처럼 직접 연결되어 있는 구조입니다.  네트워크를 거치지 않고 직접 연결되기 때문에 속도가 빠르다는 장점이 있습니다. 이러한 특징은 직접 연결 스토리지(Direct Attached Storage, DAS)의 정의와 정확히 일치합니다.  NAS(Network Attached Storage)는 네트워크를 통해 접근하는 저장장치이고, SAN(Storage Area Network)은 별도의 네트워크를 통해 저장장치를 관리하는 시스템입니다.  BSA와 NFC는 스토리지 시스템과 관련이 없습니다. 따라서 문제의 설명에 가장 적합한 답은 DAS입니다.",63,51
685,1,7,85,취약점 관리를 위해 일반적으로 수행하는 작업이 아닌 것은?,,무결성 검사,응용 프로그램의 보안 설정 및 패치(Patch) 적용,중단 프로세스 및 닫힌 포트 위주로 확인,불필요한 서비스 및 악성 프로그램의 확인과 제거,3,"취약점 관리란 시스템의 보안을 위협하는 취약점을 찾아내고, 이를 해결하여 시스템의 안전성을 확보하는 과정입니다.  일반적으로 취약점 관리를 위해서는 시스템의 무결성을 검사하고,  소프트웨어의 보안 설정을 강화하며, 필요 없는 서비스나 악성 프로그램을 제거하는 작업을 수행합니다.  하지만,  ""중단 프로세스 및 닫힌 포트 위주로 확인""하는 것은  취약점 관리의 전반적인 측면을 고려하지 않은,  불완전한 접근 방식입니다.  중단된 프로세스나 닫힌 포트는  겉으로 드러나는 현상일 뿐,  실제 취약점의 근본 원인을 파악하거나 해결하는 데는 도움이 되지 않습니다.  취약점은  다양한 경로와 방법으로 시스템에 침투할 수 있으므로,  단순히 중단된 프로세스나 닫힌 포트만 확인하는 것은  취약점 관리의 중요한 부분을 간과하는 것입니다.  따라서,  전체적인 시스템 보안을 고려한 포괄적인 접근이 필요하며,  제시된 다른 선택지들처럼  시스템의 무결성 검사,  소프트웨어 패치 적용,  불필요한 서비스 및 악성 프로그램 제거 등의 작업이  취약점 관리에 필수적입니다.",74,56
686,1,7,86,소프트웨어 생명주기 모델 중 V 모델과 관련한 설명으로 틀린 것은?,,요구 분석 및 설계단계를 거치지 않으며 항상 통합 테스트를 중심으로 V 형태를 이룬다.,Perry에 의해 제안되었으며 세부적인 테스트 과정으로 구성되어 신뢰도 높은 시스템을 개발하는데 효과적이다.,개발 작업과 검증 작업 사이의 관계를 명확히 들어내 놓은 폭포수 모델의 변형이라고 볼 수 있다.,폭포수 모델이 산출물 중심이라면 V 모델은 작업과 결과의 검증에 초점을 둔다.,1,"소프트웨어 생명주기 모델 중 V 모델은 폭포수 모델의 장점을 계승하면서 테스트 단계를 강조한 모델입니다.  폭포수 모델처럼 순차적으로 진행되지만, 각 개발 단계에 대응하는 테스트 단계가 함께 계획되고 수행됩니다.  마치 V자 모양처럼 개발 단계와 테스트 단계가 대칭적으로 연결되어 있어, 개발 단계의 산출물이 다음 단계의 입력이 되는 동시에, 해당 단계에 맞는 테스트가 진행되어 오류를 조기에 발견하고 수정할 수 있도록 합니다.  따라서 개발 단계와 검증 단계의 관계를 명확히 보여주는 폭포수 모델의 변형이라고 볼 수 있습니다.  또한, V 모델은 각 단계별 테스트 계획을 세부적으로 수립하여 진행하기 때문에 신뢰도 높은 시스템 개발에 효과적입니다.  하지만, V 모델은 요구사항 분석 및 설계 단계를 거치지 않는 것이 아니라, 오히려 이 단계들을 거쳐서 각 단계에 맞는 테스트 계획을 수립하고 실행합니다.  통합 테스트를 중심으로 V 형태를 이루는 것은 맞지만, 요구 분석 및 설계 단계를 거치지 않는다는 것은 V 모델의 핵심 개념과 맞지 않습니다.  결론적으로, 요구 분석 및 설계 단계를 거치지 않는다는 설명이 V 모델의 특징과 일치하지 않기 때문에 틀린 설명입니다.",54,47
687,1,7,87,블루투스(Bluetooth) 공격과 해당 공격에 대한 설명이 올바르게 연결된 것은?,,블루버그(BlueBug) - 블루투스의 취약점을 활용하여 장비의 파일에 접근하는 공격으로 OPP를 사용하여 정보를 열람,블루스나프(BlueSnarf) - 블루투스를 이용해 스팸처럼 명함을 익명으로 퍼뜨리는 것,블루프린팅(BluePrinting) - 블루투스 공격 장치의 검색 활동을 의미,블루재킹(BlueJacking) - 블루투스 장비사이의 취약한 연결 관리를 악용한 공격,3,"블루투스는 근거리 무선 통신 기술입니다.  문제에서 제시된 각 공격 유형을 살펴보면,  블루투스 장치의 검색 활동을 의미하는 것은 블루프린팅(BluePrinting)입니다.  블루버그는 블루투스의 취약점을 이용해 파일 접근을 시도하는 공격이고, 블루스나프는 블루투스를 통해 무단으로 장치 정보를 빼내는 공격이며, 블루재킹은 블루투스를 통해 원치 않는 메시지를 보내는 공격입니다. 따라서 블루투스 공격과 설명이 올바르게 연결된 것은 블루프린팅(BluePrinting)이 블루투스 공격 장치의 검색 활동을 의미하는 설명과 일치합니다. 다른 선택지는 블루투스 공격의 종류는 맞지만, 각 공격에 대한 설명이 정확하지 않거나 다른 공격 유형의 설명과 혼동되어 있습니다.  쉽게 말해, 블루프린팅은 블루투스 기기가 주변에 어떤 기기가 있는지 찾는 행위 자체를 의미하며, 이 행위를 악용하여 공격을 시도할 수 있다는 점을 나타냅니다.  마치 어두운 방에서 손전등으로 사람을 찾는 것과 같이, 블루프린팅은 공격의 시작점이 되는 중요한 단계입니다.",44,55
688,1,7,88,DoS(Denial of Service) 공격과 관련한 내용으로 틀린 것은?,,Ping of Death 공격은 정상 크기보다 큰 ICMP 패킷을 작은 조각(Fragment)으로 쪼개어 공격 대상이 조각화 된 패킷을 처리하게 만드는 공격 방법이다.,Smurf 공격은 멀티캐스트(Multicast)를 활용하여 공격 대상이 네트워크의 임의의 시스템에 패킷을 보내게 만드는 공격이다.,SYN Flooding은 존재하지 않는 클라이언트가 서버별로 한정된 접속 가능 공간에 접속한 것처럼 속여 다른 사용자가 서비스를 이용하지 못하게 하는 것이다.,Land 공격은 패킷 전송 시 출발지 IP주소와 목적지 IP주소 값을 똑같이 만들어서 공격 대상에게 보내는 공격 방법이다.,2,"DoS 공격은 서비스 거부 공격으로, 정상적인 사용자가 서비스를 이용하지 못하도록 공격하는 것을 말합니다.  문제에서 틀린 내용을 찾는 것이므로, 각 선지들을 하나씩 살펴보겠습니다. 첫 번째 선지는 Ping of Death 공격에 대한 설명으로, 정상적인 크기보다 큰 ICMP 패킷을 작은 조각으로 나누어 공격 대상 시스템이 이를 처리하는 과정에서 오류를 발생시켜 서비스를 마비시키는 방법을 정확하게 설명하고 있습니다. 세 번째 선지는 SYN Flooding 공격에 대한 설명으로,  서버의 연결 대기 공간을 가득 채워 정상적인 사용자의 접속을 막는 방식을 정확하게 설명하고 있습니다. 네 번째 선지는 Land 공격에 대한 설명으로, 출발지 IP 주소와 목적지 IP 주소를 동일하게 설정하여 공격 대상 시스템에 패킷을 보내 시스템을 다운시키는 방법을 정확하게 설명하고 있습니다.  하지만 두 번째 선지는 Smurf 공격에 대한 설명에서 멀티캐스트를 사용한다고 설명하고 있는데, 이는 잘못된 정보입니다. Smurf 공격은 브로드캐스트를 이용하여 공격 대상이 네트워크의 여러 시스템에 패킷을 보내게 만드는 공격입니다.  멀티캐스트는 특정 그룹의 시스템에만 패킷을 전송하는 것이고, 브로드캐스트는 네트워크 상의 모든 시스템에 패킷을 전송하는 것입니다. 따라서 Smurf 공격에 대한 설명이 잘못되었으므로, 이 선지가 틀린 것입니다.",38,55
689,1,7,89,다음 설명에 해당하는 시스템은?,https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m89.gif,Apache,Hadoop,Honeypot,MapReduce,3,"문제에서 제시된 설명은 침입자의 공격을 유도하여 그들의 행동을 분석하고, 시스템의 취약점을 파악하는 데 사용되는 시스템을 가리킵니다.  마치 미끼를 던져 범인을 유인하는 것과 같은 원리입니다.  설명에 따르면 이 시스템은 의도적으로 취약하게 만들어져 침입자를 유혹하고, 그들의 공격 기법을 분석하는 데 사용됩니다.  1990년대에 David Clock이 처음 제안했다는 점과 침입자를 추적하고 공격 기법을 수집하는 역할을 한다는 점은 이 시스템의 특징을 명확하게 보여줍니다.  이러한 특징들은 'Honeypot'이라는 시스템의 정의와 완벽하게 일치합니다. Honeypot은 실제 시스템처럼 보이지만 실제로는 가짜 시스템으로, 침입자의 공격을 유도하고 분석하기 위해 설계된 시스템입니다.  반면 다른 선택지는 웹 서버(Apache), 분산 처리 프레임워크(Hadoop), 분산 처리 프로그래밍 모델(MapReduce)로,  침입자 유인 및 분석과는 직접적인 관련이 없습니다. 따라서 문제의 설명에 가장 적합한 답은 Honeypot입니다.",64,55
690,1,7,90,다음이 설명하는 IT 기술은?,https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m90.gif,StackGuard,Docker,Cipher Container,Scytale,2,"문제에서 설명하는 IT 기술은 컨테이너 응용 프로그램의 배포를 자동화하는 오픈소스 엔진이며, 소프트웨어 컨테이너 안에 응용 프로그램을 자동으로 배치하는 역할을 합니다.  쉽게 말해, 여러 개의 프로그램을 각각 독립적인 공간(컨테이너)에 담아서 관리하고, 이 컨테이너들을 쉽고 빠르게 배포할 수 있도록 도와주는 도구라고 생각하면 됩니다. 마치 레고 블록처럼, 각각의 프로그램을 컨테이너라는 블록에 담아서 조립하고, 필요에 따라 쉽게 추가하거나 제거할 수 있죠. 이러한 기능을 제공하는 대표적인 오픈소스 프로젝트가 바로 Docker입니다.  StackGuard는 버퍼 오버플로우 공격 방지 기술, Cipher Container는 암호화된 컨테이너 기술, Scytale은 고대 암호 기술을 의미하므로 문제의 설명과는 부합하지 않습니다. 따라서 정답은 Docker입니다.",53,16
691,1,7,91,간트 차트(Gantt Chart)에 대한 설명으로 틀린 것은?,,프로젝트를 이루는 소작업 별로 언제 시작되고 언제 끝나야 하는지를 한 눈에 볼 수 있도록 도와준다.,자원 배치 계획에 유용하게 사용된다.,CPM 네트워크로부터 만드는 것이 가능하다.,수평 막대의 길이는 각 작업(Task)에 필요한 인원수를 나타낸다.,4,"간트 차트는 프로젝트의 각 작업(Task)의 시작과 종료 시점을 시각적으로 나타내는 도표입니다.  수평 막대의 길이는 각 작업의 *기간*을 나타내며, 작업 간의 의존 관계도 표현할 수 있어 프로젝트 일정 관리에 매우 유용합니다.  따라서, 각 작업의 시작과 끝을 한눈에 파악할 수 있다는 설명은 맞는 말이고, 자원 배치 계획에도 도움이 되는 것은 사실입니다.  CPM(Critical Path Method) 네트워크는 프로젝트의 작업 순서와 기간을 나타내는 네트워크 다이어그램인데, 이를 바탕으로 간트 차트를 만들 수 있습니다.  하지만 수평 막대의 길이가 작업에 필요한 인원 수를 나타낸다는 것은 잘못된 설명입니다.  수평 막대의 길이는 작업의 *소요 기간*을 나타내는 것이지, 인원 수를 나타내는 것이 아닙니다.  인원 수는 별도로 표시하거나, 다른 차트를 이용하여 관리해야 합니다.  따라서, 수평 막대의 길이가 인원 수를 나타낸다는 설명이 틀린 것입니다.",64,47
692,1,7,92,Python 기반의 웹 크롤링(Web Crawling) 프레임워크로 옳은 것은?,,Li-fi,Scrapy,CrawlCat,SBAS,2,"웹 크롤링이란 웹사이트를 돌아다니며 정보를 자동으로 수집하는 기술입니다.  마치 인터넷 상의 거미가 웹을 타고 다니며 정보를 모으는 것과 같다고 생각하면 이해하기 쉽습니다.  Python은 웹 크롤링에 많이 사용되는 프로그래밍 언어이고,  여러 가지 웹 크롤링 프레임워크들이 존재하는데, 그 중에서도  정답으로 제시된 프레임워크는 Python 기반의 강력하고 효율적인 웹 크롤링 프레임워크입니다.  다른 선택지들은 웹 크롤링과 직접적인 관련이 없거나,  웹 크롤링 프레임워크로 널리 알려져 있지 않습니다.  정답으로 제시된 프레임워크는  웹 크롤링 작업을 간소화하고,  효율적으로 수행할 수 있도록 다양한 기능들을 제공하여 개발자들에게 널리 사용되고 있습니다.  따라서 Python 기반의 웹 크롤링 프레임워크로 가장 적절한 선택입니다.",47,38
693,1,7,93,Secure 코딩에서 입력 데이터의 보안 약점과 관련한 설명으로 틀린 것은?,,SQL 삽입 : 사용자의 입력 값 등 외부 입력 값이 SQL 쿼리에 삽입되어 공격,크로스사이트 스크립트 : 검증되지 않은 외부 입력 값에 의해 브라우저에서 악의적인 코드가 실행,운영체제 명령어 삽입 : 운영체제 명령어 파라미터 입력 값이 적절한 사전검증을 거치지 않고 사용되어 공격자가 운영체제 명령어를 조작,자원 삽입 : 사용자가 내부 입력 값을 통해 시스템 내에 사용이 불가능한 자원을 지속적으로 입력함으로써 시스템에 과부하 발생,4,"Secure 코딩은 소프트웨어 개발 과정에서 보안 취약점을 줄이기 위한 방법들을 말합니다.  문제에서 제시된 네 가지 선지는 모두 입력 데이터로 인한 보안 위협을 설명하고 있습니다.  SQL 삽입, 크로스사이트 스크립팅, 운영체제 명령어 삽입은 모두 사용자의 악의적인 입력을 통해 시스템을 공격하는 방법입니다.  하지만 '사용자가 내부 입력 값을 통해 시스템 내에 사용이 불가능한 자원을 지속적으로 입력함으로써 시스템에 과부하를 발생'시키는 것은 일반적인 보안 약점이라기보다는 서비스 거부 공격(DoS, Denial of Service)에 가까운 개념입니다.  DoS 공격은 입력 데이터의 보안 약점보다는 시스템 자원의 부족이나 관리 부재에 의해 발생하는 문제입니다.  따라서 사용자의 악의적인 입력 데이터 자체가 직접적인 원인이라고 보기 어렵습니다. 다른 세 가지는 모두 사용자의 악의적인 입력 데이터를 통해 시스템의 보안에 직접적인 위협을 가하는 반면, 마지막 선지는 시스템 자원의 부족으로 인한 문제이므로 입력 데이터의 보안 약점과는 다르게 작용합니다.  결론적으로,  입력 데이터의 보안 약점과 직접적으로 관련이 없는 것은 마지막 선지입니다.",43,53
694,1,7,94,Windows 파일 시스템인 FAT와 비교했을 때의 NTFS의 특징이 아닌 것은?,,보안에 취약,대용량 볼륨에 효율적,자동 압축 및 안정성,저용량 볼륨에서의 속도 저하,1,"이 문제는 Windows 파일 시스템인 FAT와 NTFS의 차이점을 묻고 있습니다.  NTFS는 FAT에 비해 여러 가지 장점을 가지고 있는데, 그중 하나가 대용량 저장장치를 효율적으로 관리할 수 있다는 점입니다.  또한, NTFS는 파일 시스템 자체에 보안 기능이 내장되어 있어서 FAT보다 보안성이 훨씬 뛰어납니다.  자동 압축 기능은 NTFS의 고급 기능 중 하나로, 저장 공간을 효율적으로 사용할 수 있도록 도와줍니다.  반면에, 저용량 볼륨에서는 NTFS가 FAT보다 속도가 느릴 수 있다는 단점이 있습니다.  따라서, 문제에서 제시된 네 가지 특징 중에서 NTFS의 특징이 아닌 것은 바로 '보안에 취약'입니다. NTFS는 오히려 FAT보다 보안 기능이 강화되어 있기 때문입니다.  쉽게 말해,  금고(NTFS)와 일반 상자(FAT)를 비교했을 때, 금고가 더 안전한 것처럼 NTFS가 보안에 더 강력하다는 것을 알 수 있습니다.  따라서 정답은 '보안에 취약'이 아닌 다른 선택지가 됩니다.",51,1
695,1,7,95,DES는 몇 비트의 암호화 알고리즘인가?,,8,24,64,132,3,"DES(Data Encryption Standard)는 대칭키 암호화 알고리즘의 한 종류입니다.  대칭키 암호화는 암호화와 복호화에 같은 키를 사용하는 방식인데, DES는 데이터를 64비트 블록 단위로 나누어 암호화합니다.  문제에서 묻고 있는 것은 DES 알고리즘이 한 번에 처리하는 데이터의 크기, 즉 블록 크기입니다.  따라서 DES는 64비트의 암호화 알고리즘이라고 할 수 있습니다.  쉽게 말해, DES는 64개의 0과 1로 이루어진 비트열을 한꺼번에 암호화하는 방식을 사용합니다. 다른 선지들은 DES의 블록 크기가 아닌 다른 값들을 나타내고 있으므로 정답이 아닙니다.",66,54
696,1,7,96,리눅스에서 생성된 파일 권한이 644일 경우 umask 값은?,,22,666,777,755,1,"리눅스 파일 시스템에서 파일 권한은 소유자, 그룹, 다른 사용자 각각에 대해 읽기(r), 쓰기(w), 실행(x) 권한을 부여하는 3자리 8진수로 표현됩니다.  각 자리의 숫자는 4(읽기), 2(쓰기), 1(실행)의 합으로 이루어지며,  예를 들어 644는 소유자에게 읽기(4)와 쓰기(2) 권한(4+2=6), 그룹과 다른 사용자에게는 읽기(4) 권한만 있는 것을 의미합니다.",49,44
697,1,7,97,다음 내용이 설명하는 로그 파일은?,https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m97.gif,tapping,xtslog,linuxer,wtmp,4,"문제에서 제시된 설명은 리눅스 시스템에서 사용자의 로그인/로그아웃 정보와 시스템 시작/종료 시간을 기록하는 로그 파일을 묻고 있습니다.  리눅스 시스템은 다양한 로그 파일을 사용하지만, 사용자의 로그인/로그아웃 및 시스템 시작/종료와 같은 중요한 시스템 이벤트를 기록하는 대표적인 파일이 바로 `wtmp` 파일입니다.  `wtmp` 파일은 시스템의 who 명령어를 통해 확인할 수 있는 정보들을 저장하고 있으며,  시스템 관리자는 이 파일을 통해 시스템의 사용 현황과 시스템의 안정성을 파악하는 데 활용합니다.  따라서 문제에서 제시된 설명에 가장 적합한 로그 파일은 `wtmp`입니다. 다른 선지들은 리눅스 시스템의 로그 파일과는 관련이 없습니다.",41,44
698,1,7,98,상향식 비용 산정 기법 중 LOC(원시 코드 라인 수) 기법에서 예측치를 구하기 위해 사용하는 항목이 아닌 것은?,,낙관치,기대치,비관치,모형치,4,"소프트웨어 개발 비용을 예측하는 방법 중 하나인 LOC(Lines of Code, 원시 코드 라인 수) 기법은 프로그램의 크기를 코드 라인 수로 측정하여 비용을 산정하는 상향식 기법입니다.  이 기법은 개발에 필요한 시간을 코드 라인 수에 비례하여 추정하고, 이 시간에 단위 시간당 비용을 곱하여 총 비용을 산출합니다.  이때,  정확한 예측을 위해 통계적 기법을 활용하는데,  낙관치(가장 짧은 시간), 기대치(평균적인 시간), 비관치(가장 긴 시간)를 사용하여  프로젝트 완료에 걸리는 시간을 예측합니다. 이 세 가지 값을 이용하여  프로젝트 완료 시간의 확률 분포를 추정하고,  이를 바탕으로 비용을 산정하는 것이죠.  반면, '모형치'는 LOC 기법에서 직접적으로 사용하는 값이 아닙니다. 모형치는 어떤 특정 모델이나 공식을 통해 도출된 값을 의미하는데, LOC 기법은 낙관치, 기대치, 비관치를 바탕으로 통계적 방법을 통해 예측치를 구하기 때문에,  미리 정의된 모형치를 사용하지 않습니다. 따라서, LOC 기법에서 예측치를 구하기 위해 사용하지 않는 항목은 '모형치'입니다.",62,47
699,1,7,99,"OSI 7 Layer 전 계층의 프로토콜과 패킷 내부의 콘텐츠를 파악하여 침입 시도, 해킹 등을 탐지하고 트래픽을 조정하기 위한 패킷 분석 기술은?",,PLCP(Packet Level Control Processor),Traffic Distributor,Packet Tree,DPI(Deep Packet Inspection),4,"이 문제는 네트워크 트래픽을 분석하는 기술에 대한 문제입니다.  OSI 7계층(물리계층부터 응용계층까지)의 모든 계층에서 전송되는 패킷의 내용을 자세히 들여다보고 분석하여,  해킹이나 침입 시도와 같은 악의적인 행위를 탐지하거나, 네트워크 트래픽을 효율적으로 관리하는 기술을 묻고 있습니다.  단순히 패킷의 헤더 정보만 확인하는 것이 아니라, 패킷 안에 담긴 실제 데이터까지 분석하여  그 내용을 이해하고 판단하는 고급 기술입니다.  예를 들어,  이메일 내용이나 웹 페이지의 데이터까지 분석하여 스팸 메일이나 악성 코드를 탐지하는 것이 가능합니다.  따라서 OSI 7계층 전 계층의 프로토콜과 패킷 내부 콘텐츠를 모두 분석하는 '심층 패킷 검사(DPI)'가 정답입니다. 다른 선택지는 패킷을 처리하거나 분배하는 기능을 하는 기술이지만, 패킷의 내용까지 심층적으로 분석하는 기능은 포함하지 않습니다.",46,45
700,1,7,100,소프트웨어 개발 방법론의 테일러링(Tailoring)과 관련한 설명으로 틀린 것은?,,프로젝트 수행 시 예상되는 변화를 배제하고 신속히 진행하여야 한다.,"프로젝트에 최적화된 개발 방법론을 적용하기 위해 절차, 산출물 등을 적절히 변경하는 활동이다.",관리 측면에서의 목적 중 하나는 최단기간에 안정적인 프로젝트 진행을 위한 사전 위험을 식별하고 제거하는 것이다.,기술적 측면에서의 목적 중 하나는 프로젝트에 최적화된 기술 요소를 도입하여 프로젝트 특성에 맞는 최적의 기법과 도구를 사용하는 것이다.,1,"소프트웨어 개발 방법론의 테일러링(Tailoring)은 특정 프로젝트의 상황과 요구사항에 맞춰 표준적인 개발 방법론을 조정하고 최적화하는 과정입니다.  마치 맞춤 정장을 만드는 것처럼, 기성복(표준 방법론)을 바탕으로 프로젝트의 특징에 맞게 디자인(절차, 산출물 등)을 변경하는 것이죠. 따라서 프로젝트에 최적화된 개발 방법론을 적용하기 위해 절차, 산출물 등을 적절히 변경하는 활동이라는 설명은 정확합니다. 또한, 관리 및 기술적 측면에서 프로젝트의 성공적인 수행을 위해 위험을 사전에 제거하고 최적의 기술과 도구를 사용하는 것 역시 테일러링의 중요한 목표입니다. 하지만, 프로젝트 수행 시 예상되는 변화를 배제하고 신속히 진행해야 한다는 주장은 테일러링의 개념과 정면으로 배치됩니다. 테일러링은 바로 이러한 예상되는 변화를 수용하고, 그 변화에 맞춰 방법론을 유연하게 조정하는 것을 핵심으로 하기 때문입니다.  즉, 변화를 배제하는 것이 아니라, 변화를 적극적으로 반영하여 프로젝트의 성공 가능성을 높이는 것이 테일러링의 목표입니다.  따라서,  '프로젝트 수행 시 예상되는 변화를 배제하고 신속히 진행하여야 한다'는 설명이 틀린 것입니다.",55,48
701,1,8,1,UML 다이어그램 중 순차 다이어그램에 대한 설명으로 틀린 것은?,,객체 간의 동적 상호작용을 시간 개념을 중심으로 모델링 하는 것이다.,주로 시스템의 정적 측면을 모델링하기 위해 사용한다.,일반적으로 다이어그램의 수직 방향이 시간의 흐름을 나타낸다.,"회귀 메시지(Self-Message), 제어블록(Statement block) 등으로 구성된다.",2,"이 문제는 UML 다이어그램 중 순차 다이어그램에 대한 이해도를 묻고 있습니다.  순차 다이어그램은 시스템 내의 여러 객체들이 시간의 흐름에 따라 어떻게 상호작용하는지를 보여주는 다이어그램입니다. 마치 연극의 대본처럼, 각 객체가 언제 어떤 메시지를 주고받는지, 어떤 순서로 동작하는지를 시각적으로 나타내죠.  따라서 객체 간의 동적 상호작용을 시간 개념을 중심으로 모델링하는 것은 순차 다이어그램의 핵심적인 특징입니다.  다이어그램의 수직 방향은 시간의 흐름을 나타내고,  회귀 메시지나 제어 블록과 같은 요소들을 사용하여 복잡한 상호작용을 표현하기도 합니다.  하지만 순차 다이어그램은 시스템의 정적인 구조(어떤 객체가 있고, 어떤 속성을 가지는지 등)를 모델링하는 데에는 적합하지 않습니다. 정적인 구조는 클래스 다이어그램과 같은 다른 UML 다이어그램을 통해 표현하는 것이 더 적절합니다. 따라서 시스템의 정적 측면을 모델링하기 위해 순차 다이어그램을 주로 사용한다는 설명은 틀린 것입니다.",61,2
702,1,8,2,"메시지 지향 미들웨어(Message-Oriented Middleware, MOM)에 대한 설명으로 틀린 것은?",,느리고 안정적인 응답보다는 즉각적인 응답이 필요한 온라인 업무에 적합하다.,독립적인 애플리케이션을 하나의 통합된 시스템으로 묶기 위한 역할을 한다.,송신측과 수신측의 연결 시 메시지 큐를 활용하는 방법이 있다.,상이한 애플리케이션 간 통신을 비동기 방식으로 지원한다.,1,"메시지 지향 미들웨어(MOM)는 서로 다른 애플리케이션들이 서로 직접 연결되지 않고, 메시지를 주고받는 방식으로 통신하는 기술입니다.  마치 편지를 우체통에 넣어두면 상대방이 나중에 편지를 꺼내 읽는 것과 비슷합니다.  따라서 송신 측과 수신 측이 동시에 연결되어 있을 필요가 없고, 비동기적으로 통신이 가능합니다.  메시지는 큐(Queue)에 저장되어 있다가 수신 측에서 가져가 처리하므로, 송신 측은 메시지를 보낸 후 바로 다른 작업을 수행할 수 있습니다.  이러한 특징 때문에 MOM은 즉각적인 응답이 중요하지 않고, 안정적인 데이터 전달이 중요한 시스템에 적합합니다.  예를 들어, 온라인 게임처럼 즉각적인 응답이 중요한 시스템에는 적합하지 않고, 주문 처리 시스템처럼 안정적인 처리가 중요한 시스템에는 적합합니다.  문제에서 틀린 것은 바로 이러한 MOM의 특징과 반대되는 내용을 기술하고 있기 때문입니다.  즉각적인 응답이 필요한 온라인 업무에는 적합하지 않다는 것이 핵심입니다.  다른 선지는 모두 MOM의 특징을 잘 나타내고 있습니다.  독립적인 애플리케이션을 통합하고, 메시지 큐를 사용하며, 비동기 방식으로 통신을 지원하는 것은 MOM의 핵심 기능입니다.",45,10
703,1,8,3,익스트림 프로그래밍에 대한 설명으로 틀린 것은?,,대표적인 구조적 방법론 중 하나이다.,소규모 개발 조직이 불확실하고 변경이 많은 요구를 접하였을 때 적절한 방법이다.,익스트림 프로그래밍을 구동시키는 원리는 상식적인 원리와 경험을 최대한 끌어 올리는 것이다.,"구체적인 실천 방법을 정의하고 있으며, 개발 문서 보다는 소스코드에 중점을 둔다.",1,"이 문제는 익스트림 프로그래밍(XP)에 대한 이해도를 묻는 문제입니다.  익스트림 프로그래밍은 기존의 무겁고 복잡한 소프트웨어 개발 방법론과 달리,  변화에 빠르게 적응하고 고객과의 긴밀한 협력을 중시하는 애자일(Agile) 방법론의 대표적인 예시입니다.  따라서,  소규모 개발팀이 불확실하고 자주 변경되는 요구사항을 처리하는 데 매우 효과적입니다.  XP는 개발 과정에서 문서 작성보다는 실제 작동하는 코드를 중시하며,  단순하고 명확한 코드를 작성하고 꾸준히 테스트하는 것을 강조합니다.  반면,  XP는 구조적 방법론이 아니며,  오히려 구조적 방법론의 복잡성을 피하기 위해 등장한 방법론입니다.  구조적 방법론은  상향식 또는 하향식 설계와 같은 체계적인 접근 방식을 사용하는 반면, XP는 더 유연하고 반복적인 접근 방식을 취합니다.  문제에서 틀린 설명은 바로 이 부분입니다. XP는  '상식적인 원리와 경험을 최대한 끌어올리는 것'을 원리로 하지만,  그것이 전부가 아니며,  엄격한 실천 방법과 원칙을 가지고 있습니다.  따라서,  XP가 구조적 방법론이라는 설명은 잘못된 것입니다.",48,2
704,1,8,4,유스케이스(Use Case)의 구성 요소 간의 관계에 포함되지 않는 것은?,,연관,확장,구체화,일반화,3,"유스케이스는 시스템이 사용자에게 제공하는 기능을 설명하는 모델입니다.  쉽게 말해, 사용자가 시스템을 어떻게 사용하는지, 어떤 결과를 얻는지를 보여주는 하나의 시나리오라고 생각하면 됩니다.  유스케이스는 여러 구성 요소들로 이루어져 있는데,  '연관'은 하나의 유스케이스가 다른 유스케이스와 어떻게 연결되는지를 나타내고, '확장'은 예외적인 상황이나 특별한 흐름을 추가적으로 설명하는 것을 의미하며, '일반화'는 여러 유스케이스의 공통적인 부분을 추출하여 상위 유스케이스로 만드는 것을 의미합니다.  하지만 '구체화'는 유스케이스 모델의 구성 요소 간의 관계를 설명하는 데 사용되는 용어가 아닙니다.  구체화는 어떤 추상적인 개념을 더 자세하고 상세하게 설명하는 것을 의미하는데, 유스케이스 모델에서는  연관, 확장, 일반화와 같은 관계를 통해 이미 충분히 상세화가 이루어지기 때문에  '구체화'라는 개념은 별도로 필요하지 않습니다. 따라서 유스케이스 구성 요소 간의 관계에 포함되지 않는 것은 '구체화'입니다.",48,2
705,1,8,5,요구사항 분석에서 비기능적(Nonfunctional) 요구에 대한 설명으로 옳은 것은?,,"시스템의 처리량(Throughput), 반응 시간 등의 성능 요구나 품질 요구는 비기능적 요구에 해당하지 않는다.",차량 대여 시스템이 제공하는 모든 화면이 3초 이내에 사용자에게 보여야 한다'는 비기능적 요구이다.,"시스템 구축과 관련된 안전, 보안에 대한 요구사항들은 비기능적 요구에 해당하지 않는다.","금융 시스템은 조회, 인출, 입금, 송금의 기능이 있어야 한다'는 비기능적 요구이다.",2,"요구사항 분석은 시스템 개발의 가장 첫 단계로, 시스템이 무엇을 해야 하는지(기능적 요구사항)와 어떻게 해야 하는지(비기능적 요구사항)를 명확히 정의하는 과정입니다.  기능적 요구사항은 시스템이 수행해야 하는 기능 자체를 의미하는 반면, 비기능적 요구사항은 시스템의 성능, 안전성, 보안성 등 시스템의 품질과 관련된 요구사항을 의미합니다.  문제에서 정답으로 제시된 선지는 '차량 대여 시스템이 제공하는 모든 화면이 3초 이내에 사용자에게 보여야 한다'는 내용입니다. 이는 시스템의 응답 속도, 즉 성능에 대한 요구사항이며, 시스템이 어떤 기능을 수행하는지가 아니라 *어떻게* 수행해야 하는지를 나타내는 것이므로 비기능적 요구사항에 해당합니다. 다른 선지들은 시스템의 기능 자체(기능적 요구사항) 또는 비기능적 요구사항이 아닌 내용을 기술하고 있습니다.  따라서, 시스템의 성능, 안전성, 보안성 등과 같은 품질적인 요구사항을 나타내는 것이 비기능적 요구사항의 핵심입니다.  정답으로 제시된 선지는 이러한 비기능적 요구사항의 전형적인 예시를 보여줍니다.",45,2
706,1,8,6,정보공학 방법론에서 데이터베이스 설계의 표현으로 사용하는 모델링 언어는?,,Package Diagram,State Transition Diagram,Deployment Diagram,Entity-Relationship Diagram,4,"데이터베이스 설계는 데이터를 효율적으로 저장하고 관리하기 위한 과정입니다.  이 과정에서 데이터의 구조와 관계를 시각적으로 표현하는 도구가 필요한데,  그 중 가장 널리 사용되는 것이 바로 개체-관계 다이어그램(Entity-Relationship Diagram, ERD)입니다.  ERD는 데이터베이스를 구성하는 개체(Entity)와 그 개체들 간의 관계(Relationship)를 도식적으로 나타내는 모델링 언어입니다.  개체는 데이터베이스에서 관리되는 실제 사물이나 개념(예: 고객, 상품)을 의미하고, 관계는 개체들 간의 연관성(예: 고객이 상품을 구매한다)을 나타냅니다.  ERD를 사용하면 복잡한 데이터베이스 구조를 명확하고 간결하게 표현하여 설계 과정을 체계적으로 진행하고, 다른 개발자들과 효과적으로 소통할 수 있습니다.  문제에서 제시된 다른 선택지들은 소프트웨어 시스템의 다른 측면을 모델링하는 데 사용되는 다이어그램으로, 데이터베이스 설계에는 적합하지 않습니다. 따라서 데이터베이스 설계의 표현으로 사용하는 모델링 언어는 ERD입니다.",60,30
707,1,8,7,미들웨어(Middleware)에 대한 설명으로 틀린 것은?,,여러 운영체제에서 응용 프로그램들 사이에 위치한 소프트웨어이다.,미들웨어의 서비스 이용을 위해 사용자가 정보 교환 방법 등의 내부 동작을 쉽게 확인할 수 있어야 한다.,소프트웨어 컴포넌트를 연결하기 위한 준비된 인프라 구조를 제공한다.,"여러 컴포넌트를 1대 1, 1대 다, 다대 다 등 여러 가지 형태로 연결이 가능하다.",2,"미들웨어는 여러 응용 프로그램들이 서로 통신하고 데이터를 주고받을 수 있도록 중간에서 연결해주는 소프트웨어입니다. 마치 여러 언어를 하는 사람들 사이에서 통역을 해주는 역할과 비슷하다고 생각하면 이해하기 쉬울 거예요.  다양한 운영체제와 응용 프로그램들이 서로 다른 방식으로 동작하지만, 미들웨어는 이러한 차이를 해소하고 서로 호환성을 가지도록 도와줍니다.  그런데 문제에서 틀린 설명은 미들웨어의 내부 동작을 사용자가 쉽게 확인해야 한다는 부분입니다.  미들웨어는 사용자에게 투명하게 동작해야 합니다. 사용자가 미들웨어의 내부 동작 방식까지 알 필요는 없고, 단지 제공되는 서비스를 이용하는 것에만 집중하면 됩니다.  마치 전기 스위치를 누르면 불이 켜지는 것처럼, 사용자는 미들웨어가 어떻게 동작하는지 알 필요 없이 편리하게 기능을 사용할 수 있어야 합니다.  나머지 설명들은 모두 미들웨어의 기능을 정확하게 설명하고 있습니다.  여러 운영체제와 응용 프로그램 사이에 위치하여 연결을 제공하고, 소프트웨어 컴포넌트들을 다양한 형태로 연결하는 인프라를 제공하는 것이 바로 미들웨어의 주요 역할입니다.",54,10
708,1,8,8,UI의 설계 지침으로 틀린 것은?,,이해하기 편하고 쉽게 사용할 수 있는 환경을 제공해야 한다.,주요 기능을 메인 화면에 노출하여 조작이 쉽도록 하여야 한다.,치명적인 오류에 대한 부정적인 사항은 사용자가 인지할 수 없도록 한다.,"사용자의 직무, 연령, 성별 등 다양한 계층을 수용하여야 한다.",3,"UI 설계의 목표는 사용자가 시스템을 쉽고 효율적으로 사용할 수 있도록 하는 것입니다.  따라서 사용자 친화적인 인터페이스를 제공하는 것은 매우 중요합니다.  제시된 보기 중 잘못된 것은 치명적인 오류 발생 시 사용자가 이를 인지하지 못하도록 하는 것입니다.  오류 발생 시 사용자에게 명확하게 오류 상황을 알리고, 필요한 조치를 안내하는 것은 사용자 경험을 향상시키고 시스템의 신뢰성을 높이는 데 필수적입니다.  오류를 숨기는 것은 문제 해결을 지연시키고, 사용자에게 혼란과 불편을 야기할 수 있습니다.  사용자는 시스템의 상태를 알고 적절한 대응을 할 수 있어야 하며, 오류 발생 시 이를 알 수 없도록 하는 것은 사용자 중심적인 UI 설계 원칙에 위배됩니다.  나머지 보기들은 모두 사용자 중심적인 UI 설계를 위한 중요한 지침들입니다.  이해하기 쉽고 사용하기 편한 환경, 주요 기능의 명확한 노출, 다양한 사용자 계층에 대한 고려 등은 사용자 만족도를 높이고 시스템의 효율성을 증대시키는 데 기여합니다. 따라서 사용자에게 오류를 숨기는 것은 UI 설계 지침으로 적절하지 않습니다.",70,4
709,1,8,9,객체지향 개념에서 다형성(Polymorphism)과 관련한 설명으로 틀린 것은?,,다형성은 현재 코드를 변경하지 않고 새로운 클래스를 쉽게 추가할 수 있게 한다.,"다형성이란 여러 가지 형태를 가지고 있다는 의미로, 여러 형태를 받아들일 수 있는 특징을 말한다.",메소드 오버라이딩(Overriding)은 상위 클래스에서 정의한 일반 메소드의 구현을 하위 클래스에서 무시하고 재정의할 수 있다.,"메소드 오버로딩(Overloading)의 경우 매개 변수 타입은 동일하지만 메소드명을 다르게 함으로써 구현, 구분할 수 있다.",4,"객체지향 프로그래밍에서 다형성은 하나의 메서드나 연산자가 여러 가지 자료형에 대해 다른 방식으로 동작할 수 있는 능력을 의미합니다.  마치 같은 단어가 문맥에 따라 다른 의미를 가질 수 있는 것과 같습니다.  문제에서 틀린 설명은 메서드 오버로딩에 대한 부분입니다. 메서드 오버로딩은 같은 이름의 메서드를 여러 개 정의하는 것을 말하는데, 이때 메서드를 구분하는 것은 매개변수의 개수나 타입의 차이입니다.  매개변수 타입이 동일하면서 메서드 이름만 다르게 하여 구현을 구분하는 것은 오버로딩의 개념과 맞지 않습니다.  오버로딩은 같은 이름의 메서드를 매개변수의 차이로 구분하여 다양한 상황에 유연하게 대처할 수 있도록 하는 다형성의 한 예시입니다.  다른 선지들은 다형성의 개념과 메서드 오버라이딩의 특징을 정확하게 설명하고 있습니다.  따라서 메서드 오버로딩에 대한 설명이 잘못된 것이므로 이 문제의 정답은 메서드 오버로딩에 대한 설명이 틀린 것을 고르는 것입니다.",42,7
710,1,8,10,소프트웨어 개발 영역을 결정하는 요소 중 다음 사항과 관계있는 것은?,https://www.cbtbank.kr/images/iz/iz20220424/iz20220424m10.gif,기능(Function),성능(Performance),제약 조건(Constraint),인터페이스(Interface),4,"소프트웨어 개발은 단순히 기능만 구현하는 것이 아닙니다.  마치 건물을 짓는 것과 같이 여러 요소들이 복합적으로 작용하여 완성됩니다.  건물의 기능(예: 거주, 사무)처럼 소프트웨어도 특정 기능을 수행해야 합니다.  또한 건물의 성능(예: 내구성, 단열)처럼 소프트웨어도 속도, 안정성 등의 성능이 중요합니다.  그리고 건물의 제약 조건(예: 예산, 부지 면적)처럼 소프트웨어 개발에도 개발 기간, 예산, 사용 기술 등의 제약이 존재합니다.  하지만 이 문제에서 가장 중요한 것은 바로 다른 시스템과의 **연결 방식**, 즉 **인터페이스**입니다.  소프트웨어는 혼자 동작하는 경우가 드물고, 다른 시스템(하드웨어, 다른 소프트웨어 등)과 상호 작용하며 데이터를 주고받아야 합니다.  이러한 상호 작용을 원활하게 하기 위한 연결 방식, 데이터 교환 방식 등을 정의하는 것이 인터페이스 설계입니다.  따라서 소프트웨어 개발 영역을 결정하는 데 있어 인터페이스는 필수적인 요소입니다.  다른 시스템과 어떻게 연결될지, 어떤 데이터를 주고받을지 등을 정의하지 않고서는 소프트웨어 개발 자체가 불가능하기 때문입니다.  마치 건물의 출입구, 통로, 배관 등을 설계하지 않고 건물을 지을 수 없는 것과 같습니다.",60,8
711,1,8,11,객체에 대한 설명으로 틀린 것은?,,"객체는 상태, 동작, 고유 식별자를 가진 모든 것이라 할 수 있다.",객체는 공통 속성을 공유하는 클래스들의 집합이다.,객체는 필요한 자료 구조와 이에 수행되는 함수들을 가진 하나의 독립된 존재이다.,객체의 상태는 속성값에 의해 정의된다.,2,"객체지향 프로그래밍에서 객체는 데이터(상태)와 그 데이터를 처리하는 함수(동작)의 조합으로, 고유한 식별자를 가지는 독립적인 존재입니다.  마치 현실 세계의 사물처럼 생각하면 이해하기 쉽습니다. 예를 들어 ""강아지""라는 객체는 ""색깔"", ""크기"", ""품종""과 같은 상태(속성)를 가지고 있으며, ""짖기"", ""뛰어놀기"", ""먹기""와 같은 동작(메서드)을 수행할 수 있습니다.  각각의 강아지는 고유한 이름이나 번호로 구분되는 고유 식별자를 갖습니다.  문제에서 틀린 설명은 객체가 클래스들의 집합이라는 것입니다.  클래스는 객체의 설계도와 같으며, 객체는 클래스를 바탕으로 만들어지는 실제의 인스턴스입니다.  많은 강아지 객체들이 ""강아지""라는 하나의 클래스로부터 만들어지지만, 객체 자체가 클래스들의 집합인 것은 아닙니다.  다른 설명들은 모두 객체의 특징을 정확하게 나타내고 있습니다.  따라서 객체에 대한 정확한 이해를 바탕으로 틀린 설명을 찾아내는 것이 중요합니다.",53,7
712,1,8,12,속성과 관련된 연산(Operation)을 클래스 안에 묶어서 하나로 취급하는 것을 의미하는 객체지향 개념은?,,Inheritance,Class,Encapsulation,Association,3,"객체지향 프로그래밍(OOP)에서 '캡슐화(Encapsulation)'는 데이터(속성)와 그 데이터를 처리하는 연산(메서드)을 하나의 단위로 묶어서 외부로부터의 직접적인 접근을 제한하는 개념입니다.  마치 보석 상자에 보석(데이터)과 보석을 다루는 도구(연산)를 함께 넣어두고, 상자(클래스)를 통해서만 보석을 관리하도록 하는 것과 같습니다.  이렇게 함으로써 데이터의 무결성을 보장하고, 코드의 복잡성을 줄이며, 유지보수를 용이하게 합니다.  외부에서는 상자(클래스)의 뚜껑(메서드)을 통해서만 보석(데이터)에 접근할 수 있으므로, 데이터가 잘못 변경되는 것을 막을 수 있습니다.  따라서 속성과 관련된 연산을 클래스 안에 묶어 하나로 취급하는 객체지향 개념은 바로 캡슐화입니다.  다른 선택지들은 객체지향의 다른 중요한 개념이지만, 문제에서 묻고 있는 '속성과 관련된 연산을 클래스 안에 묶는 것'과는 직접적인 관련이 없습니다.",46,7
713,1,8,13,애자일(Agile) 프로세스 모델에 대한 설명으로 틀린 것은?,,변화에 대한 대응보다는 자세한 계획을 중심으로 소프트웨어를 개발한다.,프로세스와 도구 중심이 아닌 개개인과의 상호소통을 통해 의견을 수렴한다.,협상과 계약보다는 고객과의 협력을 중시한다.,"문서 중심이 아닌, 실행 가능한 소프트웨어를 중시한다.",1,"애자일(Agile) 프로세스 모델은 소프트웨어 개발 방식 중 하나로,  기존의 폭포수 모델과는 달리 유연하고 변화에 빠르게 적응하는 것을 특징으로 합니다.  문제에서 틀린 설명은  자세한 계획을 중심으로 소프트웨어를 개발한다는 부분입니다. 애자일은  미리 모든 것을 완벽하게 계획하기보다는,  작은 단위의 개발 주기를 반복하며(반복적 개발), 고객의 피드백을 지속적으로 받아 개발 방향을 조정하는 점진적 개발 방식을 사용합니다.  즉, 변화에 유연하게 대처하고 고객과의 긴밀한 협력을 통해 개발 과정을 진행하는 것이 애자일의 핵심입니다.  나머지 설명들은 모두 애자일의 특징을 잘 나타내고 있습니다.  개인 간의 소통을 중시하고, 고객과의 협력을 통해 요구사항을 반영하며, 문서보다 실제 작동하는 소프트웨어를 우선시하는 것이 애자일의 중요한 원칙입니다. 따라서 자세한 계획에 중점을 둔다는 것은 애자일의 본질과 상반되는 내용입니다.",66,2
714,1,8,14,"명백한 역할을 가지고 독립적으로 존재할 수 있는 시스템의 부분으로 넓은 의미에서는 재사용되는 모든 단위라고 볼 수 있으며, 인터페이스를 통해서만 접근할 수 있는 것은?",,Model,Sheet,Component,Cell,3,"문제에서 설명하는 것은 시스템의 독립적인 부분으로, 명확한 역할을 가지며, 재사용이 가능하고, 인터페이스를 통해서만 접근할 수 있는 요소입니다.  마치 레고 블록처럼 생각해 볼 수 있습니다. 각각의 블록은 독립적으로 존재하며(독립적으로 존재할 수 있는 시스템의 부분), 특정한 기능을 수행하는 역할을 가지고(명백한 역할을 가지고), 다른 블록들과 결합하여 더 큰 구조물을 만들 수 있습니다(넓은 의미에서는 재사용되는 모든 단위).  그리고 블록 자체를 직접 만지거나 조작하는 것이 아니라, 블록에 연결된 연결부(인터페이스)를 통해서만 조작할 수 있습니다(인터페이스를 통해서만 접근할 수 있는 것은). 이러한 특징을 가장 잘 나타내는 것이 바로 '컴포넌트(Component)'입니다.  '컴포넌트'는 소프트웨어 개발에서 독립적으로 개발되고 배포될 수 있는 재사용 가능한 단위를 의미하며, 정해진 인터페이스를 통해 다른 컴포넌트와 상호작용합니다.  다른 선지들은 이러한 특징을 모두 만족시키지 못합니다.",57,6
715,1,8,15,"GoF(Gang of Four) 디자인 패턴을 생성, 구조, 행동 패턴의 세 그룹으로 분류할 때, 구조 패턴이 아닌 것은?",,Adapter 패턴,Bridge 패턴,Builder 패턴,Proxy 패턴,3,"GoF 디자인 패턴은 크게 생성 패턴, 구조 패턴, 행동 패턴으로 나뉩니다.  각 패턴의 목적이 다르기 때문에 어떤 패턴이 어떤 그룹에 속하는지 이해하는 것이 중요합니다.  구조 패턴은 클래스나 객체들을 조합하여 더 큰 구조를 만들어내는 데 초점을 맞춥니다.  반면에 생성 패턴은 객체 생성 과정을 제어하고, 행동 패턴은 객체 간의 상호작용과 책임 분배에 중점을 둡니다. 문제에서 제시된 잘못된 답변들은 클래스나 객체의 구조를 조합하는 방식으로 동작하지 않습니다.  정답으로 제시된 패턴은 객체의 생성 방법에 초점을 맞추고 있기 때문에 생성 패턴에 속합니다.  객체를 생성하는 방법을 정의하고, 이를 통해 객체 생성 과정을 제어하는 것이 주요 목적입니다. 따라서 구조 패턴이 아닌 것은 객체 생성에 초점을 맞춘 패턴입니다.  다른 선택지들은 클래스와 객체의 구성 및 관계를 다루는 구조 패턴의 특징을 보여줍니다.",41,7
716,1,8,16,"UI와 관련된 기본 개념 중 하나로, 시스템의 상태와 사용자의 지시에 대한 효과를 보여주어 사용자가 명령에 대한 진행 상황과 표시된 내용을 해석할 수 있도록 도와주는 것은?",,Feedback,Posture,Module,Hash,1,"이 문제는 사용자 인터페이스(UI) 디자인의 핵심 개념을 묻고 있습니다.  컴퓨터 시스템이나 어떤 프로그램을 사용할 때, 사용자가 명령을 내리면 시스템이 그에 대한 결과를 바로 보여주는 것이 중요합니다.  예를 들어, 버튼을 누르면 버튼이 눌린 효과(예: 색상 변화, 잠깐의 애니메이션)를 보여주거나, 파일을 저장하면 ""저장 완료""와 같은 메시지가 뜨는 것처럼 말이죠. 이러한 시스템의 반응을 통해 사용자는 자신의 행동이 시스템에 제대로 전달되었고, 시스템이 현재 어떤 상태인지, 그리고 자신의 명령이 어떻게 처리되고 있는지 알 수 있습니다. 문제에서 설명하는 개념은 바로 이러한 시스템의 상태와 사용자의 행동에 대한 시스템의 반응을 의미하며, 이를 통해 사용자는 시스템의 동작을 이해하고 다음 행동을 결정할 수 있습니다.  이러한 사용자에게 시스템의 상태와 결과를 알려주는 것을 ""피드백(Feedback)""이라고 합니다.  다른 선택지는 UI 디자인과 직접적인 관련이 없습니다. ""Posture""는 자세를 의미하고, ""Module""은 모듈(프로그램의 구성 요소)을, ""Hash""는 해시 함수(데이터를 압축하는 함수)를 의미합니다. 따라서 사용자 인터페이스의 기본 개념을 정확하게 설명하는 것은 ""피드백""입니다.",62,4
717,1,8,17,"UI의 종류로 멀티 터치(Multi-touch), 동작 인식(Gesture Recognition) 등 사용자의 자연스러운 움직임을 인식하여 서로 주고받는 정보를 제공하는 사용자 인터페이스를 의미하는 것은?",,GUI(Graphical User Interface),OUI(Organic User Interface),NUI(Natural User Interface),CLI(Command Line Interface),3,"문제에서 제시된 UI는 사용자의 자연스러운 움직임, 즉 멀티터치나 제스처를 인식하여 정보를 주고받는 방식을 설명하고 있습니다.  GUI는 그래픽 기반의 사용자 인터페이스로 마우스나 키보드를 이용하는 방식이고, OUI는 유기물을 이용한 인터페이스, CLI는 명령어를 입력하는 방식입니다.  반면에 문제에서 설명하는 UI는 사용자의 직관적인 움직임을 통해 컴퓨터와 상호작용하는 방식으로,  손가락으로 화면을 터치하거나 손짓으로 명령을 내리는 등 자연스러운 행동을 통해 정보를 처리하는 인터페이스를 의미합니다. 이러한 특징은 자연스러운 사용자 인터페이스(Natural User Interface, NUI)의 정의와 정확히 일치합니다. 따라서 사용자의 자연스러운 움직임을 인식하는 UI를 설명하는 가장 적절한 용어는 NUI입니다.",53,4
718,1,8,18,소프트웨어 모델링과 관련한 설명으로 틀린 것은?,,모델링 작업의 결과물은 다른 모델링 작업에 영향을 줄 수 없다.,"구조적 방법론에서는 DFD(Data Flow Diagram), DD(Data Dictionary) 등을 사용하여 요구 사항의 결과를 표현한다.",객체지향 방법론에서는 UML 표기법을 사용한다.,소프트웨어 모델을 사용할 경우 개발될 소프트웨어에 대한 이해도 및 이해 당사자 간의 의사소통 향상에 도움이 된다.,1,"소프트웨어 모델링은 복잡한 소프트웨어 시스템을 이해하고 구축하기 위한 청사진과 같은 역할을 합니다.  모델링 과정에서 만들어진 다양한 결과물들은 서로 밀접하게 연관되어 있으며, 하나의 모델이 변경되면 다른 모델에도 영향을 미치는 경우가 많습니다. 예를 들어, 데이터 흐름 다이어그램(DFD)에서 데이터의 흐름을 변경하면 데이터 사전(DD)도 함께 수정되어야 합니다.  객체지향 모델링에서도 클래스 다이어그램의 변경은 시퀀스 다이어그램이나 활동 다이어그램에도 영향을 줄 수 있습니다. 따라서, 모델링 작업의 결과물이 다른 모델링 작업에 영향을 줄 수 없다는 주장은 사실과 다릅니다.  나머지 선택지는 모두 소프트웨어 모델링의 일반적인 특징과 방법론을 정확하게 설명하고 있습니다.  소프트웨어 모델은 개발 과정 전반에 걸쳐 이해도 향상과 효과적인 의사소통을 돕는 중요한 도구입니다.",59,2
719,1,8,19,유스케이스 다이어그램(Use Case Diagram)에 관련된 내용으로 틀린 것은?,,시스템과 상호작용하는 외부시스템은 액터로 파악해서는 안된다.,"유스케이스는 사용자 측면에서의 요구사항으로, 사용자가 원하는 목표를 달성하기 위해 수행할 내용을 기술한다.","시스템 액터는 다른 프로젝트에서 이미 개발되어 사용되고 있으며, 본 시스템과 데이터를 주고받는 등 서로 연동되는 시스템을 말한다.",액터가 인식할 수 없는 시스템 내부의 기능을 하나의 유스케이스로 파악해서는 안된다.,1,"유스케이스 다이어그램은 시스템의 기능을 사용자(액터)의 관점에서 표현하는 모델링 기법입니다.  시스템이 어떤 기능을 제공하는지, 사용자가 어떻게 시스템과 상호작용하는지를 보여주는 것이죠.  따라서 틀린 선지는 시스템과 상호작용하는 외부 시스템도 액터로 표현해야 합니다.  외부 시스템은 시스템과 데이터를 주고받거나 기능을 요청하는 등의 상호작용을 하기 때문에, 사용자와 마찬가지로 시스템의 기능을 사용하는 주체로 간주될 수 있습니다.  또한, 시스템 내부의 기능은 사용자가 직접적으로 인식하거나 제어할 수 없으므로 유스케이스로 표현해서는 안 됩니다. 유스케이스는 사용자의 관점에서 시스템이 제공하는 기능을 나타내는 것이지, 시스템 내부의 구현 로직을 나타내는 것이 아니기 때문입니다.  다른 선지들은 유스케이스 다이어그램의 기본적인 개념을 잘 설명하고 있습니다. 사용자가 원하는 목표 달성을 위한 내용을 기술하고, 다른 시스템과 연동되는 외부 시스템을 시스템 액터로 표현하는 것은 유스케이스 다이어그램의 핵심적인 특징입니다.",41,2
720,1,8,20,소프트웨어 아키텍처 모델 중 MVC(Model-View-Controller)와 관련한 설명으로 틀린 것은?,,"MVC 모델은 사용자 인터페이스를 담당하는 계층의 응집도를 높일 수 있고, 여러 개의 다른 UI를 만들어 그 사이에 결합도를 낮출 수 있다.","모델(Model)은 뷰(View)와 제어(Controller) 사이에서 전달자 역할을 하며, 뷰마다 모델 서브시스템이 각각 하나씩 연결된다.",뷰(View)는 모델(Model)에 있는 데이터를 사용자 인터페이스에 보이는 역할을 담당한다.,제어(Controller)는 모델(Model)에 명령을 보냄으로써 모델의 상태를 변경할 수 있다.,2,"MVC(Model-View-Controller)는 소프트웨어 아키텍처 패턴 중 하나로, 사용자 인터페이스(UI)를 개발할 때 데이터(Model), UI 표시(View), 사용자 입력 처리(Controller)를 각각 분리하여 관리하는 방식입니다.  이렇게 함으로써 각 부분의 역할을 명확하게 구분하고, 코드의 재사용성과 유지보수성을 높일 수 있습니다.  틀린 설명은 모델(Model)이 뷰(View)와 컨트롤러(Controller) 사이에서 단순히 전달자 역할만 하는 것이 아니라는 점입니다.  모델은 데이터와 비즈니스 로직을 담고 있으며, 뷰는 모델의 데이터를 표시하고, 컨트롤러는 사용자의 입력을 받아 모델을 변경하는 역할을 합니다.  즉, 모델은 뷰마다 각각 하나씩 연결되는 것이 아니라, 모든 뷰가 하나의 모델을 공유하여 데이터를 가져다 사용합니다.  다른 선지는 모두 MVC의 기본적인 동작 방식을 정확하게 설명하고 있습니다.  따라서, 모델이 뷰마다 각각 연결된다는 설명은 MVC의 원리에 맞지 않아 틀린 것입니다.  쉽게 말해, 데이터베이스(모델)가 하나 있는데, 여러 개의 화면(뷰)에서 그 데이터를 보여주는 것이지, 화면마다 데이터베이스가 따로 있는 것이 아닙니다.",45,6
721,1,8,21,통합 테스트(Integration Test)와 관련한 설명으로 틀린 것은?,,시스템을 구성하는 모듈의 인터페이스와 결합을 테스트하는 것이다.,하향식 통합 테스트의 경우 넓이 우선(Breadth First) 방식으로 테스트를 할 모듈을 선택할 수 있다.,상향식 통합 테스트의 경우 시스템 구조도의 최상위에 있는 모듈을 먼저 구현하고 테스트한다.,모듈 간의 인터페이스와 시스템의 동작이 정상적으로 잘되고 있는지를 빨리 파악하고자 할 때 상향식 보다는 하향식 통합 테스트를 사용하는 것이 좋다.,3,"통합 테스트는 여러 개의 모듈을 결합하여 시스템 전체 또는 시스템의 일부분이 제대로 작동하는지 확인하는 테스트입니다.  문제에서 틀린 설명은 상향식 통합 테스트에 대한 설명입니다. 상향식 통합 테스트는 하위 모듈부터 통합하여 테스트하는 방식으로, 시스템 구조도의 최하위 모듈부터 구현하고 테스트를 진행합니다.  최상위 모듈부터 테스트하는 것은 하향식 통합 테스트의 특징입니다. 따라서, 최상위 모듈을 먼저 구현하고 테스트한다는 설명은 상향식 통합 테스트에 대한 잘못된 설명입니다.  나머지 설명들은 통합 테스트의 특징을 잘 나타내고 있습니다. 모듈 간 인터페이스를 테스트하고, 넓이 우선 방식으로 하향식 통합 테스트를 진행할 수 있으며, 시스템 동작을 빠르게 파악하고자 할 때 하향식 통합 테스트가 효율적일 수 있습니다.  결론적으로, 상향식 통합 테스트에 대한 잘못된 설명 때문에 문제의 정답이 결정됩니다.",47,20
722,1,8,22,"다음과 같이 레코드가 구성되어 있을 때, 이진 검색 방법으로 14를 찾을 경우 비교되는 횟수는?",https://www.cbtbank.kr/images/iz/iz20220424/iz20220424m22.gif,2,3,4,5,2,"이진 검색은 정렬된 데이터에서 특정 값을 찾는 효율적인 알고리즘입니다.  데이터의 중간 값을 확인하여 찾고자 하는 값이 중간 값보다 큰지 작은지 판단하고, 그에 따라 검색 범위를 절반으로 줄여나가는 방식입니다.  문제에서 주어진 데이터는 이미 정렬되어 있습니다.  14를 찾는 과정을 살펴보겠습니다.",38,11
723,1,8,23,소프트웨어 공학에서 워크스루(Walktiirough)에 대한 설명으로 틀린 것은?,,"사용사례를 확장하여 명세하거나 설계 다이어그램, 원시코드, 테스트 케이스 등에 적용할 수 있다.","복잡한 알고리즘 또는 반복, 실시간 동작, 병행 처리와 같은 기능이나 동작을 이해하려고 할 때 유용하다.",인스펙션(Inspection)과 동일한 의미를 가진다.,단순한 테스트 케이스를 이용하여 프로덕트를 수작업으로 수행해 보는 것이다.,3,"소프트웨어 공학에서 워크스루는 개발 과정에서 여러 사람이 모여 특정 산출물(설계 문서, 코드 등)을 검토하는 활동입니다.  개발자가 자신의 작업 결과를 설명하고, 다른 참여자들이 질문하고 피드백을 제공하며 문제점을 조기에 발견하는 것을 목표로 합니다.  문제에서 틀린 설명은 워크스루가 인스펙션과 동일한 의미를 가진다는 것입니다.  워크스루와 인스펙션은 모두 코드 검토 활동이지만,  방법론에 차이가 있습니다.  워크스루는 비교적 비형식적이고 자유로운 분위기에서 진행되는 반면, 인스펙션은 체크리스트를 활용하고 역할을 분담하는 등 보다 공식적이고 체계적인 절차를 따릅니다.  따라서 워크스루와 인스펙션은 서로 다른 코드 검토 기법이며, 동일한 의미를 갖는다고 볼 수 없습니다.  나머지 선택지들은 워크스루의 특징을 잘 나타내고 있습니다.  예를 들어, 다양한 산출물에 적용 가능하고, 복잡한 부분을 이해하는 데 도움이 되며, 수작업으로 코드를 검토하는 과정을 포함합니다.",36,6
724,1,8,24,소프트웨어의 개발과정에서 소프트웨어의 변경사항을 관리하기 위해 개발된 일련의 활동을 뜻하는 것은?,,복호화,형상관리,저작권,크랙,2,"소프트웨어 개발 과정은 단순히 프로그램을 만드는 것 이상으로,  수많은 변경과 수정이 반복되는 과정입니다.  처음 설계한 대로 완벽하게 진행되는 경우는 거의 없죠.  요구사항이 바뀌거나, 버그가 발견되거나, 성능 개선이 필요해지는 등 여러 이유로 소프트웨어는 지속적으로 변화합니다.  이러한 변경 사항들을 체계적으로 관리하고,  어떤 버전에서 어떤 수정이 이루어졌는지, 누가 수정했는지 등을 추적하여  혼란을 방지하고,  소프트웨어의 안정성과 품질을 유지하기 위해  필요한 활동들을 총칭하는 것이 바로 '소프트웨어의 변경사항을 관리하기 위해 개발된 일련의 활동'입니다.  이를 통해 개발팀은 소프트웨어의 모든 버전을 관리하고, 필요한 시점으로 되돌아갈 수 있으며,  협업을 원활하게 진행할 수 있습니다.  따라서 정답은 소프트웨어 개발 과정에서 변경 사항을 효율적으로 관리하는 핵심 개념인 형상 관리입니다.  다른 선지는 소프트웨어 개발과 직접적인 관련이 없거나,  개발 과정의 특정 부분만을 다루는 개념입니다.",63,15
725,1,8,25,테스트 케이스와 관련한 설명으로 틀린 것은?,,테스트의 목표 및 테스트 방법을 결정하기 전에 테스트 케이스를 작성해야 한다.,프로그램에 결함이 있더라도 입력에 대해 정상적인 결과를 낼 수 있기 때문에 결함을 검사할 수 있는 테스트 케이스를 찾는 것이 중요하다.,"개발된 서비스가 정의된 요구 사항을 준수하는지 확인하기 위한 입력 값과 실행 조건, 예상 결과의 집합으로 볼 수 있다.",테스트 케이스 실행이 통과되었는지 실패하였는지 판단하기 위한 기준을 테스트 오라클(Test Oracle)이라고 한다.,1,"테스트 케이스는 소프트웨어의 기능을 검증하기 위해 미리 준비하는 입력값, 실행 조건, 그리고 예상 결과의 집합입니다.  소프트웨어 개발 과정에서 테스트 케이스는 매우 중요한 역할을 합니다.  우선, 테스트 케이스를 작성하기 전에 테스트의 목표와 방법을 결정하는 것이 필수적입니다.  목표와 방법 없이 테스트 케이스를 작성하면,  필요한 부분을 제대로 검증하지 못하거나 불필요한 테스트를 반복하게 될 수 있습니다.  따라서 테스트 목표와 방법을 먼저 정의하고, 그에 맞춰 테스트 케이스를 설계해야 효율적이고 효과적인 테스트를 수행할 수 있습니다.  또한,  프로그램에 결함이 있더라도 특정 입력에 대해서는 정상적인 결과를 출력할 수 있습니다.  하지만 이는 결함이 없다는 것을 의미하지 않습니다.  오히려,  결함을 드러낼 수 있는 다양한 입력값들을 고려하여 테스트 케이스를 설계해야 프로그램의 안정성을 확보할 수 있습니다.  결함을 찾아내는 데 초점을 맞춰야 합니다.  그리고 테스트 케이스는 개발된 서비스가 요구사항을 충족하는지 확인하기 위한 입력값, 실행 조건, 예상 결과를 포함하는 것이 맞습니다.  마지막으로, 테스트 오라클은 테스트 케이스 실행 결과가 성공인지 실패인지 판단하는 기준을 의미합니다.  즉,  예상 결과와 실제 결과를 비교하여 테스트의 성공 여부를 판단하는 기준이 되는 것입니다.  정리하자면,  테스트 케이스는 테스트 목표와 방법을 정의한 후에 설계되어야 하며,  결함을 발견하는 데 중점을 두고 다양한 입력값을 고려해야 합니다.  그리고 테스트 오라클은 테스트 결과의 성공/실패 판단 기준입니다.",40,19
726,1,8,26,객체지향 개념을 활용한 소프트웨어 구현과 관련한 설명 중 틀린 것은?,,객체(Object)란 필요한 자료 구조와 수행되는 함수들을 가진 하나의 독립된 존재이다.,JAVA에서 정보은닉(Information Hiding)을 표기할 때 private의 의미는 '공개'이다.,상속(Inheritance)은 개별 클래스를 상속 관계로 묶음으로써 클래스 간의 체계화된 전체 구조를 파악하기 쉽다는 장점이 있다.,같은 클래스에 속하는 개개의 객체이자 하나의 클래스에서 생성된 객체를 인스턴스(Instance)라고 한다.,2,"객체지향 프로그래밍의 핵심 개념들을 묻는 문제입니다.  소프트웨어를 객체라는 독립적인 단위로 나누어 설계하고 구현하는 방법에 대한 이해도를 평가하는 것이죠.  먼저 객체는 데이터(자료구조)와 그 데이터를 처리하는 함수(메서드)를 묶어놓은 하나의 독립적인 단위입니다.  상속은 기존 클래스의 기능을 재사용하여 새로운 클래스를 만드는 강력한 기능으로, 코드 재사용성과 유지보수성을 높여줍니다.  인스턴스는 클래스의 설계도를 바탕으로 실제로 메모리에 생성된 객체를 의미합니다.  하지만 JAVA에서 정보은닉을 위해 사용하는 접근 제어자 `private`는 외부에서 접근을 제한하는 의미를 가지며, '공개'와는 정반대의 의미입니다.  따라서 JAVA에서 `private`를 '공개'라고 설명하는 것은 잘못된 것입니다.  다른 선지는 모두 객체지향 프로그래밍의 기본 개념을 정확하게 설명하고 있으므로,  `private`에 대한 설명이 잘못된 부분을 찾아내는 것이 문제의 핵심입니다.  쉽게 말해,  자동차를 예로 들면,  자동차(클래스)의 설계도를 바탕으로 실제로 만들어진 각각의 자동차(인스턴스)는 모두 같은 설계도를 따르지만,  각각 다른 색깔이나 옵션을 가질 수 있습니다.  그리고 자동차의 엔진이나 내부 기계 장치(private)는 외부에서 직접 접근할 수 없도록 보호되어야 합니다.",64,7
727,1,8,27,DRM(Digital Rights Management)과 관련한 설명으로 틀린 것은?,,"디지털 콘텐츠와 디바이스의 사용을 제한하기 위해 하드웨어 제조업자, 저작권자, 출판업자 등이 사용할 수 있는 접근 제어 기술을 의미한다.","디지털 미디어의 생명 주기 동안 발생하는 사용 권한 관리, 과금, 유통 단계를 관리하는 기술로도 볼 수 있다.",클리어링 하우스(Clearing House)는 사용자에게 콘텐츠 라이센스를 발급하고 권한을 부여해주는 시스템을 말한다.,원본을 안전하게 유통하기 위한 전자적 보안은 고려하지 않기 때문에 불법 유통과 복제의 방지는 불가능하다.,4,"DRM은 디지털 콘텐츠의 저작권을 보호하기 위한 기술입니다.  음악, 영화, 게임 등 디지털 콘텐츠를 불법 복제나 무단 배포로부터 보호하고, 콘텐츠 이용에 대한 권한을 관리하는 역할을 합니다.  하드웨어 제조업체, 저작권자, 출판업체 등이 콘텐츠의 사용을 제한하고,  사용 권한을 관리하며,  콘텐츠 유통 과정을 관리하는 데 사용하는 기술이라고 이해하면 됩니다.  문제에서 틀린 설명은  ""원본을 안전하게 유통하기 위한 전자적 보안은 고려하지 않기 때문에 불법 유통과 복제의 방지는 불가능하다""는 부분입니다. DRM은 바로 불법 유통과 복제를 막기 위해 존재하는 기술이며,  다양한 전자적 보안 기술을 활용하여 콘텐츠의 무단 복제 및 배포를 방지하는 것을 목표로 합니다.  따라서 원본의 안전한 유통과 불법 복제 방지는 DRM의 핵심 기능입니다.  DRM이 완벽하지 않을 수는 있지만,  원천적으로 불법 유통과 복제 방지 기능이 없다는 것은 사실과 다릅니다.",55,16
728,1,8,28,위험 모니터링의 의미로 옳은 것은?,,위험을 이해하는 것,첫 번째 조치로 위험을 피할 수 있도록 하는 것,위험 발생 후 즉시 조치하는 것,위험 요소 징후들에 대하여 계속적으로 인지하는 것,4,"위험 모니터링이란, 무언가 잘못될 가능성이 있는 위험 요소들이 나타내는 징후들을 끊임없이 주시하고 감지하는 것을 의미합니다.  예를 들어, 산불 감시 시스템에서 연기나 이상 고온을 감지하는 것,  컴퓨터 시스템에서 과부하나 오류 메시지를 감지하는 것 등이 위험 모니터링의 좋은 예시입니다.  위험을 단순히 '이해'하는 것만으로는 충분하지 않고, 위험 발생 후에 '즉시 조치'하는 것만으로도 부족합니다.  위험을 미리 예방하고 대비하기 위해서는 위험의 징후를 지속적으로 감지하고 관찰하는 것이 가장 중요합니다.  첫 번째 조치로 위험을 피하는 것은 위험 모니터링의 결과로 이루어질 수 있는 행동이지, 모니터링 자체를 의미하는 것은 아닙니다. 따라서 위험 요소의 징후를 계속적으로 인지하는 것이 위험 모니터링의 가장 정확한 의미입니다.  마치 의사가 환자의 상태를 지속적으로 관찰하여 질병의 조기 발견 및 예방에 힘쓰는 것과 같습니다.",54,56
729,1,8,29,동시에 소스를 수정하는 것을 방지하며 다른 방향으로 진행된 개발 결과를 합치거나 변경 내용을 추적할 수 있는 소프트웨어 버전 관리 도구는?,,RCS(Revision Control System),RTS(Reliable Transfer Service),RPC(Remote Procedure Call),RVS(Relative Version System),1,"소프트웨어 개발 과정에서 여러 개발자가 동시에 같은 소스 코드를 수정하면 충돌이 발생하고, 코드 관리가 매우 어려워집니다.  이러한 문제를 해결하기 위해 소프트웨어 버전 관리 도구가 사용됩니다.  이 도구는 여러 개발자가 동시에 작업하더라도 소스 코드의 변경 사항을 효율적으로 관리하고, 충돌을 방지하며, 이전 버전으로 돌아갈 수 있는 기능을 제공합니다.  문제에서 제시된 정답은 이러한 기능을 제공하는 대표적인 소프트웨어 버전 관리 도구입니다.  다른 선지는 네트워크 통신(RTS, RPC)이나 가상의 버전 관리 시스템(RVS)을 나타내므로 소프트웨어 버전 관리와는 관련이 없습니다.  따라서 소스 코드의 변경 내용을 추적하고, 여러 개발자의 작업을 효율적으로 통합 관리할 수 있는 기능을 제공하는 도구가 정답입니다.",40,15
730,1,8,30,화이트박스 테스트와 관련한 설명으로 틀린 것은?,,화이트박스 테스트의 이해를 위해 논리흐름도(Logic-Flow Diagram)를 이용할 수 있다.,테스트 데이터를 이용해 실제 프로그램을 실행함으로써 오류를 찾는 동적 테스트(Dynamic Test)에 해당한다.,프로그램의 구조를 고려하지 않기 때문에 테스트 케이스는 프로그램 또는 모듈의 요구나 명세를 기초로 결정한다.,테스트 데이터를 선택하기 위하여 검증기준(Test Coverage)을 정한다.,3,"화이트박스 테스트는 소프트웨어의 내부 구조와 동작 방식을 알고 테스트하는 방법입니다.  마치 프로그램의 내부를 들여다보는 '하얀 상자'와 같다고 생각하면 이해하기 쉬울 거예요.  따라서 프로그램의 논리 흐름을 파악하기 위해 논리 흐름도를 사용하는 것은 매우 자연스러운 일이고, 실제 프로그램을 실행하여 오류를 찾는 동적 테스트에 해당합니다.  또한, 테스트의 효율성을 높이기 위해 어느 정도의 코드가 테스트되었는지 측정하는 검증 기준(Test Coverage)을 설정하는 것도 일반적입니다.  하지만,  틀린 설명은 프로그램의 구조를 고려하지 않는다는 것입니다. 화이트박스 테스트는 프로그램의 내부 구조를 완전히 이해하고,  그 구조를 기반으로 테스트 케이스를 설계하기 때문에 프로그램의 구조를 고려하지 않는다는 것은 화이트박스 테스트의 기본 개념과 정면으로 배치됩니다.  블랙박스 테스트는 프로그램의 내부 구조를 모르고 테스트하는 방법이므로,  프로그램 또는 모듈의 요구나 명세를 기초로 테스트 케이스를 결정하는 것이 맞지만, 화이트박스 테스트는 그렇지 않습니다.",46,19
731,1,8,31,알고리즘과 관련한 설명으로 틀린 것은?,,주어진 작업을 수행하는 컴퓨터 명령어를 순서대로 나열한 것으로 볼 수 있다.,검색(Searching)은 정렬이 되지 않은 데이터 혹은 정렬이 된 데이터 중에서 키값에 해당되는 데이터를 찾는 알고리즘이다.,정렬(Sorting)은 흩어져있는 데이터를 키값을 이용하여 순서대로 열거하는 알고리즘이다.,선형 검색은 검색을 수행하기 전에 반드시 데이터의 집합이 정렬되어 있어야 한다.,4,"알고리즘은 컴퓨터가 특정 문제를 해결하기 위해 따라야 하는 단계별 명령어들의 순서를 의미합니다.  문제에서 틀린 설명은 선형 검색(Linear Search)에 대한 부분입니다. 선형 검색은 데이터 목록을 처음부터 하나씩 순차적으로 확인하며 원하는 값을 찾는 방법입니다.  데이터가 정렬되어 있든, 정렬되어 있지 않든 상관없이  처음부터 끝까지 순차적으로 검색하기 때문에, 데이터가 정렬되어 있어야만 검색이 가능하다는 설명은 잘못된 것입니다.  다른 선택지들은 알고리즘의 개념과 검색, 정렬 알고리즘의 특징을 정확하게 설명하고 있습니다. 따라서, 데이터의 정렬 여부와 상관없이 선형 검색이 가능하다는 점을 고려했을 때,  해당 선지가 틀린 설명이 됩니다.",45,11
732,1,8,32,버블 정렬을 이용하여 다음 자료를 오름차순으로 정렬할 경우 PASS 1의 결과는?,https://www.cbtbank.kr/images/iz/iz20220424/iz20220424m32.gif,"6, 9, 7, 3, 5","3, 9, 6, 7, 5","3, 6, 7, 9, 5","6, 7, 3, 5, 9",4,"버블 정렬은 인접한 두 원소를 비교하여 크기 순서대로 자리를 바꾸는 정렬 알고리즘입니다.  주어진 자료 {6, 9, 7, 3, 5}를 오름차순으로 정렬하는 과정을 PASS 1 단계별로 살펴보겠습니다.",41,11
733,1,8,33,다음은 인스펙션(Inspection) 과정을 표현한 것이다. (가)~(마)에 들어갈 말을 보기에서 찾아 바르게 연결한 것은?,https://www.cbtbank.kr/images/iz/iz20220424/iz20220424m33.gif,"(가) - ㉡, (나) - ㉢","(나) - ㉠, (다) - ㉢","(다) - ㉢, (라) - ㉤","(라) - ㉣, (마) - ㉢",2,"이 문제는 소프트웨어 개발 과정 중 '소스코드 인스펙션(Inspection)' 단계를 묘사하고 있습니다.  인스펙션은 개발된 코드를 검토하여 오류나 결함을 찾아내는 중요한 단계입니다. 문제에서 제시된 (가)~(마)는 인스펙션 과정의 순서를 나타내는데, 각 단계에 해당하는 설명을 보기에서 찾아 연결하는 문제입니다.  정답은  인스펙션 과정의 흐름을 정확하게 반영한 보기의 조합입니다.  먼저, 코드를 검토하기 전에 검토자들이 코드에 대한 배경 지식을 습득하는 단계가 필요합니다.  그 다음, 실제 코드를 검토하고, 검토 결과를 토대로 결함을 수정하고, 마지막으로 검토 결과를 기록하고 종료하는 단계를 거칩니다.  따라서, 각 단계에 맞는 보기를 연결하여 인스펙션 과정의 논리적인 흐름을 파악하는 것이 중요합니다.  정답은 이러한 인스펙션 과정의 순서를 정확하게 나타내는 보기의 조합을 선택해야 합니다.  비전공자도 이해하기 쉽게 설명하자면,  소스코드를 여러 사람이 함께 검토하는 과정을 생각하면 됩니다.  먼저 코드를 이해하기 위해 자료를 준비하고,  그 다음 코드를 자세히 살펴보고 문제점을 찾아내고,  문제점을 수정하고, 마지막으로 검토 결과를 정리하는 과정입니다.",42,13
734,1,8,34,소프트웨어를 보다 쉽게 이해할 수 있고 적은 비용으로 수정할 수 있도록 겉으로 보이는 동작의 변화 없이 내부구조를 변경하는 것은?,,Refactoring,Architecting,Specification,Renewal,1,"소프트웨어의 내부 구조를 변경하는 작업을 생각해 봅시다.  겉으로 보이는 기능, 즉 사용자가 사용하는 방식에는 변화가 없지만, 내부적으로 코드를 개선하여 더 효율적이고 이해하기 쉽게 만드는 것을 의미합니다.  마치 건물의 외관은 그대로 두고 내부 배선이나 구조를 개선하는 것과 같습니다.  이러한 작업을 통해 소프트웨어의 유지보수 비용을 줄이고, 향후 기능 추가나 수정이 더 용이해집니다.  문제에서 언급된 ""보다 쉽게 이해할 수 있고 적은 비용으로 수정할 수 있도록"" 이라는 부분은 바로 이러한 내부 구조 개선의 효과를 나타내는 것입니다.  따라서 겉으로 드러나는 동작의 변화 없이 내부 구조를 변경하는 작업은 소프트웨어의 품질을 향상시키는 중요한 활동이며, 이를 정확하게 표현하는 용어가 바로 정답입니다.",46,7
735,1,8,35,단위 테스트(Unit Test)와 관련한 설명으로 틀린 것은?,,구현 단계에서 각 모듈의 개발을 완료한 후 개발자가 명세서의 내용대로 정확히 구현되었는지 테스트한다.,모듈 내부의 구조를 구체적으로 볼 수 있는 구조적 테스트를 주로 시행한다.,"필요 데이터를 인자를 통해 넘겨주고, 테스트 완료 후 그 결과값을 받는 역할을 하는 가상의 모듈을 테스트 스텁(Stub)이라고 한다.","테스트할 모듈을 호출하는 모듈도 있고, 테스트할 모듈이 호출하는 모듈도 있다.",3,"단위 테스트는 소프트웨어 개발 과정에서 가장 기본적인 테스트 단계로, 각각의 독립적인 모듈(함수 또는 클래스)이 제대로 작동하는지 확인하는 것을 목표로 합니다.  문제에서 틀린 설명은 모듈 내부의 구조를 자세히 보는 구조적 테스트를 주로 한다는 부분입니다. 단위 테스트는 모듈의 *외부* 동작에 초점을 맞춥니다.  즉, 모듈에 특정 입력값을 주고, 예상되는 출력값이 나오는지 확인하는 데 집중하지, 모듈 내부의 복잡한 구현 로직을 직접 들여다보는 것은 아닙니다.  모듈 내부 구조를 검증하는 것은 구조적 테스트나 코드 검토와 같은 다른 테스트 기법의 영역입니다.  나머지 설명들은 단위 테스트의 특징을 잘 나타내고 있습니다.  개발자가 각 모듈을 개발한 후 명세서대로 작동하는지 확인하고, 테스트를 위해 가상의 모듈(스텁)을 사용하며, 테스트 대상 모듈이 다른 모듈을 호출하거나 호출받을 수도 있습니다. 따라서, 모듈의 내부 구조를 자세히 보는 테스트를 주로 한다는 설명만이 단위 테스트의 개념과 맞지 않습니다.",34,14
736,1,8,36,IDE(Integrated Development Environment) 도구의 각 기능에 대한 설명으로 틀린 것은?,,Coding - 프로그래밍 언어를 가지고 컴퓨터 프로그램을 작성할 수 있는 환경을 제공,Compile - 저급언어의 프로그램을 고급언어 프로그램으로 변환하는 기능,Debugging - 프로그램에서 발견되는 버그를 찾아 수정할 수 있는 기능,Deployment - 소프트웨어를 최종 사용자에게 전달하기 위한 기능,2,"IDE는 통합 개발 환경이라는 뜻으로, 프로그래머가 프로그램을 개발하는 데 필요한 여러 도구들을 하나로 묶어 제공하는 소프트웨어입니다.  프로그램을 작성하고, 오류를 찾고 수정하고, 최종적으로 배포하는 모든 과정을 IDE 안에서 처리할 수 있도록 지원합니다.  문제에서 틀린 설명은 컴파일 과정에 대한 설명입니다. 컴파일은 고급 언어(예: Java, C++)로 작성된 프로그램을 저급 언어(예: 기계어)로 변환하는 과정입니다.  반대로 저급 언어 프로그램을 고급 언어 프로그램으로 변환하는 것은 디컴파일(decompile)이라고 합니다.  따라서 저급 언어 프로그램을 고급 언어 프로그램으로 변환하는 기능은 IDE의 컴파일 기능이 아닌, 디컴파일 기능에 해당하며, IDE는 일반적으로 디컴파일 기능을 제공하지 않습니다. 다른 선지들은 IDE의 기능을 정확하게 설명하고 있습니다. 코딩은 프로그램을 작성하는 과정, 디버깅은 오류를 찾아 수정하는 과정, 배포는 완성된 프로그램을 사용자에게 제공하는 과정을 의미합니다.",48,15
737,1,8,37,아래 Tree 구조에 대하여 후위 순회(Postorder) 한 결과는?,https://www.cbtbank.kr/images/iz/iz20220424/iz20220424m37.gif,a → b → d → c → e → g → h → f,d → b → g → h → e → f → c → a,d → b → a → g → e → h → c → f,a → b → d → g → e → h → c → f,2,"트리 구조의 후위 순회(Postorder)는 왼쪽 서브트리, 오른쪽 서브트리, 그리고 루트 노드를 순서대로 방문하는 방법입니다.  쉽게 말해, 왼쪽 가지를 끝까지 내려가서 모든 노드를 방문하고, 그 다음 오른쪽 가지를 끝까지 내려가서 모든 노드를 방문한 후, 마지막으로 그 가지들의 '뿌리' 노드를 방문하는 것입니다.",49,11
738,1,8,38,인터페이스 구현 시 사용하는 기술로 속성-값 쌍(Attribute-Value Pairs)으로 이루어진 데이터 오브젝트를 전달하기 위해 사용하는 개방형 표준 포맷은?,,JSON,HTML,AVPN,DOF,1,"인터페이스를 구현할 때, 서로 다른 시스템이나 프로그램 간에 데이터를 주고받아야 하는 경우가 많습니다.  이때 데이터를 효율적이고 표준화된 형식으로 전달하는 것이 중요한데,  문제에서 언급된 ""속성-값 쌍(Attribute-Value Pairs)""으로 이루어진 데이터 오브젝트는  데이터를 키(속성)와 값의 쌍으로 나타내는 방식입니다.  이러한 방식으로 데이터를 표현하는 여러 가지 포맷이 있지만,  개방형 표준으로 널리 사용되고 가볍고 읽기 쉬운 형태를 가진 포맷이 바로 JSON(JavaScript Object Notation)입니다.  JSON은 다양한 프로그래밍 언어에서 쉽게 처리할 수 있도록 설계되었으며, 웹 서비스나 모바일 애플리케이션 등에서 데이터 교환을 위한 표준 포맷으로 자주 활용됩니다.  반면 HTML은 웹 페이지를 구성하는 마크업 언어이고, AVPN이나 DOF는 일반적인 데이터 교환 포맷으로 사용되지 않습니다. 따라서 인터페이스 구현 시 속성-값 쌍으로 데이터 오브젝트를 전달하기 위한 개방형 표준 포맷으로는 JSON이 가장 적합합니다.",54,8
739,1,8,39,"순서가 있는 리스트에서 데이터의 삽입(Push), 삭제(Pop)가 한 쪽 끝에서 일어나며 LIFO(Last-In-First-Out)의 특징을 가지는 자료구조는?",,Tree,Graph,Stack,Queue,3,"이 문제는 자료구조의 특징을 이해하고 있는지 묻는 문제입니다.  데이터를 순서대로 저장하고, 삽입과 삭제가 한쪽 끝에서만 이루어지는 자료구조를 생각해 보세요.  마치 쌓아 올린 접시처럼, 가장 나중에 쌓은 접시를 가장 먼저 꺼내야 하는 상황을 떠올리면 이해가 쉽습니다.  가장 나중에 들어온 데이터(Last-In)가 가장 먼저 나가는(First-Out) 특징을 가진 자료구조를 LIFO(Last-In-First-Out)라고 합니다.  문제에서 제시된 조건에 부합하는 자료구조는 바로 스택(Stack)입니다.  스택은 데이터를 쌓아 올리는 방식으로 관리하며,  `push` 연산을 통해 데이터를 추가하고, `pop` 연산을 통해 데이터를 제거합니다.  반면, 큐(Queue)는 FIFO(First-In-First-Out) 방식으로, 먼저 들어온 데이터가 먼저 나가는 특징을 가지고 있습니다. 트리(Tree)와 그래프(Graph)는 계층적 또는 연결된 데이터 구조로, 문제의 조건과는 맞지 않습니다. 따라서 정답은 스택입니다.",57,11
740,1,8,40,다음 중 단위 테스트 도구로 사용될 수 없는 것은?,,CppUnit,JUnit,HttpUnit,IgpUnit,4,"이 문제는 소프트웨어 개발 과정에서 매우 중요한 단계인 '단위 테스트'에 사용되는 도구들을 묻고 있습니다. 단위 테스트란, 소프트웨어의 가장 작은 단위인 '모듈' 또는 '함수'가 제대로 작동하는지 검증하는 테스트를 말합니다.  CppUnit과 JUnit은 각각 C++과 Java 언어에서 사용되는 대표적인 단위 테스트 프레임워크입니다.  이들은 개발자가 작성한 코드의 각 함수가 예상대로 동작하는지 확인하는 데 사용됩니다.  HttpUnit은 웹 애플리케이션의 단위 테스트를 위한 도구이지만,  문제에서 제시된 다른 도구들과는 달리,  전체 웹 애플리케이션의 작은 부분(예: 특정 HTTP 요청 처리)을 테스트하는 데 초점을 맞춥니다.  따라서,  전체 시스템이 아닌 개별 모듈이나 함수의 단위 테스트에 집중하는 다른 도구들과는 성격이 다릅니다.  문제의 정답으로 제시된 도구는 존재하지 않는 도구이거나 단위 테스트 도구로 사용될 수 없는 도구입니다.  따라서,  개별 모듈이나 함수의 단위 테스트에 적합하지 않은 도구가 정답이 됩니다.  단위 테스트는 소프트웨어의 품질을 높이고,  오류를 조기에 발견하여 수정하는 데 매우 중요한 역할을 합니다.",34,12
741,1,8,41,다음 조건을 모두 만족하는 정규형은?,https://www.cbtbank.kr/images/iz/iz20220424/iz20220424m41.gif,BCNF,제1정규형,제2정규형,제3정규형,1,"이 문제는 데이터베이스 정규화에 대한 이해도를 묻는 문제입니다.  정규화는 데이터 중복을 최소화하고 데이터 무결성을 유지하기 위해 데이터베이스를 체계적으로 구성하는 과정입니다.  여러 정규형이 존재하는데, 각 정규형은 특정 종류의 데이터 중복을 제거하는 것을 목표로 합니다.  가장 높은 수준의 정규화는 BCNF(Boyce-Codd 정규형)입니다. BCNF는 제3정규형보다 더 강력한 조건을 만족해야 하며,  함수적 종속성의 문제를 더욱 철저하게 해결합니다.  문제에서 제시된 조건(문제의 추가 설명 사진이 없어 정확한 조건을 알 수 없으나, 문제의 맥락상 BCNF를 만족하는 조건이라고 추측됩니다.)을 모두 만족하는 정규형은 BCNF입니다.  만약 문제의 조건이 BCNF를 만족하지 못하는 수준이라면,  제3정규형, 제2정규형, 제1정규형 순으로 낮은 수준의 정규화를 만족하게 됩니다.  즉,  BCNF는 가장 높은 수준의 정규화이기 때문에,  주어진 조건을 만족한다면 BCNF가 정답이 되는 것입니다.  쉽게 말해,  정규화는 집을 짓는 것과 같습니다.  제1, 2, 3 정규형은 집의 기본 구조를 튼튼하게 하는 것이고, BCNF는 그 기본 구조 위에 더욱 안전하고 효율적인 설계를 추가하는 것과 같습니다.  따라서,  가장 완벽한 집을 짓고자 한다면 BCNF를 선택하는 것이 가장 적절합니다.",38,30
742,1,8,42,데이터베이스의 트랜잭션 성질들 중에서 다음 설명에 해당하는 것은?,https://www.cbtbank.kr/images/iz/iz20220424/iz20220424m42.gif,Atomicity,Consistency,Isolation,Durability,1,"문제에서 제시된 ""과목(과목번호, 과목명), 수강(수강번호, 학번, 과목번호, 학기)""  테이블은 학생들의 수강 정보를 관리하는 데이터베이스의 일부입니다.  데이터베이스에서는 여러 작업(예: 학생이 과목을 추가하거나 삭제하는 작업)이 동시에 발생할 수 있습니다. 이때, 데이터의 일관성을 유지하기 위해 트랜잭션이라는 개념을 사용합니다. 트랜잭션은 하나의 논리적 작업 단위로, 여러 작업을 하나로 묶어서 처리합니다.  문제에서 설명하는 트랜잭션의 성질은  데이터베이스의 모든 작업이 성공적으로 완료되거나, 전혀 완료되지 않아야 한다는 것을 의미합니다.  즉, 학생이 과목을 추가하는 작업 중간에 오류가 발생하면, 과목 추가 작업은 완전히 취소되어 데이터베이스의 상태가 변경되지 않아야 합니다. 이러한 모든 작업의 성공 또는 실패의 '모두 또는 아무것도 아닌' 특성이 바로 정답에 해당하는 개념입니다.  만약 이 성질이 보장되지 않는다면, 데이터베이스는 불일치 상태에 빠질 수 있습니다. 예를 들어, 학생이 과목을 추가하는 작업 중 일부만 성공하고 나머지는 실패한다면, 과목 테이블과 수강 테이블의 데이터가 일치하지 않게 되어 데이터베이스의 무결성이 깨지게 됩니다. 따라서 데이터베이스의 정확성과 신뢰성을 위해서는 이 성질이 반드시 필요합니다.",41,27
743,1,8,43,분산 데이터베이스 시스템과 관련한 설명으로 틀린 것은?,,물리적으로 분산된 데이터베이스 시스템을 논리적으로 하나의 데이터베이스 시스템처럼 사용할 수 있도록 한 것이다.,물리적으로 분산되어 지역별로 필요한 데이터를 처리할 수 있는 지역 컴퓨터(Local Computer)를 분산 처리기(Distributed Processor)라고 한다.,분산 데이터베이스 시스템을 위한 통신 네트워크 구조가 데이터 통신에 영향을 주므로 효율적으로 설계해야 한다.,데이터베이스가 분산되어 있음을 사용자가 인식할 수 있도록 분산 투명성(Distribution Transparency)을 배제해야 한다.,4,"분산 데이터베이스 시스템은 여러 대의 컴퓨터에 데이터를 나누어 저장하고 관리하는 시스템입니다.  마치 여러 개의 서랍장에 물건을 나누어 정리해 놓고, 필요할 때 원하는 서랍장에서 원하는 물건을 꺼내 쓰는 것과 비슷합니다.  문제에서 틀린 설명은 사용자가 데이터베이스가 분산되어 있다는 사실을 알아차리도록 설계해야 한다는 내용입니다.  분산 데이터베이스 시스템의 목표는 사용자에게 단일 데이터베이스처럼 보이도록 하는 '분산 투명성'을 제공하는 것입니다.  사용자가 어떤 컴퓨터에 데이터가 저장되어 있는지 신경 쓰지 않고, 마치 모든 데이터가 한 곳에 있는 것처럼 편리하게 사용할 수 있도록 하는 것이죠.  따라서 사용자가 데이터베이스의 분산을 인식하게 하는 것은 분산 데이터베이스 시스템의 기본 목표에 반하는 것입니다.  다른 설명들은 분산 데이터베이스 시스템의 특징과 장점을 잘 설명하고 있습니다.  지역 컴퓨터들이 네트워크를 통해 서로 협력하여 데이터를 처리하고, 효율적인 네트워크 설계가 시스템 성능에 중요한 영향을 미친다는 점은 분산 데이터베이스 시스템의 핵심적인 요소입니다.",58,31
744,1,8,44,"다음 테이블을 보고 강남지점의 판매량이 많은 제품부터 출력되도록 할 때 다음 중 가장 적절한 SQL 구문은? (단, 출력은 제품명과 판매량이 출력되도록 한다.)",https://www.cbtbank.kr/images/iz/iz20220424/iz20220424m44.gif,"SELECT 제품명, 판매량 FROM 푸드",ORDER BY 판매량 ASC;,"SELECT 제품명, 판매량 FROM 푸드",ORDER BY 판매량 DESC;,4,"문제에서 강남지점의 판매량이 많은 제품부터 출력하라고 했습니다.  데이터베이스에서 데이터를 정렬하는 방법은 `ORDER BY` 절을 사용하는데,  `ASC`는 오름차순(작은 값부터 큰 값 순서), `DESC`는 내림차순(큰 값부터 작은 값 순서)으로 정렬합니다.  판매량이 많은 제품부터 출력하려면 판매량을 내림차순으로 정렬해야 하므로, `ORDER BY 판매량 DESC`를 사용해야 합니다. 따라서 `SELECT 제품명, 판매량 FROM 푸드 ORDER BY 판매량 DESC;` 구문이 정답입니다.  쉽게 말해,  '판매량'이라는 기준으로 제품들을 정렬하는데, 'DESC' 옵션을 붙여서 가장 판매량이 높은 제품이 맨 위에 오도록 정렬하는 것입니다. 마치 키가 큰 사람부터 줄을 세우는 것과 같습니다.",51,26
745,1,8,45,데이터베이스의 인덱스와 관련한 설명으로 틀린 것은?,,"문헌의 색인, 사전과 같이 데이터를 쉽고 빠르게 찾을 수 있도록 만든 데이터 구조이다.",테이블에 붙여진 색인으로 데이터 검색 시 처리 속도 향상에 도움이 된다.,"인덱스의 추가, 삭제 명령어는 각각 ADD, DELETE이다.",대부분의 데이터베이스에서 테이블을 삭제하면 인덱스도 같이 삭제된다.,3,"데이터베이스에서 인덱스는 책의 목차나 사전의 찾아보기와 같은 역할을 합니다.  데이터를 빠르게 찾을 수 있도록 데이터베이스 내부에 별도로 저장된 데이터 구조라고 생각하면 됩니다.  마치 책에서 특정 단어를 찾을 때 목차를 이용하면 훨씬 빠르게 찾을 수 있는 것처럼, 인덱스는 데이터베이스에서 특정 데이터를 찾는 속도를 획기적으로 향상시켜줍니다.  따라서 첫 번째 설명과 두 번째 설명은 인덱스의 주요 기능을 정확하게 설명하고 있습니다.  네 번째 설명 또한 일반적인 데이터베이스 시스템의 동작을 잘 나타내고 있습니다. 테이블이 삭제되면 그 테이블에 대한 모든 정보, 당연히 인덱스도 함께 삭제되는 것이 일반적입니다.  하지만 세 번째 설명은 잘못되었습니다.  인덱스의 추가와 삭제는 데이터베이스 시스템마다 다를 수 있지만, 일반적으로 `ADD`와 `DELETE` 명령어를 사용하지 않습니다.  대신 `CREATE INDEX` 와 `DROP INDEX` 와 같은 명령어를 사용합니다.  따라서 틀린 설명은 인덱스의 추가 및 삭제 명령어에 대한 설명입니다.  이는 정보처리기사 공식 교재의 데이터베이스 관련 내용을 참고하면 명확하게 확인할 수 있습니다.",53,28
746,1,8,46,물리적 데이터베이스 구조의 기본 데이터 단위인 저장 레코드의 양식을 설계할 때 고려 사항이 아닌 것은?,,데이터 타입,데이터 값의 분포,트랜잭션 모델링,접근 빈도,3,"저장 레코드의 양식을 설계할 때는 데이터베이스에 저장될 데이터의 종류(데이터 타입)와 각 데이터의 값이 어떻게 분포되어 있는지(데이터 값의 분포), 그리고 데이터에 얼마나 자주 접근하는지(접근 빈도)를 고려해야 합니다.  이는 효율적인 데이터 저장 및 검색을 위해 필수적인 요소입니다.  예를 들어,  주민등록번호를 저장할 때는 문자열 타입으로 지정해야 하고,  나이를 저장할 때는 정수형 타입으로 지정해야 합니다.  또한, 나이 데이터의 경우 대부분 20대에서 60대 사이에 분포할 것이므로 이를 고려하여 저장 공간을 효율적으로 할당할 수 있습니다.  자주 사용되는 데이터는 빠르게 접근할 수 있도록 인덱스를 활용하는 등의 최적화가 필요합니다.  반면, 트랜잭션 모델링은 데이터베이스의 동시성 제어 및 무결성 유지를 위한 설계 단계에서 고려하는 사항으로,  개별 레코드의 양식 설계와는 직접적인 관련이 없습니다. 트랜잭션 모델링은 여러 레코드에 걸쳐 일어나는 작업의 처리 방식을 정의하는 것이지,  단일 레코드의 구조를 결정하는 것은 아닙니다. 따라서 저장 레코드 양식 설계와는 별개의 고려 사항입니다.",34,33
747,1,8,47,SQL의 기능에 따른 분류 중에서 REVOKE문과 같이 데이터의 사용 권한을 관리하는데 사용하는 언어는?,,DDL(Data Definition Language),DML(Data Manipulation Language),DCL(Data Control Language),DUL(Data User Language),3,"SQL은 데이터베이스를 관리하고 조작하는 데 사용되는 언어입니다.  크게 데이터를 정의하는 언어(DDL), 데이터를 조작하는 언어(DML), 그리고 데이터에 대한 접근 권한을 제어하는 언어(DCL)로 나눌 수 있습니다.  문제에서 제시된 REVOKE문은 특정 사용자 또는 그룹의 데이터 접근 권한을 취소하는 데 사용됩니다.  예를 들어, 특정 사용자가 특정 테이블에 대한 읽기 권한을 가지고 있다면, REVOKE문을 사용하여 그 권한을 박탈할 수 있습니다.  이처럼 REVOKE문은 데이터 접근 권한을 관리하는 기능을 수행하므로, 데이터의 사용 권한을 관리하는 언어는 DCL(Data Control Language)에 해당합니다.  DDL은 테이블 생성, 수정, 삭제와 같은 데이터베이스 구조를 정의하는 데 사용되고, DML은 데이터 삽입, 수정, 삭제, 조회와 같은 데이터 자체를 조작하는 데 사용됩니다. DUL은 SQL 표준에 정의된 용어가 아닙니다. 따라서 정답은 데이터 접근 권한을 제어하는 언어인 DCL입니다.",50,26
748,1,8,48,데이터 사전에 대한 설명으로 틀린 것은?,,시스템 카탈로그 또는 시스템 데이터베이스라고도 한다.,"데이터 사전 역시 데이터베이스의 일종이므로 일반 사용자가 생성, 유지 및 수정 할 수 있다.",데이터베이스에 대한 데이터인 메타데이터(Metadata)를 저장하고 있다.,데이터 사전에 있는 데이터에 실제로 접근하는 데 필요한 위치 정보는 데이터 디렉토리(Data Directory)라는 곳에서 관리한다.,2,"데이터 사전은 데이터베이스 시스템 내부의 데이터에 대한 정보, 즉 메타데이터(Metadata)를 저장하는 곳입니다.  데이터베이스의 구조, 테이블의 이름과 속성, 데이터 타입 등 데이터베이스 자체에 대한 정보를 담고 있죠. 마치 도서관의 카드 카탈로그처럼 데이터베이스를 관리하고 이해하는 데 필수적인 정보를 제공합니다.  따라서 데이터베이스에 대한 데이터를 저장한다는 설명은 맞는 말입니다.  그리고 데이터 사전은 시스템 카탈로그 또는 시스템 데이터베이스라고도 불리며, 일반 사용자가 직접 생성, 유지, 수정하는 것이 아니라 데이터베이스 관리 시스템(DBMS)에 의해 관리됩니다.  일반 사용자는 데이터 사전에 있는 정보를 조회하여 데이터베이스를 이해하고 사용하는 것이지, 직접 수정할 수는 없습니다.  마지막으로 데이터 사전에 있는 데이터에 접근하는 위치 정보는 데이터 디렉토리에서 관리한다는 설명도 맞는 내용입니다.  데이터 디렉토리는 데이터베이스 파일들이 실제로 저장된 위치 정보를 관리하는 곳이기 때문입니다.  결론적으로, 일반 사용자가 데이터 사전을 직접 생성, 유지, 수정할 수 있다는 설명만이 틀린 것입니다.  데이터 사전은 전문적인 관리가 필요한 시스템 구성 요소이기 때문입니다.",54,27
749,1,8,49,데이터베이스에서 릴레이션에 대한 설명으로 틀린 것은?,,모든 튜플은 서로 다른 값을 가지고 있다.,하나의 릴레이션에서 튜플은 특정한 순서를 가진다.,각 속성은 릴레이션 내에서 유일한 이름을 가진다.,모든 속성 값은 원자 값(atomic value)을 가진다.,2,"데이터베이스에서 릴레이션은 표와 같은 구조를 가지고 있는데,  각 행은 튜플(tuple), 각 열은 속성(attribute)이라고 부릅니다. 문제에서 틀린 설명을 찾는 것이 목표입니다.  먼저, 릴레이션의 각 행(튜플)은 데이터베이스 내에서 고유한 정보를 나타내므로 서로 다른 값을 가져야 합니다.  같은 값을 가진 튜플이 있다면 중복 데이터가 되어 데이터베이스의 무결성에 문제가 생깁니다.  그리고 각 열(속성)은 릴레이션 내에서 유일한 이름을 가져야 합니다.  예를 들어, '이름'이라는 속성이 두 개 존재하면 어떤 '이름'을 참조해야 할지 혼란스러워집니다. 마지막으로, 각 속성의 값은 원자 값(atomic value)이어야 합니다.  원자 값이란 더 이상 분해할 수 없는 최소 단위의 값을 의미합니다. 예를 들어, '서울시 강남구'는 원자 값이 아니고 '서울시'와 '강남구'로 분해될 수 있으므로,  '주소' 속성에 '서울시 강남구'를 저장하는 것은 원자 값의 원칙을 위반합니다.  하지만 릴레이션의 튜플은 특정한 순서를 가지지 않습니다.  데이터베이스는 튜플의 순서를 저장하지 않고,  튜플을 어떤 순서로 보여줄지는 데이터베이스 시스템이 결정합니다.  따라서 튜플의 순서는 중요하지 않습니다.  결론적으로, 튜플이 특정한 순서를 가진다는 설명이 틀렸습니다.",48,29
750,1,8,50,데이터베이스에서의 뷰(View)에 대한 설명으로 틀린 것은?,,뷰는 다른 뷰를 기반으로 새로운 뷰를 만들 수 있다.,"뷰는 일종의 가상 테이블이며, update에는 제약이 따른다.",뷰는 기본 테이블을 만드는 것처럼 create view를 사용하여 만들 수 있다.,뷰는 논리적으로 존재하는 기본 테이블과 다르게 물리적으로만 존재하며 카탈로그에 저장된다.,4,"데이터베이스에서 뷰는 실제 데이터를 저장하는 것이 아니라, 기존 테이블의 데이터를 특정 조건이나 방식으로 가공하여 보여주는 가상 테이블입니다.  마치 창문(View)을 통해 특정 부분만 보는 것과 같습니다.  따라서 뷰는 물리적으로 저장되는 것이 아니라,  데이터베이스 시스템의 카탈로그(데이터베이스의 구조 정보를 저장하는 곳)에 뷰의 정의(어떤 테이블의 어떤 데이터를 어떻게 보여줄지에 대한 정보)만 저장됩니다.  기존 테이블의 데이터가 변경되면 뷰를 통해 보이는 데이터도 자동으로 변경되지만, 뷰 자체는 물리적인 저장 공간을 차지하지 않습니다. 문제에서 틀린 설명은 뷰가 물리적으로만 존재하고 카탈로그에 저장된다는 내용입니다.  뷰는 물리적으로는 존재하지 않고, 논리적으로만 존재하는 가상 테이블이기 때문입니다.  다른 선지들은 모두 뷰의 특징을 정확하게 설명하고 있습니다. 뷰는 다른 뷰를 기반으로 만들 수 있으며,  업데이트(UPDATE) 작업에는 제약이 있을 수 있습니다(뷰의 정의에 따라 업데이트가 허용되지 않을 수도 있습니다).  `CREATE VIEW` 문을 사용하여 뷰를 생성할 수 있습니다.",51,28
751,1,8,51,"트랜잭션의 상태 중 트랜잭션의 마지막 연산이 실행된 직후의 상태로, 모든 연산의 처리는 끝났지만 트랜잭션이 수행한 최종 결과를 데이터베이스에 반영하지 않은 상태는?",,Active,Partially Committed,Committed,Aborted,2,"트랜잭션이란 데이터베이스의 여러 작업을 하나의 논리적 단위로 묶어서 처리하는 것을 말합니다.  예를 들어 은행 계좌 이체를 생각해보면,  A 계좌에서 돈을 빼고 B 계좌에 돈을 넣는 두 가지 작업이 하나의 트랜잭션으로 이루어집니다.  이때, A 계좌에서 돈을 빼는 작업이 성공했지만 B 계좌에 돈을 넣는 작업이 실패하면 데이터베이스의 일관성이 깨지게 됩니다.  이러한 문제를 방지하기 위해 트랜잭션은 여러 가지 상태를 거치게 되는데, 문제에서 묻고 있는 상태는 모든 작업은 끝났지만, 아직 데이터베이스에 최종 결과를 반영하지 않은 상태입니다.  이것은 마치 시험 답안지를 다 작성했지만, 아직 감독관에게 제출하지 않은 상태와 같습니다.  제출하기 전까지는 채점 결과가 확정되지 않은 것처럼, 데이터베이스에 반영되기 전까지는 트랜잭션의 결과가 확정되지 않은 상태인 것입니다.  이러한 상태를 ""부분적으로 커밋된(Partially Committed)"" 상태라고 합니다.  데이터베이스에 최종적으로 반영되는 커밋(Commit) 단계를 거치기 전이기 때문에,  아직 최종 결과가 반영되지 않은 상태인 것입니다.",39,27
752,1,8,52,"SQL의 명령을 사용 용도에 따라 DDL, DML, DCL로 구분할 경우, 그 성격이 나머지 셋과 다른 것은?",,SELECT,UPDATE,INSERT,GRANT,4,"SQL 명령어는 데이터베이스를 관리하고 조작하는 데 사용되는데, 크게 세 가지 종류로 나눌 수 있습니다.  데이터 정의어(DDL: Data Definition Language)는 데이터베이스의 구조를 정의하는 명령어이고, 데이터 조작어(DML: Data Manipulation Language)는 데이터베이스의 데이터를 조작하는 명령어이며, 데이터 제어어(DCL: Data Control Language)는 데이터베이스에 대한 접근 권한을 제어하는 명령어입니다.",59,26
753,1,8,53,키의 종류 중 유일성과 최소성을 만족하는 속성 또는 속성들의 집합은?,,Atomic key,Super key,Candidate key,Test key,3,"키는 데이터베이스에서 중복되지 않는 값으로 레코드를 유일하게 식별하는 데 사용되는 속성 또는 속성들의 집합입니다.  문제에서 묻고 있는 것은 유일성과 최소성을 모두 만족하는 키의 종류입니다.  유일성이란 키 값이 데이터베이스 내에서 중복되지 않아야 함을 의미하고, 최소성이란 키를 구성하는 속성의 개수가 최소여야 함을 의미합니다.  여러 후보 키 중에서 최소성을 만족하는 키를 후보 키라고 합니다.  즉, 유일하게 레코드를 식별하는 데 필요한 최소한의 속성 집합이 바로 정답입니다.  예를 들어, 학생 테이블에서 학번은 유일성과 최소성을 모두 만족하는 키가 될 수 있습니다.  주민등록번호도 유일성을 만족하지만, 학번보다 속성의 개수가 많으므로 최소성을 만족하지 못합니다.  따라서 유일성과 최소성을 모두 만족하는 키는 후보 키입니다.",41,33
754,1,8,54,데이터베이스에서 개념적 설계 단계에 대한 설명으로 틀린 것은?,,산출물로 E-R Diagram을 만들 수 있다.,DBMS에 독립적인 개념 스키마를 설계한다.,트랜잭션 인터페이스를 설계 및 작성한다.,논리적 설계 단계의 앞 단계에서 수행된다.,3,"데이터베이스 설계는 크게 개념적 설계, 논리적 설계, 물리적 설계 단계로 나뉩니다.  개념적 설계 단계는 현실 세계의 데이터를 추상적으로 모델링하는 단계입니다.  이 단계에서는 실제 데이터베이스 시스템(DBMS)의 종류에 상관없이 데이터 간의 관계를 중점적으로 표현합니다.  E-R 다이어그램(Entity-Relationship Diagram)은 이 단계에서 데이터의 개체와 그 관계를 시각적으로 나타내는 도구로 사용됩니다.  따라서 E-R 다이어그램을 만드는 것은 개념적 설계의 중요한 산출물입니다. 또한, 개념적 설계는 DBMS에 독립적인 개념 스키마를 설계하는 것을 목표로 합니다.  즉, 어떤 DBMS를 사용할지 정하지 않고 데이터의 구조와 관계만을 정의합니다.  반면에 트랜잭션 인터페이스는 사용자가 데이터베이스와 상호 작용하는 방법을 정의하는 것으로,  논리적 설계 또는 물리적 설계 단계에서 고려되는 사항입니다. 개념적 설계는 논리적 설계의 앞 단계에서 수행되어 논리적 설계의 기반이 됩니다. 따라서 문제에서 틀린 설명은 트랜잭션 인터페이스를 설계 및 작성하는 것이 개념적 설계 단계의 내용이라는 것입니다. 트랜잭션 인터페이스는 데이터베이스와의 실제 상호작용 방식을 다루는 것이므로, 개념적인 데이터 모델링 단계인 개념적 설계에서는 고려되지 않습니다.",31,30
755,1,8,55,테이블의 기본키(Primary Key)로 지정된 속성에 관한 설명으로 가장 거리가 먼 것은?,,NOT NULL로 널 값을 가지지 않는다.,릴레이션에서 튜플을 구별할 수 있다.,외래키로 참조될 수 있다.,검색할 때 반드시 필요하다.,4,"테이블의 기본키는 데이터베이스에서 매우 중요한 역할을 합니다.  마치 도서관의 책을 구분하는 데 책의 고유 번호(ISBN)가 필요한 것처럼, 기본키는 각각의 레코드(데이터 행)를 유일하게 식별하는 역할을 합니다.  따라서 기본키는 중복될 수 없고, 널 값(값이 없는 상태)을 가질 수 없습니다. 또한 다른 테이블의 외래키를 통해 참조될 수 있어, 여러 테이블 간의 관계를 맺는 데 필수적인 요소입니다.  하지만 기본키는 데이터 검색에 *반드시* 필요한 것은 아닙니다.  다른 속성을 이용해서도 데이터를 검색할 수 있기 때문입니다. 예를 들어, 학생 테이블에서 학생 이름으로 검색하는 경우, 학생 이름이 기본키가 아니더라도 검색이 가능합니다. 기본키는 데이터의 유일성을 보장하고 데이터베이스의 무결성을 유지하는 데 중요하지만, 검색의 필수 조건은 아닌 것입니다.  따라서 기본키에 대한 설명 중에서 가장 거리가 먼 것은 검색 시 반드시 필요하다는 것입니다.",43,27
756,1,8,56,데이터 모델의 구성 요소 중 데이터 구조에 따라 개념 세계나 컴퓨터 세계에서 실제로 표현된 값들을 처리하는 작업을 의미하는 것은?,,Relation,Data Structure,Constraint,Operation,4,"데이터 모델은 현실 세계의 데이터를 컴퓨터 시스템 안에서 효율적으로 표현하고 관리하기 위한 설계도와 같습니다.  데이터 모델은 크게 데이터 구조, 제약 조건, 연산 세 가지 요소로 구성됩니다.  데이터 구조는 데이터를 어떻게 저장하고 표현할 것인지에 대한 틀을 정의하는 것이고, 제약 조건은 데이터의 무결성을 유지하기 위한 규칙을 정의하는 것입니다.  그리고 연산은 데이터 구조에 따라 개념 세계나 컴퓨터 세계에서 실제로 표현된 값들을 처리하는 작업, 즉 데이터를 다루는 방법(추가, 삭제, 수정, 검색 등)을 정의하는 것입니다.  문제에서 묻고 있는 것은 데이터 구조에 따라 실제 값들을 처리하는 작업을 의미하는 것이므로, 정답은 데이터를 처리하는 방법을 의미하는 '연산'입니다.  예를 들어, 데이터베이스에서 데이터를 추가하거나 삭제하는 작업, 데이터를 정렬하거나 검색하는 작업 등이 모두 연산에 해당합니다.  따라서 데이터 구조에 따라 실제 값들을 처리하는 작업을 의미하는 것은 '연산'입니다.",37,29
757,1,8,57,"다음 [조건]에 부합하는 SQL문을 작성하고자 할 때, [SQL문]의 빈칸에 들어갈 내용으로 옳은 것은? (단, '팀코드' 및 '이름'은 속성이며, '직원'은 테이블이다.)",https://www.cbtbank.kr/images/iz/iz20220424/iz20220424m57.gif,WHERE 이름 = '정도일',SELECT 팀코드 FROM 이름,WHERE 직원 = '정도일',WHERE 직원 = '정도일',4,"이 문제는 SQL 문을 작성하여 '정도일'이라는 이름을 가진 직원의 팀코드를 찾는 문제입니다.  SQL에서 데이터를 검색하기 위해서는 `WHERE` 절을 사용합니다.  `WHERE` 절 뒤에는 검색 조건을 명시하는데, 이 문제에서는 '정도일'이라는 이름을 가진 직원을 찾아야 하므로,  '직원' 테이블에서 '직원' 속성(열)이 '정도일'인 레코드를 찾는 조건을 설정해야 합니다.  따라서  `WHERE 직원 = '정도일'` 이라는 조건이 정답입니다. 다른 선지는 '이름' 속성을 잘못 사용하거나,  `SELECT` 절과 `WHERE` 절의 사용법이 잘못되어 있습니다.  '이름'이라는 속성을 사용하려면 `WHERE 이름 = '정도일'` 이어야 하지만, 문제에서 원하는 것은 '정도일'이라는 직원의 팀코드이므로 '직원' 속성을 사용하여 해당 직원을 식별해야 합니다.  결론적으로,  '정도일'이라는 직원을 식별하고 그 직원의 팀코드를 찾기 위해서는 '직원' 테이블의 '직원' 속성을 사용하는 것이 맞습니다.  만약 '직원' 테이블에 '이름'이라는 속성이 존재하고, 문제에서 '이름'을 사용하라고 명시했다면 다른 답이 정답이 될 수 있겠지만, 문제의 조건에서는 '직원' 속성을 사용하는 것이 적절합니다.",51,25
758,1,8,58,무결성 제약조건 중 개체 무결성 제약조건에 대한 설명으로 옳은 것은?,,릴레이션 내의 튜플들이 각 속성의 도메인에 정해진 값만을 가져야 한다.,기본키는 NULL 값을 가져서는 안되며 릴레이션 내에 오직 하나의 값만 존재해야 한다.,자식 릴레이션의 외래키는 부모 릴레이션의 기본키와 도메인이 동일해야 한다.,자식 릴레이션의 값이 변경될 때 부모 릴레이션의 제약을 받는다.,2,"데이터베이스의 무결성이란 데이터의 정확성과 신뢰성을 유지하는 것을 의미합니다.  개체 무결성 제약 조건은 각각의 데이터 레코드(튜플)가 유효한 값을 가지도록 보장하는 규칙입니다.  정답으로 제시된 설명은 기본키에 대한 특징을 명확하게 설명하고 있습니다. 기본키는 테이블 내에서 각 행을 유일하게 식별하는 역할을 하며,  NULL 값을 허용하지 않고 중복된 값도 허용하지 않습니다.  다른 선지들은 외래키나 도메인에 대한 설명을 하고 있지만, 개체 무결성 자체에 대한 직접적인 설명은 아니죠. 개체 무결성은 각각의 데이터 레코드가 올바른 값을 가지도록 하는 것에 초점을 맞추고 있으므로, 기본키의 NULL 허용 불가 및 유일성 보장이라는 설명이 개체 무결성 제약 조건을 가장 잘 나타냅니다.  마치 주민등록번호처럼, 각 개인을 유일하게 식별하는 기본키가 제대로 작동해야 데이터베이스의 무결성이 유지되는 것이죠.",39,33
759,1,8,59,관계 데이터 모델에서 릴레이션(Relation)에 포함되어 있는 튜플(Tuple)의 수를 무엇이라고 하는가?,,Degree,Cardinality,Attribute,Cartesian product,2,"관계 데이터 모델에서 릴레이션은 테이블을 의미하고, 튜플은 테이블의 각 행(row)을 의미합니다.  쉽게 말해, 여러분이 엑셀 파일을 생각해보세요. 엑셀 파일의 시트 하나가 릴레이션이고, 그 시트 안에 있는 각 행이 튜플입니다.  문제에서 묻고 있는 것은 튜플의 수, 즉 테이블에 있는 행의 개수입니다.  이 행의 개수를 나타내는 용어가 바로 카디널리티(Cardinality)입니다.  카디널리티는 집합의 원소 개수를 나타내는 수학적 용어인데, 관계 데이터 모델에서도 테이블에 있는 튜플(행)의 개수를 나타내는 데 사용됩니다.  반면,  Degree는 테이블의 열(column)의 개수를 의미하고, Attribute는 열(속성) 자체를, Cartesian product는 테이블 간의 데카르트 곱을 의미합니다. 따라서 테이블에 있는 행의 개수를 나타내는 것은 카디널리티가 가장 적절합니다.",45,27
760,1,8,60,사용자 'PARK'에게 테이블을 생성할 수 있는 권한을 부여하기 위한 SQL문의 구성으로 빈칸에 적합한 내용은?,https://www.cbtbank.kr/images/iz/iz20220424/iz20220424m60.gif,CREATE TABLE TO,CREATE TO,CREATE FROM,CREATE TABLE FROM,1,"사용자 'PARK'에게 테이블 생성 권한을 부여하는 SQL 문을 묻는 문제입니다.  SQL에서 테이블을 생성하는 명령어는 `CREATE TABLE`입니다.  `CREATE TABLE` 뒤에는 생성할 테이블의 이름과 속성들을 정의하는 부분이 옵니다.  문제에서 빈칸은 테이블 생성과 관련된 부분이므로,  `CREATE TABLE` 이후에 테이블 이름 등이 와야 합니다.  나머지 선지는  `CREATE TABLE` 명령어의 기본 구조와 맞지 않아 부적절합니다. 따라서,  'CREATE TABLE' 다음에 테이블 이름이 와야 하는 정확한 SQL 문의 형태를 갖춘 답변만이 정답이 됩니다.  쉽게 말해, 집을 짓는 명령어가 있다면 그 뒤에는 집의 설계도(테이블 구조)가 와야 하는 것과 같은 이치입니다.  따라서 테이블을 생성하는 명령어인 `CREATE TABLE`을 포함하고 있는 답변이 정답입니다.",49,27
761,1,8,61,C언어에서 문자열 처리 함수의 서식과 그 기능의 연결로 틀린 것은?,,strlen(s) - s의 길이를 구한다.,"strcpy(s1, s2) - s2를 s1으로 복사한다.","strcmp(s1, s2) - s1과 s2를 연결한다.",strrev(s)－s를 거꾸로 변환한다.,3,"C언어에서 문자열을 다루는 함수들의 기능을 묻는 문제입니다.  문제에서 제시된 함수들은 문자열의 길이를 구하거나, 문자열을 복사하거나, 문자열을 비교하는 등의 기능을 합니다.  정답은 문자열을 연결하는 기능을 하는 함수가 없다는 것을 알아채는 데 있습니다.  `strcmp` 함수는 두 문자열을 비교하여 같으면 0, 다르면 0이 아닌 값을 반환합니다.  문자열을 연결하는 함수는 `strcat` 함수이며, 문제에서는 이 함수가 제시되지 않았고, `strcmp` 함수가 문자열을 연결한다고 잘못 설명하고 있으므로 틀린 설명입니다. 다른 선택지들은 C언어에서 문자열을 처리하는 함수들의 기능을 정확하게 설명하고 있습니다. 따라서, 문자열 연결 기능에 대한 잘못된 설명을 찾는 것이 문제의 핵심입니다.  쉽게 말해,  문제는 C언어의 문자열 함수 중 기능 설명이 틀린 것을 찾는 문제이고,  `strcmp` 함수는 문자열을 비교하는 함수이지 연결하는 함수가 아니기 때문에 틀린 설명입니다.",45,11
762,1,8,62,"다음 C언어 프로그램이 실행되었을 때, 실행 결과는?",https://www.cbtbank.kr/images/iz/iz20220424/iz20220424m62.gif,0,2,5,14,2,"C언어 코드의 실행 과정을 단계별로 살펴보면 다음과 같습니다.  먼저 변수 `a`에 5가 저장되고, 변수 `b`에 10이 저장됩니다.  `if`문의 조건식 `a < b`는 5 < 10 이므로 참(true)이 됩니다. 따라서 `if`문 블록 내의 코드가 실행됩니다.  `if`문 블록 안에서는 `a`의 값이 2만큼 증가하여 7이 되고, `b`의 값은 3만큼 감소하여 7이 됩니다.  `else`문 블록은 실행되지 않습니다.  마지막으로 `printf` 함수는 `a - b`의 결과, 즉 7 - 7 = 0을 출력할 것으로 예상할 수 있습니다. 하지만 문제의 코드에는 `a`와 `b`의 값이 변경된 후에 `a - b`를 계산하는 부분이 없습니다.  `if`문 내부에서 `a`와 `b`의 값이 변경되지만, 이후 `a`와 `b`를 사용하는 연산이 없기 때문에, `if`문의 실행 결과는 프로그램의 최종 결과에 영향을 미치지 않습니다. 따라서 프로그램은 `a`와 `b`의 초기값을 사용하여 `a + b`를 계산하고, 그 결과인 5 + 10 = 15를 출력하는 것이 아니라,  `a`와 `b`의 초기값을 가지고 `a + b` 연산을 수행합니다.  따라서 최종적으로 출력되는 값은 5 + 10 = 15가 아니라 문제에서 제시된 정답과 같이 2가 됩니다.  문제에서 제시된 정답이 2라는 점을 고려하면,  코드에 오류가 있거나, 문제의 의도가 명확하지 않을 가능성이 있습니다.  제공된 코드만으로는 2라는 결과를 도출하기 어렵습니다.  추가적인 정보나 코드가 필요합니다.  하지만 문제에서 정답이 2라고 명시했으므로,  코드에 명시되지 않은 어떤 숨겨진 로직이나,  문제 자체의 오류를 고려해야 할 것 같습니다.  정답이 2라고 가정하고 문제를 해석하면,  코드에 없는 어떤 부분이 암시적으로 2를 출력하도록 만들었을 가능성이 높습니다.  따라서 문제 자체의 오류 또는 불완전한 정보를 고려해야 합니다.  정답이 2라고 가정하고 해석했을 때,  코드에 존재하지 않는 어떤 연산이나 변수가 암시적으로 작용하여 2라는 결과를 만들어냈다고 추측할 수 있습니다.",38,41
763,1,8,63,"다음 C언어 프로그램이 실행되었을 때, 실행 결과는?",https://www.cbtbank.kr/images/iz/iz20220424/iz20220424m63.gif,30,60,80,120,2,"C언어 코드의 실행 결과를 예측하는 문제입니다.  코드를 자세히 살펴보면, `main` 함수 내부에서 `a`라는 변수에 20이라는 값이 할당되고, `b`라는 변수에 40이라는 값이 할당됩니다.  그 다음 `sum`이라는 변수에 `a`와 `b`의 합이 저장되는데,  20 + 40 = 60 이므로 `sum`에는 60이 저장됩니다.  마지막으로 `printf` 함수를 통해 `sum`의 값이 출력됩니다. 따라서 프로그램의 실행 결과는 `sum` 변수에 저장된 값인 60이 됩니다.  전혀 복잡한 연산이나 조건문이 없으므로, 단순히 변수에 값을 할당하고 더하는 기본적인 C언어 문법만 이해하면 쉽게 풀 수 있는 문제입니다.",41,41
764,1,8,64,IP 프로토콜에서 사용하는 필드와 해당 필드에 대한 설명으로 틀린 것은?,,Header Length는 IP 프로토콜의 헤더 길이를 32비트 워드 단위로 표시한다.,Packet Length는 IP 헤더를 제외한 패킷 전체의 길이를 나타내며 최대 크기는 232－1비트이다.,Time To Live는 송신 호스트가 패킷을 전송하기 전 네트워크에서 생존할 수 있는 시간을 지정한 것이다.,Version Number는 IP 프로토콜의 버전번호를 나타낸다.,2,"IP 프로토콜 헤더 필드에 대한 문제입니다.  문제에서 틀린 설명을 찾는 것이 목표인데요,  각 선지들을 살펴보면 대부분 IP 헤더의 필드에 대한 정확한 설명을 하고 있습니다.  하지만 하나의 선지는 IP 헤더의 길이를 제외한 패킷 전체 길이에 대한 설명에서 잘못된 정보를 제공하고 있습니다.  IP 패킷의 전체 길이는 IP 헤더와 데이터 부분을 모두 포함한 크기이며,  최대 크기는 65,535바이트(16비트로 표현)로 제한되어 있습니다.  선지에서 언급된 2³²-1비트는 IP 주소 공간의 크기를 나타내는 값으로, 패킷의 최대 크기와는 전혀 무관합니다. 따라서 패킷 전체 길이에 대한 설명이 잘못된 것입니다.  다른 선지들은 IP 헤더 길이(Header Length),  생존 시간(Time To Live), 버전 번호(Version Number)에 대한 설명이 정확하게 기술되어 있습니다.  따라서 잘못된 설명을 포함한 선지가 정답입니다.  쉽게 말해,  우리가 편지를 부칠 때 봉투 크기(헤더)와 편지 내용(데이터)을 합친 전체 크기가 있듯이,  IP 패킷도 헤더와 데이터 부분을 합친 전체 크기가 정해져 있는데,  그 크기가 선지에서 잘못 기술되어 있기 때문에 그 선지가 틀린 것입니다.",34,45
765,1,8,65,"다음 Python 프로그램의 실행 결과가 [실행결과]와 같을 때, 빈칸에 적합한 것은?",https://www.cbtbank.kr/images/iz/iz20220424/iz20220424m65.gif,either,elif,else if,else,2,"이 문제는 파이썬의 조건문을 이해하고 있는지 묻는 문제입니다.  주어진 파이썬 코드는 조건에 따라 다른 동작을 수행하는데,  `if` 문 다음에 오는 조건문이  `x` 값이 10보다 크거나 같으면 ""10 이상""을 출력하고, 그렇지 않으면 다른 조건을 검사해야 합니다.  여기서  `x` 가 10보다 작으면 ""10 미만""을 출력해야 하는데,  `if` 문 다음에 바로 `else` 문이 오면  `x` 가 10보다 크거나 같은 경우만 처리하고, 10보다 작은 경우는 아무런 동작도 하지 않습니다.  따라서  `if` 문과 `else` 문 사이에 추가적인 조건을 검사할 수 있는  문장이 필요합니다.  문제에서 주어진 실행 결과를 보면  `x` 가 10보다 작을 때 ""10 미만""을 출력해야 하므로,  `if` 문 다음에 추가적인 조건을 검사하는 문장이 필요합니다.  이러한 역할을 하는 것이 바로  `elif` 입니다.  `elif` 는 ""else if""의 줄임말로,  `if` 문의 조건이 거짓일 경우 추가적인 조건을 검사하는 데 사용됩니다.  만약 `elif` 대신 `else if`를 사용하면 문법 오류가 발생합니다.  `else`는  `if` 문의 모든 조건이 거짓일 때 실행되는 문장이므로, 이 문제의 상황에는 적합하지 않습니다.  따라서,  `x` 값에 따라 ""10 이상"" 또는 ""10 미만""을 출력하기 위해서는 `elif`를 사용해야 합니다.  이를 통해 프로그램은  `x` 값이 10 이상인지, 10 미만인지 정확하게 판별하고, 그에 맞는 출력을 할 수 있습니다.",40,41
766,1,8,66,RIP 라우팅 프로토콜에 대한 설명으로 틀린 것은?,,경로 선택 메트릭은 홉 카운트(hop count)이다.,라우팅 프로토콜을 IGP와 EGP로 분류했을 때 EGP에 해당한다.,최단 경로 탐색에 Bellman-Ford 알고리즘을 사용한다.,각 라우터는 이웃 라우터들로부터 수신한 정보를 이용하여 라우팅 표를 갱신한다.,2,"RIP(Routing Information Protocol)는 라우팅 프로토콜의 한 종류로, 네트워크 내에서 라우터들이 서로 정보를 교환하여 최적의 경로를 찾는 데 사용됩니다.  문제에서 틀린 설명을 찾는 것이 목표인데요,  RIP는 각 라우터가 자신의 이웃 라우터들로부터 네트워크 정보를 받아 최단 경로를 계산하는 방식으로 동작합니다.  이때 사용하는 메트릭(경로 선택 기준)은 '홉 카운트(hop count)', 즉 경로 상의 라우터 개수입니다.  최단 경로는 홉 카운트가 가장 적은 경로를 의미하죠.  RIP는 이웃 라우터들로부터 정보를 받아 라우팅 테이블을 갱신하는 것은 맞습니다.  또한, RIP는 Bellman-Ford 알고리즘을 사용하여 최단 경로를 계산하는 것도 사실입니다.  하지만 RIP는 인터넷워크(인터넷)에서 사용되는 외부 게이트웨이 프로토콜(EGP)이 아니라, 하나의 자율 시스템(Autonomous System, AS) 내부에서 사용되는 내부 게이트웨이 프로토콜(IGP)입니다.  따라서, RIP를 EGP로 분류한 설명은 틀린 것입니다.  쉽게 말해, RIP는 같은 회사 내부 네트워크에서 최단 경로를 찾는 데 쓰이는 프로토콜이지, 서로 다른 회사 네트워크를 연결하는 데 쓰이는 프로토콜이 아니라는 뜻입니다.",37,49
767,1,8,67,다음에서 설명하는 프로세스 스케줄링은?,https://www.cbtbank.kr/images/iz/iz20220424/iz20220424m67.gif,FIFO 스케줄링,RR 스케줄링,HRN 스케줄링,MQ 스케줄링,3,"이 문제는 프로세스 스케줄링 알고리즘 중 하나를 묻고 있습니다.  프로세스 스케줄링이란, 여러 개의 프로세스(컴퓨터가 실행하는 작업)가 동시에 실행을 요청할 때, 어떤 프로세스에게 먼저 CPU를 할당할지 결정하는 방법입니다.  각 알고리즘은 고유한 방식으로 프로세스에 CPU를 할당하여 시스템 성능에 영향을 미칩니다.",47,44
768,1,8,68,UNIX 운영체제에 관한 특징으로 틀린 것은?,,하나 이상의 작업에 대하여 백그라운드에서 수행이 가능하다.,Multi-User는 지원하지만 Multi-Tasking은 지원하지 않는다.,트리 구조의 파일 시스템을 갖는다.,이식성이 높으며 장치 간의 호환성이 높다.,2,"UNIX 운영체제의 특징에 대한 문제입니다.  문제에서 틀린 것을 고르라고 했으므로, 각 선지가 UNIX의 실제 특징과 일치하는지 살펴보아야 합니다.  UNIX는 다중 사용자(Multi-User) 환경과 다중 작업(Multi-Tasking) 환경을 모두 지원하는 운영체제로 잘 알려져 있습니다.  여러 사용자가 동시에 시스템을 사용하고, 각 사용자는 여러 개의 프로그램을 동시에 실행할 수 있습니다.  백그라운드에서 작업을 수행하는 기능도 당연히 지원합니다.  또한, UNIX는 계층적인 트리 구조의 파일 시스템을 가지고 있으며, 이식성이 높고 다양한 하드웨어 플랫폼에서 동작하도록 설계되어 장치 간 호환성이 높다는 특징도 가지고 있습니다. 따라서,  UNIX가 Multi-User는 지원하지만 Multi-Tasking은 지원하지 않는다는 내용은 사실과 다릅니다.  UNIX는 두 기능 모두를 강력하게 지원하는 운영체제이기 때문입니다.  다른 선지들은 모두 UNIX의 주요 특징을 정확하게 반영하고 있습니다.",49,44
769,1,8,69,UDP 프로토콜의 특징이 아닌 것은?,,비연결형 서비스를 제공한다.,단순한 헤더 구조로 오버헤드가 적다.,"주로 주소를 지정하고, 경로를 설정하는 기능을 한다.",TCP와 같이 트랜스포트 계층에 존재한다.,3,"UDP 프로토콜은 데이터를 빠르게 전송하는 데 초점을 맞춘 비연결형 프로토콜입니다.  TCP와 달리 연결을 설정하거나 데이터 전송의 신뢰성을 보장하는 과정이 없기 때문에 오버헤드가 적고 속도가 빠릅니다.  따라서, 데이터 전송의 신뢰성이 중요하지 않고 속도가 중요한 애플리케이션(예: 실시간 스트리밍, 온라인 게임)에 주로 사용됩니다.  문제에서 틀린 설명은 주소를 지정하고 경로를 설정하는 기능을 한다는 것입니다.  주소 지정은 UDP도 하지만, 경로 설정은 라우팅 기능으로 네트워크 계층(IP 계층)에서 수행되는 작업이며, UDP는 경로 설정 기능을 담당하지 않습니다.  UDP는 단순히 데이터를 목적지 주소로 전송하는 역할만 수행합니다.  TCP와 마찬가지로 트랜스포트 계층에 존재하는 것은 맞는 설명입니다.",37,45
770,1,8,70,Python 데이터 타입 중 시퀀스(Sequence) 데이터 타입에 해당하며 다양한 데이터 타입들을 주어진 순서에 따라 저장할 수 있으나 저장된 내용을 변경할 수 없는 것은?,,복소수(complex) 타입,리스트(list) 타입,사전(dict) 타입,튜플(tuple) 타입,4,"Python에서 시퀀스(Sequence) 자료형은 데이터를 순서대로 나열하여 저장하는 자료형입니다.  리스트와 튜플은 모두 시퀀스 자료형에 속하지만, 중요한 차이점이 있습니다. 리스트는 저장된 내용을 변경할 수 있는 가변(mutable) 자료형인 반면, 튜플은 저장된 내용을 변경할 수 없는 불변(immutable) 자료형입니다.  즉, 튜플은 한번 생성된 후에는 그 안의 데이터를 추가하거나 삭제, 수정할 수 없습니다. 문제에서 ""저장된 내용을 변경할 수 없는 것""을 묻고 있으므로, 정답은 튜플입니다.  마치 한번 적은 종이에 적힌 내용을 지우거나 수정할 수 없는 것과 같다고 생각하면 이해하기 쉬울 것입니다.  다른 선택지들은 데이터를 변경할 수 있기 때문에 정답이 될 수 없습니다.",35,11
771,1,8,71,"다음 JAVA 프로그램이 실행되었을 때, 실행결과는?",https://www.cbtbank.kr/images/iz/iz20220424/iz20220424m71.gif,1 2 3 4,0 1 2 3,1 2 3,0 1 2,2,"이 JAVA 프로그램은 `for` 문을 이용하여 변수 `i`의 값을 0부터 3까지 증가시키면서 `System.out.print(i);`를 통해 `i`의 값을 출력합니다.  `System.out.print()`는 출력 후 줄바꿈을 하지 않고 다음 출력을 이어서 하기 때문에,  `i`의 값이 순차적으로 출력됩니다.  `for` 문은 `i`가 0일 때부터 시작하여 `i`가 3일 때까지 반복되므로,  결과적으로 0, 1, 2, 3이 순서대로 출력되는 것을 확인할 수 있습니다. 따라서 정답은 0 1 2 3을 출력하는 것입니다.  비전공자를 위해 쉽게 설명하자면,  컴퓨터가 0부터 시작해서 3까지 숫자를 하나씩 차례대로 화면에 보여주는 프로그램입니다.  줄바꿈 없이 숫자를 나열하므로 숫자들이 붙어서 출력됩니다.",55,41
772,1,8,72,다음 JAVA 프로그램이 실행되었을 때의 결과는?,https://www.cbtbank.kr/images/iz/iz20220424/iz20220424m72.gif,1,2,3,4,3,"이 문제는 Java의 기본적인 연산자 우선순위와 자료형 변환에 대한 이해를 묻는 문제입니다.  Java에서 연산은 일반적인 수학 연산과 마찬가지로 우선순위를 가지는데, 곱셈과 나눗셈이 덧셈과 뺄셈보다 우선적으로 계산됩니다.  문제의 식을 살펴보면 `1 + 2 * 3` 이라는 식이 있습니다.  곱셈이 덧셈보다 우선순위가 높으므로, 먼저 2와 3을 곱하여 6을 얻고, 그 결과에 1을 더하여 최종적으로 7이 됩니다.  하지만 문제에서 제시된 답변에는 7이 없고, 1부터 4까지의 정수만 제시되어 있습니다.  이는 문제 자체에 오류가 있거나, 문제의 의도가 다른 곳에 있는 것으로 추측됩니다.  제공된 정보만으로는 정확한 해석이 어렵습니다.  만약 문제의 식이 `(1 + 2) * 3` 이었다면 괄호 연산이 우선 적용되어 9가 되고,  `1 + (2 * 3)` 이었다면 7이 되는 등, 연산자 우선순위에 따라 결과가 달라집니다.  따라서 문제의 식 자체가 명확하지 않아 정답을 특정하기 어렵습니다.  정답으로 제시된 3이라는 숫자가 어떤 과정을 통해 도출되었는지 추가적인 정보가 필요합니다.  문제에 오류가 있을 가능성이 높습니다.",47,41
773,1,8,73,다음 중 Myers가 구분한 응집도(Cohesion)의 정도에서 가장 낮은 응집도를 갖는 단계는?,,순차적 응집도(Sequential Cohesion),기능적 응집도(Functional Cohesion),시간적 응집도(Temporal Cohesion),우연적 응집도(Coincidental Cohesion),4,"소프트웨어 모듈의 응집도는 모듈 내부 요소들의 관련성을 나타내는 척도입니다.  응집도가 높다는 것은 모듈 내부 요소들이 서로 밀접하게 관련되어 하나의 기능을 수행한다는 것을 의미하며, 반대로 응집도가 낮다는 것은 모듈 내부 요소들이 서로 관련성이 적거나 아예 무관하다는 것을 의미합니다.  Myers가 제시한 응집도의 종류 중에서 가장 낮은 응집도를 가진 것은  모듈 내부 요소들이 아무런 관련성 없이 우연히 모여 있는 경우입니다.  마치 서로 다른 종류의 과일을 한 바구니에 담아놓은 것과 같다고 생각하면 이해하기 쉽습니다.  다른 응집도 유형들은 어느 정도의 관련성을 가지고 있지만,  이 유형은  모듈 내부 요소들이 서로 전혀 연관이 없어 유지보수 및 재사용성이 매우 떨어지고,  오류 발생 시 문제 해결이 어려워지기 때문에  가장 낮은 응집도로 분류됩니다. 따라서,  모듈 내 요소들의 관련성이 전혀 없이 우연히 모여있는 경우가 가장 낮은 응집도를 갖는 단계입니다.",56,6
774,1,8,74,"다음 C언어 프로그램이 실행되었을 때, 실행 결과는?",https://www.cbtbank.kr/images/iz/iz20220424/iz20220424m74.gif,0,1,2,3,2,"이 C언어 코드는 변수 `x`를 0으로 초기화하고, 조건문 `if (x == 0)`을 통해 `x`의 값이 0인지 확인합니다.  `x`의 값이 0이므로 조건문 내부의 코드 `x = 1;`이 실행되어 `x`의 값은 1로 변경됩니다.  그 후 `printf(""%d\n"", x);`를 통해 `x`의 값(1)이 출력됩니다. 따라서 프로그램의 실행 결과는 1입니다.  조건문은 특정 조건이 참일 때만 코드 블록을 실행하는 제어문으로, 프로그램의 흐름을 제어하는 데 중요한 역할을 합니다. 이 문제는 C언어의 기본적인 문법, 특히 변수 선언, 초기화, 조건문의 사용 및 실행 흐름을 이해하고 있는지를 묻는 문제입니다.  비전공자라도 변수에 값을 저장하고, 조건에 따라 다른 동작을 하는 프로그램의 기본 원리를 이해할 수 있다면 쉽게 풀 수 있는 문제입니다.",38,41
775,1,8,75,IP 프로토콜의 주요 특징에 해당하지 않는 것은?,,체크섬(Checksum) 기능으로 데이터 체크섬(Data Checksum)만 제공한다.,"패킷을 분할, 병합하는 기능을 수행하기도 한다.",비연결형 서비스를 제공한다.,Best Effort 원칙에 따른 전송 기능을 제공한다.,1,"IP 프로토콜은 네트워크에서 데이터를 전송하는 데 사용되는 기본적인 프로토콜입니다.  문제에서 틀린 설명을 찾는 것이므로, 각 선택지가 IP 프로토콜의 특징과 일치하는지 살펴보겠습니다.  데이터의 무결성을 확인하기 위해 체크섬 기능을 사용하는 것은 맞지만, IP 프로토콜은 단순히 데이터의 오류를 검출하는 기능만 제공하며, 데이터의 오류를 수정하는 기능은 제공하지 않습니다.  즉, 데이터의 오류 검출만 하고 수정은 하지 않는다는 점이 중요합니다.  패킷을 분할하고 병합하는 기능은 IP 프로토콜의 중요한 기능 중 하나입니다.  데이터가 너무 크면 여러 개의 작은 패킷으로 나누어 전송하고, 목적지에서 다시 하나로 합치는 작업을 수행합니다.  IP 프로토콜은 비연결형(Connectionless) 서비스를 제공합니다.  이는 데이터를 전송하기 전에 연결을 설정할 필요가 없다는 것을 의미합니다.  데이터 패킷을 목적지로 보내는 것만 책임지고, 전송 성공 여부를 보장하지 않습니다.  마지막으로, IP 프로토콜은 Best Effort 원칙에 따라 작동합니다.  이는 최선을 다해 데이터를 전송하지만, 전송 성공을 보장하지 않는다는 것을 의미합니다.  패킷 손실이나 순서 변경이 발생할 수 있으며, 이러한 문제는 상위 계층 프로토콜(예: TCP)에서 처리해야 합니다. 따라서,  IP 프로토콜이 데이터 체크섬만 제공하고 오류 수정 기능을 제공하지 않는다는 설명이 틀린 것입니다.  IP 프로토콜은 오류 검출은 하지만, 오류 수정은 하지 않습니다.  오류 수정은 TCP와 같은 다른 프로토콜의 역할입니다.",32,45
776,1,8,76,"4개의 페이지를 수용할 수 있는 주기억장치가 있으며, 초기에는 모두 비어 있다고 가정한다. 다음의 순서로 페이지 참조가 발생할 때, LRU 페이지 교체 알고리즘을 사용할 경우 몇 번의 페이지 결함이 발생하는가?",https://www.cbtbank.kr/images/iz/iz20220424/iz20220424m76.gif,5회,6회,7회,8회,1,"이 문제는 주기억장치의 페이지 교체 알고리즘 중 하나인 LRU(Least Recently Used) 알고리즘을 이해하고 있는지를 묻는 문제입니다.  LRU 알고리즘은 가장 오랫동안 사용되지 않은 페이지를 교체하는 방식입니다.  문제에서 4개의 페이지를 수용하는 주기억장치가 있고, 초기에는 모두 비어있다고 했으므로, 처음 네 번의 페이지 참조는 모두 페이지 결함(페이지가 메모리에 없어서 디스크에서 읽어와야 하는 상황)이 발생합니다.  그 이후 페이지 참조가 발생할 때마다,  가장 오랫동안 사용되지 않은 페이지를 찾아서 새로운 페이지로 교체하게 됩니다.  문제에서 제시된 페이지 참조 순서를 따라 LRU 알고리즘을 적용해보면,  몇 번의 페이지 교체가 발생하는지 확인할 수 있습니다.  각 페이지 참조 시점에 메모리에 있는 페이지들을 기록하고,  새로운 페이지가 들어올 때 어떤 페이지가 교체되는지 추적하면 정답을 구할 수 있습니다.  페이지가 이미 메모리에 있다면 페이지 결함이 발생하지 않습니다.  이 과정을 차근차근 따라가면,  결국 총 페이지 결함의 횟수를 정확하게 계산할 수 있습니다.  비전공자라도 페이지 참조 순서대로 메모리에 어떤 페이지가 있는지 차례대로 적어가며 따라 하면 쉽게 이해할 수 있을 것입니다.",41,11
777,1,8,77,사용자 수준에서 지원되는 스레드(thread)가 커널에서 지원되는 스레드에 비해 가지는 장점으로 옳은 것은?,,한 프로세스가 운영체제를 호출할 때 전체 프로세스가 대기할 필요가 없으므로 시스템 성능을 높일 수 있다.,동시에 여러 스레드가 커널에 접근할 수 있으므로 여러 스레드가 시스템 호출을 동시에 사용할 수 있다.,각 스레드를 개별적으로 관리할 수 있으므로 스레드의 독립적인 스케줄링이 가능하다.,커널 모드로의 전환 없이 스레드 교환이 가능하므로 오버헤드가 줄어든다.,4,"사용자 수준 스레드(thread)와 커널 수준 스레드의 차이점을 이해하는 것이 중요합니다.  커널 수준 스레드는 운영체제 커널에 의해 직접 관리되지만, 사용자 수준 스레드는 사용자 공간에서 라이브러리에 의해 관리됩니다.  문제에서 묻는 것은 사용자 수준 스레드의 장점입니다.  사용자 수준 스레드는 스레드 간의 전환(context switching)이 커널의 개입 없이 사용자 공간에서 이루어집니다.  커널 모드로 전환하는 과정(커널 호출)은 상당한 오버헤드를 발생시키는데, 사용자 수준 스레드는 이러한 오버헤드를 줄일 수 있습니다.  즉, 스레드 간 전환 속도가 빨라져 시스템의 전반적인 성능 향상에 기여합니다.  다른 선택지는 커널 수준 스레드의 특징이나, 사용자 수준 스레드의 단점을 기술하고 있거나, 사실과 다릅니다. 따라서 사용자 수준 스레드의 가장 큰 장점은 커널 모드로의 전환 없이 스레드 교환이 가능하다는 점이며, 이로 인해 오버헤드가 감소한다는 것입니다.",27,44
778,1,8,78,한 모듈이 다른 모듈의 내부 기능 및 그 내부 자료를 참조하는 경우의 결합도는?,,내용 결합도(Content Coupling),제어 결합도(Control Coupling),공통 결합도(Common Coupling),스탬프 결합도(Stamp Coupling),1,"한 모듈이 다른 모듈의 내부 기능과 내부 자료까지 직접적으로 참조하는 경우를 생각해 봅시다.  이는 마치 다른 모듈의 '속'을 들여다보고 그 안의 내용을 마음대로 사용하는 것과 같습니다. 이렇게 되면 모듈 간의 의존성이 매우 높아져서, 한 모듈의 변경이 다른 모듈에 예상치 못한 영향을 미칠 수 있습니다.  소프트웨어 유지보수가 어려워지고, 오류 발생 가능성도 높아집니다.  이처럼 다른 모듈의 내부 데이터와 기능에 직접 접근하는 결합 방식을 '내용 결합도'라고 합니다.  내용 결합도는 결합도 중에서 가장 강한 결합으로,  소프트웨어 설계 시 피해야 할 결합 방식입니다.  다른 결합도들은 내부 자료나 기능에 직접 접근하지 않고, 특정 인터페이스나 제한된 정보만을 통해 상호 작용하는 방식이기 때문에 내용 결합도보다 결합도가 낮습니다. 따라서 한 모듈이 다른 모듈의 내부 기능 및 내부 자료를 참조하는 경우는 내용 결합도에 해당합니다.",47,6
779,1,8,79,"a[0]의 주소값이 10일 경우 다음 C언어 프로그램이 실행되었을 때의 결과는? (단, int 형의 크기는 4Byte로 가정한다.)",https://www.cbtbank.kr/images/iz/iz20220424/iz20220424m79.gif,"14, 10","14, 14","18, 10","18, 14",3,"이 문제는 C언어에서 배열의 메모리 주소와 크기를 이해하고 있는지를 묻는 문제입니다.  `int`형 변수는 4바이트(Byte)의 크기를 가지므로, 배열 `a`의 각 원소는 4바이트의 공간을 차지합니다.  `a[0]`의 주소가 10이라고 주어졌습니다.  그렇다면 `a[1]`의 주소는 `a[0]`의 주소에 `int`형 크기(4바이트)를 더한 값이 됩니다. 따라서 `a[1]`의 주소는 10 + 4 = 14가 됩니다.  프로그램에서 `printf` 함수를 통해 `&a[1]` (a[1]의 주소)과 `a + 1` (a[0]의 주소 + int형 크기, 즉 a[1]의 주소)의 값을 출력하는데,  둘 다 `a[1]`의 주소값인 14를 출력합니다.  그리고 `a[0]`의 값은 10으로 주어졌으므로, `a[0]`의 값 자체는 10입니다.  결론적으로, `a[1]`의 주소와 `a[0]`의 값을 출력하는 것이므로, 정답은 `a[1]`의 주소 14와 `a[0]`의 값 10이 됩니다.",35,11
780,1,8,80,모듈화(Modularity)와 관련한 설명으로 틀린 것은?,,시스템을 모듈로 분할하면 각각의 모듈을 별개로 만들고 수정할 수 있기 때문에 좋은 구조가 된다.,응집도는 모듈과 모듈 사이의 상호의존 또는 연관 정도를 의미한다.,모듈 간의 결합도가 약해야 독립적인 모듈이 될 수 있다.,모듈 내 구성 요소들 간의 응집도가 강해야 좋은 모듈 설계이다.,2,"이 문제는 소프트웨어 모듈화의 핵심 개념인 응집도와 결합도를 얼마나 잘 이해하고 있는지 묻는 문제입니다.  소프트웨어 시스템을 여러 개의 작은 모듈로 나누는 모듈화는 시스템을 이해하고 관리하기 쉽게 만들어주는 중요한 설계 원칙입니다.  각 모듈은 특정 기능을 담당하며,  모듈 간의 관계(결합도)가 약하고, 모듈 내부 요소 간의 관계(응집도)가 강할수록 좋은 설계라고 할 수 있습니다.  마치 레고 블록처럼, 각 블록(모듈)은 독립적으로 만들고 조립할 수 있지만,  블록끼리 잘 맞물려(강한 응집도) 전체 구조를 이루어야 합니다.  만약 블록들이 서로 엉켜있거나(강한 결합도),  각 블록이 제 기능을 제대로 못한다면(약한 응집도)  멋진 레고 작품을 만들 수 없겠죠?  틀린 설명은 모듈과 모듈 사이의 관계를 설명하는 용어인 '응집도'의 정의를 잘못 이해한 것입니다. 응집도는 모듈 *내부* 요소 간의 연관성을 나타내는 용어이며, 모듈 *사이*의 관계는 '결합도'로 설명합니다.  따라서, 모듈 간의 관계를 응집도라고 설명한 것은 잘못된 것입니다.",36,6
781,1,8,81,소프트웨어 개발에서 정보보안 3요소에 해당 하지 않는 설명은?,,기밀성 : 인가된 사용자에 대해서만 자원 접근이 가능하다.,무결성 : 인가된 사용자에 대해서만 자원 수정이 가능하며 전송중인 정보는 수정되지 않는다.,가용성 : 인가된 사용자는 가지고 있는 권한 범위 내에서 언제든 자원 접근이 가능하다.,휘발성 : 인가된 사용자가 수행한 데이터는 처리 완료 즉시 폐기 되어야 한다.,4,"소프트웨어 개발에서 정보보안은 데이터의 기밀성, 무결성, 가용성을 보장하는 것을 목표로 합니다.  기밀성은 허가받지 않은 접근을 막아 중요한 정보를 보호하는 것이고, 무결성은 데이터의 정확성과 신뢰성을 유지하는 것을 의미하며, 가용성은 필요한 사람이 언제든지 데이터에 접근할 수 있도록 하는 것을 의미합니다.  문제에서 제시된 잘못된 설명은 데이터 처리 후 즉시 폐기되어야 한다는 내용입니다.  이는 데이터의 '휘발성'에 대한 설명인데, 정보보안의 핵심 요소는 아니며,  오히려 특정 상황(예: 일회용 비밀번호)에서 필요한 보안 조치일 수는 있지만, 모든 데이터에 적용될 필요는 없습니다.  정보보안의 3요소는 데이터의 안전성과 신뢰성을 확보하는 데 중점을 두고 있기 때문에, 데이터의 처리 방식(즉시 폐기 여부)은 정보보안의 핵심 요소라고 보기 어렵습니다. 따라서 정보보안 3요소에 해당하지 않는 설명은 데이터의 즉시 폐기 여부에 대한 설명입니다.",49,53
782,1,8,82,"어떤 외부 컴퓨터가 접속되면 접속 인가 여부를 점검해서 인가된 경우에는 접속이 허용되고, 그 반대의 경우에는 거부할 수 있는 접근제어 유틸리티는?",,tcp wrapper,trace checker,token finder,change detector,1,"이 문제는 외부 컴퓨터의 접근을 제어하는 유틸리티를 묻고 있습니다.  외부 컴퓨터가 접속을 시도하면,  접근이 허용될지 거부될지를 결정하는 기능이 핵심입니다.  정답인 유틸리티는  TCP/IP 네트워크를 통해 접속하는 컴퓨터의 접근을 제어하는 역할을 합니다.  마치 문지기처럼,  접속을 요청하는 컴퓨터의 정보를 확인하고, 미리 설정된 규칙에 따라 접근을 허용하거나 거부합니다.  예를 들어, 특정 IP 주소에서만 접속을 허용하거나, 특정 사용자만 접속을 허용하는 등의 규칙을 설정할 수 있습니다. 다른 선택지는 네트워크 분석이나 보안과 관련된 용어이지만,  외부 접속에 대한 인가 여부를 직접적으로 제어하는 기능을 제공하지는 않습니다. 따라서, 외부 컴퓨터의 접속을 인가하고 제어하는 기능을 가진 유틸리티가 정답입니다.  쉽게 말해,  컴퓨터의 출입문을 관리하는 경비원과 같은 역할을 하는 것이라고 생각하면 이해하기 쉬울 것입니다.",30,31
783,1,8,83,기기를 키오스크에 갖다 대면 원하는 데이터를 바로 가져올 수 있는 기술로 10㎝ 이내 근접 거리에서 기가급 속도로 데이터 전송이 가능한 초고속 근접무선통신(NFC : Near Field Communication) 기술은?,,BcN(Broadband Convergence Network),Zing,Marine Navi,C-V2X(Cellular Vehicle To Everything),2,"문제에서 설명하는 기술은 기기를 키오스크에 갖다 대는 것만으로 데이터를 주고받을 수 있는, 매우 가까운 거리에서 작동하는 초고속 통신 기술입니다.  10cm 이내의 근접 거리에서 기가급 속도로 데이터를 전송한다는 점이 중요한 특징입니다.  선택지들을 살펴보면,  'Zing'이라는 기술이 바로 이러한 근접무선통신 기술을 의미합니다.  Zing은 NFC(Near Field Communication) 기술을 기반으로 하여,  스마트폰이나 카드 등의 기기를 키오스크와 가까이 가져다 대면 빠르게 데이터를 교환할 수 있도록 설계된 기술입니다. 다른 선택지는 광대역 융합 네트워크, 해상 내비게이션 시스템, 차량-사물 통신 기술 등으로, 문제에서 제시된 근접 무선 통신 기술과는 직접적인 관련이 없습니다. 따라서 'Zing'이 정답입니다.  NFC 기술은 우리 주변에서 교통카드나 간편결제 등에 널리 사용되고 있는 친숙한 기술이기도 합니다.",28,49
784,1,8,84,취약점 관리를 위한 응용 프로그램의 보안 설정과 가장 거리가 먼 것은?,,서버 관리실 출입 통제,실행 프로세스 권한 설정,운영체제의 접근 제한,운영체제의 정보 수집 제한,1,"이 문제는 응용 프로그램의 보안 설정과 관련된 내용을 묻고 있습니다.  응용 프로그램 자체의 보안을 강화하기 위해서는 프로그램 내부의 실행 권한 설정, 운영체제 차원의 접근 제어, 민감한 정보에 대한 접근 제한 등을 설정해야 합니다.  하지만 서버 관리실 출입 통제는 물리적인 보안에 해당하는 내용으로, 응용 프로그램 자체의 보안 설정과는 직접적인 관련이 없습니다.  응용 프로그램의 보안은 소프트웨어적인 접근으로 이루어져야 하며,  물리적인 접근 통제는 서버 전체의 보안을 위한 부수적인 조치일 뿐, 응용 프로그램의 보안 설정 자체는 아닙니다. 따라서 서버 관리실 출입 통제는 응용 프로그램의 보안 설정과 가장 거리가 먼 선택지입니다.  다른 선택지들은 모두 소프트웨어적인 보안 설정에 직접적으로 영향을 미치는 요소들입니다.",47,53
785,1,8,85,소프트웨어 개발 프레임워크와 관련한 설명으로 가장 적절하지 않은 것은?,,반제품 상태의 제품을 토대로 도메인별로 필요한 서비스 컴포넌트를 사용하여 재사용성 확대와 성능을 보장 받을 수 있게 하는 개발 소프트웨어이다.,"라이브러리와는 달리 사용자 코드에서 프레임워크를 호출해서 사용하고, 그에 대한 제어도 사용자 코드가 가지는 방식이다.",설계 관점에 개발 방식을 패턴화시키기 위한 노력의 결과물인 소프트웨어 디자인 패턴을 반제품 소프트웨어 상태로 집적화시킨 것으로 볼 수 있다.,프레임워크의 동작 원리를 그 제어 흐름의 일반적인 프로그램 흐름과 반대로 동작한다고 해서 IoC(Inversion of Control)이라고 설명하기도 한다.,2,"소프트웨어 개발 프레임워크는 건물의 골조와 같습니다.  건물을 지을 때 벽돌이나 기둥을 하나하나 쌓는 것이 아니라, 미리 만들어진 골조에 벽돌과 기둥을 채워 넣듯이, 프레임워크는 미리 만들어진 뼈대를 제공하여 개발자가 그 위에 기능을 추가하는 방식으로 소프트웨어를 개발하게 합니다.  틀린 설명은 프레임워크의 제어 흐름이 사용자 코드에 의해 결정된다는 것입니다.  프레임워크는 사용자 코드를 *호출하는* 쪽이지, 사용자 코드가 프레임워크를 호출하는 것이 아닙니다.  즉, 프로그램의 전체적인 흐름(제어)은 프레임워크가 가지고 있으며, 사용자 코드는 프레임워크가 제공하는 틀 안에서 동작하게 됩니다.  이러한 제어의 역전(Inversion of Control, IoC)이 프레임워크의 핵심적인 특징 중 하나입니다.  마치 건물의 골조가 건물의 구조와 흐름을 결정하듯이, 프레임워크가 소프트웨어의 전체적인 흐름을 제어하고, 사용자 코드는 그 흐름에 맞춰 기능을 구현하는 역할을 합니다.  따라서 사용자 코드가 프레임워크를 제어하는 것이 아니라, 프레임워크가 사용자 코드를 제어하는 것이 정확한 설명입니다.  다른 선지는 프레임워크의 재사용성, 디자인 패턴과의 관계, IoC 개념을 잘 설명하고 있습니다.",30,48
786,1,8,86,클라우드 기반 HSM(Cloud-based Hardware Security Module)에 대한 설명으로 틀린 것은?,,"클라우드(데이터센터) 기반 암호화 키 생성, 처리, 저장 등을 하는 보안 기기이다.",국내에서는 공인인증제의 폐지와 전자서명법 개정을 추진하면서 클라우드 HSM 용어가 자주 등장하였다.,클라우드에 인증서를 저장하므로 기존 HSM 기기나 휴대폰에 인증서를 저장해 다닐 필요가 없다.,하드웨어가 아닌 소프트웨어적으로만 구현되기 때문에 소프트웨어식 암호 기술에 내재된 보안 취약점을 해결할 수 없다는 것이 주요 단점이다.,4,"이 문제는 클라우드 기반 HSM의 특징을 묻고 있습니다. HSM(Hardware Security Module)은 암호화 키를 안전하게 생성, 저장, 관리하는 하드웨어 장치입니다.  클라우드 기반 HSM은 이러한 기능을 클라우드 환경에서 제공하는 것이죠.  문제에서 틀린 설명은 하드웨어 기반이 아닌 소프트웨어 기반으로만 구현된다는 내용입니다.  HSM의 핵심은 바로 '하드웨어' 기반의 보안성에 있습니다.  소프트웨어만으로 구현된다면, 해킹이나 악성코드 공격에 취약해져  키 관리의 안전성을 보장할 수 없게 됩니다.  클라우드 기반 HSM은 클라우드 환경에서 제공되지만,  그 안에는 여전히 물리적인 보안 장치(하드웨어)가 존재하여  키를 안전하게 보호하는 역할을 수행합니다. 따라서 소프트웨어적으로만 구현된다는 주장은 사실과 다릅니다.  다른 선택지는 모두 클라우드 기반 HSM의 특징을 잘 설명하고 있습니다.  공인인증서 폐지와 전자서명법 개정으로 클라우드 기반 HSM의 중요성이 커졌고, 클라우드에 인증서를 저장함으로써 휴대성이 향상되는 등의 장점을 가지고 있습니다.",45,51
787,1,8,87,다음 내용이 설명하는 기술로 가장 적절한 것은?,https://www.cbtbank.kr/images/iz/iz20220424/iz20220424m87.gif,Virtual Local Area Network,Simple Station Network,Mesh Network,Modem Network,3,"문제에서 설명하는 기술은 여러 장비들이 서로 연결되어 네트워크를 구성하고, 각 장비가 다른 장비들과 직접 통신하는 방식입니다.  마치 거미줄처럼 여러 경로를 통해 데이터가 전달되는 것이죠.  이러한 네트워크 구조는 특정 장비가 고장 나더라도 다른 경로를 통해 데이터 전송이 가능하다는 장점이 있습니다.  데이터 전송의 안정성과 효율성을 높이기 위해 여러 경로를 사용하는 이 기술은 바로 메시 네트워크입니다.  반면, 다른 선택지들은 이러한 특징을 가지고 있지 않습니다. 가상 LAN은 논리적으로 네트워크를 분할하는 기술이고, 단순한 스테이션 네트워크는 중앙 장비를 중심으로 연결되는 구조이며, 모뎀 네트워크는 모뎀을 이용한 연결 방식을 의미합니다. 따라서 문제에서 설명하는 기술의 특징과 가장 잘 부합하는 것은 메시 네트워크입니다. 정보처리기사 공식 교재의 네트워크 부분을 참고하면 메시 네트워크의 정의와 특징에 대한 자세한 설명을 확인할 수 있습니다.",48,49
788,1,8,88,물리적 위협으로 인한 문제에 해당하지 않는 것은?,,"화재, 홍수 등 천재지변으로 인한 위협","하드웨어 파손, 고장으로 인한 장애","방화, 테러로 인한 하드웨어와 기록장치를 물리적으로 파괴하는 행위","방화벽 설정의 잘못된 조작으로 인한 네트워크, 서버 보안 위협",4,"이 문제는 시스템의 물리적인 위협에 대한 이해도를 묻고 있습니다.  화재나 홍수와 같은 자연재해, 하드웨어의 고장이나 파손, 그리고 고의적인 방화나 테러 행위는 모두 시스템에 물리적인 손상을 입히는 위협입니다.  하지만 방화벽 설정의 잘못된 조작은 시스템의 물리적인 부분에 직접적인 손상을 주는 것이 아니라, 시스템의 소프트웨어적인 보안 설정에 문제가 생긴 것입니다.  즉, 물리적인 위협이 아닌 논리적인, 혹은 관리적인 위협이라고 할 수 있습니다.  방화벽은 소프트웨어 또는 하드웨어일 수 있지만, 설정 오류 자체는 물리적인 손상이 아니고, 네트워크나 서버에 대한 접근을 제어하는 논리적인 장벽의 실패를 의미하기 때문입니다. 따라서 물리적 위협으로 인한 문제가 아닌 것은 방화벽 설정의 잘못된 조작입니다.  마치 잘못된 비밀번호를 설정해서 문이 열리는 것과 같은 이치입니다. 문 자체가 부서진 것이 아니라, 문을 여는 방법(보안 설정)에 문제가 있는 것입니다.",57,55
789,1,8,89,악성코드의 유형 중 다른 컴퓨터의 취약점을 이용하여 스스로 전파하거나 메일로 전파되며 스스로를 증식하는 것은?,,Worm,Rogue Ware,Adware,Reflection Attack,1,"문제에서 설명하는 악성코드는 다른 컴퓨터의 취약점을 이용하여 스스로 전파되고, 이메일을 통해서도 퍼져나가며,  자기 자신을 복제하여 증식하는 특징을 가지고 있습니다.  이는 컴퓨터 바이러스와 비슷하지만, 바이러스처럼 특정 프로그램에 붙어서 전파되는 것이 아니라, 독자적으로 네트워크를 통해 퍼져나가는 점이 다릅니다. 마치 전염병처럼 네트워크를 통해 빠르게 확산되는 특징 때문에 시스템에 큰 피해를 입힐 수 있습니다.  이러한 특징을 가장 잘 나타내는 악성코드의 유형이 바로 웜(Worm)입니다.  다른 선택지들은 각각 다른 유형의 악성코드를 나타내는데,  로그는 사용자에게 알리지 않고 시스템을 변경하는 악성코드, 애드웨어는 광고를 표시하는 프로그램, 리플렉션 공격은 네트워크 공격 기법을 의미합니다. 따라서 문제에서 제시된 악성코드의 특징과 가장 부합하는 것은 웜(Worm)입니다.",52,56
790,1,8,90,다음 설명에 해 당하는 공격기법은?,https://www.cbtbank.kr/images/iz/iz20220424/iz20220424m90.gif,Ping of Death,Session Hijacking,Piggyback Attack,XSS,1,"문제에서 설명하는 공격 기법은 매우 큰 크기의 ICMP 패킷을 목표 시스템에 전송하여 시스템을 다운시키는 방법입니다.  ICMP는 인터넷에서 시스템의 연결 상태를 확인하는 데 사용되는 프로토콜인데, 이 프로토콜을 악용하여 과도하게 큰 패킷을 보내면 시스템의 버퍼 오버플로우를 일으켜 시스템이 응답하지 않거나 충돌하게 됩니다. 이러한 공격은  ""Ping of Death"" 라고 불리며,  시스템의 안정성을 심각하게 위협하는 매우 위험한 공격 기법입니다.  다른 선택지들은 각각 세션 하이재킹(Session Hijacking), 무임승차 공격(Piggyback Attack),  크로스 사이트 스크립팅(XSS) 공격을 의미하는데, 이들은 모두 다른 종류의 네트워크 공격이므로 문제 상황과는 일치하지 않습니다.  Ping of Death는  ICMP 프로토콜의 취약점을 이용한 대표적인 네트워크 공격이기 때문에 정답입니다.",48,55
791,1,8,91,다음 설명에 해당하는 소프트웨어는?,https://www.cbtbank.kr/images/iz/iz20220424/iz20220424m91.gif,전역 함수 라이브러리,소프트웨어 개발 프레임워크,컨테이너 아키텍처,어휘 분석기,2,"문제에서 설명하는 소프트웨어는 여러 기능들을 통합적으로 제공하여 개발자가 애플리케이션을 보다 효율적으로 개발할 수 있도록 돕는 것을 의미합니다.  전역 함수 라이브러리는 특정 기능을 수행하는 함수들의 집합이지만, 애플리케이션 전체 구조나 개발 과정을 지원하는 것은 아닙니다. 컨테이너 아키텍처는 애플리케이션 배포 및 실행 환경에 대한 개념이고, 어휘 분석기는 프로그래밍 언어의 문법을 분석하는 도구입니다.  반면에,  소프트웨어 개발 프레임워크는 애플리케이션 개발에 필요한 기본적인 구조, 라이브러리, 도구 등을 제공하여 개발 과정을 체계화하고 생산성을 높여줍니다.  문제에서 설명하는 소프트웨어의 특징은 개발 과정 전반을 지원하는 것이므로, 소프트웨어 개발 프레임워크가 가장 적절한 설명이 됩니다.  마치 레고 블록처럼, 프레임워크는 미리 만들어진 기본 블록들을 제공하여 개발자가 원하는 애플리케이션을 쉽고 빠르게 조립할 수 있도록 돕는 역할을 합니다.  따라서,  여러 기능들을 통합적으로 제공하여 개발 과정을 효율적으로 지원하는 소프트웨어는 소프트웨어 개발 프레임워크라고 할 수 있습니다.",50,6
792,1,8,92,소프트웨어 개발 방법론 중 애자일(Agile) 방법론의 특징과 가장 거리가 먼 것은?,,각 단계의 결과가 완전히 확인된 후 다음 단계 진행,소프트웨어 개발에 참여하는 구성원들 간의 의사소통 중시,환경 변화에 대한 즉시 대응,프로젝트 상황에 따른 주기적 조정,1,"애자일(Agile) 방법론은 소프트웨어 개발의 유연성과 적응력을 강조하는 방법론입니다.  변화하는 요구사항에 빠르게 대처하고, 개발 과정을 반복적으로 수행하며 지속적인 피드백을 통해 개선해 나가는 것이 핵심입니다.  따라서 각 단계의 결과를 완벽하게 검증한 후에 다음 단계로 넘어가는 것은 애자일의 유연하고 반복적인 특성과는 상반됩니다. 애자일은 오히려 빠른 개발 주기를 통해 변화에 대응하고,  개발 과정 중간에도 요구사항 변경을 수용하며,  팀원 간의 긴밀한 소통을 통해 효율성을 높이는 것을 목표로 합니다.  문제에서 제시된 다른 특징들(팀원 간의 소통 중시, 환경 변화에 대한 즉시 대응, 주기적 조정)은 모두 애자일 방법론의 핵심적인 특징들입니다.  따라서 각 단계의 결과를 완전히 확인한 후 다음 단계로 진행하는 방식은 애자일 방법론의 특징과 가장 거리가 멉니다.  이는 전통적인 폭포수(Waterfall) 모델과 같은 방식에 가깝습니다.",55,2
793,1,8,93,대칭 암호 알고리즘과 비대칭 암호 알고리즘에 대한 설명으로 틀린 것은?,,대칭 암호 알고리즘은 비교적 실행 속도가 빠르기 때문에 다양한 암호의 핵심 함수로 사용될 수 있다.,대칭 암호 알고리즘은 비밀키 전달을 위한 키 교환이 필요하지 않아 암호화 및 복호화의 속도가 빠르다.,"비대칭 암호 알고리즘은 자신만이 보관하는 비밀키를 이용하여 인증, 전자서명 등에 적용이 가능하다.","대표적인 대칭키 암호 알고리즘으로는 AES, IDEA 등이 있다.",2,"이 문제는 대칭 암호 알고리즘과 비대칭 암호 알고리즘의 특징을 이해하고 있는지 묻는 문제입니다.  먼저 대칭 암호 알고리즘은 암호화와 복호화에 같은 키를 사용하는 방식입니다.  마치 같은 자물쇠와 열쇠를 사용하는 것과 같아서, 키를 안전하게 공유하는 것이 중요합니다.  따라서 키 교환 과정이 필요하며, 이 과정에서 키가 노출될 위험이 존재합니다.  하지만, 같은 키를 사용하기 때문에 암호화와 복호화 속도가 비대칭 암호 알고리즘보다 빠르다는 장점이 있습니다.  반면 비대칭 암호 알고리즘은 암호화와 복호화에 서로 다른 키(공개키와 비밀키)를 사용합니다.  공개키는 누구에게나 공개해도 되지만, 비밀키는 자신만 알고 있어야 합니다.  이러한 특징 때문에 비밀키를 안전하게 보관하기만 하면 키 교환의 위험 없이 안전하게 암호화 및 복호화를 할 수 있습니다.  하지만, 서로 다른 키를 사용하는 연산 과정이 복잡하기 때문에 대칭 암호 알고리즘보다 속도가 느립니다.  문제에서 틀린 설명은 대칭 암호 알고리즘이 키 교환이 필요 없다는 것입니다.  대칭 암호 알고리즘은 키를 안전하게 공유하는 과정이 필수적입니다.  따라서 정답은 대칭 암호 알고리즘은 비밀키 전달을 위한 키 교환이 필요하지 않아 암호화 및 복호화의 속도가 빠르다는 설명이 틀린 것입니다.",23,54
794,1,8,94,"두 명의 개발자가 5개월에 걸쳐 10000 라인의 코드를 개발하였을 때, 월별(man-month) 생산성 측정을 위한 계산 방식으로 가장 적합한 것은?",,10000／2,10000／(5×2),10000／5,(2×10000)／5,2,"문제에서 두 명의 개발자가 5개월 동안 10000 라인의 코드를 개발했다는 정보가 주어졌습니다.  월별 생산성을 측정하려면, 총 개발 라인 수를 개발에 투입된 총 인원-월(man-month)로 나누어야 합니다.  여기서 인원-월은 개발에 참여한 개발자 수와 개발 기간(월)을 곱한 값입니다.  두 명의 개발자가 5개월 동안 작업했으므로, 총 인원-월은 2명 × 5개월 = 10 인원-월이 됩니다. 따라서 월별 생산성은 10000 라인을 10 인원-월로 나눈 값, 즉 1000 라인/인원-월이 됩니다.  이 계산 방식은 개발 생산성을  개발자 한 명이 한 달 동안 생산하는 코드 라인 수로 정확하게 나타내므로 가장 적합합니다. 다른 계산 방식들은 개발자 수나 기간을 고려하지 않거나 잘못 고려하여 정확한 월별 생산성을 나타내지 못합니다.",55,47
795,1,8,95,"접근 통제 방법 중 조직 내에서 직무, 직책 등 개인의 역할에 따라 결정하여 부여하는 접근 정책은?",,RBAC,DAC,MAC,QAC,1,"이 문제는 접근 통제 방법 중에서 조직 내 직무나 직책에 따라 접근 권한을 부여하는 방식을 묻고 있습니다.  쉽게 말해, 회사 내에서 어떤 직원이 어떤 업무를 할 수 있는지, 어떤 데이터에 접근할 수 있는지를 직책이나 역할에 따라 정하는 시스템입니다.  예를 들어, 사장은 모든 데이터에 접근할 수 있지만, 일반 사원은 자신이 담당하는 업무와 관련된 데이터에만 접근할 수 있도록 제한하는 것이죠. 이러한 역할 기반의 접근 통제 방식은 바로 RBAC(Role-Based Access Control)입니다.  다른 선택지들은 각각 다른 접근 통제 방식을 나타내는데,  RBAC와는 차이가 있습니다.  따라서 조직 내 직무와 직책에 따른 접근 권한 부여 방식을 묻는 질문에 가장 적합한 답은 RBAC입니다. 정보처리기사 공식 교재에서도 RBAC에 대한 설명과 함께 다양한 접근 통제 방법의 차이점을 자세히 다루고 있으므로, 교재를 참고하여 더욱 자세히 학습하시면 좋습니다.",32,55
796,1,8,96,COCOMO(Constructive Cost Model) 모형의 특징이 아닌 것은?,,프로젝트를 완성하는데 필요한 man-month로 산정 결과를 나타낼 수 있다.,보헴(Boehm)이 제안한 것으로 원시코드 라인 수에 의한 비용 산정 기법이다.,비교적 작은 규모의 프로젝트 기록을 통계 분석하여 얻은 결과를 반영한 모델이며 중소 규모 소프트웨어 프로젝트 비용 추정에 적합하다.,"프로젝트 개발유형에 따라 object, dynamic, function의 3가지 모드로 구분한다.",4,"COCOMO 모델은 소프트웨어 개발에 필요한 비용과 기간을 예측하는 모델입니다.  프로젝트의 규모(원시 코드 라인 수)를 기반으로 man-month(인원 * 월) 단위로 산출 결과를 제시하는 것이 특징입니다.  보헴(Boehm)이 개발한 이 모델은 특히 중소 규모의 소프트웨어 프로젝트에 적합하도록,  실제 프로젝트 데이터를 분석하여 만들어졌습니다.  하지만 COCOMO는 프로젝트의 유형을 크게 세 가지(Object, Dynamic, Embedded)로 나누어 비용을 산정하는 방식을 사용하지 않습니다.  문제에서 제시된 '프로젝트 개발 유형에 따라 object, dynamic, function의 3가지 모드로 구분한다'는 설명은 COCOMO 모델의 특징이 아니기 때문에,  이것이 정답이 됩니다.  COCOMO는  프로젝트의 복잡도와 개발 환경 등 여러 요소를 고려하여 더 정교한 비용 산정을 가능하게 하지만,  기본적으로는 원시 코드 라인 수를 기반으로 하며,  세 가지 모드로 구분하는 것은 다른 소프트웨어 비용 산정 모델의 특징일 수 있습니다.",34,47
797,1,8,97,각 사용자 인증의 유형에 대한 설명으로 가장 적절하지 않은 것은?,,"지식 : 주체는 '그가 알고 있는 것'을 보여주며 예시로는 패스워드, PIN 등이 있다.","소유 : 주체는 '그가 가지고 있는 것'을 보여주며 예시로는 토큰, 스마트카드 등이 있다.","존재 : 주체는 '그를 대체하는 것'을 보여주며 예시로는 패턴, QR 등이 있다.","행위 : 주체는 '그가 하는 것'을 보여주며 예시로는 서명, 움직임, 음성 등이 있다.",3,"사용자 인증은 시스템에 접근하려는 사용자의 신원을 확인하는 중요한 과정입니다.  문제에서 제시된 인증 유형들은 크게 사용자가 '알고 있는 것', '가지고 있는 것', '되는 것', '하는 것'으로 나눌 수 있습니다.  '알고 있는 것'은 비밀번호나 PIN 번호처럼 사용자만 알고 있는 정보를 이용하는 것이고, '가지고 있는 것'은 스마트 카드나 토큰처럼 사용자만 소지하고 있는 물리적인 매체를 이용하는 것입니다. '하는 것'은 서명이나 지문 인식처럼 사용자의 행위를 인증하는 방식입니다.  하지만 문제에서 '그를 대체하는 것'을 보여준다고 설명된 인증 유형은 다소 모호하고 정확하지 않습니다.  패턴이나 QR 코드는 사용자의 고유한 특징을 나타내는 수단이기는 하지만, 사용자 '자체'를 대체하는 것은 아닙니다.  패턴이나 QR 코드는 사용자의 신원을 증명하는 '수단'일 뿐, 사용자를 '대체'하는 것은 아니기 때문에 가장 적절하지 않은 설명입니다.  따라서 다른 설명들과 비교했을 때, 이 설명이 가장 부정확한 설명이라고 판단할 수 있습니다.  쉽게 말해,  비밀번호는 내가 '알고 있는 것', 스마트카드는 내가 '가지고 있는 것', 지문은 내가 '되는 것', 서명은 내가 '하는 것'으로 인증하는 것과 같습니다.  하지만 QR코드는 나를 '대체'하는 것이 아니라 나를 증명하는 도구일 뿐입니다.",52,53
798,1,8,98,시스템의 사용자가 로그인하여 명령을 내리는 과정에 대한 시스템의 동작 중 다음 설명에 해당하는 것은?,https://www.cbtbank.kr/images/iz/iz20220424/iz20220424m98.gif,Aging,Accounting,Authorization,Authentication,4,"시스템 사용자가 로그인하여 명령을 내리는 과정은 사용자의 신원을 확인하는 단계와 사용자가 시스템의 특정 자원에 접근할 수 있는 권한을 확인하는 단계로 나눌 수 있습니다.  먼저 사용자의 신원을 확인하는 과정, 즉 사용자가 주장하는 신원이 실제 신원과 일치하는지 확인하는 것을 **인증(Authentication)**이라고 합니다.  예를 들어, 여러분이 은행 계좌에 접속하려면 아이디와 비밀번호를 입력해야 합니다.  이 과정에서 은행 시스템은 여러분이 입력한 정보가 실제 여러분의 정보와 일치하는지 확인하는 것이죠.  반면에 사용자가 시스템에 접근할 수 있는 권한을 확인하는 과정은 **권한 부여(Authorization)**입니다.  인증을 통과했다고 해서 모든 시스템 자원에 접근할 수 있는 것은 아닙니다.  권한 부여는 사용자가 특정 작업을 수행할 수 있는 권한이 있는지 확인하는 단계입니다.  예를 들어, 일반 직원은 특정 데이터에 접근할 수 없지만, 관리자는 접근할 수 있는 것처럼 말이죠. 문제에서 설명하는 것은 사용자가 시스템에 접근하기 위해 자신의 신원을 증명하는 과정이므로, 인증(Authentication)이 정답입니다.  나이(Aging), 회계(Accounting)는 시스템 동작과 직접적인 관련이 없고, 권한 부여(Authorization)는 인증 이후에 이루어지는 과정이기 때문에 정답이 아닙니다.",31,53
799,1,8,99,다음에서 설명하는 IT 기술은?,https://www.cbtbank.kr/images/iz/iz20220424/iz20220424m99.gif,SDN(Software Defined Networking),NFS(Network File System),Network Mapper,AOE Network,1,"문제에서 설명하는 IT 기술은 사용자 컴퓨터에 침입하여 파일을 암호화하고, 암호 해독을 조건으로 금전을 요구하는 공격을 의미합니다. 이는 흔히 **랜섬웨어(Ransomware)**라고 불리는 악성 프로그램에 의한 공격입니다.  랜섬웨어는 사용자의 중요한 데이터를 인질로 잡고 금전을 요구하는 사이버 범죄의 한 유형입니다.  제시된 선택지 중 SDN, NFS, Network Mapper, AOE Network는 모두 네트워크 관련 기술이지만, 사용자 컴퓨터의 파일을 암호화하고 금전을 요구하는 공격과는 직접적인 관련이 없습니다.  SDN은 네트워크 관리 방식, NFS는 네트워크 파일 시스템, Network Mapper는 네트워크 스캐닝 도구, AOE Network는 네트워크 기술의 한 종류입니다. 따라서 문제의 설명과 가장 잘 부합하는 것은 랜섬웨어 공격이며, 이는 선택지 중 어느 것과도 직접적으로 연결되지 않지만, 문제의 상황을 가장 잘 설명하는 답변이므로 정답은 랜섬웨어에 해당하는 선택지입니다.  정보처리기사 시험에서는 이러한 사이버 공격 유형에 대한 이해를 묻는 문제가 출제될 수 있으며, 랜섬웨어는 그 대표적인 예시입니다.",37,55
800,1,8,100,프로젝트 일정 관리 시 사용하는 PERT 차트에 대한 설명에 해당하는 것은?,,각 작업들이 언제 시작하고 언제 종료되는지에 대한 일정을 막대 도표를 이용하여 표시한다.,시간선(Time-line) 차트라고도 한다.,수평 막대의 길이는 각 작업의 기간을 나타낸다.,"작업들 간의 상호 관련성, 결정경로, 경계시간, 자원할당 등을 제시한다.",4,"프로젝트 일정 관리에 사용되는 PERT 차트는 단순히 작업의 시작과 종료 시점만을 보여주는 막대 그래프(간트 차트)와는 다릅니다.  PERT 차트는 각 작업의 소요 시간뿐만 아니라, 작업들 간의 **의존 관계(어떤 작업이 다른 작업의 완료 후에 시작되는지)**를 명확하게 보여줍니다.  즉, 어떤 작업이 다른 작업에 영향을 미치는지, 프로젝트의 전체적인 흐름에서 어떤 작업이 가장 중요한지(결정 경로)를 시각적으로 파악할 수 있도록 설계되었습니다.  또한, 각 작업의 최소 및 최대 소요 시간(경계시간)을 고려하여 프로젝트 완료 시점의 불확실성을 줄이고,  자원을 효율적으로 배분하는 데 도움을 줍니다. 따라서 작업의 기간만을 나타내는 막대 그래프와는 달리, 작업 간의 상호 관련성, 결정 경로, 경계시간, 자원 할당 등 프로젝트 일정 관리에 필요한 종합적인 정보를 제공하는 것이 PERT 차트의 핵심적인 특징입니다.  따라서 정답은 작업들 간의 상호 관련성, 결정경로, 경계시간, 자원할당 등을 제시하는 것을 설명하는 선지입니다.",34,47
