PB_ID,EX_ID,PB_NUM,PB_QUES,PB_DETAIL,PB_CHOI1,PB_CHOI2,PB_CHOI3,PB_CHOI4,PB_ANS,PB_SOLU,PB_CR,PB_TOPIC
1,1,1,검토회의 전에 요구사항 명세서를 미리 배포하여 사전 검토한 후 짧은 검토 회의를 통해 오류를 조기에 검출하는데 목적을 두는 요구 사항 검토 방법은?,,빌드 검증,동료 검토,워크 스루,개발자 검토,3,"문제에서 설명하는 요구사항 검토 방법은 요구사항 명세서를 미리 참석자들에게 배포하여 사전 검토를 거친 후, 짧은 회의를 통해 오류를 찾는 방식입니다. 이는 워크스루(Walkthrough) 방식과 일치합니다.  워크스루는 개발자가 작성한 산출물(이 경우 요구사항 명세서)을 미리 검토자들에게 배포하고, 검토자들이 사전에 검토한 내용을 바탕으로 짧은 시간 동안 함께 검토하며 오류를 발견하는 방법입니다.  빌드 검증은 소프트웨어를 빌드한 후 검증하는 것이고, 동료 검토는 코드를 중심으로 검토하는 것이며, 개발자 검토는 개발자가 직접 검토하는 방식이므로 문제의 상황과는 맞지 않습니다. 따라서 정답은 워크스루인 3번입니다.",82,102
2,1,2,코드 설계에서 일정한 일련번호를 부여하는 방식의 코드는?,,연상 코드,블록 코드,순차 코드,표의 숫자 코드,3,"코드 설계에서 일정한 일련번호를 부여하는 방식은 순차 코드입니다.  예를 들어, 상품에 1, 2, 3…과 같이 번호를 매기는 방식이 순차 코드입니다.  연상 코드는 상품의 특징을 코드로 나타내는 방식(예: A01-남성의류, B01-여성의류)이고, 블록 코드는 특정 범위를 나타내는 코드(예: 1000-1999: 서울 지역 상품)이며, 표의 숫자 코드는 표를 참조하여 코드를 해석하는 방식입니다.  문제에서 요구하는 것은 일련번호를 부여하는 방식이므로 순차 코드가 가장 적절합니다.",85,106
3,1,3,객체지향 프로그램에서 데이터를 추상화하는 단위는?,,메소드,클래스,상속성,메시지,2,"객체지향 프로그래밍(OOP)에서 데이터를 추상화하는 기본 단위는 클래스입니다.  클래스는 객체의 설계도와 같다고 생각하면 쉬워요.  예를 들어 ""강아지""라는 객체를 생각해 봅시다.  강아지 객체는 이름, 털 색깔, 품종 등의 데이터(속성)와 짖기, 뛰어놀기 등의 행동(메소드)을 가지고 있죠.  클래스는 이러한 강아지 객체의 속성과 메소드를 정의하는 틀입니다.  즉, 클래스는 여러 개의 객체를 만들어낼 수 있는 템플릿 역할을 하며,  데이터(속성)를 묶어서 관리하고,  데이터를 처리하는 메소드를 함께 정의하여 데이터 추상화를 가능하게 합니다.  메소드는 클래스 내부의 특정 기능을 수행하는 함수이고, 상속성은 클래스 간의 관계를 나타내는 개념이며, 메시지는 객체 간의 상호작용을 나타내는 개념이므로 데이터 추상화의 기본 단위는 아닙니다.",83,107
4,1,4,데이터 흐름도(DFD)의 구성요소에 포함되지 않는 것은?,,process,data flow,data store,data dictionary,4,"데이터 흐름도(DFD)는 시스템의 데이터 흐름을 그림으로 나타내는 기법입니다.  주요 구성 요소는 데이터가 처리되는 과정(Process), 데이터가 이동하는 경로(Data Flow), 데이터가 저장되는 장소(Data Store)입니다.  데이터 딕셔너리(Data Dictionary)는 DFD의 구성 요소가 아니고, 각 데이터 요소에 대한 상세한 설명(데이터 이름, 데이터 타입, 데이터 길이 등)을 정의한 별도의 문서입니다.  DFD는 시스템의 전반적인 데이터 흐름을 보여주는 데 초점을 맞추고, 데이터 딕셔너리는 각 데이터 요소에 대한 세부 정보를 제공하여 DFD를 보완하는 역할을 합니다. 따라서 DFD를 이해하고 활용하는 데에는 데이터 딕셔너리가 필요하지만, DFD 자체의 구성 요소는 아닙니다.",83,103
5,1,5,소프트웨어 설계시 구축된 플랫폼의 성능특성 분석에 사용되는 측정 항목이 아닌 것은?,,응답시간(Response Time),가용성(Availability),사용률(Utilization),서버 튜닝(Server Tuning),4,"이 문제는 소프트웨어 설계 시 구축된 플랫폼의 성능 특성을 분석하는 데 사용되는 측정 항목을 묻고 있습니다.  응답시간, 가용성, 사용률은 모두 플랫폼의 성능을 평가하는 데 중요한 지표입니다. 응답시간은 사용자 요청에 대한 시스템의 반응 속도를 나타내고, 가용성은 시스템이 얼마나 안정적으로 작동하는지를 나타내며, 사용률은 시스템 자원의 활용도를 나타냅니다.  반면, 서버 튜닝은 시스템 성능을 *개선하기 위한* 활동이지, 성능을 *측정하는* 항목이 아닙니다.  서버 튜닝은 응답시간, 가용성, 사용률 등을 개선하기 위해 수행하는 작업이므로, 성능 측정 항목이라고 볼 수 없습니다. 따라서 정답은 4번, 서버 튜닝입니다.",90,101
6,1,6,UML 확장 모델에서 스테레오 타입 객체를 표현할 때 사용하는 기호로 맞는 것은?,,《 》,(( )),{{ }},[[ ]],1,"UML(Unified Modeling Language)은 소프트웨어 시스템을 시각적으로 표현하는 표준 모델링 언어입니다.  UML에서는 다양한 기호를 사용하여 클래스, 객체, 인터페이스 등을 나타내는데,  확장 모델에서 스테레오타입 객체를 표현할 때는 꺾쇠괄호 `《 》`를 사용합니다.  꺾쇠괄호 안에 스테레오타입 이름을 적어 객체의 특별한 속성이나 역할을 명시적으로 표현하는 것입니다. 예를 들어,  `《데이터베이스》사용자` 와 같이 표현하면 '사용자' 객체가 데이터베이스와 관련된 특별한 역할을 한다는 것을 나타낼 수 있습니다. 다른 괄호 기호들은 UML에서 다른 용도로 사용되거나 UML 표준에 포함되지 않습니다. 따라서 스테레오타입 객체를 표현하는 데는 `《 》`가 적절합니다.",82,102
7,1,7,GoF(Gang of Four)의 디자인 패턴에서 행위 패턴에 속하는 것은?,,Builder,Visitor,Prototype,Bridge,2,"GoF 디자인 패턴은 객체지향 설계에서 자주 발생하는 문제들을 해결하기 위한 디자인 템플릿입니다.  행위 패턴은 객체나 클래스 사이의 알고리즘과 책임 분배에 초점을 맞춘 패턴입니다.  제시된 선택지 중 Builder, Prototype, Bridge는 객체 생성이나 클래스 구조에 관련된 생성 패턴 또는 구조 패턴에 속합니다.  반면 Visitor 패턴은 객체 구조를 순회하며 각 객체에 대해 특정 작업을 수행하는 방식으로, 객체 간의 상호작용에 초점을 맞추어 행위 패턴에 해당합니다.  따라서 Visitor 패턴이 정답입니다.  쉽게 말해, Visitor 패턴은 여러 종류의 객체에 대해 각각 다른 작업을 수행해야 할 때 유용하게 사용되는 패턴입니다.  마치 여러 종류의 과일을 각각 다른 방법으로 가공하는 것과 같습니다.  각 과일(객체)에 대해 특정 작업(Visitor)을 수행하는 것이죠.",65,107
8,1,8,자료 사전에서 자료의 생략을 의미하는 기호는?,,{ },**,=,(　),4,"자료 사전에서 괄호 `(　)`는 자료의 생략을 나타내는 기호입니다.  데이터베이스나 프로그래밍에서 자료의 일부를 생략하거나,  자료의 값이 없음을 표현할 때 사용됩니다.  예를 들어,  사람의 이름과 나이를 저장하는 자료에서 나이 정보가 없는 경우 `(　)`를 사용하여  나이 부분을 비워둘 수 있습니다.  다른 기호들은 자료의 생략과는 직접적인 관련이 없습니다.  `{}`는 집합을 나타내고, `**`는 강조 표시, `=`는 대입 연산자로 사용됩니다. 따라서 자료 생략을 의미하는 기호는 `(　)`가 가장 적절합니다.",79,111
9,1,9,트랜잭션이 올바르게 처리되고 있는지 데이터를 감시하고 제어하는 미들웨어는?,,RPC,ORB,TP monitor,HUB,3,"트랜잭션(Transaction)이란 데이터베이스에서 여러 작업을 하나의 논리적 단위로 묶어서 처리하는 것을 말합니다.  예를 들어, 계좌 이체를 생각해보면, 출금 계좌에서 돈을 빼고, 입금 계좌에 돈을 넣는 두 가지 작업이 하나의 트랜잭션으로 이루어집니다.  이때, 출금은 성공했는데 입금이 실패하는 등의 부분적인 실패가 발생하면 안 되겠죠?  트랜잭션 모니터(TP monitor)는 이러한 트랜잭션이 올바르게 처리되었는지, 즉 데이터의 일관성(Consistency)을 유지하며 완료되었는지 감시하고 제어하는 미들웨어입니다.  만약 문제가 발생하면 트랜잭션을 롤백(Rollback)하여 이전 상태로 되돌리는 기능도 제공합니다.  RPC, ORB, HUB는 트랜잭션의 성공 여부를 직접적으로 감시하고 제어하는 기능을 제공하지 않습니다.  RPC는 원격 프로시저 호출을, ORB는 객체 요청 브로커 역할을, HUB는 네트워크 연결을 중계하는 역할을 수행합니다. 따라서 트랜잭션의 성공적인 처리를 보장하는 미들웨어는 TP monitor입니다.",83,110
10,1,10,UI 설계 원칙에서 누구나 쉽게 이해하고 사용할 수 있어야 한다는 것은?,,유효성,직관성,무결성,유연성,2,"UI 설계의 핵심 원칙 중 하나는 누구든지 쉽게 이해하고 사용할 수 있도록 만드는 것입니다.  이는 사용자에게 직관적인 인터페이스를 제공하여 최소한의 학습으로도 시스템을 효율적으로 사용할 수 있도록 하는 것을 의미합니다.  1번의 유효성은 시스템이 제대로 작동하는지를, 3번의 무결성은 데이터의 정확성과 신뢰성을, 4번의 유연성은 시스템의 변화에 대한 적응력을 나타냅니다.  하지만 문제에서 요구하는 '누구나 쉽게 이해하고 사용할 수 있어야 한다'는 것은 사용자의 편의성과 직결되는 '직관성'을 의미합니다.  따라서 정답은 2번 직관성입니다. 정보처리기사 공식 교재에서는 UI 설계 원칙을 설명하면서 사용자 중심 설계의 중요성을 강조하고 있으며, 직관성은 사용자 중심 설계의 핵심 요소로 다루고 있을 것입니다.",91,104
11,1,11,XP(eXtreme Programming)의 5가지 가치로 거리가 먼 것은?,,용기,의사소통,정형분석,피드백,3,"XP(eXtreme Programming)는 소프트웨어 개발 방법론 중 하나로,  변화에 대한 빠른 적응과 고객 만족을 최우선으로 하는 애자일(Agile) 방법론의 대표적인 예시입니다.  XP의 핵심 가치는  '단순성', '의사소통', '피드백', '용기', '존중' 입니다.  문제에서 제시된 보기 중 '정형분석'은 XP의 가치와 거리가 멉니다. XP는  유연성과 빠른 개발을 중시하기 때문에,  엄격하고 정형화된 분석보다는  고객과의 지속적인 소통과  반복적인 개발 과정을 통해 요구사항을  점진적으로 구체화해 나가는 것을 선호합니다.  정형분석은  일반적으로  요구사항을  미리  철저하게 분석하고  문서화하는  방법론에  더  적합합니다. 따라서 XP의 유연하고 반복적인 특성과는 상반되는 개념이라고 할 수 있습니다.",81,102
12,1,12,UML 모델에서 사용하는 Structural Diagram 에 속하지 않은 것은?,,Class Diagram,Object Diagram,Component Diagram,Activity Diagram,4,"UML(Unified Modeling Language)은 소프트웨어 시스템을 시각적으로 표현하는 표준 모델링 언어입니다.  UML 다이어그램은 크게 구조 다이어그램(Structural Diagram)과 행위 다이어그램(Behavioral Diagram)으로 나뉘는데, 구조 다이어그램은 시스템의 정적인 구조를 보여주고, 행위 다이어그램은 시스템의 동적인 행위를 보여줍니다.  문제에서 제시된 Class Diagram, Object Diagram, Component Diagram은 모두 시스템의 구성 요소와 그 관계를 나타내는 정적인 구조를 표현하는 다이어그램이므로 구조 다이어그램에 속합니다. 반면 Activity Diagram은 시스템의 동적인 흐름과 활동을 보여주는 다이어그램으로 행위 다이어그램에 속합니다. 따라서 UML 모델에서 사용하는 구조 다이어그램에 속하지 않는 것은 Activity Diagram입니다.  쉽게 말해, Class Diagram, Object Diagram, Component Diagram은 시스템의 '무엇'을 보여주는 그림이고, Activity Diagram은 시스템이 '어떻게' 동작하는지를 보여주는 그림입니다.",76,102
13,1,13,소프트웨어 개발 방법 중 요구사항 분석(requirements annalysis)과 거리가 먼 것은?,,비용과 일정에 대한 제약설정,타당성 조사,요구사항 정의 문서화,설계 명세서 작성,4,"소프트웨어 개발은 크게 요구사항 분석, 설계, 구현, 테스트 단계로 나눌 수 있습니다.  요구사항 분석 단계에서는 사용자의 요구를 파악하고 문서화하는 작업을 합니다.  1번의 비용과 일정 제약 설정은 프로젝트 관리의 일환으로 요구사항 분석에 영향을 미치지만, 분석 자체의 내용은 아닙니다. 2번의 타당성 조사는 프로젝트를 시작하기 전에 시스템 개발의 필요성과 실현 가능성을 검토하는 단계이며, 요구사항 분석의 전 단계입니다. 3번의 요구사항 정의 문서화는 분석 결과를 문서로 정리하는 작업으로 요구사항 분석의 핵심적인 부분입니다.  반면 4번의 설계 명세서 작성은 요구사항 분석이 끝난 후, 분석 결과를 바탕으로 시스템을 어떻게 구현할지 구체적으로 기술하는 단계입니다. 따라서 요구사항 분석과는 구분되는 단계입니다.  문제에서 묻는 것은 요구사항 분석과 거리가 먼 것이므로, 요구사항 분석 이후의 단계인 설계 명세서 작성이 정답입니다.",65,102
14,1,14,럼바우(Rumbaugh)의 객체지향 분석 절차를 가장 바르게 나열한 것은?,,객체 모형→동적 모형→기능 모형,객체 모형→기능 모형→동적 모형,기능 모형→동적 모형→객체 모형,기능 모형→객체 모형→동적 모형,1,"럼바우의 객체지향 분석 절차는 시스템을 객체, 동작, 기능으로 모델링하는 과정을 나타냅니다.  먼저 시스템을 구성하는 객체들을 식별하고 그들의 속성과 관계를 정의하는 **객체 모형**을 만듭니다.  다음으로 객체들 간의 상호작용과 시간에 따른 변화를 나타내는 **동적 모형**을 생성합니다. 마지막으로 시스템의 기능을 정의하고 객체들이 어떻게 기능을 수행하는지 보여주는 **기능 모형**을 만듭니다. 따라서 객체의 정의가 먼저 이루어져야 객체 간의 상호작용을 나타내는 동적 모형을 만들 수 있고, 객체와 동작을 바탕으로 기능을 정의하는 것이 자연스러운 순서입니다.  따라서 객체 모형 → 동적 모형 → 기능 모형의 순서가 가장 적절합니다. 다른 선택지는 이러한 논리적 순서를 따르지 않아 잘못된 것입니다.",86,107
15,1,15,공통 모듈에 대한 명세 기법 중 해당 기능에 대해 일관되게 이해하고 한 가지로 해석될 수 있도록 작성하는 원칙은?,,상호작용성,명확성,독립성,내용성,2,"공통 모듈이란 여러 프로그램에서 공통적으로 사용되는 기능을 모아놓은 부분입니다.  이러한 공통 모듈에 대한 명세를 작성할 때,  '명확성' 원칙은 해당 기능에 대한 설명이 모호하지 않고, 모든 개발자가 동일하게 이해하여 하나의 결과물로 구현될 수 있도록 하는 것을 의미합니다.  상호작용성, 독립성, 내용성은 중요한 요소이지만,  모든 개발자가 기능을 일관되게 이해하고 해석하는 데 가장 중요한 원칙은 명확성입니다.  명확하지 않으면 상호작용성이나 독립성을 확보하기 어렵고, 내용 자체가 불명확하면 내용성도 보장할 수 없기 때문입니다.  따라서 공통 모듈의 명세는 누가 보더라도 같은 의미로 해석될 수 있도록 명확하게 작성되어야 합니다.",86,106
16,1,16,객체지향 기법에서 클래스들 사이의 ‘부분-전체(part-whole)' 관계 또는 ’부분(is-a-part-of)'의 관계로 설명되는 연관성을 나타내는 용어는?,,일반화,추상화,캡슐화,집단화,4,"객체지향 기법에서 클래스는 객체의 설계도와 같습니다.  여러 개의 클래스가 서로 관계를 맺을 수 있는데, 그 중 '부분-전체' 관계는 하나의 클래스가 다른 클래스의 일부분으로 구성되는 관계를 의미합니다. 예를 들어, 자동차라는 클래스가 있다면 엔진, 바퀴, 시트 등의 클래스는 자동차의 부분이 되겠죠.  이처럼 전체를 구성하는 부분들의 관계를 나타내는 용어가 바로 '집단화'입니다.  일반화는 상위 개념과 하위 개념의 관계를 나타내고, 추상화는 복잡한 내용을 간략하게 표현하는 것이며, 캡슐화는 데이터와 함수를 하나로 묶는 것을 의미합니다. 따라서 자동차와 그 부품들의 관계를 가장 잘 설명하는 용어는 집단화입니다.",63,107
17,1,17,CASE가 갖고 있는 주요 기능이 아닌 것은?,,그래픽 지원,소프트웨어 생명주기 전 단계의 연결,언어번역,다양한 소프트웨어 개발 모형 지원,3,"CASE (Computer-Aided Software Engineering)는 소프트웨어 개발 과정을 지원하는 도구들의 총칭입니다.  그래픽 지원을 통해 시각적으로 소프트웨어 설계를 표현하고, 소프트웨어 생명주기(요구사항 분석부터 유지보수까지) 전 단계를 연결하여 효율적인 개발을 돕습니다. 또한 다양한 소프트웨어 개발 방법론(예: 폭포수 모델, 애자일)을 지원하여 개발팀의 상황에 맞는 개발 방식을 선택할 수 있도록 합니다. 하지만 CASE는 언어 번역 기능을 제공하지 않습니다. 언어 번역은 컴파일러나 인터프리터와 같은 별도의 도구가 담당하는 영역입니다.  CASE는 소프트웨어 개발 과정을 자동화하고 효율화하는 데 초점을 맞춘 도구이지, 언어 자체를 번역하는 도구는 아닙니다.",84,147
18,1,18,DBMS 분석시 고려사항으로 거리가 먼 것은?,,가용성,성능,네트워크 구성도,상호 호환성,3,"DBMS(데이터베이스 관리 시스템) 분석 시 고려해야 할 사항은 데이터베이스의 성능, 안정성, 그리고 데이터의 호환성 등입니다.  가용성은 데이터베이스가 얼마나 안정적으로 서비스를 제공하는지를 나타내는 지표이고, 성능은 데이터베이스의 처리 속도와 효율성을 의미하며, 상호 호환성은 다른 시스템과의 데이터 교환 가능성을 의미합니다.  하지만 네트워크 구성도는 DBMS 자체의 기능이나 성능과 직접적으로 관련된 요소가 아닙니다.  네트워크 구성은 DBMS가 동작하는 환경을 제공하는 부분이지, DBMS 분석의 핵심 요소는 아닙니다.  DBMS 분석은 데이터베이스 자체의 특성과 기능에 집중해야 하며, 네트워크 구성은 DBMS를 운영하는 데 필요한 인프라의 일부일 뿐입니다. 따라서 DBMS 분석 시 고려 사항으로 거리가 먼 것은 네트워크 구성도입니다.",83,101
19,1,19,HIPO(Hierarchy Input Process Output)에 대한 설명으로 거리가 먼 것은?,,상향식 소프트웨어 개발을 위한 문서화 도구이다.,"HIPO 차트 종류에는 가시적 도표, 총체적 도표, 세부적 도표가 있다.",기능과 자료의 의존 관계를 동시에 표현할 수 있다.,보기 쉽고 이해하기 쉽다.,1,"HIPO(Hierarchy Input Process Output)는 소프트웨어 개발 과정에서 시스템의 기능을 계층적으로 표현하는 문서화 도구입니다.  계층적 구조를 통해 시스템의 전체적인 흐름을 한눈에 파악하고, 각 기능의 입력, 처리, 출력을 명확하게 보여줍니다.  쉽게 말해, 큰 그림부터 시작해서 점점 세부적인 내용으로 들어가는 '탑다운(Top-down)' 방식의 설계에 적합합니다.  따라서, 상향식(Bottom-up) 소프트웨어 개발에는 적합하지 않습니다. 상향식은 작은 부분부터 조립하여 전체 시스템을 만드는 방식이기 때문입니다.  HIPO 차트는 가시적 도표(전체 시스템의 개요를 보여주는 도표), 총체적 도표(각 모듈의 기능을 개괄적으로 보여주는 도표), 세부적 도표(각 모듈의 상세한 기능을 보여주는 도표)로 구성되어 시각적으로 이해하기 쉽도록 설계되었습니다.  또한, 각 기능의 입력과 출력을 명확히 함으로써 기능과 자료의 의존 관계를 효과적으로 표현할 수 있습니다.  따라서 보기 쉽고 이해하기 쉽다는 특징도 가지고 있습니다.  문제에서 1번이 거리가 먼 이유는 바로 이 '탑다운' 방식과 '상향식' 방식의 차이 때문입니다.",78,106
20,1,20,"객체지향 분석 방법론 중 E-R 다이어그램을 사용하여 객체의 행위를 모델링하며, 객체식별, 구조 식별, 주체 정의, 속성 및 관계 정의, 서비스 정의 등의 과정으로 구성되는 것은?",,Coad와 Yourdon 방법,Booch 방법,Jacobson 방법,Wirfs-Brocks 방법,1,"이 문제는 객체지향 분석 방법론 중 E-R 다이어그램을 활용하는 방법을 묻고 있습니다.  객체지향 분석은 시스템을 객체(object)라는 독립적인 단위로 나누어 분석하는 방법론입니다.  여러 객체지향 분석 방법론 중 Coad와 Yourdon 방법은 E-R 다이어그램을 사용하여 객체의 행위를 모델링하는 특징이 있습니다.  E-R 다이어그램은 엔티티(Entity, 객체)와 관계(Relationship)를 표현하는 도구로, 객체 식별, 구조 식별, 주체 정의, 속성 및 관계 정의, 서비스 정의 등의 과정을 통해 시스템을 모델링합니다.  Booch, Jacobson, Wirfs-Brocks 방법도 객체지향 분석 방법론이지만, Coad와 Yourdon 방법처럼 E-R 다이어그램을 중심으로 객체의 행위를 모델링하는 방식은 아닙니다. 따라서 정답은 1번 Coad와 Yourdon 방법입니다.",79,107
21,1,21,정렬된 N개의 데이터를 처리하는데 O(Nlog2N)의 시간이 소요되는 정렬 알고리즘은?,,선택정렬,삽입정렬,버블정렬,합병정렬,4,"정렬 알고리즘은 데이터를 특정 순서(예: 오름차순 또는 내림차순)로 정렬하는 알고리즘입니다.  선택 정렬, 삽입 정렬, 버블 정렬은 시간 복잡도가 O(N²)인 알고리즘입니다.  이는 데이터의 개수(N)가 증가함에 따라 처리 시간이 N의 제곱에 비례하여 증가한다는 것을 의미합니다.  반면, 합병 정렬은 데이터를 반으로 나누어 정렬한 후 합치는 방식으로, 시간 복잡도가 O(N log₂N)입니다.  log₂N은 N의 이진 로그를 의미하며, N이 증가하더라도 N에 비해 훨씬 느리게 증가합니다. 따라서, 데이터의 개수가 많을수록 합병 정렬이 선택 정렬, 삽입 정렬, 버블 정렬보다 훨씬 효율적입니다. 문제에서 O(N log₂N)의 시간 복잡도를 갖는 정렬 알고리즘을 묻고 있으므로 정답은 합병 정렬입니다.",69,121
22,1,22,White Box Testing 에 대한 설명으로 옳지 않은 것은?,,"Base Path Testing, Boundary Value Analysis가 대표적인 기법이다.",Source Code 의 모든 문장을 한번 이상 수행함으로서 진행된다.,모듈 안의 작동을 직접 관찰 할 수 있다.,"산출물의 각 기능별로 적절한 프로그램의 제어구조에 따라 선택, 반복 등의 부분들을 수행함으로써 논리적 경로를 점검한다.",1,"White Box Testing(화이트 박스 테스팅)은 소프트웨어의 내부 구조와 동작 방식을 알고 테스트하는 방법입니다.  마치 투명한 상자(White Box)를 들여다보며 테스트하는 것과 같다고 생각하면 됩니다.  문제에서 옳지 않다고 하는 1번 선택지 ""Base Path Testing, Boundary Value Analysis가 대표적인 기법이다""는 잘못된 설명입니다. Base Path Testing과 Boundary Value Analysis는 블랙박스 테스트 기법에 속합니다. 블랙박스 테스트는 소프트웨어의 내부 구조를 모르고, 외부에서 입력값을 넣고 출력값을 확인하는 방식입니다.  화이트 박스 테스트는 소스 코드를 직접 분석하여 모든 경로를 테스트하는 것이 목표이므로, 소스 코드를 직접 확인하고 분석하는 2, 3, 4번 선택지는 모두 화이트 박스 테스트의 특징을 잘 나타내고 있습니다. 따라서 1번이 옳지 않은 설명입니다.",67,119
23,1,23,소프트웨어 품질 측정을 위해 개발자 관점에서 고려해야 할 항목으로 거리가 먼 것은?,,정확성,무결성,사용성,간결성,4,"소프트웨어 품질 측정은 개발된 소프트웨어가 얼마나 좋은지를 다양한 측면에서 평가하는 것을 말합니다.  정확성은 소프트웨어가 올바른 결과를 내는지, 무결성은 소프트웨어가 의도하지 않은 변경이나 손상으로부터 안전한지를, 사용성은 사용자가 얼마나 쉽고 편리하게 사용할 수 있는지를 나타냅니다.  반면 간결성은 소프트웨어의 코드가 얼마나 간결하고 효율적인지를 나타내는 것으로, 개발자 관점에서는 중요한 요소이지만,  **사용자 관점에서 소프트웨어 품질을 평가할 때는 직접적으로 고려되는 항목은 아닙니다.**  따라서 사용자의 만족도나 소프트웨어의 효율성을 평가하는 기준으로는 적합하지 않아 다른 항목들과 비교하여 거리가 멉니다.  간결성은 개발 효율성과 유지보수 용이성에 영향을 미치는 내부적인 측면이 강하기 때문에 사용자 관점의 품질 측정에서는 중요도가 낮습니다.",63,117
24,1,24,인터페이스 구현 검증도구 중 아래에서 설명하는 것은?,https://www.cbtbank.kr/images/iz/iz20200606/iz20200606m24.gif,xUnit,STAF,FitNesse,RubyNode,2,"문제에서 설명하는 검증 도구는 서비스 호출이나 컴포넌트 재사용 등 다양한 환경을 지원하는 테스트 프레임워크이며, 분산 환경에서 데몬을 사용하여 테스트를 자동화하는 특징을 가지고 있습니다.  제시된 선택지 중 이러한 특징을 가장 잘 나타내는 것은 STAF(Software Testing Automation Framework)입니다. STAF는 분산 환경에서 여러 시스템에 걸쳐 테스트를 자동화하는 데 특화된 프레임워크로, 다양한 플랫폼과 환경을 지원하며, 데몬을 이용하여 테스트를 관리하고 실행합니다.  xUnit은 단위 테스트 프레임워크, FitNesse는 피처 테스트 프레임워크, RubyNode는 특정 언어에 종속적인 도구이므로 문제의 설명과 일치하지 않습니다. 따라서 정답은 STAF(2번)입니다.",64,124
25,1,25,EAI(Enterprise Application Integration)의 구축 유형으로 옳지 않은 것은?,,Point-to-Point,Hub&Spoke,Message Bus,Tree,4,"EAI(Enterprise Application Integration)는 여러 기업용 애플리케이션들을 서로 연결하여 정보를 통합하고 공유하는 기술입니다.  문제에서 제시된 구축 유형들은 EAI 시스템을 구축하는 방식들을 나타냅니다.  Point-to-Point는 각 애플리케이션을 개별적으로 연결하는 방식이고, Hub&Spoke는 중앙 허브를 통해 여러 애플리케이션을 연결하는 방식이며, Message Bus는 메시지를 중개하는 버스를 통해 애플리케이션 간 통신을 관리하는 방식입니다.  반면 Tree는 계층적인 구조를 가지는 방식으로, EAI 시스템 구축에 일반적으로 사용되는 유형은 아닙니다.  EAI는 여러 애플리케이션 간의 효율적인 데이터 교환을 목표로 하기 때문에, 계층적인 Tree 구조는 유연성과 확장성 측면에서 비효율적일 수 있습니다. 따라서 4번 Tree가 옳지 않은 구축 유형입니다.",73,110
26,1,26,다음 트리를 전위 순회(preorder traversal)한 결과는?,https://www.cbtbank.kr/images/iz/iz20200606/iz20200606m26.gif,+*AB/*CDE,AB/C*D*E+,A/B*C*D+E,+**/ABCDE,4,"이 문제는 트리 자료구조의 전위 순회(preorder traversal)를 이해하고 있는지 묻는 문제입니다. 전위 순회란, 트리를 순회하는 방법 중 하나로,  먼저 루트 노드를 방문하고, 그 다음 왼쪽 서브트리를 순회한 후, 오른쪽 서브트리를 순회하는 방식입니다.  주어진 트리를 살펴보면 루트 노드는 '+'입니다.  그 다음 왼쪽 서브트리의 루트 노드는 '*'이고, 그 다음 왼쪽 서브트리의 루트 노드는 '*'입니다. 이런 식으로 루트 노드부터 차례대로 왼쪽 서브트리, 오른쪽 서브트리를 방문하며 노드를 순회하면  '+ * * A B / C D E' 순서로 방문하게 됩니다. 따라서 전위 순회 결과는 '+* * A B / C D E'가 됩니다.  문제의 보기 중 '+**/ABCDE'는 이 순서를 나타내는 가장 적절한 표현입니다.  다만, 보기의 표현 방식이 다소 생략적인 부분이 있어 혼란스러울 수 있지만, 전위 순회의 원리를 이해하면 정답을 찾을 수 있습니다.",79,111
27,1,27,인터페이스 보안을 위해 네트워크 영역에 적용될 수 있는 솔루션과 거리가 먼 것은?,,IPSec,SMTP,SSL,S-HTTP,2,"이 문제는 네트워크 영역에서 인터페이스 보안을 위해 사용되는 솔루션들을 묻고 있습니다.  IPSec, SSL, S-HTTP는 모두 네트워크 통신의 보안을 강화하는 프로토콜 또는 기술입니다. IPSec은 IP 패킷을 암호화하여 네트워크 상에서의 데이터 전송을 보호하고, SSL(Secure Sockets Layer)과 S-HTTP(Secure Hypertext Transfer Protocol)는 웹 통신에서 데이터를 안전하게 전송하기 위한 보안 프로토콜입니다. 반면 SMTP(Simple Mail Transfer Protocol)는 이메일 전송 프로토콜로,  자체적으로는 데이터 암호화 기능을 제공하지 않습니다. 따라서 네트워크 영역의 인터페이스 보안을 위해 직접적으로 사용되는 솔루션과는 거리가 멀다고 볼 수 있습니다.  SMTP를 통해 안전한 이메일 전송을 위해서는 SSL/TLS와 같은 별도의 보안 프로토콜을 함께 사용해야 합니다.  따라서 정답은 SMTP입니다.",77,156
28,1,28,평가 점수에 따른 성적부여는 다음 표와 같다. 이를 구현한 소프트웨어를 경계값 분석 기법으로 테스트 하고자 할 때 다음 중 테스트 케이스의 입력 값으로 옳지 않은 것은?,https://www.cbtbank.kr/images/iz/iz20200606/iz20200606m28.gif,59,80,90,101,3,"이 문제는 소프트웨어 테스트 기법 중 하나인 경계값 분석을 이해하고 있는지 묻는 문제입니다. 경계값 분석은 입력값의 경계선에 해당하는 값들을 테스트 케이스로 사용하여 프로그램의 오류를 찾는 기법입니다.  문제에서 주어진 성적 평가 기준은 80~100점이 A, 60~79점이 B, 0~59점이 C입니다.  각 구간의 경계값은 0, 59, 60, 79, 80, 100입니다.  따라서 이 값들을 테스트 케이스로 사용하여 프로그램이 정상적으로 동작하는지 확인해야 합니다.  선택지 1(59), 2(80), 4(101)는 모두 경계값이거나 경계값 바로 근처의 값이므로 테스트 케이스로 적합합니다. 하지만 선택지 3(90)은 경계값이 아니며, 80~100 구간 내부의 값이므로 경계값 분석의 목적에 부합하지 않습니다. 경계값 분석은 경계선에서 오류가 발생할 가능성이 높다는 점을 이용한 테스트 기법이기 때문에, 구간 내부의 값은 상대적으로 오류 발생 가능성이 낮습니다. 따라서 90점은 경계값 분석 테스트 케이스로 적합하지 않습니다.",77,119
29,1,29,반정규화(Denormalization) 유형중 중복 테이블을 추가하는 방법에 해당하지 않는 것은?,,빌드 테이블의 추가,집계 테이블의 추가,진행 테이블의 추가,특정 부분만을 포함하는 테이블의 추가,1,"반정규화는 데이터베이스의 성능을 향상시키기 위해 정규화된 데이터베이스를 의도적으로 비정규화하는 기법입니다.  중복 데이터를 허용하여 데이터베이스 조회 속도를 높이는 것이 목적입니다.  문제에서 제시된 옵션들을 살펴보면, 집계 테이블(2)은 특정 데이터의 집계 값을 저장하여 쿼리 속도를 높이는 데 사용되고, 진행 테이블(3)은 특정 작업의 진행 상황을 저장하는 데 사용되며, 특정 부분만을 포함하는 테이블(4)은 전체 테이블의 일부 데이터만을 저장하여 특정 쿼리의 성능을 향상시키는 데 사용됩니다. 이들은 모두 중복 데이터를 허용하여 성능을 개선하는 반정규화의 한 유형입니다. 반면, 빌드 테이블(1)은 일반적으로 데이터베이스 설계 과정에서 임시적으로 사용되는 테이블이지,  데이터베이스 성능 향상을 위한 중복 테이블 추가라는 반정규화의 목적과는 관련이 없습니다. 따라서 빌드 테이블의 추가는 반정규화 유형 중 중복 테이블을 추가하는 방법에 해당하지 않습니다.",47,133
30,1,30,ISO/IEC 9126의 소프트웨어 품질 특성 중 기능성(Functionlity)의 하위 특성으로 옳지 않은 것은?,,학습성,적합성,정확성,보안성,1,"ISO/IEC 9126는 소프트웨어의 품질을 평가하기 위한 국제 표준입니다.  기능성(Functionality)은 소프트웨어가 의도된 기능을 얼마나 잘 수행하는지를 나타내는 품질 특성입니다.  기능성의 하위 특성으로는 정확성(Accuracy), 적합성(Suitability), 상호운용성(Interoperability), 보안성(Security) 등이 있습니다.  문제에서 제시된 1번 '학습성'은 소프트웨어를 사용하는 사용자가 얼마나 쉽게 소프트웨어를 배우고 사용할 수 있는지를 나타내는 특성으로,  ISO/IEC 9126에서는 사용성(Usability)의 하위 특성으로 분류됩니다. 따라서 기능성의 하위 특성이 아닌 사용성의 하위 특성인 '학습성'이 정답입니다.  쉽게 말해, 기능성은 소프트웨어가 제대로 작동하는지에 대한 것이고, 학습성은 소프트웨어를 사용하기 쉬운지에 대한 것입니다.",61,117
31,1,31,다음 트리의 차수(degree)와 단말 노드(terminal node)의 수는?,https://www.cbtbank.kr/images/iz/iz20200606/iz20200606m31.gif,"차수: 4, 단말 노드: 4","차수: 2, 단말 노드: 4","차수: 4, 단말 노드: 8","차수: 2, 단말 노드: 8",2,"문제에서 제시된 트리는 계층적인 구조를 나타냅니다.  트리에서 각 노드의 차수는 그 노드가 가지고 있는 자식 노드의 개수를 의미합니다.  주어진 트리를 살펴보면, 루트 노드 A는 2개의 자식 노드(B, C)를 가지고 있고, 노드 B는 1개(D), 노드 C는 2개(E, F), 노드 E는 2개(G, H)의 자식 노드를 가지고 있습니다.  따라서 트리의 차수는 가장 많은 자식 노드를 가진 노드의 자식 노드 개수를 의미하는 것이 아니라, 각 노드의 자식 노드 개수 중 최댓값을 의미하는 것이 아닙니다.  문제에서 요구하는 것은 트리의 차수가 아니라, 각 노드의 차수 중 최댓값입니다.  이 트리에서 각 노드의 차수는 {2, 1, 2, 0, 2, 0, 0, 0} 이고, 최댓값은 2입니다. 따라서 트리의 차수는 2가 됩니다.  단말 노드는 자식 노드가 없는 노드를 의미하며, 주어진 트리에는 D, F, G, H 총 4개의 단말 노드가 있습니다. 따라서 정답은 2번, 차수: 2, 단말 노드: 4 입니다.  정보처리기사 시험에서는 자료구조에 대한 이해를 묻는 문제로, 트리의 기본적인 개념과 용어를 정확히 알고 있어야 풀 수 있는 문제입니다.",72,111
32,1,32,디지털 저작권 관리(DRM)의 기술 요소가 아닌 것은?,,크랙 방지 기술,정책 관리 기술,암호화 기술,방화벽 기술,4,"디지털 저작권 관리(DRM)은 디지털 콘텐츠의 저작권을 보호하기 위한 기술입니다.  크랙 방지 기술은 불법 복제를 막기 위해 사용되고, 정책 관리 기술은 콘텐츠 접근 권한을 제어하며, 암호화 기술은 콘텐츠를 암호화하여 무단 접근을 방지하는 데 사용됩니다.  반면 방화벽 기술은 외부의 불법적인 접근을 차단하는 네트워크 보안 기술로, DRM의 핵심 기술 요소는 아닙니다. DRM은 콘텐츠 자체의 보호에 초점을 맞추는 반면, 방화벽은 네트워크 전체의 보안을 담당합니다. 따라서 DRM의 기술 요소가 아닌 것은 방화벽 기술입니다.",77,116
33,1,33,소프트 웨어 테스트에서 오류의 80%는 전체 모듈의 20% 내에서 발견된다는 법칙은?,,Brooks의 법칙,Boehm의 법칙,Pareto의 법칙,Jackson의 법칙,3,"소프트웨어 테스트를 진행하다 보면, 전체 오류의 대부분이 소수의 모듈에서 발생하는 현상을 경험하게 됩니다.  파레토 법칙(Pareto principle)은 이러한 현상을 수치적으로 설명하는 법칙으로, 전체 오류의 80%가 전체 모듈의 20%에서 발견된다는 것을 의미합니다.  이는 소프트웨어 테스트의 효율성을 높이기 위해,  오류가 많이 발생할 가능성이 높은 모듈을 집중적으로 테스트해야 함을 시사합니다.  즉, 모든 모듈을 균일하게 테스트하는 것보다,  핵심 모듈에 집중하여 테스트하는 것이 더 효과적이라는 것을 보여주는 법칙입니다.  이는 흔히 '80/20 법칙'으로도 불리며, 소프트웨어 개발뿐 아니라 다양한 분야에서 활용되는 일반적인 원리입니다.",75,119
34,1,34,소프트웨어 형상 관리의 의미로 적절한 것은?,,비용에 관한 사항을 효율적으로 관리하는 것,개발 과정의 변경 사항을 관리하는 것,테스트 과정에서 소프트웨어를 통합하는 것,개발 인력을 관리하는 것,2,"소프트웨어 형상 관리란 소프트웨어 개발 과정에서 발생하는 모든 변경 사항을 체계적으로 관리하는 것을 의미합니다.  소스 코드, 설계 문서, 테스트 결과 등 소프트웨어 개발과 관련된 모든 산출물의 변경 이력을 추적하고 관리하여, 버전 관리, 변경 통제, 협업 등을 효율적으로 수행할 수 있도록 지원하는 활동입니다.  1번은 비용 관리, 3번은 소프트웨어 통합, 4번은 인력 관리에 대한 내용으로 소프트웨어 개발 과정의 변경 사항 자체를 관리하는 것과는 직접적인 관련이 없습니다. 따라서 소프트웨어 개발 과정의 변경 사항을 관리하는 2번이 가장 적절한 정답입니다.",69,115
35,1,35,알고리즘 시간복잡도 O(1)이 의미하는 것은?,,컴퓨터 처리가 불가,알고리즘 입력 데이터 수가 한 개,알고리즘 수행시간이 입력 데이터 수와 관계없이 일정,알고리즘 길이가 입력 데이터보다 작음,3,"O(1)은 알고리즘의 시간 복잡도를 나타내는 표기법입니다.  시간 복잡도는 알고리즘의 수행 시간이 입력 데이터의 크기에 따라 어떻게 변하는지를 나타내는 척도입니다. O(1)은 입력 데이터의 크기(n)에 관계없이 알고리즘의 수행 시간이 항상 일정하다는 것을 의미합니다.  예를 들어, 배열의 특정 인덱스에 접근하는 작업은 항상 같은 시간이 걸리므로 O(1)의 시간 복잡도를 가집니다.  입력 데이터가 1개이든 100만 개이든,  배열의 5번째 원소에 접근하는 데 걸리는 시간은 동일합니다.  따라서 정답은 3번, 알고리즘 수행시간이 입력 데이터 수와 관계없이 일정한 것입니다. 다른 선택지는 알고리즘의 시간 복잡도와 직접적인 관련이 없습니다.",76,121
36,1,36,소스코드 품질분석 도구 중 정적분석 도구가 아닌 것은?,,pmd,cppcheck,valMeter,checkstyle,3,"소스코드 품질분석 도구는 개발된 소스코드의 품질을 분석하고 개선하는 데 사용되는 도구입니다.  정적 분석 도구는 코드를 실행하지 않고 코드 자체를 분석하여 버그나 취약점, 스타일 위반 등을 찾아내는 도구입니다. 반면, 동적 분석 도구는 코드를 실제로 실행하면서 분석하는 도구입니다.  문제에서 제시된 pmd, cppcheck, checkstyle은 모두 코드를 실행하지 않고 분석하는 정적 분석 도구입니다.  valMeter는 코드 실행을 통해 성능이나 메모리 사용량 등을 측정하는 동적 분석 도구이므로, 정적 분석 도구가 아닙니다. 따라서 정답은 3번 valMeter입니다.",66,121
37,1,37,"검증 검사 기법 중 개발자의 장소에서 사용자가 개발자 앞에서 행하는 기법이며, 일반적으로 통제된 환경에서 사용자와 개발자가 함께 확인하면서 수행되는 검사는?",,동치 분할 검사,형상 검사,알파 검사,베타 검사,3,"문제에서 설명하는 검사 기법은 개발자가 만든 프로그램을 사용자가 직접 사용해보면서 오류를 찾는 검사입니다.  개발자의 장소에서 사용자가 직접 프로그램을 사용하고, 개발자는 옆에서 사용자의 행동을 관찰하며 문제점을 파악합니다. 이러한 검사는 일반적으로 통제된 환경에서 이루어지며, 사용자의 피드백을 바로 받아 수정할 수 있다는 장점이 있습니다.  선택지 중 알파 검사(3번)가 이러한 조건에 가장 부합합니다. 알파 검사는 소프트웨어 개발의 마지막 단계에서 내부 사용자(개발팀 또는 회사 내 사용자)가 제한된 환경에서 소프트웨어를 테스트하는 것을 의미합니다. 베타 검사는 외부 사용자를 대상으로 하는 반면, 알파 검사는 내부 사용자를 대상으로 하여 개발자의 장소에서 이루어진다는 점이 중요합니다.  동치 분할 검사는 테스트 케이스를 설계하는 기법이고, 형상 검사는 소프트웨어의 변경 사항을 관리하는 기법이므로 문제의 상황과는 맞지 않습니다.",79,119
38,1,38,하향식 통합에 있어서 모듈 간의 통합 시험을 위해 일시적으로 필요한 조건만을 가지고 임시로 제공되는 시험용 모듈을 무엇이라고 하는가?,,Stub,Driver,Procedure,Function,1,"하향식 통합 방식은 큰 모듈부터 통합하여 시스템을 구축하는 방식입니다.  이때, 아직 구현되지 않은 하위 모듈과의 통합을 위해 임시로 기능을 제공하는 모듈이 필요한데, 이를 Stub(스터브)라고 합니다.  스터브는 실제 기능을 수행하는 대신, 하위 모듈이 호출했을 때 미리 정의된 값을 반환하거나, 특정 동작을 시뮬레이션하는 역할을 합니다.  즉,  하위 모듈의 통합 테스트를 위해 일시적으로 필요한 조건만을 가지고 임시로 제공되는 시험용 모듈인 것입니다.  Driver는 상위 모듈을 테스트하기 위해 임시로 만든 모듈이고, Procedure와 Function은 일반적인 프로그램 구성 요소이므로 문제의 상황과는 맞지 않습니다.",82,114
39,1,39,SW 패키징 도구 활용 시 고려 사항과 거리가 먼 것은?,,패키징 시 사용자에게 배포되는 SW이므로 보안을 고려한다.,사용자 편의성을 위한 복합성 및 비효율성 문제를 고려한다.,보안상 단일 기종에서만 사용할 수 있도록 해야 한다.,제품 SW 종류에 적합한 암호화 알고리즘을 적용한다.,3,"SW 패키징은 소프트웨어를 사용자에게 배포하기 위한 과정입니다.  이 과정에서 여러 가지 사항을 고려해야 하는데,  보안은 가장 중요한 요소 중 하나입니다.  사용자에게 배포되는 소프트웨어이므로 악의적인 공격으로부터 안전하게 보호되어야 하며,  적절한 암호화 알고리즘을 사용하는 것도 중요합니다. 또한, 사용자들이 쉽고 편리하게 소프트웨어를 설치하고 사용할 수 있도록  패키징 과정을 설계해야 합니다.  하지만,  단일 기종에서만 사용하도록 제한하는 것은 사용자 편의성을 저해하고 제품의 활용성을 떨어뜨리므로  고려 사항에서 제외됩니다.  따라서 정답은 3번입니다.",89,116
40,1,40,외계인코드(Alien Code)에 대한 설명으로 옳은 것은?,,프로그램의 로직이 복잡하여 이해하기 어려운 프로그램을 의미한다.,아주 오래되거나 참고문서 또는 개발자가 없어 유지보수 작업이 어려운 프로그램을 의미한다.,오류가 없어 디버깅 과정이 필요 없는 프로그램을 의미한다.,사용자가 직접 작성한 프로그램을 의미한다.,2,"외계인 코드(Alien Code)는 2번처럼 아주 오래되거나 관련 문서나 개발자가 없어서 유지보수가 어려운 프로그램을 의미합니다.  마치 외계인이 만든 것처럼 이해하기 어렵고 수정하기 힘든 코드를 비유적으로 표현한 것입니다. 1번의 경우, 로직이 복잡한 프로그램은 많지만, 반드시 유지보수가 어려운 것은 아닙니다.  3번은 오류가 없는 프로그램을 의미하는데, 실제로 오류가 없는 프로그램은 거의 없고, 디버깅 과정은 필수적입니다. 4번은 사용자가 직접 작성한 프로그램을 의미하는데, 이는 외계인 코드와는 관련이 없습니다. 따라서, 오래되어 유지보수가 어려운 프로그램을 묘사하는 2번이 가장 적절한 설명입니다.",82,118
41,1,41,SQL 의 분류 중 DDL에 해당하지 않는 것은?,,UPDATE,ALTER,DROP,CREATE,1,"SQL은 데이터베이스를 관리하는 데 사용되는 언어입니다.  DDL(Data Definition Language)은 데이터베이스의 구조를 정의하는 데 사용되는 SQL의 한 종류입니다.  CREATE, ALTER, DROP 명령어는 테이블을 생성, 수정, 삭제하는 등 데이터베이스의 구조를 변경하는 데 사용되므로 DDL에 속합니다. 반면 UPDATE 명령어는 이미 존재하는 테이블의 데이터를 변경하는 데 사용됩니다.  데이터의 *내용*을 변경하는 것은 DML(Data Manipulation Language)의 영역이지 DDL의 영역이 아닙니다. 따라서 DDL에 해당하지 않는 것은 UPDATE입니다.  쉽게 말해, DDL은 데이터베이스의 '뼈대'를 다루고, DML은 '살'을 다루는 것이라고 생각하면 이해하기 쉽습니다.",74,127
42,1,42,다음 두 릴레이션에서 외래키로 사용된 것은? (단 밑줄 친 속성은 기본키이다.),https://www.cbtbank.kr/images/iz/iz20200606/iz20200606m42.gif,수강번호,과목번호,학번,과목명,2,"두 릴레이션(관계) 과목과 수강을 살펴보면, 과목 릴레이션에는 과목번호와 과목명이라는 속성이 있고, 수강 릴레이션에는 수강번호, 학번, 과목번호, 학기라는 속성이 있습니다.  밑줄 친 속성이 기본키이므로, 과목 릴레이션의 기본키는 과목번호이고, 수강 릴레이션의 기본키는 수강번호입니다.  외래키는 다른 릴레이션의 기본키를 참조하는 속성입니다.  수강 릴레이션의 과목번호 속성은 과목 릴레이션의 기본키인 과목번호를 참조하고 있으므로, 수강 릴레이션에서 외래키로 사용된 것은 과목번호입니다.  쉽게 말해, 수강 릴레이션은 어떤 과목을 수강했는지 알려주기 위해 과목 릴레이션의 과목번호를 참조하고 있는 것입니다. 따라서 정답은 2번 과목번호입니다.",86,129
43,1,43,데이터 무결성 제약조건 중 “개체 무결성 제약”조건에 대한 설명으로 맞는 것은?,,릴레이션 내의 튜플들이 각 속성의 도메인에 지정된 값만을 가져야 한다.,기본키에 속해 있는 애트리뷰트는 널값이나 중복값을 가질 수 없다.,릴레이션은 참조할 수 없는 외래키 값을 가질 수 없다.,외래키 값은 참조 릴레이션의 기본키 값과 동일해야 한다.,2,"데이터 무결성 제약 조건은 데이터베이스의 데이터가 정확하고 일관성 있게 유지되도록 보장하는 규칙입니다.  개체 무결성 제약 조건은 그 중에서도 각 데이터 레코드(튜플)의 기본키(Primary Key)에 대한 무결성을 보장하는 규칙입니다. 기본키는 각 레코드를 유일하게 식별하는 속성(Attribute)이므로,  널값(NULL, 값이 없음을 의미)이나 중복값을 가질 수 없습니다.  따라서 2번이 정답입니다. 1번은 도메인 무결성 제약 조건, 3번과 4번은 참조 무결성 제약 조건에 대한 설명입니다.  쉽게 말해, 개체 무결성은 각각의 데이터 행이 유일하게 구분될 수 있도록 기본키를 관리하는 규칙이라고 생각하면 됩니다.  예를 들어, 학생들의 정보를 담은 데이터베이스에서 학생 아이디(기본키)가 널값이거나 다른 학생과 중복될 수 없다는 것이 개체 무결성 제약 조건입니다.",76,133
44,1,44,뷰(view)에 대한 설명으로 옳지 않은 것은?,,뷰는 CREATE 문을 사용하여 정의한다.,뷰는 데이터의 논리적 독립성을 제공한다.,뷰를 제거할 때에는 DROP 문을 사용한다.,뷰는 저장장치 내에 물리적으로 존재한다.,4,"뷰(view)는 데이터베이스의 테이블들을 기반으로 만들어진 가상의 테이블입니다.  실제로 데이터를 저장하고 있는 것이 아니라, 기존 테이블들의 데이터를 특정 조건에 따라 보여주는 역할을 합니다.  CREATE VIEW 문을 사용하여 뷰를 정의하고, DROP VIEW 문을 사용하여 뷰를 제거합니다.  뷰는 기존 테이블의 데이터를 참조하여 보여주기 때문에, 기존 테이블의 구조가 변경되더라도 뷰를 통해 보이는 데이터는 논리적으로 독립성을 유지할 수 있습니다. 하지만 뷰 자체는 실제 데이터를 저장하는 공간이 아니므로 저장장치에 물리적으로 존재하지 않습니다. 따라서 4번이 옳지 않은 설명입니다.  마치  사진을 여러 장 붙여서 만든 콜라주처럼 생각하면 됩니다. 콜라주 자체는 새로운 사진이지만, 실제로는 원본 사진들이 존재해야만 합니다.  뷰는 원본 테이블(사진)을 기반으로 만들어진 가상의 테이블(콜라주)인 것이죠.",76,128
45,1,45,다음 SQL 문의 실행 결과는?,https://www.cbtbank.kr/images/iz/iz20200606/iz20200606m45.gif,"10,000","15,000","20,000","25,000",4,"이 SQL 문제는 두 개의 테이블, `도서` 테이블과 `도서가격` 테이블을 사용합니다.  `도서` 테이블에는 책번호와 책명이, `도서가격` 테이블에는 책번호와 가격이 저장되어 있습니다. 문제에서 요구하는 것은 '자료구조'라는 책의 가격을 찾는 것입니다.  먼저 안쪽의 `SELECT` 문 (서브쿼리) 에서 '자료구조' 책의 책번호를 찾습니다. `도서` 테이블을 조회하여 책명이 '자료구조'인 행을 찾으면 책번호는 222입니다. 이 책번호 222를 바깥쪽 `SELECT` 문의 `WHERE` 절에 사용하여 `도서가격` 테이블에서 책번호가 222인 행의 가격을 찾습니다.  `도서가격` 테이블에서 책번호 222의 가격은 25,000원입니다. 따라서 최종 결과는 25,000입니다.",89,128
46,1,46,데이터베이스의 논리적 설계(logical design) 단계에서 수행하는 작업이 아닌 것은?,,레코드 집중의 분석 및 설계,논리적 데이터베이스 구조로 매핑(mapping),트랜잭션 인터페이스 설계,스키마의 평가 및 정제,1,"데이터베이스의 논리적 설계는 데이터베이스의 구조를 사용자의 관점에서 정의하는 단계입니다.  어떤 데이터를 저장하고, 그 데이터들 간의 관계는 어떻게 되는지 등을 논리적으로 정의하는 것이죠.  레코드 집중(Record Focusing)은 물리적 설계 단계에서 데이터의 효율적인 저장을 위해 레코드들을 어떻게 그룹화하고 저장할지 결정하는 작업입니다.  따라서 레코드 집중의 분석 및 설계는 논리적 설계 단계에서 수행하는 작업이 아닙니다.  나머지 옵션들은 데이터베이스의 논리적 구조를 정의하고 평가하는 작업들로 논리적 설계 단계에 포함됩니다.  논리적 설계는 사용자의 요구사항을 충족하는 데이터베이스 구조를 만드는 데 초점을 맞추는 반면, 물리적 설계는 실제 데이터베이스 시스템에 구현하는 방법에 초점을 맞춥니다.  레코드 집중은 저장 공간 효율성과 같은 물리적인 측면을 고려하는 작업이므로 논리적 설계와는 구분됩니다.",45,130
47,1,47,이행적 함수 종속 관계를 의미하는 것은?,,"A→B이고 B→C 일 때, A→C를 만족하는 관계","A→B이고 B→C 일 때, C→A를 만족하는 관계","A→B이고 B→C 일 때, B→A를 만족하는 관계","A→B이고 B→C 일 때, C→B를 만족하는 관계",1,"이행적 함수 종속 관계는 데이터베이스 설계에서 매우 중요한 개념입니다.  간단히 말해, A라는 속성이 B라는 속성을 결정하고, B라는 속성이 C라는 속성을 결정하면, A라는 속성은 C라는 속성도 결정한다는 의미입니다.  마치 ""A가 B를 결정하고, B가 C를 결정하므로, A는 C를 결정한다"" 와 같은 논리적 추론과 같습니다.  문제에서 제시된 1번 선택지 ""A→B이고 B→C 일 때, A→C를 만족하는 관계""가 바로 이러한 이행적 함수 종속 관계를 정확하게 나타냅니다.  다른 선택지는 A, B, C 속성 간의 관계를 잘못 표현하고 있습니다. 예를 들어 2번 선택지는 A가 C를 결정한다는 것을 의미하는데, 문제의 조건만으로는 이를 알 수 없습니다.",85,129
48,1,48,하나의 애트리뷰트가 가질 수 있는 원자값들의 집합을 의미하는 것은?,,도메인,튜플,엔티티,다형성,1,"하나의 애트리뷰트(Attribute)는 데이터베이스에서 특정 엔티티(Entity)의 특징을 나타내는 속성을 말합니다. 예를 들어, ""고객""이라는 엔티티가 있다면, ""이름"", ""주소"", ""전화번호"" 등이 애트리뷰트가 됩니다.  이때, 각 애트리뷰트는 여러 값을 가질 수 있는데,  ""전화번호"" 애트리뷰트는  ""010-1234-5678"", ""02-1234-5678"" 등 다양한 전화번호를 가질 수 있습니다.  이처럼 하나의 애트리뷰트가 가질 수 있는 모든 가능한 값들의 집합을 도메인(Domain)이라고 합니다.  따라서 ""전화번호"" 애트리뷰트의 도메인은 모든 가능한 전화번호 형태의 값들의 집합이 되는 것입니다.  다른 선택지는 엔티티(실체), 튜플(데이터베이스 테이블의 한 행), 다형성(객체지향 프로그래밍 개념)으로 문제와 관련이 없습니다.",66,129
49,1,49,"STUDENT 테이블에 독일어과 학생 50명, 중국어과 학생 30명, 영어영문학과 학생 50명의 정보가 저장되어 있을 때, 다음 두 SQL문의 실행 결과 튜플 수는? (단, DEPT 컬럼은 학과명)",https://www.cbtbank.kr/images/iz/iz20200606/iz20200606m49.gif,"ⓐ 3, ⓑ 3","ⓐ 50, ⓑ 3","ⓐ 130, ⓑ 3","ⓐ 130, ⓑ 130",3,"STUDENT 테이블에는 학과(DEPT) 정보와 학생 정보가 저장되어 있습니다.  문제에서 독일어과, 중국어과, 영어영문학과 학생들의 정보가 각각 50명, 30명, 50명 있다고 했죠.",82,127
50,1,50,관계대수 연산에서 두 릴레이션이 공통으로 가지고 있는 속성을 이용하여 두 개의 릴레이션을 하나로 합쳐서 새로운 릴레이션을 만드는 연산은?,,https://www.cbtbank.kr/images/iz/iz20200606/iz20200606m50b1.gif,https://www.cbtbank.kr/images/iz/iz20200606/iz20200606m50b2.gif,https://www.cbtbank.kr/images/iz/iz20200606/iz20200606m50b3.gif,https://www.cbtbank.kr/images/iz/iz20200606/iz20200606m50b4.gif,1,"관계대수 연산에서 두 릴레이션을 하나로 합치는 연산은 조인(Join) 연산입니다.  두 릴레이션이 공통으로 가지고 있는 속성(열)을 기준으로 두 릴레이션의 행들을 결합하여 새로운 릴레이션을 생성합니다.  예를 들어, 학생 정보를 담은 릴레이션과 수강 정보를 담은 릴레이션이 있다고 가정해 봅시다. 두 릴레이션 모두 '학생 ID'라는 공통 속성을 가지고 있다면, '학생 ID'를 기준으로 조인 연산을 수행하면 학생 정보와 수강 정보가 하나의 릴레이션으로 통합됩니다.  이때, 어떤 종류의 조인을 사용할지는 공통 속성의 값이 어떻게 매칭되는지에 따라 다릅니다. (내부 조인, 외부 조인 등 여러 종류가 존재합니다.) 문제에서 언급된 ""공통으로 가지고 있는 속성을 이용하여 두 개의 릴레이션을 하나로 합쳐서 새로운 릴레이션을 만드는 연산""은 조인 연산의 개념을 가장 잘 설명하고 있습니다.",82,129
51,1,51,트랜잭션의 특성 중 다음 설명에 해당하는 것은?,https://www.cbtbank.kr/images/iz/iz20200606/iz20200606m51.gif,Durability,Share,Consistency,Atomicity,4,"문제에서 제시된 설명은 트랜잭션의 연산이 데이터베이스에 완벽하게 적용되거나 전혀 적용되지 않아야 함을 의미합니다.  즉, 트랜잭션 내 여러 작업들이 하나의 단위로 처리되어야 하며, 중간에 오류가 발생하더라도 모든 작업이 취소되어 일관성을 유지하거나, 모든 작업이 성공적으로 완료되어야 합니다. 이러한 특성을 원자성(Atomicity)이라고 합니다.  원자(Atom)는 더 이상 쪼갤 수 없는 가장 작은 단위를 의미하는데, 트랜잭션도 마찬가지로 하나의 논리적인 작업 단위로 간주되어, 성공 또는 실패 여부에 관계없이 데이터베이스의 일관성을 유지하는 데 중요한 역할을 합니다.  예를 들어, 계좌 이체 트랜잭션에서 출금과 입금 작업이 동시에 성공하거나 모두 실패해야만 데이터베이스의 전체적인 균형이 유지됩니다. 하나만 성공하고 다른 하나가 실패하면 데이터베이스에 오류가 발생하게 됩니다. 따라서, 문제의 설명은 트랜잭션의 원자성(Atomicity)을 설명하고 있습니다.",73,127
52,1,52,분산 데이터베이스 목표 중 “데이터베이스의 분산된 물리적 환경에서 특정 지역의 컴퓨터 시스템이나 네트워크에 장애가 발생해도 데이터 무결성이 보장된다”는 것과 관계있는 것은?,,장애 투명성,병행 투명성,위치 투명성,중복 투명성,1,"문제에서 제시된 분산 데이터베이스의 목표는 ""특정 지역의 컴퓨터 시스템이나 네트워크 장애에도 데이터 무결성을 보장하는 것""입니다.  이는 시스템의 어떤 부분에 장애가 발생하더라도 사용자는 그 장애를 인지하지 못하고, 마치 장애가 없는 것처럼 시스템을 사용할 수 있도록 하는 것을 의미합니다.  이러한 특징을 가장 잘 나타내는 용어가 바로 '장애 투명성'입니다.  장애 투명성은 분산 데이터베이스 시스템이 내부적으로 장애를 처리하고 사용자에게는 장애가 발생하지 않은 것처럼 보이도록 하는 기능을 말합니다.  반면, 병행 투명성은 여러 사용자가 동시에 데이터베이스를 접근하더라도 서로의 작업에 영향을 받지 않는 것을 의미하고, 위치 투명성은 데이터가 어디에 저장되어 있는지 사용자가 알 필요가 없도록 하는 것을 의미하며, 중복 투명성은 데이터의 중복 저장 사실을 사용자가 알 필요가 없도록 하는 것을 의미합니다. 따라서, 특정 지역의 장애에도 데이터 무결성을 보장하는 목표와 가장 직접적으로 관련된 것은 장애 투명성입니다.",71,131
53,1,53,"데이터베이스 시스템에서 삽입, 갱신, 삭제 등의 이벤트가 발생할 때마다 관련 작업이 자동으로 수행되는 절차형 SQL은?",,트리거(trigger),무결성(integrity),잠금(lock),복귀(rollback),1,"데이터베이스 시스템에서 삽입, 갱신, 삭제와 같은 이벤트가 발생했을 때, 특정 작업을 자동으로 수행하도록 미리 설정해 놓은 것을 트리거(trigger)라고 합니다.  예를 들어, 특정 테이블에 새로운 데이터가 삽입될 때마다 자동으로 다른 테이블에 관련 정보를 추가하거나, 데이터가 수정될 때마다 로그 테이블에 변경 내역을 기록하는 등의 작업을 트리거를 통해 자동화할 수 있습니다.  이는 개발자가 직접 코드를 작성하여 이벤트 발생 시마다 처리하는 것보다 훨씬 효율적이고 관리하기 쉽습니다.  따라서 데이터베이스의 무결성을 유지하고, 데이터 관리를 자동화하는 데 매우 유용한 기능입니다.  문제에서 제시된 다른 선택지들은 데이터베이스 관리와 관련된 개념이지만, 이벤트 발생 시 자동으로 작업을 수행하는 기능을 직접적으로 나타내는 것은 트리거입니다.  무결성은 데이터의 정확성과 일관성을 의미하고, 잠금은 동시 접근 제어를 위한 것이며, 복귀는 트랜잭션 처리 중 오류 발생 시 이전 상태로 되돌리는 기능입니다.",82,125
54,1,54,참조 무결성을 유지하기 위하여 DROP문에서 부모 테이블의 항목 값을 삭제할 경우 자동적으로 자식 테이블의 해당 레코드를 삭제하기 위한 옵션은?,,CLUSTER,CASCADE,SET-NULL,RESTRICTED,2,"참조 무결성이란 부모 테이블과 자식 테이블 간의 관계를 유지하는 무결성 규칙입니다.  부모 테이블의 특정 레코드가 삭제될 때, 자식 테이블에 해당 레코드와 관련된 레코드를 어떻게 처리할지 정하는 옵션이 필요합니다.  문제에서 제시된 옵션들을 살펴보면, CASCADE 옵션은 부모 테이블의 레코드가 삭제될 때, 자식 테이블에서 해당 부모 레코드를 참조하는 모든 레코드를 자동으로 삭제하는 기능을 제공합니다.  즉, 부모 테이블의 데이터 삭제가 자식 테이블에 연쇄적으로 영향을 미치도록 하는 것입니다.  다른 옵션들은 각각 다른 동작을 합니다. RESTRICTED는 부모 테이블의 레코드를 삭제할 수 없도록 제한하고, SET NULL은 자식 테이블의 해당 레코드의 부모 키 값을 NULL로 변경하며, CLUSTER는 물리적 저장 방식과 관련된 옵션입니다. 따라서 부모 테이블의 항목 값 삭제 시 자식 테이블의 해당 레코드를 자동 삭제하는 옵션은 CASCADE입니다.",77,127
55,1,55,DML에 해당하는 SQL 명령으로만 나열된 것은?,,"DELETE, UPDATE, CREATE, ALTER","INSERT, DELETE, UPDATE, DROP","SELECT, INSERT, DELETE, UPDATE","SELECT, INSERT, DELETE, ALTER",3,"SQL(Structured Query Language)은 데이터베이스를 관리하고 조작하는 데 사용되는 표준 언어입니다.  SQL 명령어는 크게 데이터 정의어(DDL), 데이터 조작어(DML), 데이터 제어어(DCL)로 나눌 수 있습니다.  DDL은 데이터베이스의 구조를 정의하는 명령어(CREATE, ALTER, DROP 등)이고, DML은 데이터베이스의 데이터를 조작하는 명령어(SELECT, INSERT, UPDATE, DELETE 등)이며, DCL은 데이터베이스에 대한 접근 권한을 제어하는 명령어(GRANT, REVOKE 등)입니다. 문제에서 제시된 보기 중 DML에 해당하는 명령어만 나열된 것은 3번입니다.  SELECT는 데이터를 조회하는 명령어, INSERT는 데이터를 추가하는 명령어, DELETE는 데이터를 삭제하는 명령어, UPDATE는 데이터를 수정하는 명령어이므로 모두 DML에 속합니다.  나머지 보기에는 DDL 명령어인 CREATE, ALTER, DROP이 포함되어 있습니다.",81,126
56,1,56,데이터 제어언어(DCL)의 기능으로 옳지 않은 것은?,,데이터 보안,"논리적, 물리적 데이터 구조 정의",무결성 유지,병행수행 제어,2,"데이터 제어 언어(DCL)은 데이터베이스 시스템에서 데이터에 대한 접근 권한을 관리하고 보호하는 데 사용되는 명령어 집합입니다.  데이터 보안, 무결성 유지, 병행 수행 제어 등의 기능을 통해 데이터베이스의 안전성과 신뢰성을 확보하는 역할을 합니다.  하지만 데이터베이스의 논리적, 물리적 구조 자체를 정의하는 것은 데이터 정의 언어(DDL)의 영역입니다.  DDL은 테이블, 뷰, 인덱스 등 데이터베이스의 구조를 생성하고 수정하는 명령어들을 포함합니다. 따라서 논리적, 물리적 데이터 구조 정의는 DCL의 기능이 아닙니다.  쉽게 말해, DCL은 누가 데이터에 접근할 수 있는지, 어떤 작업을 할 수 있는지를 관리하는 것이고, DDL은 데이터베이스의 기본 틀을 만드는 것입니다.  문제에서 2번이 옳지 않은 이유는 DCL이 데이터 구조를 정의하는 것이 아니라 데이터 접근 권한을 제어하는 기능을 담당하기 때문입니다.",67,126
57,1,57,병행제어의 로킹(Locking) 단위에 대한 설명으로 옳지 않은 것은?,,"데이터베이스, 파일, 레코드 등은 로킹 단위가 될 수 있다.",로킹 단위가 작아지면 로킹 오버헤드가 감소한다.,로킹 단위가 작아지면 데이터베이스 공유도가 증가한다.,한꺼번에 로킹 할 수 있는 객체의 크기를 로킹 단위라고 한다.,2,"로킹(Locking)은 여러 사용자가 동시에 데이터베이스에 접근하여 데이터를 변경하는 것을 방지하기 위해 특정 데이터 영역에 대한 접근을 제어하는 기법입니다.  로킹 단위란 한 번에 잠글 수 있는 데이터의 크기를 의미하는데, 데이터베이스 전체, 파일, 레코드 등 다양한 크기가 될 수 있습니다.  문제에서 2번이 옳지 않은 이유는 로킹 단위가 작아질수록 잠가야 할 데이터 영역이 많아져 오히려 로킹 오버헤드(자원 소모)가 증가하기 때문입니다.  작은 단위로 자주 잠금을 해제하고 다시 잠그는 작업이 반복되면서 시스템 성능 저하를 초래할 수 있습니다.  반대로 로킹 단위가 크면 로킹 오버헤드는 감소하지만, 데이터베이스 공유도는 감소합니다.  큰 단위로 잠그면 여러 사용자가 동시에 접근할 수 있는 데이터 영역이 줄어들기 때문입니다. 따라서 로킹 단위의 크기는 시스템 성능과 데이터 공유도 사이의 절충점을 찾는 것이 중요합니다.  4번은 로킹 단위의 정의를 정확하게 설명하고 있습니다.",77,131
58,1,58,E-R 모델의 표현 방법으로 옳지 않은 것은?,,개체타입: 사각형,관계타입: 마름모,속성: 오각형,연결: 선,3,"E-R 모델은 데이터베이스 설계에 사용되는 개체-관계 모델입니다.  개체(Entity)는 사물이나 개념을 나타내고, 관계(Relationship)는 개체들 간의 연관성을 표현합니다.  속성(Attribute)은 개체나 관계에 대한 특징을 나타내는 정보입니다.  E-R 다이어그램에서는 일반적으로 개체는 사각형, 관계는 마름모, 속성은 타원형(혹은 사각형 안에 속성을 나열)으로 표현합니다.  문제에서 속성을 오각형으로 표현하는 것은 E-R 모델의 표준 표현 방식과 일치하지 않으므로 옳지 않습니다. 따라서 정답은 3번입니다.",87,130
59,1,59,다음 설명의 ( )안에 들어갈 내용으로 적합한 것은?,https://www.cbtbank.kr/images/iz/iz20200606/iz20200606m59.gif,중복성,최소성,참조성,동일성,2,"후보키는 테이블(릴레이션) 내의 각 행(튜플)을 유일하게 식별하는 데 사용되는 속성 또는 속성들의 집합입니다.  유일성이란, 후보키를 구성하는 속성값들의 조합이 테이블 내 모든 행에서 중복되지 않아야 함을 의미합니다.  그리고 최소성이란, 후보키를 구성하는 속성 중 어떤 하나라도 제거하면 유일성이 보장되지 않아야 함을 의미합니다.  즉, 후보키는 유일하게 행을 식별하는 최소한의 속성 집합이어야 합니다. 문제에서 ( ) 안에 들어갈 내용은 후보키의 두 가지 조건 중 하나인 최소성을 의미합니다.  1번의 중복성은 후보키의 조건이 아니고, 3번의 참조성과 4번의 동일성은 데이터베이스의 다른 개념입니다. 따라서 정답은 2번 최소성입니다.",78,129
60,1,60,정규화 과정 중 1NF에서 2NF가 되기 위한 조건은?,,1NF를 만족하는 모든 도메인이 원자 값이어야 한다.,1NF를 만족하고 키가 아닌 모든 애트리뷰트들이 기본 키에 이행적으로 함수 종속되지 않아야 한다.,1NF를 만족하고 다치 종속이 제거되어야 한다.,1NF를 만족하고 키가 아닌 모든 속성이 기본키에 대하여 완전 함수적 종속 관계를 만족해야 한다.,4,"1NF(제1정규형)은 테이블의 각 칼럼(속성)이 원자값을 가져야 한다는 조건을 만족하는 정규화 단계입니다.  원자값이란 더 이상 나눌 수 없는 최소 단위의 값을 의미합니다. 예를 들어, 주소 칼럼에 ""서울시 강남구 역삼동 123-45"" 와 같이 여러 값이 합쳐져 있으면 원자값이 아니고, ""서울시"", ""강남구"", ""역삼동"", ""123-45"" 와 같이 나누어야 원자값이 됩니다.",57,130
61,1,61,IPv6에 대한 설명으로 틀린 것은?,,128비트의 주소 공간을 제공한다.,인증 및 보안 기능을 포함하고 있다.,패킷 크기가 64Kbyte로 고정되어 있다.,IPv6 확장 헤더를 통해 네트워크 기능 확장이 용이하다.,3,"IPv6는 인터넷 프로토콜 버전 6으로, 기존 IPv4의 주소 부족 문제를 해결하기 위해 개발된 차세대 인터넷 프로토콜입니다.  IPv4가 32비트 주소를 사용하는 반면, IPv6는 128비트 주소를 사용하여 훨씬 더 많은 장치에 고유한 IP 주소를 할당할 수 있습니다.  또한, IPv6는 보안 기능을 강화하여 네트워크의 안전성을 높였습니다.  IPv6 확장 헤더는 다양한 네트워크 기능을 추가할 수 있도록 유연성을 제공합니다.  하지만, 문제의 3번처럼 IPv6 패킷의 크기는 고정되어 있지 않고 가변적입니다.  IPv4와 마찬가지로 최대 전송 단위(MTU)에 따라 패킷 크기가 달라집니다. 따라서 3번이 틀린 설명입니다.",80,145
62,1,62,C언어에서 비트 논리연산자에 해당하지 않는 것은?,,^,?,&,~,2,"C언어에서 비트 논리 연산자는 비트 단위로 연산을 수행하는 연산자입니다.  ^는 XOR(배타적 논리합), &는 AND(논리곱), ~는 NOT(논리 부정) 연산자입니다.  이 연산자들은 각 비트에 대해 논리 연산을 수행하여 결과를 반환합니다.  문제에서 제시된 2번의 '?'는 C언어의 비트 논리 연산자가 아니며, 조건 연산자로 사용됩니다.  따라서 정답은 2번입니다.  쉽게 말해,  ^, &, ~는 컴퓨터가 숫자를 0과 1로 이루어진 비트로 처리할 때 각 비트별로 논리 연산을 하는 도구이고, ?는 그런 용도가 아니라는 것입니다.",69,141
63,1,63,TCP/IP 프로토콜 중 전송계층 프로토콜은?,,HTTP,SMTP,FTP,TCP,4,"TCP/IP 프로토콜은 인터넷에서 데이터를 주고받기 위한 규칙들의 집합입니다.  이 프로토콜은 여러 계층으로 나뉘는데, 그 중 전송 계층은 데이터를 안전하고 신뢰성 있게 전달하는 역할을 합니다.  HTTP, SMTP, FTP는 모두 응용 계층 프로토콜로,  웹 페이지 접근(HTTP), 이메일 전송(SMTP), 파일 전송(FTP)과 같은 특정 응용 서비스를 제공합니다.  반면 TCP는 전송 계층 프로토콜로,  데이터의 순서를 보장하고 오류를 검출하여 재전송하는 등 신뢰성 있는 데이터 전달을 담당합니다.  따라서 HTTP, SMTP, FTP는 TCP를 이용하여 데이터를 전송합니다.  문제에서 묻는 것은 전송 계층 프로토콜이므로 정답은 TCP입니다.  정보처리기사 공식 교재에서는 네트워크 계층과 전송 계층의 역할과 각 프로토콜의 특징을 자세히 설명하고 있을 것입니다.",71,145
64,1,64,시스템에서 모듈 사이의 결합도(Coupling)에 대한 설명으로 옳은 것은?,,한 모듈 내에 있는 처리요소들 사이의 기능적인 연관 정도를 나타낸다.,결합도가 높으면 시스템 구현 및 유지보수 작업이 쉽다.,모듈간의 결합도를 약하게 하면 모듈 독립성이 향상된다.,자료결합도는 내용결합도 보다 결합도가 높다.,3,"이 문제는 소프트웨어 모듈 간의 관계를 나타내는 '결합도(Coupling)'에 대한 이해도를 묻는 문제입니다.  결합도는 모듈 간의 의존성을 나타내는 척도로, 결합도가 높다는 것은 모듈들이 서로 복잡하게 얽혀있다는 것을 의미합니다.  반대로 결합도가 낮으면 모듈들이 서로 독립적으로 동작할 수 있다는 것을 의미합니다.",69,106
65,1,65,은행가 알고리즘(Banker's Algorithm)은 교착상태의 해결 방법 중 어떤 기법에 해당하는가?,,Avoidance,Detection,Prevention,Recovery,1,"은행가 알고리즘(Banker's Algorithm)은 운영체제에서 자원 할당을 관리하여 교착 상태(Deadlock)를 사전에 예방하는 기법 중 **교착 상태 회피(Avoidance)**에 해당합니다.  교착 상태는 여러 프로세스가 서로 필요한 자원을 점유하고 다른 프로세스가 그 자원을 기다리는 상황으로,  시스템이 멈추는 심각한 문제를 야기합니다.  교착 상태 회피 기법은 자원 할당 요청이 들어왔을 때, 그 요청을 수락하면 교착 상태가 발생할 가능성이 있는지 미리 검사하여 안전하다면 자원을 할당하고, 위험하다면 거부하는 방식입니다. 은행가 알고리즘은 이러한 안전성 검사를 수행하는 대표적인 알고리즘입니다.  마치 은행에서 고객에게 돈을 빌려줄 때, 빌려준 돈을 모두 갚을 수 있는지 확인하는 것과 유사합니다.  즉,  자원을 할당하기 전에 미리 안전성을 검사하여 교착 상태 발생 가능성을 줄이는 예방적 접근 방식입니다.  반면, 교착 상태 검출(Detection)은 교착 상태가 이미 발생한 후에 이를 찾아내는 기법이고, 교착 상태 예방(Prevention)은 교착 상태 발생 조건을 제거하여 애초에 발생하지 않도록 하는 기법이며, 교착 상태 복구(Recovery)는 교착 상태가 발생한 후에 시스템을 복구하는 기법입니다.  은행가 알고리즘은 교착 상태를 완전히 예방하는 것은 아니지만, 발생 가능성을 크게 줄이는 데 효과적입니다.",73,121
66,1,66,UNIX의 쉘(Shell)에 관한 설명으로 옳지 않은 것은?,,명령어 해석기이다.,시스템과 사용자 간의 인터페이스를 담당한다.,여러 종류의 쉘이 있다.,"프로세스, 기억장치, 입출력 관리를 수행한다.",4,"UNIX 쉘은 사용자가 명령어를 입력하면 그 명령어를 해석하고 실행하는 프로그램입니다.  마치 번역가처럼 사용자의 명령어를 컴퓨터가 이해할 수 있는 언어로 바꿔주는 역할을 합니다.  따라서 1번과 2번 설명은 쉘의 주요 기능을 정확하게 나타냅니다. 3번 역시 다양한 종류의 쉘(bash, zsh, csh 등)이 존재하는 것이 사실입니다. 하지만 4번은 옳지 않습니다. 프로세스, 기억장치, 입출력 관리 등은 운영체제(OS)의 커널(kernel)이 담당하는 기능입니다. 쉘은 사용자 인터페이스를 제공하고 커널에게 명령을 전달하는 역할을 할 뿐, 직접적으로 시스템 자원을 관리하지는 않습니다.  쉽게 말해, 쉘은 운영체제의 커널 위에서 동작하는 프로그램이며, 커널이 시스템 자원을 관리하는 일을 쉘이 대신하지는 않는다는 것입니다.",67,144
67,1,67,교착 상태 발생의 필요 충분 조건이 아닌 것은?,,상호 배제(mutual exclusion),점유와 대기(hold and wait),환형 대기(circular wait),선점(preemption),4,"교착 상태(Deadlock)란 두 개 이상의 프로세스가 서로 상대방이 갖고 있는 자원을 기다리면서 영원히 진행되지 못하는 상황을 말합니다.  교착 상태가 발생하기 위한 필요충분조건은 상호 배제, 점유와 대기, 환형 대기의 세 가지 조건이 모두 충족되어야 합니다.  문제에서 제시된 4번 선점은 교착 상태 발생 조건이 아닙니다.  선점이란 한 프로세스가 다른 프로세스가 사용 중인 자원을 강제로 빼앗는 것을 의미하는데,  만약 선점이 가능하다면,  한 프로세스가 다른 프로세스가 기다리고 있는 자원을 빼앗아 사용할 수 있으므로 교착 상태를 회피할 수 있습니다.  즉, 선점이 가능하면 환형 대기가 발생하지 않거나 해결될 수 있기 때문에 교착 상태의 필요충분조건이 될 수 없습니다.  다른 세 가지 조건은 교착 상태 발생에 필수적인 조건입니다. 상호 배제는 한 번에 하나의 프로세스만 자원을 사용할 수 있도록 하는 것이고, 점유와 대기는 이미 자원을 점유하고 있는 프로세스가 다른 자원을 요청하며 기다리는 상황을, 환형 대기는 여러 프로세스가 원형으로 자원을 요청하는 상황을 의미합니다.  이 세 가지 조건이 동시에 만족될 때 교착 상태가 발생할 수 있습니다.",67,144
68,1,68,"OSI-7계층에서 종단간 신뢰성 있고 효율적인 데이터를 전송하기 위해 오류검출과 복구, 흐름 제어를 수행하는 계층은?",,전송 계층,세션 계층,표현 계층,응용 계층,1,"OSI 7계층은 데이터를 효율적으로 전송하기 위해 각 계층마다 특정 역할을 수행하는데요,  종단간 신뢰성 있는 데이터 전송을 위해서는 데이터의 오류를 검출하고 복구하며, 데이터 전송 속도를 조절하는 흐름 제어가 필수적입니다.  이러한 오류 검출 및 복구, 흐름 제어는 바로 전송 계층(Transport Layer)에서 담당합니다.  전송 계층은 응용 계층에서 받은 데이터를  목적지까지 신뢰성 있게 전달하기 위해 TCP(Transmission Control Protocol) 와 같은 프로토콜을 사용하여 순서대로 데이터를 전송하고, 오류 발생 시 재전송을 요청하는 등의 작업을 수행합니다.  세션 계층은 통신 세션을 관리하고, 표현 계층은 데이터의 형식을 변환하며, 응용 계층은 사용자에게 직접적인 서비스를 제공하는 계층이기 때문에 오류 검출 및 복구, 흐름 제어와는 직접적인 관련이 없습니다. 따라서 정답은 1번 전송 계층입니다.",78,145
69,1,69,IPv6의 주소체계로 거리가 먼 것은?,,Unicast,Anycast,Broadcast,Multicast,3,"IPv6 주소 체계는 네트워크 상의 장치들을 식별하는 데 사용되는 주소 시스템입니다.  Unicast는 하나의 특정 장치에 메시지를 전송하는 방식이고, Anycast는 여러 장치 중 하나에 메시지를 전송하는 방식이며, Multicast는 여러 장치에 동시에 메시지를 전송하는 방식입니다.  반면 Broadcast는 네트워크 상의 모든 장치에 메시지를 전송하는 방식인데, IPv6에서는 효율성과 보안 문제로 인해 Broadcast 기능이 제한적으로 지원되거나 아예 지원되지 않습니다.  IPv6는 대규모 네트워크 환경에서 효율적인 주소 할당을 위해 설계되었고, Broadcast처럼 모든 장치에 메시지를 보내는 것은 네트워크 부하를 크게 증가시키기 때문입니다. 따라서 IPv6의 주소 체계와 거리가 먼 것은 Broadcast입니다.",74,145
70,1,70,TCP/IP 네트워크에서 IP 주소를 MAC 주소로 변환하는 프로토콜은?,,UDP,ARP,TCP,ICMP,2,"TCP/IP 네트워크에서 컴퓨터는 서로 통신하기 위해 IP 주소를 사용합니다.  IP 주소는 네트워크 상의 논리적인 주소이고, MAC 주소는 네트워크 인터페이스 카드(NIC)에 고유하게 할당된 물리적인 주소입니다.  컴퓨터가 다른 컴퓨터에 데이터를 전송하려면, 목적지 컴퓨터의 IP 주소를 알고 있어야 하지만, 실제 데이터 전송은 MAC 주소를 사용하여 이루어집니다.  IP 주소만으로는 데이터를 직접 전송할 수 없기 때문에, IP 주소를 MAC 주소로 변환하는 과정이 필요합니다.  이때 사용되는 프로토콜이 바로 ARP(Address Resolution Protocol)입니다.  ARP는 IP 주소를 알고 있을 때, 해당 IP 주소를 가지고 있는 컴퓨터의 MAC 주소를 찾아주는 역할을 합니다.  즉, ARP 요청을 통해 네트워크 상의 다른 컴퓨터에게 ""이 IP 주소의 MAC 주소를 알려줘""라고 질문하고, 응답을 통해 MAC 주소를 얻게 됩니다.  따라서 정답은 2번 ARP입니다.",71,145
71,1,71,프로세스 상태의 종류가 아닌 것은?,,Ready,Running,Request,Exit,3,"이 문제는 운영체제에서 프로세스의 상태를 묻고 있습니다.  프로세스는 컴퓨터가 실행 중인 프로그램을 의미하며, 여러 가지 상태를 거치며 동작합니다.  'Ready' 상태는 프로세스가 실행될 준비가 완료되었지만, 현재 CPU를 할당받지 못한 상태입니다. 'Running' 상태는 프로세스가 CPU를 할당받아 실행 중인 상태입니다. 'Exit' 상태는 프로세스가 실행을 종료한 상태입니다.  반면 'Request' 상태는 일반적인 프로세스 상태가 아닙니다.  프로세스는 요청(Request)을 하는 행위를 할 수 있지만, 그 자체가 'Request'라는 상태로 존재하는 것은 아닙니다.  프로세스는 항상 위 세 가지 상태(Ready, Running, Exit) 중 하나에 속하게 됩니다. 따라서 정답은 3번 'Request'입니다.",67,144
72,1,72,스레드(Thread)에 대한 설명으로 옳지 않은 것은?,,한 개의 프로세스는 여러 개의 스레드를 가질 수 없다.,커널 스레드의 경우 운영체제에 의해 스레드를 운용한다.,사용자 스레드의 경우 사용자가 만든 라이브러리를 사용하여 스레드를 운용한다.,"스레드를 사용함으로써 하드웨어, 운영체제의 성능과 응용 프로그램의 처리율을 향상시킬 수 있다.",1,"문제에서 제시된 네 가지 설명 중 옳지 않은 것을 찾는 문제입니다.  스레드(Thread)는 하나의 프로세스 내에서 동시에 실행되는 여러 개의 실행 흐름을 의미합니다.  쉽게 말해, 하나의 프로그램 안에서 여러 가지 일을 동시에 처리하는 작은 작업 단위라고 생각하면 됩니다.  예를 들어, 워드프로세서에서 문서를 작성하면서 동시에 다른 파일을 열어 참고하는 경우, 각 작업은 별도의 스레드로 처리될 수 있습니다.  따라서, 하나의 프로세스는 여러 개의 스레드를 가질 수 있습니다.  1번 선택지 ""한 개의 프로세스는 여러 개의 스레드를 가질 수 없다""는 이러한 스레드의 개념과 정반대되는 내용이므로 옳지 않은 설명입니다.  2번과 3번은 각각 커널 스레드와 사용자 스레드의 운용 방식을 설명하고 있으며, 4번은 스레드를 사용하는 이점을 설명하고 있습니다.  이들은 모두 스레드의 특징을 올바르게 나타내고 있습니다.",79,144
73,1,73,HRN(Highest Response-ratio Next) 스케줄링 방식에 대한 설명으로 옳지 않은 것은?,,대기 시간이 긴 프로세스의 경우 우선 순위가 높아진다.,SJF 기법을 보완하기 위한 방식이다.,긴 작업과 짧은 작업 간의 지나친 불평등을 해소할 수 있다.,우선 순위를 계산하여 그 수치가 가장 낮은 것부터 높은 순으로 우선 순위가 부여된다.,4,"HRN(Highest Response-ratio Next) 스케줄링은 프로세스의 우선순위를 계산하여 스케줄링하는 방식입니다.  우선순위는  (대기시간 + 서비스시간) / 서비스시간  으로 계산되는데, 이 값이 클수록 우선순위가 높아집니다.  즉, 대기시간이 길거나 서비스시간이 짧은 프로세스일수록 우선순위가 높아지는 것입니다.  이는 SJF(Shortest Job First) 스케줄링의 단점인 긴 작업의 무한정 대기 문제를 해결하기 위해 고안된 방식입니다.  SJF는 짧은 작업만 계속 처리하여 긴 작업이 계속 뒤로 밀리는 문제가 있는데, HRN은 대기시간을 고려하여 긴 작업에도 우선순위를 부여함으로써 이러한 불균형을 완화합니다.  문제의 4번 선택지는 ""우선 순위를 계산하여 그 수치가 가장 낮은 것부터 높은 순으로 우선 순위가 부여된다""라고 되어 있는데, HRN은 계산된 우선순위 값이 *높은* 것부터 *낮은* 순으로 스케줄링하므로 옳지 않습니다.  따라서 정답은 4번입니다.",70,144
74,1,74,IEEE 802.11 워킹 그룹의 무선 LAN 표준화 현황 중 QoS 강화를 위해 MAC 지원 가능을 채택한 것은?,,802.11a,802.11b,802.11g,802.11e,4,"IEEE 802.11 표준은 무선랜(WLAN) 통신을 위한 표준 규격입니다.  802.11a, b, g는 초기 무선랜 표준으로 데이터 전송 속도 향상에 초점을 맞추었습니다. 하지만,  데이터 전송의 우선순위를 정하거나(예: 화상회의 중 음성 데이터 우선 전송),  실시간 서비스의 품질을 보장하는 기능(QoS, Quality of Service)은 부족했습니다.  802.11e는 이러한 문제점을 해결하기 위해 등장한 표준으로,  MAC(Media Access Control) 계층에서 QoS 기능을 지원하여  실시간 애플리케이션의 성능을 향상시키는 데 중점을 두었습니다.  따라서 QoS 강화를 위해 MAC 지원 가능을 채택한 것은 802.11e입니다.  쉽게 말해,  802.11e는  데이터 전송의 '순서'를 정할 수 있게 해주는 기능을 추가하여 중요한 데이터가 먼저 전송되도록 함으로써  끊김 없는 통화나 원활한 영상 스트리밍을 가능하게 합니다.",61,149
75,1,75,C언어에서 사용할 수 없는 변수명은?,,student2019,text-color,_korea,amount,2,"C언어에서 변수명을 지을 때는 몇 가지 규칙을 따라야 합니다.  문제에서 제시된 변수명들을 살펴보면,  `student2019`는 영문자와 숫자로만 이루어져 있으므로 C언어에서 허용되는 변수명입니다. `_korea`는 언더바(_)로 시작하지만, 이후에 영문자로 이루어져 있으므로 역시 허용됩니다. `amount`는 영문자로만 이루어져 있으므로 허용됩니다. 하지만 `text-color`는 하이픈(-)을 포함하고 있습니다. C언어 변수명에는 영문자, 숫자, 언더바(_)만 사용할 수 있으며, 숫자로 시작할 수 없습니다. 따라서 하이픈(-)을 포함한 `text-color`는 C언어에서 사용할 수 없는 변수명입니다.  쉽게 말해, C언어 변수명은 영어 단어처럼 생각하면 됩니다.  띄어쓰기나 특수문자는 사용할 수 없고, 언더바(_)는 단어를 연결하는 용도로만 사용 가능합니다.",70,141
76,1,76,스크립트 언어가 아닌 것은?,,PHP,Cobol,Basic,Python,2,"문제에서 제시된 프로그래밍 언어 중 PHP, Basic, Python은 스크립트 언어에 해당합니다. 스크립트 언어는 컴파일 과정 없이 인터프리터를 통해 바로 실행되는 언어로, 일반적으로 웹 개발이나 자동화 스크립트 작성 등에 사용됩니다. 반면 COBOL은 컴파일을 거쳐 실행되는 절차적 프로그래밍 언어로, 주로 대규모 비즈니스 애플리케이션 개발에 사용되어 왔습니다. 따라서 스크립트 언어가 아닌 것은 COBOL입니다.  정보처리기사 시험에서는 다양한 프로그래밍 언어의 특징을 이해하고 있어야 하며, 각 언어의 적용 분야와 특징을 구분하는 능력이 중요합니다.",61,142
77,1,77,"다음의 페이지 참조 열(Page reference string)에 대해 페이지 교체 기법으로 선입선출 알고리즘을 사용할 경우 페이지 부재(Page Fault) 횟수는? (단, 할당된 페이지 프레임 수는 3이고, 처음에는 모든 프레임이 비어 있다.)",https://www.cbtbank.kr/images/iz/iz20200606/iz20200606m77.gif,13,14,15,20,2,"페이지 교체 기법 중 선입선출(FIFO) 알고리즘은 가장 먼저 들어온 페이지를 가장 먼저 교체하는 방식입니다.  문제에서 페이지 프레임은 3개이고, 참조 열은 7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0 입니다.  각 페이지 참조 시 프레임에 해당 페이지가 있는지 확인하고, 없다면 페이지 부재(Page Fault)가 발생합니다.  FIFO 알고리즘을 적용하여 페이지 부재 횟수를 계산해 보겠습니다.",56,144
78,1,78,C언어에서 배열 b[5]의 값은?,https://www.cbtbank.kr/images/iz/iz20200606/iz20200606m78.gif,0,1,2,3,1,"`static int b[9] = {1, 2, 3};` 라는 C언어 코드에서 배열 b는 크기가 9인 정수형 배열입니다.  초기화 부분 `{1, 2, 3}` 에서는 배열의 처음 세 요소(b[0], b[1], b[2])에 각각 1, 2, 3의 값이 할당됩니다.  `static` 키워드는 전역 변수처럼 프로그램의 실행 내내 메모리에 존재하게 하지만, 다른 파일에서 접근할 수 없도록 합니다.  나머지 요소들(b[3]부터 b[8]까지)은 초기화되지 않았으므로, C언어의 특성상 자동으로 0으로 초기화됩니다. 따라서 b[5]의 값은 0입니다. 문제의 정답 1은 잘못된 답변입니다.  문제에서 b[5]의 값을 묻고 있으므로, 초기화되지 않은 부분의 값인 0이 정답이 되어야 합니다.  따라서 문제 자체에 오류가 있거나, 문제의 의도가 명확하지 않습니다.  정답은 0입니다.",73,111
79,1,79,응집도가 가장 낮은 것은?,,기능적 응집도,시간적 응집도,절차적 응집도,우연적 응집도,4,"응집도는 하나의 모듈 내부 요소들이 서로 얼마나 관련성이 높은지를 나타내는 척도입니다.  응집도가 높다는 것은 모듈 내부 요소들이 서로 밀접하게 연관되어 하나의 목적을 위해 함께 동작한다는 의미이고, 응집도가 낮다는 것은 모듈 내부 요소들이 서로 관련성이 적거나 아예 무관하다는 의미입니다.  문제에서 제시된 네 가지 응집도 중 우연적 응집도는 모듈 내 요소들이 아무런 관련성 없이 우연히 모여 있는 경우를 말합니다.  기능적 응집도는 하나의 기능만을 수행하는 모듈, 시간적 응집도는 시간적으로 연관된 작업을 수행하는 모듈, 절차적 응집도는 특정 순서에 따라 작업을 수행하는 모듈을 의미합니다.  따라서, 요소 간 관련성이 가장 낮은 것은 우연적 응집도입니다.  정보처리기사 공식 교재에서는 응집도의 종류와 각각의 특징을 설명하며, 우연적 응집도가 가장 낮은 응집도임을 명시하고 있습니다.",80,106
80,1,80,JAVA 언어에서 접근제한자가 아닌 것은?,,public,protected,package,private,3,"JAVA에서 접근 제한자는 클래스나 클래스 멤버(변수, 메서드)에 대한 접근 권한을 제어하는 역할을 합니다.  `public`, `protected`, `private`은 모두 JAVA에서 사용되는 접근 제한자입니다.  `public`은 모든 곳에서 접근 가능하고, `protected`는 같은 패키지 내부 또는 상속 관계에 있는 클래스에서 접근 가능하며, `private`는 같은 클래스 내부에서만 접근 가능합니다.  반면 `package`는 접근 제한자로 사용되지 않습니다.  `package`는 JAVA에서 패키지를 선언하는 키워드로, 클래스의 이름 공간을 관리하는 역할을 합니다. 따라서  `package`는 접근 제한을 설정하는 것이 아니라, 클래스를 어떤 패키지에 속하게 할지를 정의하는 것입니다.  문제에서 묻는 것은 접근 제한자이므로, 패키지를 선언하는 키워드인 `package`는 정답이 될 수 없습니다.",75,107
81,1,81,Rayleigh-Norden 곡선의 노력 분포도를 이용한 프로젝트 비용 산정기법은?,,Putnam 모형,델파이 모형,COCOMO 모형,기능점수 모형,1,"Rayleigh-Norden 곡선은 소프트웨어 개발에서 노력(시간, 비용)이 프로젝트 진행에 따라 어떻게 분포되는지를 보여주는 곡선입니다.  초기에는 설계 및 분석에 많은 노력이 투입되고, 중간 단계에서는 코딩 및 테스트에 노력이 집중되며, 후반부에는 통합 및 배포에 노력이 집중되는 형태를 나타냅니다.  Putnam 모형은 이러한 Rayleigh-Norden 곡선을 기반으로 프로젝트의 노력 분포를 예측하고, 이를 통해 프로젝트의 총 비용을 산정하는 기법입니다.  즉,  Rayleigh-Norden 곡선의 노력 분포도를 이용하여 프로젝트 비용을 예측하는 모델이 바로 Putnam 모형입니다.  다른 선택지들은 소프트웨어 비용 산정에 사용되는 다른 기법들이지만, Rayleigh-Norden 곡선을 직접적으로 사용하지는 않습니다.",57,147
82,1,82,메모리상에서 프로그램의 복귀 주소와 변수사이에 특정 값을 저장해 두었다가 그 값이 변경되었을 경우 오버플로우 상태로 가정하여 프로그램 실행을 중단하는 기술은?,,모드체크,리커버리 통제,시스로그,스택가드,4,"프로그램이 실행될 때,  프로그램의 실행 순서와 복귀 위치를 기억하는 공간이 바로 스택입니다.  스택에는 변수들과 함께 프로그램이 어디로 돌아가야 하는지 알려주는 복귀 주소가 저장됩니다.  스택가드는 이 스택 영역에 특정 값(가드 값)을 복귀 주소와 변수 사이에 미리 저장해두는 기술입니다.  만약 프로그램 실행 중에 버퍼 오버플로우와 같은 문제가 발생하면,  변수 영역이 침범하여 이 가드 값이 변경될 수 있습니다.  스택가드는 이 가드 값의 변화를 감시하고,  값이 변경되었을 경우(즉, 오버플로우가 발생했을 경우) 프로그램 실행을 중단시켜 시스템의 안정성을 확보하는 역할을 합니다.  마치 경계병처럼 스택의 경계를 지키는 것이라고 생각하면 쉽습니다.  오버플로우로 인해 프로그램이 예상치 못한 동작을 하거나 시스템 전체에 영향을 미치는 것을 방지하는 중요한 보안 기술입니다.",76,144
83,1,83,백도어 탐지 방법으로 틀린 것은?,,무결성 검사,닫힌 포트 확인,로그 분석,SetUID 파일 검사,2,"백도어는 시스템에 무단으로 접근할 수 있도록 만든 비밀 통로입니다.  백도어 탐지 방법을 묻는 문제에서 2번 '닫힌 포트 확인'이 틀린 이유는 백도어가 항상 닫힌 포트를 통해 작동하는 것은 아니기 때문입니다. 백도어는 열린 포트나 심지어는 시스템의 정상적인 통신 프로토콜을 악용하여 숨겨져 있을 수 있습니다. 따라서 닫힌 포트만 확인하는 것은 백도어 탐지에 효과적이지 않습니다. 반면, 1번 '무결성 검사'는 시스템 파일의 변조 여부를 확인하여 백도어 설치 여부를 파악할 수 있고, 3번 '로그 분석'은 시스템 접근 기록을 분석하여 비정상적인 접근을 탐지할 수 있으며, 4번 'SetUID 파일 검사'는 특권을 가진 사용자 권한으로 실행되는 파일을 검사하여 백도어가 설치되었는지 확인하는 데 도움이 됩니다.  결론적으로 백도어는 다양한 방법으로 숨겨질 수 있으므로, 여러 가지 방법을 종합적으로 사용하여 탐지하는 것이 중요합니다.",71,156
84,1,84,IP 또는 ICMP의 특성을 악용하여 특정 사이트에 집중적으로 데이터를 보내 네트워크 또는 시스템의 상태를 불능으로 만드는 공격 방법은?,,TearDrop,Smishing,Qshing,Smurfing,4,"Smurfing 공격은 ICMP(Internet Control Message Protocol)의 특성을 악용하는 대표적인 DDoS(Distributed Denial of Service) 공격 방식입니다.  ICMP는 네트워크 장비의 상태를 확인하거나 오류를 알리는 데 사용되는 프로토콜인데, Smurfing 공격은 이 프로토콜의 브로드캐스트 기능을 악용합니다. 공격자는 특정 대상 사이트의 IP 주소를 포함한 ICMP 에코 요청(ping) 패킷을 네트워크의 브로드캐스트 주소로 보냅니다.  브로드캐스트 주소를 받은 네트워크 장비는 이 요청에 대한 응답을 대상 사이트로 보내게 되는데, 공격자는 이러한 응답 패킷을 대량으로 생성하여 대상 사이트에 엄청난 양의 트래픽을 발생시켜 서비스를 마비시키는 것입니다.  마치 한 사람이 많은 사람들에게 동시에 전화를 걸어 상대방의 전화기를 불통으로 만드는 것과 비슷한 원리입니다.  결국, 대상 사이트는 과도한 트래픽으로 인해 정상적인 서비스를 제공할 수 없게 되는 것입니다.  IP 주소를 악용하는 경우는 대상 IP 주소를 스푸핑(가짜 IP 주소를 사용)하여 추적을 어렵게 만드는 방식으로 사용될 수 있습니다.",67,155
85,1,85,CMM(Capability Maturity Model) 모델의 레벨로 옳지 않은 것은?,,최적단계,관리단계,정의단계,계획단계,4,"CMM(Capability Maturity Model)은 소프트웨어 개발 조직의 성숙도를 5단계로 평가하는 모델입니다.  각 단계는 소프트웨어 개발 프로세스의 안정성과 예측 가능성을 나타냅니다.  1단계는 초기 단계(Initial), 2단계는 관리 단계(Managed), 3단계는 정의 단계(Defined), 4단계는 관리 단계(Managed), 5단계는 최적 단계(Optimizing)입니다.  문제에서 제시된 4번 '계획 단계'는 CMM의 공식적인 레벨이 아니므로 옳지 않은 것입니다. CMM은 계획 단계를 포함하지만,  그 자체로 하나의 성숙도 레벨로 분류하지는 않습니다.  계획은 각 레벨에서 중요한 요소이지만,  CMM 레벨 자체를 나타내는 용어는 아닙니다.",52,147
86,1,86,웹과 컴퓨터 프로그램에서 용량이 적은 데이터를 교환하기 위해 데이터 객체를 속성·값의 쌍 형태로 표현하는 형식으로 자바스크립트(JavaScript)를 토대로 개발되어진 형식은?,,Python,XML,JSON,WEB SEVER,3,"웹이나 컴퓨터 프로그램에서 데이터를 주고받을 때, 용량이 큰 데이터를 XML처럼 복잡하게 표현할 필요 없이 간단하고 가볍게 표현하는 방법이 필요합니다.  JSON(JavaScript Object Notation)은 이러한 요구를 충족시키는 데이터 교환 형식입니다.  데이터를 속성(key)과 값(value)의 쌍으로 표현하여,  중괄호 `{}`와 대괄호 `[]`를 사용하여 계층적인 구조를 간결하게 나타냅니다. 자바스크립트 기반으로 개발되었기 때문에 자바스크립트를 사용하는 웹 환경에서 매우 효율적으로 사용할 수 있으며, 다른 프로그래밍 언어에서도 쉽게 파싱(해석)하여 사용할 수 있다는 장점이 있습니다.  문제에서 언급된 '용량이 적은 데이터'라는 조건과 '속성·값의 쌍 형태'라는 특징은 JSON의 주요 특징을 잘 나타내고 있습니다.  Python은 프로그래밍 언어이고, XML은 데이터 표현 방식이지만 JSON보다 복잡하며, 웹 서버는 데이터 교환 형식이 아닙니다. 따라서 정답은 JSON입니다.",79,142
87,1,87,"크래커가 침입하여 백도어를 만들어 놓거나, 설정 파일을 변경했을 때 분석하는 도구는?",,trace,tripwire,udpdump,cron,2,"시스템의 무결성을 감시하고, 무단 변경을 탐지하는 도구가 필요한 상황입니다.  크래커가 백도어를 생성하거나 설정 파일을 변경하는 것은 시스템의 무결성을 침해하는 행위입니다.  문제에서 제시된 옵션들을 살펴보면, trace는 시스템의 활동을 추적하는 도구이고, udpdump는 UDP 패킷을 덤프하는 도구이며, cron은 시스템에서 주기적으로 작업을 실행하는 스케줄러입니다. 이들은 시스템의 무결성 변화를 감지하는 데 직접적으로 사용되지 않습니다. 반면, tripwire는 시스템 파일의 무결성을 감시하는 도구로, 파일의 변경 사항을 감지하여 관리자에게 알려줍니다. 따라서 크래커의 침입으로 인한 백도어 생성이나 설정 파일 변경을 감지하는 데 가장 적합한 도구는 tripwire입니다.  정보처리기사 시험에서는 시스템 보안과 관련된 다양한 도구들의 기능을 이해하고 있어야 하며, 각 도구의 용도에 맞게 적절히 선택하는 능력이 중요합니다.  tripwire는 시스템의 파일 시스템 변화를 감지하여 시스템의 무결성을 보장하는 데 사용되는 대표적인 도구입니다.",73,156
88,1,88,소프트웨어 개발 프레임워크를 적용할 경우 기대효과로 거리가 먼 것은?,,품질보증,시스템 복잡도 증가,개발 용이성,변경 용이성,2,"소프트웨어 개발 프레임워크는 소프트웨어 개발 과정을 체계화하고 효율성을 높이기 위한 일종의 틀이나 규칙입니다.  프레임워크를 사용하면 반복적인 작업을 줄이고, 개발 과정을 표준화하여 품질을 향상시키며, 개발 기간을 단축할 수 있습니다.  변경이 발생하더라도 프레임워크 내에서 관리하기 때문에 변경에 대한 대응도 용이해집니다.  하지만 프레임워크 자체가 복잡할 수 있고,  프레임워크를 이해하고 적용하는 데 추가적인 학습 비용이 발생할 수 있습니다.  따라서 프레임워크 도입으로 인해 시스템의 복잡도가 증가하는 것은 기대효과라기보다는 오히려 부작용에 가까운 측면입니다.  나머지 옵션들은 모두 프레임워크 적용으로 얻을 수 있는 긍정적인 효과입니다.  따라서 정답은 2번, 시스템 복잡도 증가입니다.",87,148
89,1,89,"COCOMO model 중 기관 내부에서 개발된 중소 규모의 소프트웨어로 일괄 자료 처리나 과학기술 계산용, 비즈니스 자료 처리용으로 5만 라인 이하의 소프트웨어를 개발하는 유형은?",,embeded,organic,semi-detached,semi-embeded,2,"COCOMO(Constructive Cost Model) 모델은 소프트웨어 개발에 필요한 비용과 기간을 예측하는 모델입니다.  여러 유형으로 나뉘는데, 문제에서 제시된 조건(기관 내부 개발, 중소 규모, 5만 라인 이하, 일괄 자료 처리, 과학기술 계산, 비즈니스 자료 처리)에 가장 적합한 유형은 Organic 모형입니다.  Organic 모형은 소규모 팀이 잘 정의된 요구사항을 가지고 개발하는 프로젝트에 적용되며, 개발 팀의 경험과 숙련도가 높고, 프로젝트 관리가 상대적으로 용이한 경우에 사용됩니다.  반면, Embedded 모형은 실시간 시스템이나 임베디드 시스템처럼 제약 조건이 많은 프로젝트에, Semi-detached 모형은 Organic과 Embedded의 중간 정도의 복잡성을 가진 프로젝트에 적용됩니다. 따라서 문제의 조건에 가장 부합하는 것은 규모가 작고, 요구사항이 명확하며, 개발팀의 경험이 풍부한 상황을 가정하는 Organic 모형입니다.",71,147
90,1,90,여러 개의 독립된 통신장치가 UWB(Ultra Wideband)기술 또는 블루투스 기술을 사용하여 통신망을 형성하는 무선 네트워크 기술은?,,PICONET,SCRUM,NFC,WI-SUN,1,"여러 개의 독립된 통신 장치가 UWB(Ultra Wideband) 기술 또는 블루투스 기술을 사용하여 통신망을 형성하는 무선 네트워크 기술을 묻는 문제입니다.  정답은 PICONET입니다.  PICONET은 블루투스 기술에서 사용되는 네트워크 토폴로지의 한 종류로, 하나의 마스터 장치와 여러 개의 슬레이브 장치로 구성됩니다. 마스터 장치는 슬레이브 장치들과 직접 통신하며, 슬레이브 장치들은 서로 직접 통신할 수 없습니다.  UWB 기술 역시 근거리 무선 통신 기술이며,  PICONET과 유사한 방식으로 여러 장치가 네트워크를 구성할 수 있습니다.  반면, SCRUM은 소프트웨어 개발 프로세스, NFC는 근거리 무선 통신 기술이지만 PICONET처럼 여러 장치의 네트워크를 형성하는 방식은 아니고, WI-SUN은 저전력 광역 통신 기술입니다. 따라서, 여러 개의 독립된 통신 장치가 근거리 무선 통신을 통해 네트워크를 형성하는 기술을 가장 잘 나타내는 용어는 PICONET입니다.",55,149
91,1,91,프로토타입을 지속적으로 발전시켜 최종 소프트웨어 개발까지 이르는 개발방법으로 위험관리가 중심인 소프트웨어 생명주기 모형은?,,나선형 모형,델파이 모형,폭포수 모형,기능점수 모형,1,"이 문제는 소프트웨어 개발 방법론 중 프로토타입을 반복적으로 개선하여 최종 소프트웨어를 개발하는 방식, 특히 위험 관리에 중점을 두는 모형을 묻고 있습니다.  폭포수 모형은 순차적인 단계를 거치는 방식이고, 델파이 모형은 전문가 의견을 수렴하는 예측 기법이며, 기능점수 모형은 소프트웨어 규모를 측정하는 방법입니다.  나선형 모형은 각 단계마다 프로토타입을 만들고 평가하여 위험을 줄여나가면서 개발하는 반복적인 접근 방식을 사용합니다.  따라서 위험 관리를 중심으로 프로토타입을 지속적으로 발전시켜 최종 소프트웨어 개발까지 이르는 개발 방법론은 나선형 모형입니다.  나선형 모형은 각 단계에서 위험을 평가하고 관리하며, 필요에 따라 이전 단계로 돌아가 수정할 수 있는 유연성을 제공합니다.",74,147
92,1,92,다음이 설명하는 용어로 옳은 것은?,https://www.cbtbank.kr/images/iz/iz20200606/iz20200606m92.gif,하둡(Hadoop),비컨(Beacon),포스퀘어(Foursquare),맴리스터(Memristor),1,"문제에서 제시된 설명은 오픈소스 기반의 분산 컴퓨팅 플랫폼으로, 일반 PC들을 활용하여 대용량 스토리지를 구축하고 빅데이터를 효율적으로 처리하는 시스템을 가리킵니다.  이러한 특징은 바로 하둡(Hadoop)의 핵심 기능을 정확하게 설명하고 있습니다. 하둡은 수많은 컴퓨터들을 하나의 거대한 시스템처럼 연결하여 데이터를 저장하고 처리하는 기술로, 빅데이터 분석에 널리 사용됩니다.  반면 비컨은 근거리 무선 통신 기술, 포스퀘어는 위치 기반 서비스 플랫폼, 맴리스터는 새로운 종류의 메모리 소자를 의미하므로 문제의 설명과는 부합하지 않습니다. 따라서 정답은 1번 하둡(Hadoop)입니다.",76,131
93,1,93,소인수 분해 문제를 이용한 공개키 암호화 기법에 널리 사용되는 암호 알고리즘 기법은?,,RSA,ECC,PKI,PEM,1,"소인수분해 문제를 이용한 공개키 암호화 기법은 매우 중요한 암호화 알고리즘의 기반입니다.  큰 수를 소수(1과 자기 자신만으로 나누어 떨어지는 수)의 곱으로 분해하는 것은 쉽지 않다는 수학적 원리를 이용합니다.  RSA 알고리즘은 이러한 소인수분해의 어려움을 바탕으로 공개키와 개인키를 생성합니다. 공개키는 누구에게나 공개되어 데이터를 암호화하는 데 사용되고, 개인키는 소유자만 알고 있어 암호화된 데이터를 복호화하는 데 사용됩니다.  만약 공개키로 암호화된 데이터를 해독하려면, 매우 큰 수를 소인수분해해야 하는데, 이는 현재의 컴퓨터 기술로는 매우 어려운 작업이기 때문에 데이터의 보안이 유지되는 것입니다.  따라서 소인수분해 문제를 이용한 공개키 암호화 기법에 널리 사용되는 알고리즘은 RSA입니다. ECC는 타원곡선 암호기술을 사용하며, PKI는 공개키 기반구조, PEM은 Privacy Enhanced Mail을 의미하는데, 이들은 RSA와 같은 암호 알고리즘을 활용하는 시스템이나 프로토콜의 일부입니다.",79,154
94,1,94,"LOC 기법에 의하여 예측된 총 라인수가 50000라인, 프로그래머의 월 평균 생산성이 200라인, 개발에 참여할 프로그래머가 10인 일 때, 개발 소요 기간은?",,25개월,50개월,200개월,2000개월,1,"문제에서 주어진 정보는 총 라인 수(50000라인), 프로그래머 1인당 월 평균 생산성(200라인), 프로그래머 수(10명)입니다.  먼저, 10명의 프로그래머가 한 달에 생산하는 총 라인 수를 계산하면 200라인/명 * 10명 = 2000라인/월 입니다.  총 50000라인을 개발하려면 50000라인 / 2000라인/월 = 25개월이 소요됩니다. 따라서 개발 소요 기간은 25개월입니다.  LOC(Lines of Code) 기법은 소프트웨어 개발 규모를 코드 라인 수로 추정하여 개발 기간이나 비용을 예측하는 간단한 방법입니다.  이 문제는 LOC 기법을 이용하여 개발 기간을 계산하는 문제입니다.",86,147
95,1,95,최대 홉수를 15로 제한한 라우팅 프로토콜은?,,RIP,OSPF,Static,EIGRP,1,"라우팅 프로토콜은 네트워크 내에서 데이터 패킷이 목적지까지 최적의 경로를 찾아 이동하도록 하는 프로토콜입니다.  RIP(Routing Information Protocol)은 거리 벡터 라우팅 프로토콜의 한 종류로, 각 라우터는 이웃 라우터로부터 목적지까지의 거리(홉 수) 정보를 받아 최단 경로를 계산합니다. RIP의 특징 중 하나는 최대 홉 수를 15로 제한한다는 점입니다.  홉 수가 15를 넘어가면 해당 네트워크는 도달할 수 없다고 판단합니다.  따라서 최대 홉수를 15로 제한한 라우팅 프로토콜은 RIP입니다. OSPF(Open Shortest Path First)나 EIGRP(Enhanced Interior Gateway Routing Protocol)는 더욱 복잡한 알고리즘을 사용하며, 홉 수 제한이 15로 고정되어 있지 않습니다. Static 라우팅은 관리자가 직접 경로를 설정하는 방식으로, 홉 수 제한과는 무관합니다.",72,149
96,1,96,"컴퓨터 사용자의 키보드 움직임을 탐지해 ID, 패스워드 등 개인의 중요한 정보를 몰래 빼가는 해킹 공격은?",,Key Logger Attack,Worm,Rollback,Zombie Worm,1,"키로거 공격(Key Logger Attack)은 사용자의 키보드 입력을 몰래 기록하는 악성 프로그램을 이용한 해킹 기법입니다.  사용자가 키보드를 통해 입력하는 모든 정보, 예를 들어 ID, 비밀번호, 신용카드 번호, 주소 등 개인 정보가 키로거에 의해 감지되어 해커에게 전송됩니다.  키로거는 사용자의 컴퓨터에 설치되어 몰래 작동하며, 사용자는 자신이 감시당하고 있다는 사실을 전혀 인지하지 못할 수 있습니다.  이러한 정보는 해커가 금융 사기, 개인 정보 도용, 계정 탈취 등의 불법 행위를 저지르는 데 악용될 수 있습니다.  따라서 키로거 공격은 매우 위험한 해킹 기법 중 하나이며, 개인 정보 보호를 위해 항상 주의해야 합니다.  다른 선택지들은 웜(Worm)이나 좀비 웜(Zombie Worm)처럼 네트워크를 통해 확산되는 악성 프로그램 또는 시스템 복원과 관련된 Rollback과는 다른 개념입니다.",87,156
97,1,97,테일러링(Tailoring) 개발 방법론의 내부 기준에 해당하지 않는 것은?,,납기/비용,기술환경,구성원 능력,국제표준 품질기준,4,"테일러링(Tailoring) 개발 방법론은 표준적인 소프트웨어 개발 방법론을 특정 프로젝트의 상황에 맞게 조정하는 것을 의미합니다.  프로젝트의 성공적인 수행을 위해서는  납기, 비용, 기술 환경, 구성원의 능력 등을 고려하여 방법론을 조정해야 합니다.  하지만 국제표준 품질기준은 프로젝트의 특수한 상황에 맞춰 변경될 수 있는 내부 기준이 아니고,  프로젝트가 따라야 하는 외부적인 기준입니다. 따라서 프로젝트의 상황에 따라 조정하는 내부 기준이 아닌 국제표준 품질기준은 테일러링의 내부 기준에 해당하지 않습니다.  쉽게 말해,  테일러링은 '옷을 맞춤 제작하는 것'과 같습니다.  옷감(기술), 재봉틀(도구), 재봉사의 숙련도(구성원 능력), 예산(비용), 마감일(납기) 등을 고려하여 옷을 만들지만,  옷을 만드는 기본적인 규칙(국제표준 품질기준)은 바꿀 수 없습니다.",60,148
98,1,98,폭포수 모형의 특징으로 거리가 먼 것은,,개발 중 발생한 요구사항을 쉽게 반영할 수 있다.,순차적인 접근방법을 이용한다.,단계적 정의와 산출물이 명확하다.,모형의 적용 경험과 성공사례가 많다.,1,"폭포수 모형은 소프트웨어 개발 과정을 여러 단계로 나누어 순차적으로 진행하는 방법입니다.  각 단계는 명확하게 정의되고, 이전 단계가 완료되어야 다음 단계로 진행할 수 있습니다.  따라서 단계적 정의와 산출물이 명확하고,  오랜 기간 사용되어 많은 적용 경험과 성공사례가 축적되어 있습니다. 하지만,  개발 중에 요구사항이 변경되면 이전 단계로 돌아가 수정해야 하므로,  요구사항 변경에 유연하게 대처하기 어렵다는 단점이 있습니다. 문제에서 1번은 폭포수 모형의 특징이 아니며,  나머지 2, 3, 4번은 폭포수 모형의 주요 특징을 잘 나타내고 있습니다. 따라서 정답은 1번입니다.",84,147
99,1,99,다음 설명의 정보보안 침해 공격 관련 용어는?,https://www.cbtbank.kr/images/iz/iz20200606/iz20200606m99.gif,Smishing,C-brain,Trojan Horse,Ransomware,4,"문제에서 제시된 4가지 용어 중 정답은 'Ransomware'입니다.  Smishing은 SMS(문자 메시지)를 이용한 피싱 공격, C-brain은 문제와 관련 없는 용어, Trojan Horse는 악성 코드의 한 종류이지만, 문제의 설명과 직접적으로 연결되지 않습니다.  Ransomware는 사용자의 데이터를 암호화하고, 그 암호를 풀어주는 대가로 금전을 요구하는 악성 프로그램입니다. 문제의 추가 설명 이미지가 없어 정확한 맥락을 알 수 없지만,  데이터 암호화 및 금전 요구라는 랜섬웨어의 특징이 문제의 설명에 포함되어 있을 가능성이 높아 정답으로 추정됩니다.  따라서 랜섬웨어가 데이터를 암호화하여 사용자에게 피해를 입히는 정보보안 침해 공격이라는 점을 파악하는 것이 중요합니다.",83,156
100,1,100,시스템 내의 정보는 오직 인가된 사용자만 수정할 수 있는 보안 요소는?,,기밀성,부인방지,가용성,무결성,4,"시스템 내의 정보를 오직 인가된 사용자만 수정할 수 있도록 하는 보안 요소는 무결성입니다.  무결성은 데이터의 정확성, 완전성, 일관성을 유지하는 것을 의미합니다.  인가되지 않은 사용자가 데이터를 변경하거나 삭제하면 데이터의 무결성이 깨지게 되죠.  따라서, 인가된 사용자만 수정할 수 있도록 제한하는 것은 데이터의 무결성을 보장하는 중요한 보안 요소입니다.  반면 기밀성은 정보의 비밀을 유지하는 것이고, 부인방지는 행위를 부인하지 못하도록 하는 것이며, 가용성은 필요한 시점에 정보에 접근할 수 있는 능력을 의미합니다.  문제에서 요구하는 것은 정보의 수정 권한을 인가된 사용자에게만 부여하는 것이므로 무결성이 가장 적절한 답입니다.",45,153
101,2,1,요구사항 분석 시에 필요한 기술로 가장 거리가 먼 것은?,,청취와 인터뷰 질문 기술,분석과 중재기술,설계 및 코딩 기술,관찰 및 모델 작성 기술,3,"요구사항 분석은 사용자의 요구를 정확하게 파악하고 시스템에 반영하는 과정입니다.  청취와 인터뷰, 분석과 중재, 관찰과 모델 작성은 모두 사용자의 요구를 효과적으로 수집하고 이해하는 데 필요한 기술입니다.  예를 들어, 인터뷰를 통해 사용자의 니즈를 직접 듣고, 관찰을 통해 사용자의 행동 패턴을 분석하고, 이를 바탕으로 시스템의 모델을 만들 수 있습니다.  하지만 설계 및 코딩 기술은 시스템을 구현하는 단계에서 필요한 기술이지, 사용자의 요구를 분석하는 단계에서는 직접적으로 사용되지 않습니다.  요구사항 분석 단계에서는 사용자의 요구를 명확히 이해하고 문서화하는 것이 중요하며, 실제 코딩은 그 이후의 단계에서 진행됩니다. 따라서 요구사항 분석 시에 필요한 기술로 가장 거리가 먼 것은 설계 및 코딩 기술입니다.",90,102
102,2,2,다음 내용이 설명하는 디자인 패턴은?,https://www.cbtbank.kr/images/iz/iz20200822/iz20200822m2.gif,Visitor패턴,Observer패턴,Factory Method 패턴,Bridge 패턴,3,"문제에서 설명하는 디자인 패턴은 **Factory Method 패턴**입니다.  Factory Method 패턴은 객체를 생성하는 방법을 서브클래스로 위임하는 디자인 패턴입니다.  즉, 어떤 종류의 객체를 만들지는 미리 정해져 있지 않고, 서브클래스에서 필요에 따라 객체의 종류를 결정하여 생성합니다.  마치 공장(Factory)에서 여러 종류의 제품을 만들 수 있는 것과 같습니다.  문제에서 ""객체를 생성하기 위한 인터페이스를 정의하며 어떤 클래스가 인스턴스화 될 것인지는 서브 클래스가 결정하도록 하는 것""이라고 설명하고 있는데, 이는 Factory Method 패턴의 핵심 개념을 정확하게 나타냅니다.  ""Virtual Constructor""라고도 불리는 이유는,  일반적인 생성자처럼 객체를 생성하지만, 어떤 클래스의 객체를 생성할지는 런타임에 결정되기 때문에 가상적인 생성자처럼 동작하기 때문입니다.  이를 통해 코드의 유연성과 확장성을 높일 수 있습니다.",73,107
103,2,3,럼바우 객체 지향 분석과 거리가 먼 것은?,,기능 모델링,동적 모델링,객체 모델링,정적 모델링,4,"럼바우 객체 지향 분석은 시스템을 객체들의 상호작용으로 모델링하는 방법입니다.  객체 모델링은 객체의 속성과 연산을 정의하고, 객체들 간의 관계를 나타내는 정적인 측면을 다룹니다.  동적 모델링은 객체들의 상호작용과 시간에 따른 변화를 나타내는 측면을 다루고, 기능 모델링은 시스템의 기능을 분해하고 표현하는 것을 목표로 합니다.  정적 모델링은 시스템의 구조와 구성요소 간의 관계를 시간에 무관하게 표현하는 것이므로, 객체 모델링의 정적인 측면과 일치합니다. 따라서 럼바우 객체 지향 분석은 정적 모델링과 밀접한 관련이 있습니다.  문제에서 묻는 것은 럼바우 객체 지향 분석과 거리가 먼 것인데, 럼바우 분석은 시스템의 정적인 구조와 동적인 행위를 모두 고려하기 때문에 정적 모델링은 오히려 핵심적인 부분입니다.  따라서 정적 모델링이 아닌 다른 선택지가 정답이 됩니다.",92,107
104,2,4,애자일 기법에 대한 설명으로 맞지 않은 것은?,,절차와 도구보다 개인과 소통을 중요하게 생각한다.,계획에 중점을 두어 변경 대응이 난해하다.,소프트웨어가 잘 실행되는데 가치를 둔다.,고객과의 피드백을 중요하게 생각한다.,2,"애자일 기법은 소프트웨어 개발 방법론 중 하나로,  변화에 유연하게 대처하고 고객과의 협업을 강조하는 방식입니다.  문제에서 제시된 보기들을 살펴보면, 1번은 애자일의 핵심 가치인 '개인과의 소통'을 강조하고 있고, 3번은 고객에게 가치 있는 소프트웨어를 제공하는 것을 목표로 한다는 점에서 애자일의 특징을 잘 나타냅니다. 4번 또한 고객 피드백을 중요시하는 애자일의 특징을 보여줍니다.  반면 2번은 ""계획에 중점을 두어 변경 대응이 난해하다""라고 하는데, 애자일은 오히려 계획보다 유연성과 변경에 대한 빠른 대응을 중요시하기 때문에 애자일 기법에 대한 설명으로는 적절하지 않습니다. 애자일은 변화하는 요구사항에 맞춰 계획을 지속적으로 수정하고 개선하는 반복적인 개발 프로세스를 사용합니다. 따라서 계획에 얽매여 변경에 대응하기 어렵다는 것은 애자일의 특징과 정반대입니다.",92,102
105,2,5,미들웨어 솔루션의 유형에 포함되지 않는 것은?,,WAS,Web Server,RPC,ORB,2,"이 문제는 미들웨어 솔루션의 종류를 묻고 있습니다. 미들웨어는 애플리케이션과 운영체제 사이에서 동작하며 애플리케이션 간의 상호 작용을 원활하게 해주는 소프트웨어입니다.  WAS(Web Application Server)는 웹 애플리케이션을 실행하고 관리하는 미들웨어이고, RPC(Remote Procedure Call)는 원격 프로시저 호출을 위한 미들웨어, ORB(Object Request Broker)는 분산 객체 환경에서 객체 간의 통신을 지원하는 미들웨어입니다. 반면 웹 서버는 정적인 웹 페이지를 제공하는 역할을 하며, 애플리케이션 자체를 실행하거나 애플리케이션 간의 상호 작용을 중개하는 미들웨어의 역할은 하지 않습니다. 따라서 웹 서버는 미들웨어 솔루션의 유형에 포함되지 않습니다.  쉽게 말해, 웹 서버는 집의 현관문이고, WAS, RPC, ORB는 집 안에서 여러 방들을 연결해주는 통로와 같은 역할을 합니다.",73,110
106,2,6,UML에서 시퀀스 다이어그램의 구성 항목에 해당하지 않는 것은?,,생명선,실행,확장,메시지,3,"시퀀스 다이어그램은 시스템의 동작을 시간 순서에 따라 보여주는 UML 다이어그램입니다.  생명선(Lifeline)은 객체의 수명주기를 나타내는 수직선이고, 실행(Activation)은 객체가 메시지를 처리하는 동안의 활성화 상태를 나타내는 사각형이며, 메시지(Message)는 객체 간의 상호작용을 나타내는 화살표입니다.  반면, 확장(Extension)은 시퀀스 다이어그램의 구성 요소가 아니며, 특정 조건 하에서 발생하는 예외적인 상황이나 대체적인 동작을 표현할 때 사용하는 것은 루프, 조건문, alt, opt 등의 다양한 요소를 활용합니다. 따라서 시퀀스 다이어그램의 구성 항목에 해당하지 않는 것은 확장입니다.  정보처리기사 공식 교재에서는 시퀀스 다이어그램의 기본 구성 요소로 생명선, 실행, 메시지를 설명하고 있으며, 확장은 별도의 제어 흐름을 표현하는 요소로 다루고 있을 것입니다.",63,102
107,2,7,객체지향에서 정보 은닉과 가장 밀접한 관계가 있는 것은?,,Encapsulation,Class,Method,Instance,1,"객체지향 프로그래밍(OOP)에서 정보 은닉(Data Hiding)이란, 객체 내부의 데이터(멤버 변수)를 외부에서 직접 접근하지 못하도록 숨기는 것을 의미합니다.  외부에서 데이터에 접근하려면 객체가 제공하는 메서드(함수)를 이용해야 합니다. 이를 통해 데이터의 무결성을 보장하고, 코드의 유지보수 및 확장성을 높일 수 있습니다.  정보 은닉을 구현하는 핵심 개념이 바로 캡슐화(Encapsulation)입니다. 캡슐화는 데이터와 데이터를 처리하는 메서드를 하나의 단위(클래스)로 묶어서, 데이터를 보호하고 코드의 재사용성을 높이는 것을 말합니다.  클래스는 객체의 설계도이고, 메서드는 객체가 수행하는 동작이며, 인스턴스는 클래스를 바탕으로 생성된 실제 객체입니다. 따라서 정보 은닉과 가장 밀접한 관계를 갖는 것은 캡슐화(Encapsulation)입니다.",89,107
108,2,8,디자인 패턴 중에서 행위적 패턴에 속하지 않는 것은?,,커맨드 (Command) 패턴,옵저버 (Observer) 패턴,프로토타입 (Prototype) 패턴,상태 (State) 패턴,3,"디자인 패턴은 소프트웨어 개발에서 자주 발생하는 문제에 대한 재사용 가능한 해결책을 제공하는 설계 원칙입니다.  행위적 패턴은 객체 간의 상호 작용과 책임 분배에 초점을 맞춰 객체의 행위를 정의하고 관리하는 패턴들을 의미합니다.  커맨드(Command), 옵저버(Observer), 상태(State) 패턴은 모두 객체의 행위를 다루는 방식에 대한 해결책을 제시하는 행위적 패턴입니다. 반면, 프로토타입(Prototype) 패턴은 객체의 생성 방식에 초점을 맞춘 생성 패턴입니다.  프로토타입 패턴은 기존 객체를 복제하여 새로운 객체를 생성하는 방법을 제공하며, 객체의 행위보다는 객체의 생성에 중점을 둡니다. 따라서 행위적 패턴에 속하지 않는 것은 프로토타입 패턴입니다.  정보처리기사 공식 교재에서는 디자인 패턴을 객체지향 설계의 중요한 부분으로 다루며, 각 패턴의 특징과 사용 예시를 설명하고 있습니다.  이 문제는 다양한 디자인 패턴 중에서 행위적 패턴의 개념을 이해하고 있는지 묻는 문제입니다.",71,107
109,2,9,UI 설계 원칙 중 누구나 쉽게 이해하고 사용할 수 있어야 한다는 원칙은?,,희소성,유연성,직관성,멀티운용성,3,"UI 설계 원칙 중 '누구나 쉽게 이해하고 사용할 수 있어야 한다'는 원칙은 **직관성**을 의미합니다.  직관성이 높은 UI는 사용자가 별도의 설명이나 학습 없이도 쉽게 기능을 이해하고 사용할 수 있도록 디자인된 인터페이스를 말합니다.  복잡한 기능을 간결하고 명확하게 표현하여 사용자의 인지 부하를 줄이고, 효율적인 작업 수행을 가능하게 합니다.  반면 직관성이 떨어지는 UI는 사용자가 기능을 찾거나 사용하는 데 어려움을 겪게 만들어 사용자 경험을 저해합니다.  따라서 좋은 UI 디자인을 위해서는 직관성을 최우선적으로 고려해야 합니다.  문제에서 제시된 다른 선택지들은 UI 설계에 중요한 요소이지만, '누구나 쉽게 이해하고 사용할 수 있다'는 의미와는 직접적으로 연결되지 않습니다.",93,104
110,2,10,코드의 기본 기능으로 거리가 먼 것은?,,복잡성,표준화,분류,식별,1,"코드의 기본 기능은 데이터를 처리하고, 명령을 실행하며, 문제를 해결하는 데 있습니다.  복잡성은 코드의 특징 중 하나일 수 있지만, 코드의 기본적인 기능 자체는 아닙니다.  코드는 복잡할 수도 있고 간단할 수도 있지만,  기본적으로는 명확한 목적을 가지고 특정 작업을 수행하도록 설계됩니다. 표준화, 분류, 식별은 코드를 작성하고 관리하는 데 필요한 요소이지, 코드가 본질적으로 가지는 기능은 아닙니다.  표준화된 코드는 가독성과 유지보수성이 향상되고, 분류와 식별을 통해 코드를 효율적으로 관리할 수 있지만, 이러한 요소들은 코드의 근본적인 기능과는 다릅니다. 따라서 코드의 기본 기능과 거리가 먼 것은 '복잡성'입니다.",94,106
111,2,11,다음 ( ) 안에 들어갈 내용으로 옳은 것은?,https://www.cbtbank.kr/images/iz/iz20200822/iz20200822m11.gif,협약(Contract),프로토콜(Protocol),패턴(Pattern),관계(Relation),1,"이 문제는 소프트웨어 컴포넌트 설계 시 중요한 개념인 '계약(Contract)'에 대한 이해를 묻고 있습니다.  컴포넌트는 독립적으로 개발되고 다른 컴포넌트와 상호작용하는데, 이때 컴포넌트 간의 명확한 인터페이스 정의가 필수적입니다.  '계약에 의한 설계'는 이러한 인터페이스를 계약(Contract)으로 정의하여 컴포넌트 간의 상호작용을 명확하게 규정하는 방법입니다.  계약은 컴포넌트가 제공하는 서비스(오퍼레이션)에 대한 선행조건, 결과조건, 그리고 불변조건을 명시합니다.  선행조건은 서비스 사용 전에 충족되어야 하는 조건이고, 결과조건은 서비스 사용 후 만족되어야 하는 조건이며, 불변조건은 서비스 실행 중 항상 유지되어야 하는 조건입니다.  이러한 계약을 통해 컴포넌트 간의 오류를 줄이고, 재사용성과 유지보수성을 높일 수 있습니다.  반면, 프로토콜은 통신 규약, 패턴은 반복되는 설계 해결책, 관계는 데이터베이스의 관계를 의미하므로 문제의 맥락과는 맞지 않습니다. 따라서 정답은 1번 협약(Contract)입니다.",81,106
112,2,12,"UML에서 활용되는 다이어그램 중, 시스템의 동작을 표현하는 행위(Behavioral) 다이어그램에 해당하지 않는 것은?",,유스케이스 다이어그램(Use Case Diagram),시퀀스 다이어그램(Sequence Diagram),활동 다이어그램(Activity Diagram),배치 다이어그램(Deployment Diagram),4,"이 문제는 UML 다이어그램의 종류와 각 다이어그램이 표현하는 내용을 이해하고 있는지 묻는 문제입니다. UML(Unified Modeling Language)은 소프트웨어 시스템을 시각적으로 모델링하는 표준 언어입니다.  UML 다이어그램은 크게 구조(Structural) 다이어그램과 행위(Behavioral) 다이어그램으로 나뉘는데, 행위 다이어그램은 시스템의 동작이나 행위를 표현합니다.  문제에서 제시된 1번, 2번, 3번 다이어그램(유스케이스 다이어그램, 시퀀스 다이어그램, 활동 다이어그램)은 모두 시스템의 동작을 다양한 관점에서 보여주는 행위 다이어그램입니다. 반면, 4번의 배치 다이어그램은 시스템의 물리적인 구성 요소와 그들의 배치를 보여주는 구조 다이어그램입니다. 따라서 시스템의 동작을 표현하는 행위 다이어그램에 해당하지 않는 것은 배치 다이어그램입니다.  쉽게 말해, 행위 다이어그램은 ""무엇을 하는가""를 보여주고, 구조 다이어그램은 ""무엇으로 구성되는가""를 보여준다고 생각하면 이해하기 쉽습니다.",71,102
113,2,13,객체 지향 소프트웨어 공학에서 하나 이상의 유사한 객체들을 묶어서 하나의 공통된 특성을 표현한 것은?,,트랜지션,클래스,시퀀스,서브루틴,2,"객체 지향 소프트웨어 공학에서 객체란, 특정한 속성(데이터)과 행위(메서드)를 가지는 실체를 말합니다.  예를 들어, ""강아지""라는 객체는 ""털 색깔"", ""크기"", ""짖는다"", ""뛰어논다"" 와 같은 속성과 행위를 가질 수 있습니다.  여러 개의 강아지 객체는 각각 다른 속성 값을 가질 수 있지만, 모두 ""강아지""라는 공통된 특징을 가지고 있습니다.  이처럼 유사한 객체들의 공통된 특성을 표현하기 위해 사용하는 것이 바로 ""클래스""입니다. 클래스는 객체의 설계도와 같다고 생각하면 됩니다.  클래스를 정의하면, 그 클래스를 바탕으로 여러 개의 객체를 만들 수 있습니다. 따라서 하나 이상의 유사한 객체들을 묶어서 하나의 공통된 특성을 표현한 것은 클래스입니다.  다른 선택지는 객체 지향 프로그래밍과 직접적인 관련이 없습니다. 트랜지션은 상태 변화를, 시퀀스는 객체 간의 상호 작용 순서를, 서브루틴은 특정 기능을 수행하는 코드 블록을 나타냅니다.",92,107
114,2,14,아래의 UML 모델에서 '차' 클래스와 각 클래스의 관계로 옳은 것은?,https://www.cbtbank.kr/images/iz/iz20200822/iz20200822m14.gif,추상화 관계,의존 관계,일반화 관계,그룹 관계,3,"문제에서 제시된 UML 모델은 '차'라는 상위 개념(부모 클래스) 아래에 '버스', '트럭', '택시'라는 하위 개념(자식 클래스)들이 속해있는 구조를 보여줍니다.  이는 객체지향 프로그래밍에서 상위 클래스가 하위 클래스의 공통적인 특징을 가지고, 하위 클래스는 상위 클래스의 특징을 상속받는 일반화(Generalization) 관계를 나타냅니다.  '차'라는 클래스는 '버스', '트럭', '택시'의 공통적인 속성(바퀴, 엔진 등)과 기능(주행 등)을 정의하고, 각 하위 클래스는 자신만의 고유한 속성(좌석 수, 적재 용량 등)과 기능을 추가적으로 정의할 수 있습니다.  따라서 '차'와 그 하위 클래스들의 관계는 일반화 관계가 됩니다.  추상화는 공통적인 특징을 추출하는 과정이고, 의존 관계는 한 클래스가 다른 클래스의 기능에 의존하는 관계이며, 그룹 관계는 클래스들을 그룹으로 묶는 관계이므로 문제의 UML 모델과는 맞지 않습니다.",75,102
115,2,15,객체지향 소프트웨어 설계시 디자인 패턴을 구성하는 요소로서 가장 거리가 먼 것은?,,개발자이름,문제 및 배경,사례,샘플코드,1,"객체지향 소프트웨어 설계에서 디자인 패턴은 소프트웨어 개발 과정에서 자주 발생하는 문제에 대한 재사용 가능한 해결책을 제공하는 일종의 템플릿입니다.  디자인 패턴을 구성하는 요소는 문제 상황, 해결책, 그리고 그 해결책을 적용하는 방법 등을 포함합니다.  개발자의 이름은 디자인 패턴 자체의 구성 요소가 아니며, 디자인 패턴의 적용 여부나 효율성에 영향을 미치지 않습니다. 디자인 패턴은 특정 개발자에게 국한되지 않고, 누구나 재사용할 수 있는 일반적인 해결책을 제공하는 것이 목적입니다. 따라서 디자인 패턴을 구성하는 요소로서 개발자 이름은 가장 거리가 멉니다.  문제, 배경, 사례, 샘플 코드는 디자인 패턴을 이해하고 적용하는 데 필요한 정보들을 제공하는 요소들입니다.",93,107
116,2,16,자료 사전에서 자료의 반복을 의미하는 것은?,,=,( ),{ },[ ],3,"자료 사전에서 자료의 반복을 나타내는 기호는 중괄호 `{}`입니다.  중괄호 안에 여러 개의 자료가 들어가면, 그 자료들이 반복되는 것을 의미합니다. 예를 들어, `{A, B, C}` 라면 A, B, C가 반복될 수 있음을 나타냅니다.  다른 기호들은 자료의 반복을 나타내는 데 사용되지 않습니다. `=`는 대입 연산자, `()`는 괄호, `[]`는 대괄호로 각각 다른 용도로 사용됩니다. 따라서 자료의 반복을 표현하는 가장 적절한 기호는 중괄호 `{}`입니다.  이는 정보처리기사 시험에서 자료구조를 다룰 때 자주 접하게 되는 개념입니다.",81,111
117,2,17,"객체지향 설계 원칙 중, 서브타입(상속받은 하위 클래스)은 어디에서나 자신의 기반타입(상위클래스)으로 교체할 수 있어야 함을 의미하는 원칙은?",,ISP(Interface Segregation Principle),DIP(Dependency Inversion Principle),LSP(Liskov Substitution Principle),SRP(Single Responsibility Principle),3,"객체지향 설계 원칙 중 LSP(Liskov Substitution Principle, 리스코프 치환 원칙)은 상속을 통해 만들어진 하위 클래스(서브타입)의 객체가 언제든지 상위 클래스(기반 타입)의 객체와 바꿔서 사용해도 프로그램의 정상적인 동작에 문제가 없어야 한다는 원칙입니다.  쉽게 말해, 자식 클래스가 부모 클래스를 대체해도 프로그램이 제대로 작동해야 한다는 의미입니다.  만약 자식 클래스를 부모 클래스 대신 사용했을 때 프로그램이 예상치 못한 오류를 발생시킨다면, LSP 원칙을 위반한 것입니다.  이는 코드의 유지보수성과 확장성을 높이는 데 매우 중요한 원칙입니다.  예를 들어, 사각형 클래스를 상속받아 정사각형 클래스를 만들었다면, 정사각형 객체는 사각형 객체가 사용되는 어떤 곳에도 문제없이 대체되어야 합니다.  만약 정사각형의 높이를 변경하면 너비도 자동으로 변경되는 등의 특수한 동작이 있다면 LSP 원칙을 위반할 수 있습니다.",71,107
118,2,18,자료흐름도(Data Flow Diagram)의 구성요소로 옳은 것은?,,"process, data flow, data store, comment","process, data flow, data store, terminator","data flow, data store, terminator, data dictionary","process, data store, terminator, mini-spec",2,"자료흐름도(DFD)는 시스템의 자료 흐름을 그림으로 표현하는 기법입니다.  시스템 내에서 자료가 어떻게 생성, 처리, 저장, 그리고 소멸되는지를 시각적으로 보여주는 도구죠.  문제에서 제시된 구성요소들을 살펴보면,  '프로세스(Process)'는 자료를 처리하는 작업을, '자료흐름(Data Flow)'은 자료가 이동하는 경로를, '자료저장소(Data Store)'는 자료를 저장하는 장소를, '종단(Terminator)'은 시스템의 외부와 상호작용하는 개체(사람, 다른 시스템 등)를 나타냅니다.  정답 2번은 이 네 가지 요소를 모두 포함하고 있으므로 자료흐름도의 구성요소로 옳습니다.  다른 보기들은 일부 요소가 빠져있거나, 자료흐름도와 직접적인 관련이 없는 요소(데이터 딕셔너리, 미니 스펙)를 포함하고 있습니다. 따라서 자료흐름도의 핵심 구성요소는 프로세스, 자료흐름, 자료저장소, 종단입니다.",87,103
119,2,19,CASE(Computer-Aided Software Engineering)도구에 대한 설명으로 거리가 먼 것은?,,소프트웨어 개발 과정의 일부 또는 전체를 자동화하기 위한 도구이다.,표준화된 개발 환경 구축 및 문서 자동화 기능을 제공한다.,작업 과정 및 데이터 공유를 통해 작업자간 커뮤니케이션을 증대한다.,"2000년대 이후 소개되었으며, 객체지향 시스템에 한해 효과적으로 활용된다.",4,"CASE 도구는 소프트웨어 개발 과정을 효율적으로 지원하는 도구입니다.  1번과 2번은 CASE 도구의 주요 기능을 정확하게 설명하고 있습니다. 자동화를 통해 개발 시간을 단축하고, 표준화된 환경을 제공하여 개발 품질을 높이는 데 기여합니다. 3번 또한 CASE 도구가 개발팀 내부의 소통을 원활하게 하는 데 도움이 된다는 점을 보여주는 설명입니다. 하지만 4번은 잘못된 설명입니다. CASE 도구는 객체지향 시스템에만 국한되지 않고, 다양한 소프트웨어 개발 방식에 적용될 수 있으며, 2000년대 이전부터 사용되어 왔습니다.  따라서 4번이 CASE 도구에 대한 설명으로 거리가 멉니다.",84,103
120,2,20,인터페이스 요구 사항 검토 방법에 대한 설명이 옳은 것은?,,"리팩토링 : 작성자 이외의 전문 검토 그룹이 요구사항 명세서를 상세히 조사하여 결함, 표준 위배, 문제점 등을 파악",동료검토 : 요구 사항 명세서 작성자가 요구 사항 명세서를 설명하고 이해관계자들이 설명을 들으면서 결함을 발견,인스펙션 : 자동화된 요구 사항 관리 도구를 이용하여 요구 사항 추적성과 일관성을 검토,CASE 도구 : 검토 자료를 회의 전에 배포해서 사전 검토한 후 짧은 시간 동안 검토 회의를 진행하면서 결함을 발견,2,"문제에서 제시된 네 가지 인터페이스 요구사항 검토 방법 중 정답은 2번, 동료 검토입니다.  각각의 방법을 살펴보면, 1번 리팩토링은 코드 개선을 위한 활동으로 요구사항 검토와는 관련이 없습니다. 3번 인스펙션은 자동화 도구를 이용한 검토를 설명하지만, 문제에서는 사람에 의한 검토 방법을 묻고 있습니다. 4번 CASE 도구는 요구사항 관리 도구를 활용하는 방법을 설명하지만, 동료 검토처럼 작성자의 설명과 이해관계자의 참여를 강조하지 않습니다.  반면 2번 동료 검토는 요구사항 명세서 작성자가 직접 설명하고 이해관계자들이 함께 검토하는 방식으로,  실제로 요구사항의 오류나 누락을 발견하는데 효과적인 방법입니다.  이는 정보처리기사 시험에서 강조하는 실무적인 요구사항 검토 방법과 일치합니다.  즉, 작성자의 설명을 듣고 이해관계자들이 함께 검토하는 과정을 통해 요구사항의 명확성과 정확성을 높이는 것이 핵심입니다.",75,108
121,2,21,인터페이스 보안을 위해 네트워크 영역에 적용될 수 있는 솔루션과 거리가 먼 것은?,,IPSec,SSL,SMTP,S-HTTP,3,"이 문제는 네트워크 영역에서 인터페이스 보안을 위해 사용되는 솔루션들을 묻고 있습니다.  IPSec과 SSL은 네트워크 통신을 안전하게 보호하는 데 사용되는 프로토콜입니다. IPSec은 IP 패킷 자체를 암호화하여 네트워크 계층에서 보안을 제공하고, SSL(현재는 TLS로 더 많이 불립니다)은 웹 브라우저와 웹 서버 간의 통신을 안전하게 보호하는 데 사용됩니다.  반면 SMTP는 이메일 전송 프로토콜이고, S-HTTP는 HTTP의 보안 버전으로 웹 상에서의 안전한 데이터 전송을 위한 프로토콜입니다.  하지만 SMTP는 이메일 전송 자체에 초점을 맞춘 프로토콜이지 네트워크 영역의 보안을 직접적으로 다루는 프로토콜이 아니므로, 네트워크 영역의 인터페이스 보안 솔루션과는 거리가 멉니다. 따라서 정답은 3번 SMTP입니다.  쉽게 말해, SMTP는 이메일을 보내는 데 쓰는 우편 배달부와 같고, IPSec과 SSL은 그 우편물을 안전하게 포장하고 배송하는 보안 장치와 같은 역할을 합니다.",87,153
122,2,22,소프트웨어 공학의 기본 원칙이라고 볼 수 없는 것은?,,품질 높은 소프트웨어 상품 개발,지속적인 검증 시행,결과에 대한 명확한 기록 유지,최대한 많은 인력 투입,4,"소프트웨어 공학의 기본 원칙은 효율적이고 효과적인 소프트웨어 개발을 위한 지침입니다.  품질 높은 소프트웨어를 개발하고, 지속적으로 검증하며, 결과를 명확하게 기록하는 것은 모두 소프트웨어 개발의 성공을 위한 필수적인 요소입니다. 하지만 최대한 많은 인력을 투입하는 것이 항상 좋은 결과를 보장하는 것은 아닙니다.  인력 투입은 개발 비용 증가와 관리의 어려움을 야기할 수 있으며,  개발 과정의 효율성을 저해할 수도 있습니다.  소프트웨어 개발은 적절한 인력과 효율적인 프로세스 관리를 통해 최고의 결과를 얻는 것이 중요합니다. 따라서 '최대한 많은 인력 투입'은 소프트웨어 공학의 기본 원칙이라고 보기 어렵습니다.  인력의 질과 효율적인 협업이 더 중요한 요소입니다.",94,147
123,2,23,패키지 소프트웨어의 일반적인 제품 품질 요구사항 및 테스트를 위한 국제 표준은?,,ISO/IEC 2196,IEEE 19554,ISO/IEC 12119,ISO/IEC 14959,3,"이 문제는 패키지 소프트웨어의 품질 요구사항과 테스트를 위한 국제 표준을 묻고 있습니다.  여러 국제 표준 중에서 ISO/IEC 12119는 소프트웨어 제품의 품질 특성과 테스트에 대한 요구사항을 다루는 표준입니다.  쉽게 말해,  소프트웨어를 만들고 판매할 때 어떤 품질을 갖춰야 하고, 그 품질을 검증하기 위해 어떤 테스트를 해야 하는지에 대한 국제적인 규칙을 정의한 것이죠.  다른 선택지들은 소프트웨어 품질이나 테스트와 관련이 있을 수 있지만, 패키지 소프트웨어의 품질 요구사항과 테스트에 특화된 표준은 ISO/IEC 12119입니다. 따라서 정답은 3번입니다.",72,117
124,2,24,다음 중 클린 코드 작성원칙으로 거리가 먼 것은?,,누구든지 쉽게 이해하는 코드 작성,중복이 최대화된 코드 작성,다른 모듈에 미치는 영향 최소화,"단순, 명료한 코드 작성",2,"클린 코드 작성 원칙은 코드의 가독성을 높이고 유지보수를 용이하게 하기 위한 지침입니다.  1번의 '누구든지 쉽게 이해하는 코드 작성'과 4번의 '단순, 명료한 코드 작성'은 모두 코드의 가독성을 높이는 데 초점을 맞춘 원칙입니다. 3번의 '다른 모듈에 미치는 영향 최소화'는 모듈 간의 결합도를 낮추어 코드의 유지보수성을 높이는 원칙입니다. 반면, 2번의 '중복이 최대화된 코드 작성'은 클린 코드 원칙과 정반대입니다. 중복 코드는 유지보수 비용을 증가시키고, 코드의 가독성을 떨어뜨리며, 오류 발생 가능성을 높입니다. 클린 코드는 중복을 최소화하여 코드의 효율성과 유지보수성을 높이는 것을 목표로 합니다. 따라서 정답은 2번입니다. 정보처리기사 공식 교재에서는 클린 코드 작성에 대한 구체적인 내용은 다루지 않지만,  소프트웨어 공학적 관점에서 코드의 가독성, 유지보수성, 재사용성을 높이는 방법을 설명하는 부분에서 이 원칙을 간접적으로 다루고 있습니다.",94,107
125,2,25,블랙박스 테스트의 유형으로 틀린 것은?,,경계값 분석,오류 예측,동등 분할 기법,"조건, 루프 검사",4,"블랙박스 테스트는 소프트웨어의 내부 구조를 알지 못하고, 입력값과 출력값만을 가지고 테스트하는 방법입니다.  문제에서 제시된 1번 경계값 분석, 2번 오류 예측, 3번 동등 분할 기법은 모두 블랙박스 테스트의 대표적인 유형입니다. 경계값 분석은 입력값의 경계선을 중심으로 테스트하는 것이고, 오류 예측은 과거 경험이나 데이터를 바탕으로 발생 가능한 오류를 예측하여 테스트하는 것이며, 동등 분할 기법은 입력값을 여러 개의 동등한 그룹으로 나누어 각 그룹에서 대표값을 선택하여 테스트하는 기법입니다.  반면 4번 조건, 루프 검사는 화이트박스 테스트의 유형입니다. 화이트박스 테스트는 소프트웨어의 내부 구조와 코드를 알고 테스트하는 방법으로, 조건문이나 반복문(루프)의 모든 경로를 검사하는 것을 포함합니다. 따라서 블랙박스 테스트의 유형으로 틀린 것은 4번 조건, 루프 검사입니다.",74,119
126,2,26,제어흐름 그래프가 다음과 같을 때 McCabe의 cyclomatic 수는 얼마인가?,https://www.cbtbank.kr/images/iz/iz20200822/iz20200822m26.gif,3,4,5,6,2,"McCabe의 cyclomatic 수는 소프트웨어의 복잡도를 측정하는 지표입니다.  제어 흐름 그래프에서 독립적인 경로의 수를 나타내며,  테스트 케이스의 최소 개수를 추정하는 데 사용됩니다.  제시된 그래프는 간단한 순차적인 흐름으로, 시작점에서 끝점까지 단 하나의 경로만 존재합니다.  따라서 분기(decision)가 없으므로 독립적인 경로의 수는 1개입니다.  McCabe의 cyclomatic 수는  `V(G) = E - N + 2P`  (E: 간선의 수, N: 노드의 수, P: 연결된 구성요소의 수) 공식으로 계산할 수도 있지만, 이 경우 더 간단하게 독립적인 경로의 수를 직접 세어도 됩니다.  하지만 문제에서 제시된 그래프가 단순한 선형 흐름이라면,  McCabe cyclomatic complexity는 1이 되어야 합니다.  문제의 정답이 2라고 제시되었으나, 제공된 정보만으로는 그 이유를 설명하기 어렵습니다.  제공된 그래프가 불완전하거나, 문제 자체에 오류가 있을 가능성이 있습니다.  만약 그래프에 분기(조건문 등)가 추가된다면 cyclomatic 수는 증가합니다. 예를 들어, 조건문이 하나 추가되면 cyclomatic 수는 2가 됩니다.  하지만 현재 그래프로는 2라는 답을 도출할 수 없습니다.  문제의 정답과 제시된 그래프가 일치하지 않으므로, 추가 정보가 필요합니다.",64,119
127,2,27,다음 자료에 대하여 선택(Selection) 정렬을 이용하여 오름차순으로 정렬하고자 한다. 3회전 후의 결과로 옳은 것은?,https://www.cbtbank.kr/images/iz/iz20200822/iz20200822m27.gif,"14, 17, 37, 40, 35","14, 37, 17, 40, 35","17, 14, 37, 35, 40","14, 17, 35, 40, 37",4,"선택 정렬은 주어진 자료들 중 가장 작은 값을 찾아서 맨 앞으로 보내는 과정을 반복하는 정렬 알고리즘입니다.  37, 14, 17, 40, 35를 오름차순으로 정렬하는 과정을 살펴보겠습니다.",69,111
128,2,28,형상 관리 도구의 주요 기능으로 거리가 먼 것은?,,정규화(Normalization),체크인(Check-in),체크아웃(Check-out),커밋(commit),1,"형상 관리 도구는 소프트웨어 개발 과정에서 소스 코드, 문서, 디자인 등의 변경 사항을 추적하고 관리하는 데 사용되는 도구입니다.  체크인(Check-in)은 변경된 내용을 저장소에 저장하는 기능이고, 체크아웃(Check-out)은 저장소에서 파일을 가져와 수정할 수 있도록 하는 기능이며, 커밋(Commit)은 변경 사항을 저장소에 반영하는 기능입니다.  반면 정규화(Normalization)는 데이터베이스 설계에서 데이터 중복을 최소화하고 데이터 무결성을 높이기 위한 기법으로, 형상 관리 도구의 기능과는 직접적인 관련이 없습니다.  따라서 형상 관리 도구의 주요 기능으로 거리가 먼 것은 정규화입니다.  쉽게 말해, 형상관리 도구는 소프트웨어 개발 과정에서 발생하는 모든 변경 사항을 기록하고 관리하는 역할을 하며, 정규화는 데이터베이스 설계 단계에서 데이터를 효율적으로 관리하기 위한 기법이기 때문에 서로 다른 영역에 속합니다.",71,115
129,2,29,다음 트리를 Preorder 운행법으로 운행할 경우 가장 먼저 탐색되는 것은?,https://www.cbtbank.kr/images/iz/iz20200822/iz20200822m29.gif,A,B,D,G,1,"이 문제는 트리 자료구조의 순회 방법 중 하나인 전위 순회(Preorder traversal)를 이해하고 있는지 묻는 문제입니다. 전위 순회는 트리를 탐색하는 방법 중 하나로,  먼저 루트 노드를 방문하고, 그 다음 왼쪽 서브트리를 순회하고, 마지막으로 오른쪽 서브트리를 순회하는 방식입니다.  주어진 트리에서 루트 노드는 A입니다. 따라서 전위 순회를 시작하면 가장 먼저 A 노드를 방문하게 되고, 그 후 B, D, ... 순으로 방문하게 됩니다.  따라서 가장 먼저 탐색되는 노드는 A입니다.",80,111
130,2,30,소프트웨어 품질 목표 중 주어진 시간동안 주어진 기능을 오류없이 수행하는 정도를 나타내는 것은?,,직관성,사용 용이성,신뢰성,이식성,3,"문제에서 묻고 있는 것은 소프트웨어의 품질 목표 중 하나입니다.  주어진 시간 안에 주어진 기능을 오류 없이 수행하는 정도를 나타내는 것은 바로 '신뢰성'입니다.  신뢰성이 높은 소프트웨어는 오류 없이 안정적으로 동작하여 사용자에게 예상대로의 결과를 제공합니다.  반대로 신뢰성이 낮은 소프트웨어는 자주 오류가 발생하거나 예상치 못한 결과를 내놓아 사용자에게 불편을 초래할 수 있습니다.  직관성이나 사용 용이성은 사용자 인터페이스와 관련된 품질 속성이고, 이식성은 다른 환경에서도 동작하는 정도를 나타내는 속성이므로 문제의 질문과는 부합하지 않습니다. 따라서 정답은 신뢰성(3번)입니다.",82,117
131,2,31,알고리즘 설계 기법으로 거리가 먼 것은?,,Divide and Conquer,Greedy,Static Block,Backtracking,3,"알고리즘 설계 기법은 문제를 해결하기 위한 단계적인 절차를 설계하는 방법론입니다.  Divide and Conquer(분할 정복), Greedy(탐욕적), Backtracking(백트래킹)은 모두 효율적인 알고리즘을 설계하는 데 사용되는 대표적인 기법들입니다.  Divide and Conquer는 문제를 작은 하위 문제로 나누어 해결하고, Greedy는 각 단계에서 가장 좋아 보이는 선택을 하는 방법이며, Backtracking은 모든 가능성을 탐색하며 해결책을 찾는 방법입니다.  반면 Static Block은 알고리즘 설계 기법이 아닙니다. Static Block은 특정 프로그래밍 언어(예: Java)에서 클래스 초기화에 사용되는 코드 블록으로, 알고리즘의 효율성이나 문제 해결 전략과는 직접적인 관련이 없습니다. 따라서 알고리즘 설계 기법과 거리가 먼 것은 Static Block입니다.",53,121
132,2,32,제품 소프트웨어의 형상 관리 역할로 틀린 것은?,,형상 관리를 통해 이전 리버전이나 버전에 대한 정보에 접근 가능하여 배포본 관리에 유용,불필요한 사용자의 소스 수정 제한,프로젝트 개발비용을 효율적으로 관리,동일한 프로젝트에 대해 여러 개발자 동시 개발 가능,3,"제품 소프트웨어의 형상 관리란 소프트웨어 개발 과정에서 발생하는 변경 사항들을 체계적으로 관리하고 추적하는 것을 말합니다.  1번의 경우, 이전 버전에 대한 접근이 가능하므로 배포본 관리에 유용하다는 것은 형상 관리의 중요한 장점입니다. 2번 역시,  소스 코드 수정을 제한하여 오류 발생을 줄이고 개발의 안정성을 확보하는 데 기여합니다. 4번 또한 여러 개발자가 동시에 작업할 수 있도록 지원하여 개발 속도를 높이는 데 도움이 됩니다. 하지만 3번, 프로젝트 개발 비용을 효율적으로 관리하는 것은 형상 관리의 직접적인 목표가 아닙니다. 형상 관리는 개발 과정의 효율성을 높여 *간접적으로* 비용 절감에 기여할 수는 있지만, 비용 자체를 직접 관리하는 기능은 아닙니다.  형상 관리는 소프트웨어의 품질과 안정성을 확보하고 개발 과정을 효율적으로 관리하는 데 초점을 맞추고 있기 때문입니다. 따라서 3번이 틀린 설명입니다.",58,115
133,2,33,제품 소프트웨어 패키징 도구 활용 시 고려사항이 아닌 것은?,,제품 소프트웨어의 종류에 적합한 암호화 알고리즘을 고려한다.,추가로 다양한 이기종 연동을 고려한다.,사용자 편의성을 위한 복잡성 및 비효율성 문제를 고려한다.,내부 콘텐츠에 대한 보안은 고려하지 않는다.,4,"제품 소프트웨어 패키징은 소프트웨어를 사용자에게 배포하기 위한 최종 단계입니다.  여기에는 소프트웨어 설치 파일을 만들고, 필요한 구성 요소들을 묶어서 배포하는 과정이 포함됩니다.  문제에서 제시된 1번, 2번, 3번은 모두 소프트웨어 패키징 과정에서 중요하게 고려해야 할 사항입니다.  1번은 소프트웨어의 안전한 배포를 위해 적절한 암호화 방식을 선택해야 함을 의미하고, 2번은 다양한 시스템과의 호환성을 고려해야 함을, 3번은 사용자의 편의성을 위해 패키징 과정을 최적화해야 함을 나타냅니다.  하지만 4번은 내부 콘텐츠에 대한 보안을 고려하지 않는다는 내용으로, 소프트웨어 패키징의 가장 중요한 목표 중 하나인 소프트웨어의 무결성과 보안을 위배합니다. 따라서 소프트웨어 패키징 과정에서는 반드시 내부 콘텐츠 보안을 고려해야 합니다.  정답은 4번입니다.",90,116
134,2,34,디지털 저작권 관리(DRM) 기술과 거리가 먼 것은?,,콘텐츠 암호화 및 키 관리,콘텐츠 식별체계 표현,콘텐츠 오류 감지 및 복구,라이센스 발급 및 관리,3,"디지털 저작권 관리(DRM) 기술은 디지털 콘텐츠의 저작권을 보호하기 위한 기술입니다.  콘텐츠 암호화 및 키 관리를 통해 콘텐츠 접근을 제한하고, 콘텐츠 식별체계 표현으로 콘텐츠의 출처와 저작권 정보를 명확히 하며, 라이센스 발급 및 관리를 통해 콘텐츠 이용 권한을 효율적으로 관리합니다.  반면, 콘텐츠 오류 감지 및 복구는 콘텐츠의 무결성을 유지하는 기술이지만, 저작권 보호와는 직접적인 관련이 없습니다.  DRM은 콘텐츠의 불법 복제 및 배포를 막는 데 초점을 맞추고 있기 때문에, 콘텐츠 자체의 오류 수정은 DRM의 주요 목표가 아니라고 할 수 있습니다. 따라서 콘텐츠 오류 감지 및 복구는 DRM 기술과 거리가 먼 기술입니다.",82,116
135,2,35,물리데이터 저장소의 파티션 설계에서 파티션 유형으로 옳지 않은 것은?,,범위분할(Range Partitioning),해시분할(Hash Partitioning),조합분할(Composite Partitioning),유닛분할(Unit Partitioning),4,"물리 데이터 저장소의 파티션 설계는 데이터베이스의 성능 향상을 위해 데이터를 여러 개의 작은 단위로 나누는 것을 의미합니다.  범위 분할은 데이터의 특정 범위를 기준으로 파티션을 나누는 방식이고, 해시 분할은 해시 함수를 이용하여 데이터를 분산시키는 방식이며, 조합 분할은 범위 분할과 해시 분할을 결합한 방식입니다.  반면에 '유닛 분할(Unit Partitioning)'이라는 파티션 유형은 일반적으로 데이터베이스 파티셔닝 기법에서 사용되지 않습니다.  따라서 4번이 옳지 않은 파티션 유형입니다.  쉽게 말해,  집을 여러 방으로 나누는 것처럼 데이터베이스를 효율적으로 관리하기 위해 데이터를 나누는 방법인데,  '유닛 분할'이라는 방법은 존재하지 않는 방법입니다.",55,132
136,2,36,다음이 설명하는 애플리케이션 통합 테스트 유형은?,https://www.cbtbank.kr/images/iz/iz20200822/iz20200822m36.gif,하향식 통합 테스트,상향식 통합 테스트,회귀 테스트,빅뱅 테스트,1,"애플리케이션 통합 테스트는 여러 개의 모듈이나 컴포넌트를 결합하여 하나의 시스템으로 동작하는지 확인하는 테스트입니다.  문제에서 설명하는 ""깊이 우선 방식 또는 너비 우선 방식"", ""상위 컴포넌트를 테스트하고 점증적으로 하위 컴포넌트를 테스트"", ""하위 컴포넌트 개발이 완료되지 않은 경우 스텁(Stub)을 사용""은 모두 하향식 통합 테스트의 특징입니다. 하향식 통합 테스트는 상위 모듈부터 테스트를 시작하여 점차 하위 모듈을 통합해 나가는 방식입니다.  깊이 우선 방식은 상위 모듈에서 가장 깊숙한 하위 모듈까지 테스트한 후, 다시 상위 레벨로 돌아와 다른 하위 모듈을 테스트하는 방식이고, 너비 우선 방식은 상위 모듈의 모든 하위 모듈을 먼저 테스트하는 방식입니다.  하위 모듈이 아직 개발되지 않았다면, 스텁이라는 더미 모듈을 사용하여 테스트를 진행할 수 있습니다. 반면 상향식 통합 테스트는 하위 모듈부터 테스트를 시작하여 점차 상위 모듈로 통합해 나가는 방식입니다.  빅뱅 테스트는 모든 모듈을 한꺼번에 통합하여 테스트하는 방식으로, 문제 상황과는 맞지 않습니다. 회귀 테스트는 이미 테스트된 부분에 새로운 오류가 발생하지 않았는지 확인하는 테스트입니다. 따라서 문제의 설명에 가장 적합한 답은 하향식 통합 테스트입니다.",90,120
137,2,37,인터페이스 구현시 사용하는 기술 중 다음 내용이 설명하는 것은?,https://www.cbtbank.kr/images/iz/iz20200822/iz20200822m37.gif,Procedure,Trigger,Greedy,AJAX,4,"문제에서 설명하는 기술은 JavaScript를 이용하여 클라이언트(예: 웹 브라우저)와 서버 사이에서 XML 데이터를 비동기적으로 주고받는 방식입니다.  비동기란 서버와의 통신이 완료될 때까지 기다리지 않고, 다른 작업을 계속 진행할 수 있다는 것을 의미합니다.  예를 들어, 웹페이지에서 버튼을 클릭하면 서버에 데이터를 요청하고, 서버가 응답하는 동안 사용자는 페이지의 다른 부분을 계속 사용할 수 있습니다.  AJAX(Asynchronous JavaScript and XML)는 이러한 비동기 통신을 구현하는 기술이며,  웹 페이지를 새로고침하지 않고도 부분적으로 내용을 업데이트하는 데 사용됩니다.  따라서 정답은 AJAX입니다.  Procedure, Trigger, Greedy는 데이터베이스나 알고리즘 관련 용어로,  웹 페이지의 비동기 통신과는 관련이 없습니다.",84,108
138,2,38,소프트웨어 재공학이 소프트웨어의 재개발에 비해 갖는 장점으로 거리가 먼 것은?,,위험부담 감소,비용 절감,시스템 명세의 오류억제,개발시간의 증가,4,"소프트웨어 재공학은 기존 소프트웨어 시스템을 분석하고 개선하여 새로운 시스템으로 변환하는 과정입니다.  재개발과 비교했을 때, 재공학은 기존 시스템의 기능과 데이터를 활용하기 때문에 위험 부담이 줄어들고 비용도 절감할 수 있습니다. 또한, 기존 시스템의 분석 과정을 통해 시스템 명세의 오류를 억제하는 데 도움이 됩니다. 하지만 재공학은 재개발보다 시간이 더 오래 걸릴 수 있습니다. 기존 시스템을 분석하고 이해하는 데 시간이 소요되며,  기능 개선 및 새로운 기술 적용 등의 과정도 추가적으로 필요하기 때문입니다. 따라서 소프트웨어 재공학이 소프트웨어 재개발에 비해 갖는 장점으로 거리가 먼 것은 '개발시간의 증가'입니다.",93,147
139,2,39,"알파, 베타 테스트와 가장 밀접한 연관이 있는 테스트 단계는?",,단위 테스트,인수 테스트,통합 테스트,시스템 테스트,2,"알파 테스트와 베타 테스트는 소프트웨어 개발의 마지막 단계에서 실제 사용자의 피드백을 얻기 위해 수행하는 테스트입니다.  알파 테스트는 개발팀 내부 또는 제한된 사용자 그룹을 대상으로 진행되며, 베타 테스트는 제품 출시 전에 훨씬 더 넓은 범위의 잠재적 사용자들에게 배포하여 실제 사용 환경에서의 성능과 사용성을 평가하는 테스트입니다.  따라서 알파, 베타 테스트는 개발이 완료된 후, 제품을 실제 사용 환경에 가깝게 적용하여 검증하는 단계이므로,  여러 테스트 단계 중에서도 특히 **인수 테스트(2)**와 가장 밀접한 관련이 있습니다. 인수 테스트는 시스템이 사용자의 요구사항을 충족하는지 확인하는 최종 단계의 테스트로, 알파 및 베타 테스트의 결과를 바탕으로 최종적인 검증을 수행합니다. 단위 테스트, 통합 테스트, 시스템 테스트는 인수 테스트 이전 단계의 테스트로, 알파, 베타 테스트와 직접적인 연관성이 낮습니다.",70,119
140,2,40,다음 트리의 차수(degree)는?,https://www.cbtbank.kr/images/iz/iz20200822/iz20200822m40.gif,2,3,4,5,2,"문제에서 제시된 트리는 루트 노드 A를 가지고 있습니다.  A는 B, C, F 세 개의 자식 노드를 가지고 있고, 각 자식 노드는 다시 다른 노드들을 자식으로 가질 수 있습니다.  트리의 차수(degree)는 루트 노드를 제외한 각 노드가 가질 수 있는 최대 자식 노드의 개수를 의미합니다.  문제의 트리에서 노드 B는 3개(D, E, F), 노드 C는 1개(G), 노드 F는 2개(H, I)의 자식 노드를 가지고 있습니다. 따라서 이 트리의 차수는 가장 많은 자식 노드를 가진 노드의 자식 노드 개수인 3이 됩니다. 하지만 문제의 정답은 2라고 제시되어 있습니다. 이는 문제에서 제시된 트리 그림이 잘못되었거나, 문제의 의도가 트리의 차수가 아닌 다른 개념을 묻고 있는 것일 수 있습니다.  문제의 그림이 없어 정확한 해석이 어렵지만, 제공된 정보만으로는 정답이 2가 되는 이유를 설명하기 어렵습니다.  제공된 정보를 바탕으로 추론해보면, 문제에서 특정 노드의 차수를 묻고 있을 가능성이 있으며, 그 노드의 차수가 2인 경우가 있을 수 있습니다.  하지만 문제의 그림이 없으므로 정확한 답변은 어렵습니다.",77,111
141,2,41,릴레이션 R의 모든 결정자(determinant)가 후보키이면 그 릴레이션 R은 어떤 정규형에 속하는가?,,제 1 정규형,제 2 정규형,보이스/코드 정규형,제 4 정규형,3,"릴레이션 R의 모든 결정자가 후보키라는 것은, 릴레이션의 어떤 속성 집합도 다른 속성 집합을 완벽하게 결정할 수 있다면, 그 속성 집합은 반드시 후보키여야 함을 의미합니다.  즉, 부분 함수 종속이나 이항 종속과 같은 이상 현상이 존재하지 않는다는 뜻입니다.  이러한 조건은 보이스-코드 정규형(BCNF)의 정의와 일치합니다.  제1, 2 정규형은 부분 함수 종속, 전이 종속 등의 이상 현상을 다루지만, 모든 결정자가 후보키라는 조건까지는 고려하지 않습니다. 제4 정규형은 다치 종속을 다루는 정규형으로, 문제의 조건과는 직접적인 관련이 없습니다. 따라서 모든 결정자가 후보키인 릴레이션은 보이스-코드 정규형을 만족합니다.",67,130
142,2,42,다음 관계형 데이터 모델에 대한 설명으로 옳은 것은?,https://www.cbtbank.kr/images/iz/iz20200822/iz20200822m42.gif,"relation 3개, attribute 3개, tuple 5개","relation 3개, attribute 5개, tuple 3개","relation 1개, attribute 5개, tuple 3개","relation 1개, attribute 3개, tuple 5개",4,"문제에서 제시된 표는 고객 정보를 나타내는 테이블입니다.  관계형 데이터 모델에서 테이블은 'relation'이라고 부르고, 테이블의 각 열(column)은 'attribute'라고 부르며, 각 행(row)은 'tuple'이라고 부릅니다.  표를 살펴보면, 고객 정보라는 하나의 relation이 있고,  '고객ID', '고객이름', '거주도시'라는 세 개의 attribute가 있으며,  홍길동, 이정재 등 다섯 명의 고객 정보를 나타내는 다섯 개의 tuple이 있습니다. 따라서 정답은 relation 1개, attribute 3개, tuple 5개인 4번입니다.",76,127
143,2,43,Commit과 Rollback 명령어에 의해 보장 받는 트랜잭션의 특성은?,,병행성,보안성,원자성,로그,3,"Commit과 Rollback 명령어는 데이터베이스 트랜잭션(Transaction)을 관리하는 데 사용됩니다.  트랜잭션이란 데이터베이스에 대한 일련의 작업들을 하나의 논리적 단위로 묶어서 처리하는 것을 말합니다.  예를 들어, 계좌 이체를 생각해보세요.  출금 계좌에서 돈을 빼고, 입금 계좌에 돈을 넣는 두 가지 작업이 하나의 트랜잭션으로 처리됩니다.  만약 출금은 성공했는데 입금이 실패하면 데이터베이스는 일관성을 잃게 되겠죠.  이런 문제를 해결하기 위해 Commit과 Rollback이 사용됩니다.",72,127
144,2,44,관계 데이터베이스인 테이블 R1에 대한 아래 SQL 문의 실행결과로 옳은 것은?,https://www.cbtbank.kr/images/iz/iz20200822/iz20200822m44.gif,https://www.cbtbank.kr/images/iz/iz20200822/iz20200822m44b1.gif,https://www.cbtbank.kr/images/iz/iz20200822/iz20200822m44b2.gif,https://www.cbtbank.kr/images/iz/iz20200822/iz20200822m44b3.gif,https://www.cbtbank.kr/images/iz/iz20200822/iz20200822m44b4.gif,2,"문제에서 제시된 SQL 문 `SELECT DISTINCT 학년 FROM R1;`은 테이블 R1에서 '학년' 컬럼의 값들을 가져오되, 중복되는 값은 하나만 출력하라는 의미입니다.  `DISTINCT` 키워드가 중복 제거를 담당합니다.  테이블 R1의 '학년' 컬럼에는 1, 2, 3의 값이 존재하며, 각각 여러 번 중복될 수 있지만 `DISTINCT` 때문에 각 학년은 한 번씩만 결과에 나타납니다. 따라서 정답은 2번,  '학년' 컬럼에 1, 2, 3이 각각 한 줄씩 출력되는 결과입니다. 1번은 중복된 학년이 출력되어 잘못되었고, 3번과 4번은 '이름' 컬럼까지 출력하도록 되어있어 문제의 요구사항과 일치하지 않습니다.",83,127
145,2,45,DCL(Data Control Language) 명령어가 아닌 것은?,,COMMIT,ROLLBACK,GRANT,SELECT,4,"데이터 제어 언어(DCL)은 데이터베이스의 접근 권한을 관리하고 트랜잭션을 제어하는 데 사용되는 SQL 명령어 집합입니다.  COMMIT 명령어는 트랜잭션을 성공적으로 완료하고 데이터베이스에 변경 사항을 영구적으로 저장하는 역할을 합니다. ROLLBACK 명령어는 트랜잭션 중 발생한 오류를 복구하고 이전 상태로 되돌리는 역할을 합니다. GRANT 명령어는 특정 사용자에게 데이터베이스 객체에 대한 접근 권한을 부여합니다. 반면 SELECT 명령어는 데이터베이스에서 데이터를 조회하는 데 사용되는 데이터 조작 언어(DML) 명령어입니다. 따라서 DCL 명령어가 아닌 것은 SELECT입니다.  쉽게 말해, COMMIT, ROLLBACK, GRANT는 데이터베이스의 '보안 및 관리'에 관련된 명령어이고, SELECT는 데이터를 '읽어오는' 명령어이기 때문에 다른 종류의 명령어입니다.",84,126
146,2,46,병행제어 기법 중 로킹에 대한 설명으로 옳지 않은 것은?,,로킹의 대상이 되는 객체의 크기를 로킹 단위라고 한다.,"데이터베이스, 파일, 레코드 등은 로킹 단위가 될 수 있다.",로킹의 단위가 작아지면 로킹 오버헤드가 증가한다.,로킹의 단위가 커지면 데이터베이스 공유도가 증가한다.,4,"로킹(Locking)은 여러 사용자가 동시에 데이터베이스에 접근하여 데이터를 변경하는 것을 방지하기 위한 병행 제어 기법입니다.  특정 데이터에 대한 접근을 일시적으로 제한하여 데이터의 일관성을 유지하는 것이죠.  문제에서 옳지 않은 것은 4번입니다. 로킹 단위가 커지면(예를 들어, 전체 데이터베이스를 로킹한다면)  동시에 접근할 수 있는 데이터의 양이 줄어들어 데이터베이스 공유도가 감소합니다.  반대로 로킹 단위가 작아지면(예를 들어, 레코드 단위로 로킹한다면) 더 많은 사용자가 동시에 데이터에 접근할 수 있으므로 데이터베이스 공유도가 증가합니다.  1번은 로킹 단위의 정의를 잘 설명하고 있으며, 2번은 로킹 단위의 예시를 잘 보여줍니다. 3번은 로킹 단위가 작아질수록 더 많은 로킹이 필요해지므로 오버헤드가 증가하는 것을 설명합니다. 따라서 4번이 틀린 설명입니다.",80,131
147,2,47,관계 데이터모델의 무결성 제약 중 기본키 값의 속성 값이 널(Null)값이 아닌 원자 값을 갖는 성질은?,,개체 무결성,참조 무결성,도메인 무결성,튜플의 유일성,1,"관계 데이터 모델에서 무결성(Integrity)이란 데이터의 정확성과 일관성을 유지하는 것을 의미합니다.  여러 종류의 무결성 제약 조건이 있는데, 그 중 개체 무결성은 각 테이블의 기본 키(Primary Key)에 대한 제약 조건입니다. 기본 키는 테이블 내 각 행(튜플)을 유일하게 식별하는 속성(또는 속성들의 집합)이며, 개체 무결성 제약 조건에 따르면 기본 키 값은 반드시 NULL 값이 아니어야 하고, 중복되어서도 안 됩니다.  즉, 기본 키 값은 항상 유일하고, 값을 가져야 한다는 의미입니다. 문제에서 언급된 ""기본키 값의 속성 값이 널(Null)값이 아닌 원자 값을 갖는 성질""은 바로 이 개체 무결성을 의미합니다.  ""원자 값""이란 더 이상 나눌 수 없는 단일 값을 의미합니다.  예를 들어, 이름이라는 기본키에 ""홍길동""이라는 원자값이 들어가는 것이지, ""홍길동, 김철수"" 와 같이 여러 값이 들어가서는 안됩니다.",81,129
148,2,48,뷰(View)의 장점이 아닌 것은?,,뷰 자체로 인덱스를 가짐,데이터 보안 용이,논리적 독립성 제공,사용자 데이터 관리 용이,1,"뷰(View)는 기존 테이블의 데이터를 기반으로 만들어진 가상 테이블입니다.  쉽게 말해, 특정 테이블의 일부분만 보여주거나, 여러 테이블의 데이터를 하나로 합쳐서 보여주는 역할을 합니다.  뷰 자체는 실제 데이터를 저장하지 않고, 기존 테이블의 데이터를 참조하여 보여주기 때문에 데이터를 직접 저장하는 공간이 아닙니다. 따라서 뷰는 인덱스를 가지지 않습니다. 인덱스는 실제 데이터 저장 공간에 생성되어 데이터 검색 속도를 높이는 역할을 하는데, 뷰는 데이터를 저장하지 않으므로 인덱스를 가질 수 없습니다.  반면 데이터 보안, 논리적 독립성 제공, 사용자 데이터 관리 용이성은 뷰의 주요 장점입니다.  데이터 보안 측면에서는 뷰를 통해 특정 사용자에게 필요한 데이터만 제한적으로 보여줄 수 있고, 논리적 독립성은 기존 테이블 구조 변경 시 뷰에 영향을 최소화하여 유지보수를 용이하게 합니다.  사용자는 뷰를 통해 복잡한 데이터 구조를 간편하게 관리할 수 있습니다. 따라서 뷰의 장점이 아닌 것은 1번, 뷰 자체로 인덱스를 가짐입니다.",64,128
149,2,49,분산 데이터베이스의 투명성(Transparency)에 해당 하지 않는 것은?,,Location Transparency,Replication Transparency,Failure Transparency,Media Access Transparency,4,"분산 데이터베이스의 투명성(Transparency)은 사용자가 데이터가 어디에 저장되어 있는지, 어떻게 복제되어 있는지, 어떤 시스템이 실패했는지 등을 알 필요 없이 데이터에 접근하고 사용할 수 있도록 하는 기능입니다.  Location Transparency는 데이터의 물리적 위치를 숨기고, Replication Transparency는 데이터의 복제 상태를 숨기며, Failure Transparency는 시스템 장애를 숨겨 사용자에게는 마치 하나의 통합된 데이터베이스처럼 보이도록 합니다.  반면 Media Access Transparency는 데이터가 저장되는 매체(하드디스크, SSD 등)의 종류를 숨기는 것을 의미합니다.  분산 데이터베이스에서는 사용자는 어떤 저장 매체에 데이터가 저장되어 있는지 알 필요가 없으므로, 이는 투명성에 해당하지 않습니다. 따라서 정답은 4번 Media Access Transparency입니다.  사용자는 데이터의 물리적인 저장 위치나 방식에 대해서는 알 필요가 없고, 단지 데이터에 접근하고 사용하는 것에만 집중할 수 있도록 하는 것이 분산 데이터베이스의 투명성의 목표입니다.",66,131
150,2,50,정규화의 목적으로 옳지 않은 것은?,,어떠한 릴레이션이라도 데이터베이스 내에서 표현 가능하게 만든다.,데이터 삽입시 릴레이션을 재구성할 필요성을 줄인다.,"중복을 배제하여 삽입, 삭제, 갱신 이상의 발생을 야기한다.",효과적인 검색 알고리즘을 생성할 수 있다.,3,"정규화는 데이터베이스의 중복을 제거하고 데이터 무결성을 유지하기 위한 과정입니다.  정규화를 통해 데이터베이스의 효율성과 안정성을 높일 수 있습니다.  문제에서 3번은 ""중복을 배제하여 삽입, 삭제, 갱신 이상의 발생을 야기한다""라고 되어 있는데, 이는 정규화의 목적과 정반대입니다. 정규화는 오히려 삽입, 삭제, 갱신 이상(데이터 불일치)을 *방지*하기 위해 수행됩니다.  중복을 제거하면 데이터를 한 곳에서만 관리하면 되므로 데이터 변경 시 일관성을 유지하고, 이상 현상 발생 가능성을 줄일 수 있습니다. 따라서 3번은 정규화의 목적과 일치하지 않습니다.  나머지 보기들은 모두 정규화를 통해 얻을 수 있는 이점들을 나타냅니다. 1번은 데이터 표현의 가능성을 높이고, 2번은 데이터 관리의 효율성을 높이며, 4번은 데이터 검색의 효율성을 높입니다.",83,130
151,2,51,다음에 해당하는 함수 종속의 추론 규칙은?,https://www.cbtbank.kr/images/iz/iz20200822/iz20200822m51.gif,분해 규칙,이행 규칙,반사 규칙,결합 규칙,2,"이 문제는 함수 종속의 추론 규칙 중 '이행 규칙'을 묻고 있습니다.  함수 종속이란, 어떤 속성(X)의 값이 결정되면 다른 속성(Y)의 값도 결정되는 관계를 말합니다.  문제에서 제시된 ""X→Y이고 Y→Z이면 X→Z이다""는 바로 이행 규칙을 나타냅니다.  쉽게 말해, X가 Y를 결정하고, Y가 Z를 결정한다면, 결국 X는 Z도 결정한다는 의미입니다.  마치 도미노처럼 X가 쓰러지면 Y가 쓰러지고, Y가 쓰러지면 Z가 쓰러지는 것과 같습니다.  다른 규칙들은 이러한 연쇄적인 함수 종속 관계를 설명하지 못합니다. 따라서 정답은 2번 이행 규칙입니다.",86,129
152,2,52,다음 R과 S 두 릴레이션에 대한 Division 연산의 수행 결과는?,https://www.cbtbank.kr/images/iz/iz20200822/iz20200822m52.gif,https://www.cbtbank.kr/images/iz/iz20200822/iz20200822m52b1.gif,https://www.cbtbank.kr/images/iz/iz20200822/iz20200822m52b2.gif,https://www.cbtbank.kr/images/iz/iz20200822/iz20200822m52b3.gif,https://www.cbtbank.kr/images/iz/iz20200822/iz20200822m52b4.gif,4,"이 문제는 관계형 데이터베이스에서의 Division 연산을 묻는 문제입니다. Division 연산은 R 릴레이션의 모든 튜플이 S 릴레이션의 모든 튜플과 조인될 수 있는지 확인하는 연산입니다.  쉽게 말해, R 릴레이션에서 S 릴레이션의 모든 조건을 만족하는 D1 값들을 찾는 것입니다.",83,128
153,2,53,"player 테이블에는 player_name, team_id, height 컬럼이 존재한다. 아래 SQL문에서 문법적 오류가 있는 부분은?",https://www.cbtbank.kr/images/iz/iz20200822/iz20200822m53.gif,-1,-2,-3,-4,4,"문제의 SQL 문에서 오류가 있는 부분은 (4)번입니다.  `BETWEEN` 연산자는 범위를 지정할 때 사용하는데,  `BETWEEN 170 AND 180` 과 같이 사용해야 합니다.  `170 or 180` 은 170 또는 180 중 하나를 의미하는 논리 연산자 `OR`을 사용한 것이므로,  `BETWEEN` 연산자와 함께 사용할 수 없습니다.  `BETWEEN`은 170 이상 180 이하의 범위를 나타내는 것이고, `OR`은 170 또는 180 중 하나를 만족하는 조건을 나타내는 것입니다. 따라서 height가 170 또는 180인 경우만 선택하고 싶다면 `height = 170 OR height = 180` 이라고 작성해야 합니다.  문제의 SQL문은 height가 170과 180 사이의 값을 갖는 레코드를 선택하려는 의도로 보이지만, `or` 연산자의 잘못된 사용으로 인해 의도와 다른 결과를 가져올 수 있습니다.  `player.name` 부분은 player 테이블의 name 컬럼을 참조하는 것이므로,  `player_name`으로 수정해야 합니다. 하지만 문제에서는 이 부분을 오류로 지적하지 않았으므로,  정답은 4번입니다.",85,125
154,2,54,데이터베이스 로그(log)를 필요로 하는 회복 기법은?,,즉각 갱신 기법,대수적 코딩 방법,타임 스탬프 기법,폴딩 기법,1,"데이터베이스의 회복 기법은 시스템 장애 발생 후 데이터베이스의 일관성을 유지하기 위해 사용되는 방법입니다.  여러 회복 기법 중 즉각 갱신 기법은 트랜잭션이 실행될 때마다 데이터베이스에 즉시 변경 사항을 반영하는 기법입니다.  만약 시스템 장애가 발생하더라도,  로그에 기록된 정보를 이용하여 장애 발생 시점까지의 변경 사항을 복구할 수 있습니다.  즉, 데이터베이스 로그를 통해 장애 이전 상태로 복구하는 데 필수적인 정보를 제공하기 때문에 즉각 갱신 기법이 데이터베이스 로그를 필요로 합니다.  반면 다른 선택지들은 데이터베이스 로그에 의존하지 않고 데이터베이스의 일관성을 유지하는 다른 방식을 사용합니다.  예를 들어, 타임 스탬프 기법은 데이터 변경 시점을 기록하여 일관성을 유지하지만, 즉각 갱신 기법처럼 로그 자체를 직접 활용하여 복구하는 방식은 아닙니다.",52,127
155,2,55,DML(Data Manipulation Language) 명령어가 아닌 것은?,,INSERT,UPDATE,ALTER,DELETE,3,"DML(Data Manipulation Language)은 데이터베이스의 데이터를 조작하는 데 사용되는 명령어 집합입니다.  INSERT는 새로운 데이터를 추가하고, UPDATE는 기존 데이터를 수정하며, DELETE는 데이터를 삭제하는 명령어입니다.  반면 ALTER는 데이터베이스의 구조(테이블, 뷰 등)를 변경하는 데 사용되는 DDL(Data Definition Language) 명령어입니다.  따라서 데이터를 조작하는 것이 아니라 데이터베이스의 *구조*를 변경하는 ALTER는 DML 명령어가 아닙니다.  쉽게 말해, DML은 데이터 자체를 다루고, DDL은 데이터를 담는 그릇(테이블 등)을 다루는 것이라고 생각하면 됩니다.",82,126
156,2,56,다음과 같이 위쪽 릴레이션을 아래쪽 릴레이션으로 정규화를 하였을 때 어떤 정규화 작업을 한 것인가?,https://www.cbtbank.kr/images/iz/iz20200822/iz20200822m56.gif,제1정규형,제2정규형,제3정규형,제4정규형,1,"처음 표는 '국가'라는 하나의 행에 여러 개의 도시 정보가 함께 들어있습니다.  데이터베이스에서는 이렇게 하나의 행에 여러 값이 들어있는 것을 '비정규화'되었다고 합니다.  정규화는 데이터 중복을 줄이고 데이터 무결성을 높이기 위해 데이터를 여러 개의 테이블로 나누는 과정입니다.  문제에서 보여주는 변환은 '국가'와 '도시'를 각각 하나의 열로 가지는 별도의 행으로 나누어 하나의 국가에 여러 도시가 있더라도 각 도시에 대해 별도의 행을 만드는 작업입니다. 이는 데이터 중복을 제거하고 데이터 무결성을 향상시키는 가장 기본적인 정규화 과정인 제1정규형(1NF)에 해당합니다.  제1정규형은  하나의 열에 여러 값이 들어있지 않도록(즉, 반복되는 그룹이 없도록) 하는 것을 목표로 합니다.  따라서,  하나의 국가에 여러 도시가 있는 경우, 각 도시를 별도의 행으로 분리하는 것이 제1정규형을 만족시키는 것입니다.",76,130
157,2,57,관계대수의 순수관계 연산자가 아닌 것은?,,Select,Cartesian Product,Division,Project,2,"관계대수는 관계형 데이터베이스를 조작하기 위한 수학적 언어입니다.  문제에서 제시된 연산자들은 모두 관계형 데이터베이스에서 데이터를 처리하는 데 사용되는 연산자들입니다.  `Select` 연산자는 특정 조건을 만족하는 튜플(행)을 선택하는 연산이고, `Project` 연산자는 특정 속성(열)만을 선택하는 연산이며, `Division` 연산자는 두 관계 간의 나눗셈 연산을 수행합니다.  반면, `Cartesian Product`(카테시안 곱) 연산자는 두 관계의 모든 튜플들을 서로 조합하여 새로운 관계를 생성하는 연산입니다.  순수 관계 연산자는 기본적인 관계 연산을 통해 다른 연산을 만들어낼 수 있는 연산자를 의미합니다.  `Select`, `Project`, `Division`은 이러한 기본 연산을 통해 다른 복잡한 연산을 만들어낼 수 있지만, `Cartesian Product`는 그 자체로는 다른 연산을 구성하는 데 사용되지 않고, 다른 연산과 함께 사용되어야 의미를 갖습니다. 따라서 순수 관계 연산자가 아닌 것은 `Cartesian Product`입니다.  쉽게 말해, 다른 연산의 재료가 되기보다는 결과를 만들어내는 데 직접 사용되는 연산이라고 생각하면 됩니다.",72,129
158,2,58,다음 중 SQL의 집계 함수(aggregation function)가 아닌 것은?,,AVG,COUNT,SUM,CREATE,4,"SQL은 데이터베이스를 관리하고 조작하는 데 사용되는 언어입니다.  집계 함수는 여러 행의 데이터를 하나의 값으로 요약하는 함수를 말합니다.  문제에서 제시된 AVG(평균), COUNT(개수), SUM(합계)는 모두 여러 행의 데이터를 하나의 값으로 요약하는 대표적인 집계 함수입니다.  반면 CREATE는 데이터베이스 객체(테이블, 뷰 등)를 생성하는 명령어이지, 기존 데이터를 요약하는 집계 함수는 아닙니다. 따라서 SQL의 집계 함수가 아닌 것은 CREATE입니다.",90,126
159,2,59,릴레이션 조작 시 데이터들이 불필요하게 중복되어 예기치 않게 발생하는 곤란한 현상을 의미하는 것은?,,normalization,rollback,cardinality,anomaly,4,"릴레이션(관계)은 데이터베이스에서 테이블을 의미합니다.  데이터베이스를 설계할 때, 데이터 중복을 최소화하여 효율적으로 데이터를 관리하는 것이 중요합니다.  만약 데이터 중복이 많으면, 데이터를 추가하거나 수정, 삭제할 때 예상치 못한 문제(이상 현상, anomaly)가 발생할 수 있습니다.  예를 들어, 같은 고객 정보가 여러 테이블에 중복되어 저장되어 있다면, 한 곳에서만 고객 정보를 수정했을 때 다른 곳은 수정되지 않아 데이터 불일치가 발생할 수 있습니다. 이러한 데이터 불일치 현상을  '이상 현상(anomaly)'이라고 부릅니다.  정규화(normalization)는 이러한 이상 현상을 방지하기 위해 데이터 중복을 최소화하는 데이터베이스 설계 기법입니다.  롤백(rollback)은 트랜잭션 처리 중 오류 발생 시 이전 상태로 되돌리는 기능이고, 카디널리티(cardinality)는 관계 데이터베이스에서 테이블 간의 관계를 나타내는 개념입니다. 따라서 릴레이션 조작 시 데이터 중복으로 인해 발생하는 곤란한 현상은 '이상 현상(anomaly)'입니다.",78,130
160,2,60,릴레이션에 대한 설명으로 거리가 먼 것은?,,"튜플들의 삽입, 삭제 등의 작업으로 인해 릴레이션은 시간에 따라 변한다.",한 릴레이션에 포함된 튜플들은 모두 상이하다.,애트리뷰트는 논리적으로 쪼갤 수 없는 원자값으로 저장한다.,한 릴레이션에 포함된 튜플 사이에는 순서가 있다.,4,"릴레이션은 데이터베이스에서 테이블에 해당하는 개념입니다.  테이블은 행(튜플)과 열(애트리뷰트)로 구성되는데, 각 행은 데이터베이스에 저장되는 하나의 레코드를 나타내고, 각 열은 레코드의 특정 속성(예: 이름, 나이, 주소)을 나타냅니다.  문제에서 1번은 릴레이션의 동적인 특성을, 2번은 릴레이션 내 튜플의 유일성을, 3번은 애트리뷰트의 원자성을 설명하고 있습니다.  하지만 4번은 릴레이션 내 튜플의 순서가 있다고 주장하는데, 이는 사실과 다릅니다. 관계형 데이터베이스에서는 튜플의 순서는 의미를 갖지 않습니다.  데이터베이스 시스템은 튜플의 순서를 보장하지 않으며, 튜플의 순서를 변경하더라도 데이터베이스의 의미에는 변화가 없습니다. 따라서 릴레이션에 대한 설명으로 거리가 먼 것은 4번입니다.",77,129
161,2,61,다음 자바 프로그램 조건문에 대해 삼항 조건 연산자를 사용하여 옳게 나타낸 것은?,https://www.cbtbank.kr/images/iz/iz20200822/iz20200822m61.gif,"int i = 7, j = 9;",int k;,k = (i＞j)?(i – j):(i + j);,"int i = 7, j = 9;",1,"문제에서 제시된 자바 코드는 변수 `i`와 `j`의 값을 비교하여 `i`가 `j`보다 크면 `i - j`의 결과를 `k`에 저장하고, 그렇지 않으면 `i + j`의 결과를 `k`에 저장하는 조건문입니다.  삼항 조건 연산자는 `조건 ? 참일 때 값 : 거짓일 때 값`의 형태로 조건에 따라 다른 값을 반환하는 연산자입니다. 따라서 문제의 조건문을 삼항 조건 연산자로 표현하면 `k = (i > j) ? (i - j) : (i + j);`가 됩니다.  1번 선택지가 이를 정확하게 나타내고 있습니다.  다른 선택지는 변수 선언 부분이 누락되어 있거나, 삼항 연산자의 사용이 잘못되어 있습니다.  따라서 정답은 1번입니다.",82,141
162,2,62,다음 내용이 설명하는 소프트웨어 취약점은?,https://www.cbtbank.kr/images/iz/iz20200822/iz20200822m62.gif,FTP 바운스 공격,SQL 삽입,버퍼 오버플로,디렉토리 접근 공격,3,"메모리를 다루는 데 오류가 발생하여 잘못된 동작을 하는 프로그램 취약점은 바로 **버퍼 오버플로(Buffer Overflow)**입니다.  프로그램은 데이터를 저장하기 위해 메모리 공간(버퍼)을 할당받는데, 이 버퍼의 크기보다 더 많은 데이터를 입력받으면 버퍼의 경계를 넘어 다른 메모리 영역을 덮어쓰게 됩니다. 이로 인해 프로그램이 예상치 못한 동작을 하거나, 심각한 경우 시스템 전체가 충돌하거나 악의적인 코드가 실행될 수 있습니다.  마치 컵에 담을 수 있는 양보다 더 많은 물을 부으면 컵이 넘치는 것과 같은 원리입니다.  버퍼 오버플로는 해커들이 시스템을 공격하는 데 악용하는 대표적인 취약점 중 하나입니다.",78,156
163,2,63,다음 중 bash 쉘 스크립트에서 사용할 수 있는 제어문이 아닌 것은?,,if,for,repeat_do,while,3,"bash 쉘 스크립트는 리눅스나 유닉스 계열 운영체제에서 명령어들을 자동으로 실행하는 프로그램을 작성하는 데 사용하는 스크립트 언어입니다.  if, for, while 문은 프로그래밍에서 흔히 사용되는 제어문으로, bash 쉘 스크립트에서도 조건에 따라 코드 실행을 제어하거나 반복적인 작업을 수행하는 데 사용됩니다.  if 문은 조건이 참일 때만 코드 블록을 실행하고, for 문은 특정 횟수만큼 또는 목록의 요소들을 순회하며 코드 블록을 실행하며, while 문은 조건이 참인 동안 코드 블록을 반복 실행합니다.  반면, repeat_do 문은 bash 쉘 스크립트에서 제공하는 표준 제어문이 아닙니다. 다른 프로그래밍 언어에는 유사한 구조가 있을 수 있지만, bash에서는  repeat_do라는 명령어를 사용하여 반복문을 구성할 수 없습니다. 따라서 정답은 3번입니다.",85,144
164,2,64,IPv6에 대한 설명으로 틀린 것은?,,32비트의 주소체계를 사용한다.,멀티미디어의 실시간 처리가 가능하다.,IPv4보다 보안성이 강화되었다.,자동으로 네트워크 환경구성이 가능하다.,1,"IPv6는 차세대 인터넷 프로토콜로, 기존 IPv4의 주소 부족 문제를 해결하기 위해 고안되었습니다. IPv4는 32비트 주소 체계를 사용하지만, IPv6는 128비트 주소 체계를 사용하여 훨씬 더 많은 장치에 고유한 IP 주소를 할당할 수 있습니다. 문제에서 1번 보기는 ""32비트의 주소체계를 사용한다""라고 되어 있는데, 이는 IPv4의 특징이며 IPv6의 특징이 아니므로 틀린 설명입니다.  2번 보기는 128비트의 넓은 주소 공간을 통해 멀티미디어 실시간 처리에 유리한 환경을 제공한다는 점에서 맞는 설명입니다. 3번 보기는 IPv6가 IPv4보다 향상된 보안 기능을 제공하는 점에서 맞는 설명입니다. 4번 보기는 IPv6의 자동 구성 기능(Autoconfiguration)을 통해 네트워크 환경을 자동으로 설정할 수 있다는 점에서 맞는 설명입니다. 따라서 문제의 정답은 IPv6의 주소 체계에 대한 잘못된 설명을 포함하고 있는 1번입니다.",89,145
165,2,65,효과적인 모듈 설계를 위한 유의사항으로 거리가 먼 것은?,,모듈간의 결합도를 약하게 하면 모듈 독립성이 향상된다.,복잡도와 중복성을 줄이고 일관성을 유지시킨다.,모듈의 기능은 예측이 가능해야 하며 지나치게 제한적 이여야 한다.,유지보수가 용이해야 한다.,3,"효과적인 모듈 설계를 위한 유의사항을 묻는 문제입니다.  모듈이란 소프트웨어를 구성하는 독립적인 기능 단위를 말합니다.  좋은 모듈 설계는 소프트웨어의 유지보수 및 확장성을 높이는 데 매우 중요합니다.  1번과 4번은 모듈의 독립성과 유지보수 용이성을 강조하며 좋은 모듈 설계의 목표와 일치합니다. 2번 또한 중복을 줄이고 일관성을 유지하는 것은 효율적인 설계의 중요한 요소입니다.  하지만 3번은 ""지나치게 제한적이어야 한다""는 부분에서 문제가 있습니다.  모듈의 기능은 예측 가능해야 하지만, 지나치게 제한적이면 다른 모듈과의 상호작용이 어려워지고 전체 시스템의 유연성을 떨어뜨릴 수 있습니다.  적절한 수준의 기능을 가지면서 다른 모듈과의 연동성을 고려하는 것이 중요합니다. 따라서 3번이 효과적인 모듈 설계를 위한 유의사항으로 거리가 먼 것입니다.",90,106
166,2,66,"HRN 방식으로 스케줄링 할 경우, 입력된 작업이 다음과 같을 때 처리되는 작업 순서로 옳은 것은?",https://www.cbtbank.kr/images/iz/iz20200822/iz20200822m66.gif,A→B→C→D,A→C→B→D,D→B→C→A,D→A→B→C,3,"HRN(Highest Response Ratio Next) 스케줄링은 우선순위 스케줄링 방식의 하나로,  대기시간과 서비스 시간을 고려하여 우선순위를 결정합니다.  우선순위는  (대기시간 + 서비스시간) / 서비스시간  으로 계산됩니다.  값이 클수록 우선순위가 높습니다.  각 작업에 대해 이 값을 계산해보면 다음과 같습니다.",61,144
167,2,67,운영체제에 대한 설명으로 거리가 먼 것은?,,다중 사용자와 다중 응용프로그램 환경하에서 자원의 현재 상태를 파악하고 자원 분배를 위한 스케줄링을 담당한다.,"CPU, 메모리 공간, 기억 장치, 입출력 장치 등의 자원을 관리한다.","운영체제의 종류로는 매크로 프로세서, 어셈블러, 컴파일러 등이 있다.",입출력 장치와 사용자 프로그램을 제어한다.,3,"이 문제는 운영체제의 역할과 구성요소에 대한 이해도를 묻는 문제입니다.  1번, 2번, 4번은 모두 운영체제가 수행하는 주요 기능을 설명하고 있습니다.  다중 사용자 환경에서 자원 관리(1번),  시스템 자원 관리(2번), 그리고 입출력 장치 및 사용자 프로그램 제어(4번)는 모두 운영체제의 핵심적인 역할입니다.  하지만 3번은 운영체제의 종류를 설명하는 부분에서 매크로 프로세서, 어셈블러, 컴파일러를 언급하고 있는데, 이들은 운영체제가 아닌 프로그래밍 도구입니다.  매크로 프로세서는 매크로 명령어를 처리하고, 어셈블러는 어셈블리어를 기계어로 변환하며, 컴파일러는 고급 언어를 기계어로 변환하는 역할을 합니다.  이들은 운영체제 위에서 동작하는 프로그램이지 운영체제 자체가 아닙니다. 따라서 운영체제에 대한 설명으로 거리가 먼 것은 3번입니다.",79,144
168,2,68,배치 프로그램의 필수 요소에 대한 설명으로 틀린 것은?,,자동화는 심각한 오류 상황 외에는 사용자의 개입 없이 동작해야 한다.,"안정성은 어떤 문제가 생겼는지, 언제 발생했는지 등을 추적할 수 있어야 한다.",대용량 데이터는 대용량의 데이터를 처리할 수 있어야 한다.,"무결성은 주어진 시간 내에 처리를 완료할 수 있어야 하고, 동시에 동작하고 있는 다른 애플리케이션을 방해하지 말아야 한다.",4,"배치 프로그램의 필수 요소에 대한 문제입니다.  4번 선택지가 틀린 이유는 '무결성'의 개념을 잘못 이해하고 있기 때문입니다.  무결성은 데이터의 정확성과 신뢰성을 유지하는 것을 의미합니다.  즉, 배치 프로그램이 처리 과정에서 데이터를 손상시키거나 잘못된 결과를 만들어내지 않도록 하는 것이 중요합니다.  문제의 4번 선택지는 처리 시간과 다른 애플리케이션과의 간섭에 초점을 맞추고 있는데, 이는 '성능'이나 '안정성'과 관련된 내용이지 무결성과는 직접적인 관련이 없습니다.  자동화, 안정성, 대용량 데이터 처리 능력은 배치 프로그램의 필수적인 요소이지만, 무결성은 처리 속도나 다른 프로그램과의 호환성이 아니라 데이터의 정확성과 완전성을 보장하는 데 있습니다. 따라서 4번은 배치 프로그램의 무결성에 대한 잘못된 설명입니다.",62,140
169,2,69,TCP 프로토콜에 대한 설명으로 거리가 먼 것은?,,신뢰성이 있는 연결 지향형 전달 서비스이다.,기본 헤더 크기는 100byte이고 160byte까지 확장 가능하다.,스트림 전송 기능을 제공한다.,"순서제어, 오류제어, 흐름제어 기능을 제공한다.",2,"TCP 프로토콜은 데이터를 안전하고 신뢰성 있게 전송하는 데 사용되는 네트워크 프로토콜입니다.  문제에서 옳지 않은 설명은 2번입니다. TCP 헤더의 크기는 기본적으로 20바이트이며, 옵션을 포함하면 최대 60바이트까지 확장될 수 있습니다.  100바이트 또는 160바이트라는 설명은 사실과 다릅니다.  나머지 선택지들은 모두 TCP 프로토콜의 주요 특징을 정확하게 나타내고 있습니다.  1번은 TCP가 연결 지향형(Connection-oriented)이며 데이터 전송의 신뢰성을 보장한다는 점을, 3번은 TCP가 데이터 스트림 형태로 전송한다는 점을, 4번은 TCP가 순서, 오류, 흐름 제어 기능을 제공하여 안정적인 데이터 전송을 보장한다는 점을 각각 설명하고 있습니다. 따라서 TCP 프로토콜의 헤더 크기에 대한 잘못된 정보를 포함하고 있는 2번이 정답입니다.",77,145
170,2,70,다음이 설명하는 응집도의 유형은?,https://www.cbtbank.kr/images/iz/iz20200822/iz20200822m70.gif,기능적 응집도,우연적 응집도,논리적 응집도,절차적 응집도,4,"문제에서 설명하는 응집도는 하나의 모듈 안에 여러 기능이 있고, 그 기능들이 순차적으로 실행되는 경우를 말합니다.  마치 조립 라인처럼, 기능 A를 수행한 후 기능 B, 그 다음 기능 C… 이런 식으로 순서대로 작업이 진행되는 것이죠. 이러한 유형의 응집도를 정보처리기사 공식 교재에서는 '절차적 응집도'라고 합니다.  다른 기능들이 서로 연관되어 있지만, 각 기능이 독립적인 것이 아니라 순서대로 실행되어야 하는 특징을 가지고 있습니다.  예를 들어, 주문 처리 모듈이 있다면, 주문 접수 → 결제 처리 → 배송 준비 → 배송 완료 와 같이 순차적으로 진행되는 것이 절차적 응집도의 좋은 예시입니다.  반면 기능적 응집도는 하나의 모듈이 하나의 기능만 수행하는 것을 의미하고, 우연적 응집도는 모듈 내 구성 요소들이 서로 관련이 없는 경우, 논리적 응집도는 여러 기능을 수행하지만 서로 관련된 기능들을 하나의 모듈로 묶은 경우를 의미합니다. 따라서 문제의 설명과 가장 잘 맞는 응집도는 절차적 응집도입니다.",81,106
171,2,71,"OSI-7Layer에서 링크의 설정과 유지 및 종료를 담당하며, 노드간의 오류제어와 흐름제어 기능을 수행하는 계층은?",,데이터링크 계층,물리 계층,세션 계층,응용 계층,1,"OSI 7계층은 네트워크 통신을 7개의 계층으로 나누어 각 계층이 특정 기능을 담당하도록 설계된 모델입니다.  문제에서 언급된 ""링크의 설정과 유지 및 종료를 담당하며, 노드 간의 오류 제어와 흐름 제어 기능을 수행하는 계층""은 데이터링크 계층입니다.  데이터링크 계층은 물리 계층 위에 위치하며, 물리 계층에서 전송된 비트들을 의미있는 데이터 프레임으로 묶고,  오류 검출 및 재전송, 흐름 제어 등을 통해 안정적인 데이터 전송을 보장합니다.  쉽게 말해,  데이터가 물리적으로 전송되는 것을 넘어서,  데이터가 정확하게 상대방에게 도착했는지 확인하고,  데이터 전송 속도를 조절하는 역할을 합니다.  다른 계층들은 각각 다른 기능을 담당합니다. 물리 계층은 물리적인 전송 매체를 통해 데이터를 전달하는 가장 기본적인 계층이고, 세션 계층은 두 노드 간의 통신 세션을 관리하며, 응용 계층은 사용자가 직접적으로 사용하는 응용 프로그램(예: 웹 브라우저, 이메일 클라이언트)과 관련된 기능을 제공합니다. 따라서, 링크 설정 및 유지, 오류 제어, 흐름 제어 기능은 데이터링크 계층에서 수행됩니다.",79,145
172,2,72,다음 중 가장 결합도가 강한 것은?,,data coupling,stamp coupling,common coupling,control coupling,3,"이 문제는 소프트웨어 모듈 간의 결합도(Coupling)에 대한 이해를 묻는 문제입니다.  결합도란 모듈 간의 상호 의존성 정도를 나타내는 척도로, 결합도가 높을수록 모듈 간의 의존성이 강하다는 의미입니다.  결합도가 높으면 모듈 하나를 변경할 때 다른 모듈에도 영향을 미칠 가능성이 커지므로 유지보수가 어려워지고, 프로그램의 안정성이 떨어집니다. 반대로 결합도가 낮으면 모듈 간의 독립성이 높아져 유지보수가 용이하고, 변경에 대한 영향이 적어 안정적인 시스템을 구축할 수 있습니다.",64,106
173,2,73,메모리 관리 기법 중 Worst fit 방법을 사용할 경우 10K 크기의 프로그램 실행을 위해서는 어느 부분에 할당되는가?,https://www.cbtbank.kr/images/iz/iz20200822/iz20200822m73.gif,NO.2,NO.3,NO.4,NO.5,4,"Worst fit 메모리 할당 기법은 사용 가능한 메모리 블록 중 가장 큰 크기의 블록에 프로그램을 할당하는 방법입니다.  문제에서 10K 크기의 프로그램을 실행하기 위해 사용 가능한 메모리 블록은 NO.1(8K), NO.2(12K), NO.5(16K) 세 곳입니다. Worst fit 기법은 가장 큰 블록을 선택하므로, 16K 크기의 NO.5 영역에 할당됩니다. 따라서 정답은 4번입니다.  NO.2(12K)도 충분하지만, Worst fit은 가장 큰 공간을 찾기 때문에 NO.5를 선택하는 것입니다.",69,144
174,2,74,200.1.1.0/24 네트워크를 FLSM 방식을 이용하여 10개의 Subnet으로 나누고 ip subnet-zero를 적용했다. 이때 서브네팅된 네트워크 중 10번째 네트워크의 broadcast IP주소는?,,200.1.1.159,201.1.5.175,202.1.11.254,203.1.255.245,1,"200.1.1.0/24 네트워크는 총 256개(2<sup>8</sup>)의 IP 주소를 가지고 있습니다. 이를 10개의 서브넷으로 나누려면, 최소 4비트(2<sup>4</sup>=16)의 비트를 서브넷 마스크에 추가해야 합니다.  (/24는 24비트를 네트워크 주소로 사용한다는 의미이므로, 24+4=28비트가 새로운 서브넷 마스크가 됩니다. 즉, /28이 됩니다).  따라서 새로운 서브넷 마스크는 255.255.255.240이 됩니다.  ip subnet-zero를 적용했으므로, 0번째 서브넷도 사용 가능합니다.",52,145
175,2,75,다음은 사용자로부터 입력받은 문자열에서 처음과 끝의 3글자를 추출한 후 합쳐서 출력하는 파이썬 코드에서 ㉠에 들어갈 내용은?,https://www.cbtbank.kr/images/iz/iz20200822/iz20200822m75.gif,string[1:3] + string[-3:],string[:3] + string[-3:-1],string[0:3] + string[-3:],string[0:] + string[:-1],3,"문제에서 요구하는 것은 사용자로부터 입력받은 문자열의 처음 3글자와 마지막 3글자를 추출하여 합치는 것입니다. 파이썬 문자열 슬라이싱을 이용하여 해결할 수 있습니다.  `string[:3]`은 문자열의 처음 3글자를, `string[-3:]`은 문자열의 마지막 3글자를 추출합니다. 따라서 정답은 3번 `string[0:3] + string[-3:]` 입니다. 1번은 두 번째 글자부터 세 번째 글자까지를 잘못 추출하고, 2번은 마지막 두 글자만 추출하며, 4번은 전체 문자열과 마지막 글자를 제외한 문자열을 합치는 잘못된 코드입니다.  문제의 핵심은 파이썬 문자열 슬라이싱의 이해에 있습니다.",73,141
176,2,76,파이썬의 변수 작성 규칙 설명으로 옳지 않은 것은?,,첫 자리에 숫자를 사용할 수 없다.,"영문 대문자/소문자, 숫자, 밑줄(_)의 사용이 가능하다.",변수 이름의 중간에 공백을 사용할 수 있다.,이미 사용되고 있는 예약어는 사용할 수 없다.,3,"파이썬 변수 작성 규칙에 대한 문제입니다.  파이썬에서 변수는 데이터를 저장하는 공간을 의미하며, 변수 이름을 지을 때는 특정 규칙을 따라야 합니다.  1번은 첫 자리에 숫자를 사용할 수 없다는 규칙으로,  `1abc` 와 같은 변수 이름은 허용되지 않습니다.  2번은 영문 대문자, 소문자, 숫자, 밑줄(_)을 사용할 수 있다는 규칙으로, `my_variable`, `MyVariable`, `variable1` 등의 변수 이름이 가능합니다.  4번은 이미 사용되고 있는 예약어(파이썬에서 특별한 의미를 가지는 키워드, 예: if, for, while 등)는 변수 이름으로 사용할 수 없다는 규칙입니다.  하지만 3번은 변수 이름의 중간에 공백을 사용할 수 있다는 내용인데, 이는 잘못된 설명입니다.  파이썬 변수 이름에는 공백을 사용할 수 없습니다.  `my variable` 과 같은 이름은 에러를 발생시킵니다. 따라서 3번이 옳지 않은 설명입니다.",84,141
177,2,77,"어떤 모듈이 다른 모듈의 내부 논리 조직을 제어하기 위한 목적으로 제어신호를 이용하여 통신하는 경우이며, 하위 모듈에서 상위 모듈로 제어신호가 이동하여 상위 모듈에게 처리 명령을 부여하는 권리 전도현상이 발생하게 되는 결합도는?",,data coupling,stamp coupling,control coupling,common coupling,3,"이 문제는 소프트웨어 모듈 간의 결합도(Coupling)를 묻는 문제입니다.  결합도는 모듈 간의 상호 의존성 정도를 나타내는 척도로, 결합도가 높을수록 모듈 간의 의존성이 높아 유지보수 및 변경이 어려워집니다.  문제에서 설명하는 상황은 상위 모듈이 하위 모듈의 동작을 제어하기 위해 제어 신호를 보내는 것입니다.  하위 모듈은 상위 모듈로부터 받은 제어 신호에 따라 동작을 변경하는데, 이때 하위 모듈이 상위 모듈에게 처리 명령을 부여하는 권리 전도 현상(Control Inversion)이 발생합니다. 이러한 상황은 '제어 결합(Control Coupling)'에 해당합니다.  데이터 결합(Data Coupling)은 데이터만 주고받는 경우이고, 스탬프 결합(Stamp Coupling)은 데이터 구조 전체를 전달하는 경우, 공통 결합(Common Coupling)은 전역 변수를 공유하는 경우입니다.  문제에서 제시된 상황은 제어 신호를 통해 상위 모듈이 하위 모듈의 동작을 직접 제어하는 것이므로, 제어 결합이 가장 적절한 답입니다.",80,106
178,2,78,다음 C 프로그램의 결과 값은?,https://www.cbtbank.kr/images/iz/iz20200822/iz20200822m78.gif,15,19,25,27,3,"이 C 프로그램은 1부터 10까지의 홀수의 합을 구하는 프로그램입니다.  `for` 문에서 `i = i + 2`는 i에 2씩 더해주므로, i는 1, 3, 5, 7, 9의 값을 가지게 됩니다.  `sum` 변수는 이 홀수들을 차례로 더해나가는 역할을 합니다. 따라서, 최종적으로 `sum`에는 1 + 3 + 5 + 7 + 9 = 25가 저장되고, `printf` 함수를 통해 25가 출력됩니다.",79,141
179,2,79,UNIX에서 새로운 프로세스를 생성하는 명령어는?,,ls,cat,fork,chmod,3,"UNIX는 다양한 명령어를 사용하는 운영체제입니다.  문제에서 제시된 명령어 중 `fork()`는 새로운 프로세스를 생성하는 데 사용되는 시스템 콜입니다.  `fork()` 함수를 호출하면 현재 실행 중인 프로세스가 자신과 동일한 복사본(자식 프로세스)을 생성합니다.  부모 프로세스와 자식 프로세스는 각각 독립적인 메모리 공간을 가지며, 동시에 실행될 수 있습니다.  반면, `ls`는 파일 목록을 표시하고, `cat`은 파일 내용을 출력하며, `chmod`는 파일의 접근 권한을 변경하는 명령어입니다. 따라서 새로운 프로세스를 생성하는 명령어는 `fork()`입니다.",68,144
180,2,80,C언어에서 정수 자료형으로 옳은 것은?,,int,float,char,double,1,"C언어에서 자료형은 변수에 저장되는 데이터의 종류와 크기를 나타냅니다.  문제에서 제시된 자료형들을 살펴보면, int는 정수(예: -2, 0, 10, 100)를 저장하는 자료형입니다. float와 double은 실수(예: 3.14, -2.5)를 저장하는 자료형이며, float는 double보다 정밀도가 낮습니다. char는 문자(예: 'A', 'b', '1')를 저장하는 자료형입니다. 따라서 정수 자료형으로 옳은 것은 int입니다.",88,141
181,2,81,"물리적인 사물과 컴퓨터에 동일하게 표현되는 가상의 모델로 실제 물리적인 자산 대신 소프트웨어로 가상화함으로써 실제 자산의 특성에 대한 정확한 정보를 얻을 수 있고, 자산 최적화, 돌발사고 최소화, 생산성 증가 등 설계부터 제조, 서비스에 이르는 모든 과정의 효율성을 향상시킬 수 있는 모델은?",,최적화,실행 시간,디지털 트윈,N-Screen,3,"문제에서 설명하는 모델은 실제 사물이나 시스템을 컴퓨터 안에 가상으로 구현한 것입니다.  마치 실제 물건의 쌍둥이(Twin)처럼 똑같이 동작하고, 데이터를 주고받으며 실제 상황을 미리 시뮬레이션하거나 예측할 수 있도록 해줍니다.  예를 들어, 자동차를 만든다고 생각해 봅시다.  디지털 트윈을 이용하면 실제 자동차를 만들기 전에 컴퓨터 안에서 가상의 자동차를 만들어 여러 가지 상황(충돌 테스트, 연비 테스트 등)을 시뮬레이션해 볼 수 있습니다.  이를 통해 실제 자동차 제작 과정에서 발생할 수 있는 문제점을 미리 파악하고 개선하여, 최적화된 자동차를 만들고 제작 비용과 시간을 절약할 수 있습니다.  문제에서 언급된 '자산 최적화, 돌발사고 최소화, 생산성 증가' 등의 효과는 모두 디지털 트윈을 통해 얻을 수 있는 이점입니다.  '최적화'는 디지털 트윈의 결과물 중 하나일 뿐, 디지털 트윈 자체를 설명하는 것은 아닙니다.  '실행 시간'은 컴퓨터 시스템의 성능과 관련된 개념이고, 'N-Screen'은 여러 기기에서 동일한 콘텐츠를 이용하는 기술을 의미하므로 문제의 설명과는 맞지 않습니다. 따라서 정답은 디지털 트윈(Digital Twin)입니다.",73,150
182,2,82,정보보안의 3대 요소에 해당하지 않는 것은?,,기밀성,휘발성,무결성,가용성,2,"정보보안의 3대 요소는 기밀성, 무결성, 가용성입니다.  기밀성은 정보에 대한 접근을 허가된 사용자에게만 제한하는 것을 의미하고, 무결성은 정보의 정확성과 신뢰성을 유지하는 것을 의미하며, 가용성은 정보가 필요한 사용자에게 언제든지 이용 가능하도록 하는 것을 의미합니다.  문제에서 제시된 '휘발성'은 정보가 일정 시간이 지나면 사라지는 성질을 의미하는데, 이는 정보보안의 목표와는 관련이 없습니다. 따라서 정보보안의 3대 요소에 해당하지 않는 것은 휘발성입니다.  쉽게 말해, 정보를 안전하게 지키기 위해서는 비밀로 유지(기밀성), 정확하게 유지(무결성), 필요할 때 사용할 수 있게 유지(가용성)하는 것이 중요하지, 정보가 얼마나 빨리 사라지는지는 보안과 직접적인 관련이 없다는 것입니다.",88,153
183,2,83,다음 빈칸에 알맞은 기술은,https://www.cbtbank.kr/images/iz/iz20200822/iz20200822m83.gif,Quantum Key Distribution,Digital Rights Management,Grayware,Mashup,4,"괄호 안에 들어갈 기술은 '매시업(Mashup)'입니다. 매시업은 웹에서 제공하는 다양한 정보와 서비스(예: 지도 서비스, 날씨 정보, 뉴스 기사 등)들을 조합하여 새로운 소프트웨어, 서비스, 또는 데이터베이스를 만드는 기술을 의미합니다.  마치 요리사가 여러 재료를 섞어 새로운 요리를 만들 듯, 기존 웹 서비스들을 재조합하여 새로운 가치를 창출하는 것이죠.  예를 들어, 지도 서비스에 날씨 정보를 결합하여 특정 지역의 날씨를 지도 위에 표시하는 애플리케이션을 만드는 것이 매시업의 대표적인 예시입니다.  따라서 웹에서 제공하는 정보와 서비스를 활용하여 새로운 것을 만드는 기술이라는 문제의 설명에 가장 적합한 답변입니다.  다른 선택지는 웹 서비스 조합과는 직접적인 관련이 없습니다. 양자 키 분배(Quantum Key Distribution)는 암호화 기술, 디지털 저작권 관리(Digital Rights Management)는 콘텐츠 보호 기술, 그레이웨어(Grayware)는 악성코드의 일종입니다.",73,138
184,2,84,기능점수(Functional Point)모형에서 비용산정에 이용되는 요소가 아닌 것은?,,클래스 인터페이스,명령어(사용자 질의수),데이터파일,출력보고서,1,"기능점수(Functional Point) 모형은 소프트웨어 개발 비용을 산정하는 방법 중 하나입니다.  소프트웨어의 기능 규모를 측정하여 비용을 예측하는 방식인데요,  여기서 기능 규모는 사용자에게 제공되는 기능의 양을 의미합니다.  문제에서 제시된 요소들 중 '명령어(사용자 질의수)', '데이터파일', '출력보고서'는 모두 사용자에게 직접적인 기능을 제공하는 요소들입니다.  사용자가 시스템에 명령을 내리고(명령어), 데이터를 입력하고(데이터파일), 결과를 확인하는(출력보고서) 과정에서 발생하는 기능들이죠.  반면 '클래스 인터페이스'는 소프트웨어 내부의 구조를 나타내는 요소로, 사용자에게 직접적으로 보이거나 기능을 제공하는 부분이 아닙니다.  즉, 사용자는 클래스 인터페이스를 통해 기능을 사용하지만, 클래스 인터페이스 자체가 기능의 규모를 측정하는 데 직접적으로 사용되는 요소는 아닙니다.  따라서 기능점수 모형에서 비용 산정에 이용되는 요소가 아닌 것은 클래스 인터페이스입니다.",42,147
185,2,85,블록 암호화 방식이 아닌 것은?,,DES,RC4,AES,SEED,2,"이 문제는 암호화 방식 중 블록 암호와 스트림 암호를 구분하는 문제입니다.  블록 암호는 데이터를 고정된 크기의 블록으로 나누어 각 블록을 독립적으로 암호화하는 방식이고, 스트림 암호는 데이터를 비트 또는 바이트 단위로 순차적으로 암호화하는 방식입니다.  DES(Data Encryption Standard), AES(Advanced Encryption Standard), SEED는 모두 블록 암호의 대표적인 예시입니다. 반면, RC4는 스트림 암호 알고리즘입니다. 따라서 블록 암호화 방식이 아닌 것은 RC4입니다.  정보처리기사 시험에서는 암호화 알고리즘의 종류와 특징을 이해하고 있어야 하므로, 블록 암호와 스트림 암호의 차이점을 명확히 알아두는 것이 중요합니다.",65,154
186,2,86,Putnam 모형을 기초로 해서 만든 자동화 추정 도구는?,,SQLR/30,SLIM,MESH,NFV,2,"Putnam 모형은 소프트웨어 개발 프로젝트의 노력과 기간을 예측하는 데 사용되는 경험적 모델입니다.  이 모형을 기반으로 자동화된 추정 도구를 만든다면, 개발 프로젝트의 규모, 복잡도, 요구사항 등의 정보를 입력받아 개발에 필요한 시간과 자원을 자동으로 계산해 줍니다.  문제에서 제시된 선택지 중 SLIM(Software Life Cycle Management)은 Putnam 모형을 기반으로 한 자동화 추정 도구로 알려져 있습니다.  다른 선택지는 소프트웨어 개발이나 시스템 관리와 관련된 용어이지만, Putnam 모형을 기반으로 한 자동화 추정 도구와 직접적인 관련은 없습니다. 따라서 정답은 SLIM입니다.",73,103
187,2,87,큰 숫자를 소인수 분해하기 어렵다는 기반 하에 1978년 MIT에 의해 제안된 공개키 암호화 알고리즘은?,,DES,ARIA,SEED,RSA,4,"RSA 암호 알고리즘은 큰 수의 소인수분해가 어렵다는 수학적 원리를 이용한 공개키 암호화 알고리즘입니다.  공개키 암호화는 두 개의 키, 즉 공개키(Public Key)와 개인키(Private Key)를 사용하는데, 공개키는 누구에게나 공개해도 되지만 개인키는 소유자만 알고 있어야 합니다.  RSA 알고리즘에서는 큰 두 소수를 곱하여 얻은 수(n)와 다른 수(e)를 공개키로 사용하고, 이 공개키로 암호화된 메시지는 개인키만을 이용하여 복호화할 수 있습니다.  큰 수의 소인수분해가 어렵기 때문에, 공개키로 암호화된 메시지를 해독하려면 엄청난 계산량이 필요하여 실질적으로 불가능에 가깝습니다.  1978년 MIT의 리베스트(Rivest), 샤미르(Shamir), 애들먼(Adleman) 세 사람에 의해 개발되어 그들의 이름 앞글자를 따서 RSA라고 명명되었습니다.  따라서 큰 숫자를 소인수 분해하기 어렵다는 기반 하에 1978년 MIT에 의해 제안된 공개키 암호화 알고리즘은 RSA입니다.",78,154
188,2,88,COCOMO 모델의 프로젝트 유형으로 거리가 먼 것은?,,Organic,Semi-detached,Embedded,Sequentail,4,"COCOMO(Constructive Cost Model) 모델은 소프트웨어 개발 프로젝트의 비용과 기간을 예측하는 모델입니다.  프로젝트의 규모와 복잡도에 따라 Organic, Semi-detached, Embedded 세 가지 유형으로 나뉩니다.  Organic 유형은 소규모, 잘 정의된 프로젝트에 적용되고, Semi-detached 유형은 중간 규모의 프로젝트에, Embedded 유형은 하드웨어와 밀접하게 연관된 시스템 소프트웨어 개발에 적용됩니다.  Sequential(순차적)은 COCOMO 모델의 프로젝트 유형 분류와는 관련이 없는 용어입니다.  Sequential은 소프트웨어 개발 프로세스의 한 단계를 나타내는 용어일 수 있지만, COCOMO 모델에서 프로젝트의 특성을 구분하는 기준이 아니기 때문에 정답은 4번입니다.",81,147
189,2,89,빅데이터 분석 기술 중 대량의 데이터를 분석하여 데이터 속에 내재되어 있는 변수 사이의 상호관례를 규명하여 일정한 패턴을 찾아내는 기법은?,,Data Mining,Wm-Bus,Digital Twin,Zigbee,1,"문제에서 묻고 있는 것은 대량의 데이터를 분석하여 데이터 내 변수 간의 관계를 파악하고 패턴을 찾는 기법입니다.  Data Mining(데이터 마이닝)은 바로 이러한 목적을 달성하기 위한 기술입니다.  데이터 마이닝은 대규모 데이터셋에서 유용한 정보, 패턴, 지식을 발견하는 과정을 말하며, 통계적 기법, 머신러닝 알고리즘 등을 활용하여 데이터 속에 숨겨진 상관관계나 예측 가능한 패턴을 찾아냅니다.  반면, Wm-Bus, Digital Twin, Zigbee는 각각 원격검침 시스템, 디지털 트윈 기술, 무선 통신 프로토콜을 의미하며, 데이터 분석 기법과는 직접적인 관련이 없습니다. 따라서 정답은 Data Mining입니다.",80,135
190,2,90,"기존 무선 랜의 한계 극복을 위해 등장하였으며, 대규모 디바이스의 네트워크 생성에 최적화되어 차세대 이동통신, 홈네트워킹, 공공 안전 등의 특수목적을 위한 새로운 방식의 네트워크 기술을 의미하는 것은?",,Software Defined Perimeter,Virtual Private Network,Local Area Network,Mesh Network,4,"기존 무선랜(예를 들어 Wi-Fi)은 중앙 장치(Access Point)를 중심으로 통신하는 방식이라, 장치가 많아지거나 거리가 멀어지면 성능이 저하되는 한계가 있습니다.  Mesh Network는 여러 장치가 서로 연결되어 네트워크를 형성하는 방식입니다.  각 장치가 중계기 역할을 하므로, 중앙 장치에 대한 의존도가 낮아 대규모 장치 연결에 유리하고, 통신 범위도 넓힐 수 있습니다.  따라서 차세대 이동통신, 홈 네트워킹, 공공 안전 등 대규모 네트워크가 필요한 분야에 적합합니다.  Software Defined Perimeter는 네트워크 보안 기술, Virtual Private Network는 가상 사설망 기술, Local Area Network는 근거리 통신망 기술로 문제의 상황과는 부합하지 않습니다.",62,149
191,2,91,DDoS 공격과 연관이 있는 공격 방법은?,,Secure shell,Tribe Flood Network,Nimda,Deadlock,2,"DDoS(Distributed Denial of Service) 공격은 여러 대의 컴퓨터(봇넷)를 이용하여 특정 서버나 네트워크에 과도한 트래픽을 발생시켜 서비스를 마비시키는 공격입니다.  Tribe Flood Network는 이러한 DDoS 공격에 사용되는 봇넷의 한 종류로, 많은 수의 감염된 컴퓨터를 제어하여 대규모 DDoS 공격을 수행할 수 있습니다.  나머지 선택지들은 DDoS 공격과 직접적인 관련이 없습니다. Secure shell은 안전한 원격 접속을 위한 프로토콜이고, Nimda는 웜 바이러스의 일종이며, Deadlock은 프로그램 실행 중 발생하는 교착 상태를 의미합니다. 따라서 DDoS 공격과 관련된 공격 방법은 Tribe Flood Network입니다.",68,155
192,2,92,CPM 네트워크가 다음과 같을 때 임계경로의 소요기일은?,https://www.cbtbank.kr/images/iz/iz20200822/iz20200822m92.gif,10일,12일,14일,16일,3,"CPM(Critical Path Method) 네트워크는 프로젝트의 작업들을 네트워크로 표현하여 각 작업의 소요시간을 고려하여 프로젝트 완료까지의 최소 시간(임계경로)을 구하는 기법입니다.  문제에서 주어진 네트워크를 살펴보면, 여러 경로가 존재합니다. 각 경로의 소요시간을 계산하여 가장 긴 경로를 찾아야 합니다.",75,147
193,2,93,RIP(Routing Information Protocol)에 대한 설명으로 틀린 것은?,,거리 벡터 라우팅 프로토콜이라고도 한다.,소규모 네트워크 환경에 적합하다.,최대 홉 카운트를 115홉 이하로 한정하고 있다.,최단경로탐색에는 Bellman-Ford 알고리즘을 사용한다.,3,"RIP(Routing Information Protocol)는 라우터들이 서로 네트워크 정보를 주고받아 최적의 경로를 찾는 라우팅 프로토콜입니다.  문제에서 틀린 것은 3번입니다. RIP는 최대 홉 카운트(한 경로를 따라 거치는 라우터의 수)를 15홉으로 제한하고 있습니다.  115홉이라는 것은 잘못된 정보입니다.  RIP는 거리 벡터 라우팅 프로토콜로, 각 라우터는 자신과 연결된 다른 라우터까지의 거리(홉 수)를 알려주고, 이 정보를 바탕으로 Bellman-Ford 알고리즘을 사용하여 최단 경로를 계산합니다. 소규모 네트워크에서 효율적으로 작동하지만, 대규모 네트워크에서는 15홉 제한 때문에 경로가 제대로 설정되지 않을 수 있으며, 느린 수렴 속도 때문에 성능이 저하될 수 있습니다. 따라서 소규모 네트워크에 적합하다는 2번은 맞는 설명입니다.  요약하자면, RIP는 홉 카운트 제한(15홉)과 Bellman-Ford 알고리즘 사용이 특징이며, 소규모 네트워크에 적합한 거리 벡터 라우팅 프로토콜입니다.",73,149
194,2,94,"소프트웨어 생명주기 모형 중 고전적 생명주기 모형으로 선형 순차적 모델이라고도 하며, 타당성 검토, 계획, 요구사항 분석, 구현, 테스트, 유지보수의 단계를 통해 소프트웨어를 개발하는 모형은?",,폭포수 모형,애자일 모형,컴포넌트 기반 방법론,6GT 모형,1,"문제에서 설명하는 소프트웨어 개발 모형은 '폭포수 모형'입니다.  폭포수 모형은 소프트웨어 개발 과정을 여러 단계로 나누어 순차적으로 진행하는 전통적인 방법론입니다.  마치 폭포수가 위에서 아래로 떨어지듯이, 각 단계가 완료되어야만 다음 단계로 넘어갈 수 있습니다.  문제에서 제시된 타당성 검토, 계획, 요구사항 분석, 구현, 테스트, 유지보수 단계는 폭포수 모형의 전형적인 단계들을 보여줍니다.  각 단계는 명확하게 구분되며, 이전 단계의 결과물이 다음 단계의 입력으로 사용됩니다.  다른 선택지인 애자일 모형은 반복적인 개발과 유연성을 강조하는 반면, 폭포수 모형은 계획 중심적이고 변화에 대한 대응이 상대적으로 덜 유연합니다.  컴포넌트 기반 방법론은 기존의 소프트웨어 컴포넌트를 재사용하는 방식이고, 6GT 모형은 특정한 소프트웨어 개발 방법론을 지칭하는 용어가 아닙니다. 따라서, 제시된 단계들을 고려했을 때, 정답은 폭포수 모형입니다.",89,147
195,2,95,소프트웨어 개발 모델 중 나선형 모델의 4가지 주요 활동이 순서대로 나열된 것은?,https://www.cbtbank.kr/images/iz/iz20200822/iz20200822m95.gif,Ⓐ-Ⓑ-Ⓓ-Ⓒ 순으로 반복,Ⓐ-Ⓓ-Ⓒ-Ⓑ 순으로 반복,Ⓐ-Ⓑ-Ⓒ-Ⓓ 순으로 반복,Ⓐ-Ⓒ-Ⓑ-Ⓓ 순으로 반복,2,"나선형 모델은 소프트웨어 개발 과정을 여러 번의 반복적인 사이클(나선)로 진행하는 모델입니다. 각 사이클은 계획 수립, 위험 분석, 개발 및 검증, 고객 평가의 네 가지 주요 활동으로 구성됩니다.  먼저, 계획을 세우고(Ⓐ)  잠재적인 위험을 분석하여(Ⓓ)  해결 방안을 마련합니다. 그 후, 실제 소프트웨어를 개발하고 검증하며(Ⓒ),  마지막으로 고객에게 평가를 받아(Ⓑ) 다음 사이클을 위한 피드백을 얻습니다. 이 과정을 여러 번 반복하며 점진적으로 소프트웨어를 완성해 나가는 것이 나선형 모델의 특징입니다. 따라서, 각 사이클의 순서는 Ⓐ-Ⓓ-Ⓒ-Ⓑ가 되며, 이 순서를 반복하는 것이 나선형 모델의 핵심입니다.",82,147
196,2,96,"전자 칩과 같은 소프트웨어 부품, 즉 블록(모듈)을 만들어서 끼워 맞추는 방법으로 소프트웨어를 완성시키는 재사용 방법은?",,합성 중심,생성 중심,분리 중심,구조 중심,1,"소프트웨어를 전자 칩과 같은 작은 단위, 즉 블록(모듈)으로 나누어 만들고, 이러한 블록들을 조립하듯이 끼워 맞춰서 완성하는 방식을 생각해 보세요.  마치 레고 블록을 조립하는 것처럼, 미리 만들어 놓은 여러 개의 블록들을 조합하여 새로운 소프트웨어를 만드는 것입니다. 이러한 재사용 방법을  '합성 중심'이라고 합니다.  '합성'이라는 단어에서 알 수 있듯이, 기존에 만들어진 부품들을 합쳐서 새로운 것을 만드는 방식이기 때문입니다.  반대로,  '생성 중심'은 처음부터 소프트웨어를 새로 만드는 방식이고, 다른 선택지는 이 문제와 직접적인 관련이 없습니다.",73,106
197,2,97,"다음 JAVA코드에서 밑줄로 표시된 부분에는 어떤 보안 약점이 존재하는가? (단, key는 암호화 키를 저장하는 변수이다.)",https://www.cbtbank.kr/images/iz/iz20200822/iz20200822m97.gif,무결성 검사 없는 코드 다운로드,중요 자원에 대한 잘못된 권한 설정,하드코드된 암호화 키 사용,적절한 인증없는 중요 기능 허용,3,"JAVA 코드에서 암호화 키 `""22df3023sf~2:asn!@#/as>""`가 코드 내부에 직접적으로 작성되어 있습니다. 이렇게 키를 코드에 직접적으로 포함하는 것을 ""하드코드(Hardcoded)""라고 합니다.  만약 이 코드가 악의적인 목적으로 해킹당하거나, 코드 자체가 유출될 경우, 암호화 키도 함께 노출되어 시스템의 보안이 심각하게 위협받게 됩니다.  암호화의 목적은 데이터를 보호하기 위한 것이지만, 키가 노출되면 암호화는 무용지물이 되기 때문입니다.  따라서, 암호화 키는 코드 외부의 안전한 장소(예: 환경 변수, 암호화된 설정 파일, 키 관리 시스템)에 저장하고, 프로그램 실행 시 안전하게 불러와 사용하는 것이 중요합니다.  이 문제는 하드코드된 암호화 키 사용으로 인한 보안 취약점을 다루고 있습니다.",78,154
198,2,98,소프트웨어 개발 표준 중 소프트웨어 품질 및 생산성 향상을 위해 소프트웨어 프로세스를 평가 및 개선하는 국제 표준은?,,SCRUM,ISO/IEC 12509,SPICE,CASE,3,"소프트웨어 품질 및 생산성 향상을 위해 소프트웨어 프로세스를 평가하고 개선하는 국제 표준을 묻는 문제입니다.  SCRUM은 애자일 개발 방법론 중 하나이며, ISO/IEC 12509는 소프트웨어 테스트에 관한 표준입니다. CASE는 컴퓨터 지원 소프트웨어 공학 도구를 의미합니다.  반면 SPICE(SPICE: Software Process Improvement and Capability dEtermination)는 소프트웨어 프로세스 성숙도를 평가하고 개선하기 위한 국제 표준 프레임워크입니다.  따라서 소프트웨어 프로세스의 평가 및 개선이라는 문제의 요구사항에 가장 적합한 답은 SPICE입니다.  SPICE는 조직의 소프트웨어 개발 프로세스를 평가하여 그 성숙도를 측정하고, 개선을 위한 구체적인 방향을 제시하는 데 사용됩니다.  정보처리기사 공식 교재에서는 SPICE를 소프트웨어 프로세스 개선 및 평가를 위한 표준으로 다루고 있을 것입니다.",69,148
199,2,99,실무적으로 검증된 개발보안 방법론 중 하나로써 SW보안의 모범 사례를 SDLC(Software Development Life Cycle)에 통합한 소프트웨어 개발 보안 생명주기 방법론은?,,CLASP,CWE,PIMS,Seven Touchpoints,4,"소프트웨어 개발 보안 생명주기 방법론은 소프트웨어 개발의 전 과정(SDLC)에 보안을 고려하여 개발하는 방법론입니다.  문제에서 제시된 4번, Seven Touchpoints는  소프트웨어 개발 단계별로 보안 활동을 수행하는 대표적인 모범 사례 중 하나입니다.  즉,  요구사항 분석부터 설계, 구현, 테스트, 배포, 운영, 폐기까지 전 단계에서 보안을 고려하여  취약점을 최소화하고 안전한 소프트웨어를 개발하는 것을 목표로 합니다. 다른 선택지들은  SW 보안과 직접적으로 관련된 개념이지만, SDLC 전반에 걸쳐 보안을 통합하는 방법론으로서 Seven Touchpoints만큼 명확하게 제시하지는 않습니다.  CLASP는 보안 취약성을 분류하는 체계이고, CWE는 약점 목록이며, PIMS는 특정 보안 관리 시스템과 관련된 용어일 가능성이 높습니다. 따라서,  SW 보안의 모범 사례를 SDLC에 통합한 방법론으로는 Seven Touchpoints가 가장 적절합니다.",55,153
200,2,100,다음 LAN의 네트워크 토폴로지는?,https://www.cbtbank.kr/images/iz/iz20200822/iz20200822m100.gif,버스형,성형,링형,그물형,1,"문제에서 제시된 그림은 여러 개의 스테이션(컴퓨터)이 하나의 통신선(버스)에 연결되어 있는 네트워크 구조를 보여줍니다.  데이터는 이 버스를 통해 모든 스테이션으로 전송되며, 각 스테이션은 전송되는 모든 데이터를 수신하지만, 자신에게 전송된 데이터만 처리합니다. 이러한 구조는 버스형 토폴로지의 특징입니다. 성형 토폴로지는 중앙 허브를 중심으로 연결되는 구조이고, 링형 토폴로지는 스테이션들이 링 형태로 연결되는 구조이며, 그물형 토폴로지는 여러 경로를 통해 데이터를 전송하는 구조입니다. 문제 그림과 일치하는 것은 버스형 토폴로지이므로 정답은 1번입니다.",90,145
201,3,1,XP(eXtreme Programming)의 기본원리로 볼 수 없는 것은?,,Linear Sequential Method,Pair Programming,Collective Ownership,Continuous Integration,1,"XP(eXtreme Programming)는 소프트웨어 개발 방법론 중 하나로, 빠르게 변화하는 요구사항에 유연하게 대처하고 고품질의 소프트웨어를 개발하기 위한 목적으로 고안되었습니다.  문제에서 제시된 옵션들을 살펴보면, Pair Programming(짝 프로그래밍), Collective Ownership(집단 소유), Continuous Integration(지속적 통합)은 모두 XP의 핵심 원리입니다.  Pair Programming은 두 명의 프로그래머가 함께 코드를 작성하여 코드 품질을 높이고 지식을 공유하는 방식이고, Collective Ownership은 모든 개발자가 모든 코드에 대해 책임을 지는 방식으로, 유연성과 협업을 증진시킵니다. Continuous Integration은 코드를 자주 통합하여 오류를 조기에 발견하고 해결하는 방식입니다. 반면, Linear Sequential Method(선형 순차적 방법)는 폭포수 모델과 같이 단계별로 순차적으로 진행하는 개발 방법론으로, XP의 반복적이고 점진적인 개발 방식과는 상반됩니다. XP는 변화에 대한 적응력을 중시하며, 선형적인 순차적 접근 방식과는 맞지 않습니다. 따라서 XP의 기본 원리로 볼 수 없는 것은 Linear Sequential Method입니다.",72,147
202,3,2,럼바우(Rumbaugh) 객체지향 분석 기법에서 동적 모델링에 활용되는 다이어그램은?,,객체 다이어그램(Object Diagram),패키지 다이어그램(Package Diagram),상태 다이어그램(State Diagram),자료 흐름도(Data Flow Diagram),3,"럼바우 객체지향 분석 기법은 시스템을 객체들의 상호작용으로 모델링하는 기법입니다.  동적 모델링은 시스템의 시간에 따른 변화와 객체들의 상호작용을 표현하는 것을 의미하는데, 이를 위해 럼바우 기법에서는 상태 다이어그램(State Diagram)을 사용합니다. 상태 다이어그램은 객체의 상태 변화와 그에 따른 이벤트 처리를 시각적으로 보여주는 다이어그램입니다.  객체의 상태가 어떤 이벤트에 의해 어떻게 변화하는지, 그리고 각 상태에서 어떤 동작을 수행하는지를 화살표와 상태 박스를 이용하여 표현합니다.  따라서 시스템의 동적인 측면을 분석하고 설계하는 데 매우 유용합니다.  객체 다이어그램은 객체의 구조를, 패키지 다이어그램은 시스템의 구성 요소를, 자료 흐름도는 데이터의 흐름을 나타내는 다이어그램이므로 동적 모델링과는 직접적인 관련이 없습니다.",68,102
203,3,3,CASE(Computer Aided Software Engineering)의 주요 기능으로 옳지 않은 것은?,,S/W 라이프 사이클 전 단계의 연결,그래픽 지원,다양한 소프트웨어 개발 모형 지원,언어 번역,4,"CASE(Computer Aided Software Engineering)는 소프트웨어 개발 과정을 자동화하고 효율적으로 관리하기 위한 도구입니다.  문제에서 제시된 1번, 2번, 3번은 모두 CASE 도구의 주요 기능입니다.  소프트웨어 개발의 전 단계를 연결하여 통합 관리하고(1), 그래픽 인터페이스를 통해 직관적인 사용을 지원하며(2), 다양한 개발 방법론(예: 폭포수 모델, 애자일)을 지원하는(3) 것이 CASE의 핵심 기능입니다. 하지만 4번, 언어 번역은 CASE의 주요 기능이 아닙니다.  언어 번역은 컴파일러나 인터프리터와 같은 별도의 도구가 담당하는 영역이며, CASE는 소프트웨어 개발 *과정* 자체를 지원하는 데 초점을 맞춥니다.  따라서 소프트웨어 개발 과정의 효율성을 높이는 데 직접적으로 기여하지 않는 언어 번역은 CASE의 주요 기능으로 보기 어렵습니다.",86,147
204,3,4,객체지향 기법의 캡슐화(Encapsulation)에 대한 설명으로 틀린 것은?,,인터페이스가 단순화 된다.,소프트웨어 재사용성이 높아진다.,변경 발생 시 오류의 파급효과가 적다.,상위 클래스의 모든 속성과 연산을 하위 클래스가 물려받는 것을 의미한다.,4,"캡슐화(Encapsulation)는 객체지향 프로그래밍의 핵심 개념 중 하나입니다.  객체의 속성(데이터)과 연산(메서드)을 하나로 묶어서 외부로부터 직접 접근하지 못하도록 감추는 것을 의미합니다.  이는 마치 약 상자처럼, 약의 성분(데이터)과 복용법(메서드)은 상자 안에 들어있고, 사용자는 상자 겉면에 적힌 정보(인터페이스)만 보고 약을 복용하는 것과 같습니다.  따라서 캡슐화를 통해 인터페이스는 단순해지고, 내부 구현이 변경되더라도 외부에 영향을 미치지 않아 소프트웨어의 재사용성과 안정성이 높아집니다.  하지만 4번의 경우, 상위 클래스의 모든 속성과 연산을 하위 클래스가 무조건 물려받는 것은 상속(Inheritance)의 개념이며, 캡슐화와는 별개의 개념입니다.  캡슐화는 정보 은닉을 통해 외부 접근을 제한하는 것이지, 상속을 통해 모든 것을 물려주는 것을 의미하지 않습니다.  따라서 4번이 틀린 설명입니다.",90,107
205,3,5,다음 내용이 설명하는 객체지향 설계 원칙은?,https://www.cbtbank.kr/images/iz/iz20200926/iz20200926m5.gif,인터페이스 분리 원칙,단일 책임 원칙,개방 폐쇄의 원칙,리스코프 교체의 원칙,1,"이 문제는 객체지향 설계 원칙 중 하나인 '인터페이스 분리 원칙(Interface Segregation Principle)'을 묻고 있습니다.  클라이언트(프로그램이나 다른 시스템)는 자신이 실제로 사용하지 않는 메서드나 인터페이스에 의존해서는 안 된다는 원칙입니다.  마치 레스토랑에서 필요 없는 메뉴까지 다 주문할 필요가 없는 것과 같습니다.  필요한 메뉴(메서드)만 주문(사용)하고, 불필요한 메뉴(메서드)는 주문하지 않아도(사용하지 않아도) 되도록 인터페이스를 분리하는 것이 좋습니다.  문제에서 제시된 설명은 클라이언트가 불필요한 메서드나 인터페이스로 인해 영향을 받지 않아야 한다는 점을 강조하고 있으며, 이는 인터페이스 분리 원칙의 핵심 내용입니다.  다른 선택지들은 이러한 클라이언트의 불필요한 의존성 문제를 직접적으로 다루지 않습니다.",79,107
206,3,6,파이프 필터 형태의 소프트웨어 아키텍처에 대한 설명으로 옳은 것은?,,노드와 간선으로 구성된다.,서브시스템이 입력데이터를 받아 처리하고 결과를 다음 서브시스템으로 넘겨주는 과정을 반복한다.,계층 모델이라고도 한다.,"3개의 서브시스템(모델, 뷰, 제어)으로 구성되어 있다.",2,"파이프 필터 아키텍처는 데이터 처리 과정을 여러 개의 필터(서브시스템)로 나누어, 각 필터가 데이터를 순차적으로 처리하는 방식입니다.  마치 공장의 조립 라인처럼,  입력 데이터가 첫 번째 필터에 들어가 처리된 후 결과가 다음 필터로 전달되고, 이 과정이 마지막 필터까지 반복됩니다.  각 필터는 특정 작업만 수행하므로, 시스템을 모듈화하고 유지보수를 용이하게 합니다.  1번은 파이프-필터 아키텍처가 그래프 형태로 표현될 수 있지만,  그것이 아키텍처의 본질적인 특징을 설명하는 것은 아닙니다. 3번은 계층적 아키텍처를 설명하는 것이고, 4번은 MVC(Model-View-Controller) 아키텍처를 설명하는 것입니다. 따라서 2번이 파이프 필터 아키텍처의 가장 핵심적인 특징을 정확하게 나타내는 설명입니다.",78,106
207,3,7,"코드화 대상 항목의 중량, 면적, 용량 등의 물리적 수치를 이용하여 만든 코드는?",,순차 코드,10진 코드,표의 숫자 코드,블록 코드,3,"코드화 대상 항목의 물리적 수치(중량, 면적, 용량 등)를 이용하여 만든 코드는 '표의 숫자 코드'입니다.  순차 코드는 순서대로 숫자를 부여하는 방식이고, 10진 코드는 10진수를 이용하는 방식이며, 블록 코드는 특정 범위의 숫자를 블록으로 묶어 코드화하는 방식입니다.  반면 표의 숫자 코드는  물리적 수치를  표에 매핑하여 코드를 부여하는 방식으로,  예를 들어  무게 10g은 코드 'A1', 면적 100cm²는 코드 'B2' 와 같이  물리적 특성과 코드를  표 형태로  관계를 맺어  코드화하는 것을 의미합니다. 따라서 중량, 면적, 용량과 같은 물리적 수치를 코드로 변환하는 데 가장 적합한 방식은 표의 숫자 코드입니다.",76,130
208,3,8,디자인 패턴 사용의 장٠단점에 대한 설명으로 거리가 먼 것은?,,소프트웨어 구조 파악이 용이하다.,객체지향 설계 및 구현의 생산성을 높이는데 적합하다.,재사용을 위한 개발 시간이 단축된다.,절차형 언어와 함께 이용될 때 효율이 극대화된다.,4,"디자인 패턴은 소프트웨어 개발에서 자주 발생하는 문제에 대한 재사용 가능한 해결책을 제공하는 일종의 템플릿입니다.  마치 요리 레시피처럼, 특정 상황에 맞는 코드 구조와 설계 원칙을 미리 정의해 놓은 것이죠.  따라서 소프트웨어 구조를 이해하기 쉽게 만들고, 객체지향 설계의 생산성을 높이며, 코드 재사용을 통해 개발 시간을 단축하는 데 효과적입니다. 하지만 디자인 패턴은 객체지향 프로그래밍 언어에 최적화되어 있으며, 절차형 언어와의 호환성은 떨어집니다. 절차형 언어와 함께 사용하면 오히려 복잡성이 증가할 수 있고 효율이 떨어질 수 있습니다. 따라서 4번 선택지 ""절차형 언어와 함께 이용될 때 효율이 극대화된다""는 디자인 패턴의 장점이 아닌 단점을 나타내는 잘못된 설명입니다.",85,107
209,3,9,DFD(data flow diagram)에 대한 설명으로 틀린 것은?,,자료 흐름 그래프 또는 버블(bubble) 차트라고도 한다.,구조적 분석 기법에 이용된다.,시간 흐름을 명확하게 표현할 수 있다.,"DFD의 요소는 화살표, 원, 사각형, 직선(단선/이중선)으로 표시한다.",3,"DFD(Data Flow Diagram, 자료 흐름도)는 시스템 내에서 데이터가 어떻게 흐르는지를 시각적으로 표현하는 도구입니다.  마치 물이 파이프를 통해 흐르는 모습을 그림으로 나타내는 것과 같습니다.  원(버블)은 데이터를 처리하는 과정(프로세스)을, 화살표는 데이터의 흐름을, 사각형은 외부 엔티티(데이터의 출처 또는 목적지)를, 직선은 데이터 저장소를 나타냅니다.  따라서 1번과 2번, 4번 설명은 모두 맞는 설명입니다. 하지만 3번은 틀린 설명입니다. DFD는 데이터의 흐름을 중점적으로 보여주는 것이지, 시간의 흐름을 명확하게 표현하는 데 초점을 맞춘 도구는 아닙니다.  시간 흐름을 표현하려면 다른 도구(예: 시퀀스 다이어그램)를 사용해야 합니다.  DFD는 시스템의 구조와 데이터 흐름을 이해하기 쉽게 만들어주는 분석 도구로, 구조적 분석 기법에서 중요한 역할을 합니다.",71,103
210,3,10,그래픽 표기법을 이용하여 소프트웨어 구성 요소를 모델링하는 럼바우 분석 기법에 포함되지 않는 것은?,,객체 모델링,기능 모델링,동적 모델링,블랙박스 분석 모델링,4,"럼바우 분석 기법은 객체지향 분석 기법의 하나로, 시스템을 객체, 속성, 메서드로 모델링하여 시스템의 구조와 동작을 표현하는 방법입니다.  객체 모델링은 객체 간의 관계를 정의하고, 기능 모델링은 시스템의 기능을 표현하며, 동적 모델링은 시스템의 시간에 따른 변화를 나타냅니다.  반면 블랙박스 분석 모델링은 시스템의 내부 구조를 고려하지 않고, 입력과 출력만을 고려하여 시스템을 분석하는 방법입니다.  럼바우 분석 기법은 시스템의 내부 구조를 모델링하는 데 중점을 두기 때문에, 시스템의 내부 구조를 무시하는 블랙박스 분석 모델링은 포함되지 않습니다.  쉽게 말해, 럼바우 기법은 시스템의 '부품'과 '부품 간의 연결'을 자세히 그리는 그림을 그리는 방법인데, 블랙박스 분석은 '상자 안이 어떻게 생겼는지'는 신경 쓰지 않고 '상자에 무엇을 넣으면 무엇이 나오는지'만 보는 방법입니다. 따라서 럼바우 기법에는 블랙박스 분석 모델링이 포함되지 않는 것이죠.",94,103
211,3,11,UML의 기본 구성요소가 아닌 것은?,,Things,Terminal,Relationship,Diagram,2,"UML(Unified Modeling Language)은 소프트웨어 시스템을 시각적으로 표현하는 표준 모델링 언어입니다.  UML의 기본 구성 요소는 시스템을 구성하는 요소(Things), 요소들 간의 관계(Relationship), 그리고 이러한 요소와 관계를 표현하는 다이어그램(Diagram)으로 이루어져 있습니다.  'Things'는 클래스, 인터페이스, 객체 등 시스템의 구성 요소를 나타내고, 'Relationship'은 이들 구성 요소 간의 연관성(연결, 상속 등)을 나타내며, 'Diagram'은 이러한 요소와 관계를 시각적으로 보여주는 다양한 그림(예: 클래스 다이어그램, 시퀀스 다이어그램)입니다.  문제에서 제시된 'Terminal'은 UML의 기본 구성 요소가 아닙니다. 'Terminal'은 일반적으로 사용자 인터페이스나 통신 포트 등을 의미하며, UML 모델링에서는 다른 요소(예: 클래스, 인터페이스)로 표현됩니다. 따라서 UML의 기본 구성 요소가 아닌 것은 2번 Terminal입니다.",70,102
212,3,12,소프트웨어의 상위설계에 속하지 않는 것은?,,아키텍처 설계,모듈 설계,인터페이스 정의,사용자 인터페이스 설계,2,"소프트웨어 상위 설계는 시스템의 전체적인 구조와 뼈대를 잡는 단계입니다.  아키텍처 설계는 시스템의 전체적인 구조를 설계하는 것이고, 인터페이스 정의는 시스템 내부 또는 외부 시스템과의 데이터 교환 방식을 정의하는 것이며, 사용자 인터페이스 설계는 사용자가 시스템과 상호작용하는 방식을 디자인하는 것입니다.  반면 모듈 설계는 상위 설계에서 정의된 아키텍처 내에서 개별적인 기능을 수행하는 모듈들을 구체적으로 설계하는 단계입니다. 상위 설계는 시스템의 큰 그림을 그리는 것이므로, 개별 모듈의 세부적인 설계는 상위 설계의 범위를 넘어선다고 볼 수 있습니다. 따라서 소프트웨어 상위 설계에 속하지 않는 것은 모듈 설계입니다.  상위 설계는 전체적인 구조와 인터페이스를 정의하는 데 집중하고, 모듈 설계는 그 이후에 이루어지는 하위 설계의 영역입니다.",54,106
213,3,13,다음 중 자료사전(Data Dictionary)에서 선택의 의미를 나타내는 것은?,,[ ],{ },＋,＝,1,"자료사전(Data Dictionary)은 데이터베이스 시스템에서 사용되는 데이터의 구조와 의미를 정의하는 문서입니다.  여기서 각 데이터 항목의 속성(데이터 타입, 길이 등)뿐만 아니라,  데이터의 의미와 제약 조건 등을 명확하게 기술합니다. 문제에서 괄호 기호는 데이터의 선택적 속성을 나타내는 데 사용됩니다.  `[]`는 해당 항목이 선택적임을 의미하며,  `{}`는 집합을 나타내는 기호로,  `+`는 반복을 의미하고, `=`는 할당을 의미합니다. 따라서 자료사전에서 선택의 의미를 나타내는 기호는 `[]`입니다.  쉽게 말해,  `[이름]` 이라고 되어 있다면 이름 항목은 입력하지 않아도 된다는 뜻입니다.",82,127
214,3,14,소프트웨어의 사용자 인터페이스개발시스템(User Interface Development System)이 가져야 할 기능이 아닌 것은?,,사용자 입력의 검증,에러 처리와 에러 메시지 처리,도움과 프롬프트(prompt) 제공,소스 코드 분석 및 오류 복구,4,"사용자 인터페이스 개발 시스템(UI Development System)은 사용자가 소프트웨어를 쉽고 효율적으로 사용할 수 있도록 인터페이스를 개발하는 데 필요한 도구와 기능들을 제공하는 시스템입니다.  문제에서 제시된 1번, 2번, 3번 기능들은 모두 사용자에게 양질의 인터페이스를 제공하기 위해 필수적인 요소입니다. 사용자 입력을 검증하여 잘못된 입력을 방지하고, 에러 발생 시 적절한 메시지를 표시하여 사용자가 문제를 해결하도록 돕고, 도움말이나 안내 메시지를 제공하여 사용성을 높이는 것은 UI 개발 시스템의 중요한 역할입니다.  반면 4번 기능인 '소스 코드 분석 및 오류 복구'는 개발자를 위한 기능이지, 사용자 인터페이스를 개선하기 위한 기능이 아닙니다. 소스 코드 분석 및 오류 복구는 소프트웨어 개발 과정의 다른 단계에서 수행되는 작업이며, UI 개발 시스템의 핵심 기능이라고 보기 어렵습니다. 따라서 사용자 인터페이스 개발 시스템이 가져야 할 기능이 아닌 것은 소스 코드 분석 및 오류 복구입니다.",85,104
215,3,15,요구 사항 명세기법에 대한 설명으로 틀린 것은?,,비정형 명세기법은 사용자의 요구를 표현할 때 자연어를 기반으로 서술한다.,비정형 명세기법은 사용자의 요구를 표현할 때 Z 비정형 명세기법을 사용한다.,정형 명세기법은 사용자의 요구를 표현할 때 수학적인 원리와 표기법을 이용한다.,정형 명세기법은 비정형 명세기법에 비해 표현이 간결하다.,2,"요구사항 명세 기법은 사용자의 요구를 문서화하는 방법입니다.  정형 명세 기법은 수학적 표기법이나 형식 언어를 사용하여 명확하고 모호하지 않게 요구사항을 기술하는 반면, 비정형 명세 기법은 자연어를 사용하여 상대적으로 자유롭게 요구사항을 기술합니다.  문제에서 틀린 것은 2번입니다. Z 기법은 정형 명세 기법의 한 종류이지 비정형 명세 기법이 아닙니다. 비정형 명세 기법은 자연어를 사용하여 요구사항을 서술하는 것이 특징이며, Z 기법과 같은 정형적인 표현 방식을 사용하지 않습니다. 따라서 2번은 요구사항 명세 기법에 대한 잘못된 설명입니다.",70,102
216,3,16,소프트웨어 개발 단계에서 요구 분석 과정에 대한 설명으로 거리가 먼 것은?,,분석 결과의 문서화를 통해 향후 유지보수에 유용하게 활용 할 수 있다.,개발 비용이 가장 많이 소요되는 단계이다.,"자료흐름도, 자료 사전 등이 효과적으로 이용될 수 있다.",보다 구체적인 명세를 위해 소단위 명세서(Mini-Spec)가 활용될 수 있다.,2,"소프트웨어 개발 단계 중 요구 분석 단계는 사용자의 요구를 분석하고 문서화하는 과정입니다.  1번은 분석 결과를 문서로 남겨 유지보수에 활용한다는 내용으로, 요구 분석의 중요한 목표 중 하나입니다. 3번은 자료흐름도나 자료 사전과 같은 도구를 사용하여 분석을 효율적으로 수행할 수 있다는 내용으로, 요구 분석 과정에서 실제로 사용되는 기법들을 언급하고 있습니다. 4번은 보다 명확한 요구사항을 위해 소단위 명세서를 활용한다는 내용으로, 요구 분석의 세부적인 활동을 보여줍니다.  하지만 2번은 개발 비용이 가장 많이 소요되는 단계라는 주장입니다.  요구 분석 단계는 중요하지만, 실제로 개발 비용이 가장 많이 드는 단계는 구현이나 테스트 단계일 가능성이 높습니다. 요구 분석 단계에서는 주로 분석과 설계에 집중하며, 실제 코드 작성이나 테스트에 비해 비용이 상대적으로 적게 소요됩니다. 따라서 2번은 요구 분석 과정에 대한 설명으로 거리가 멉니다.",90,102
217,3,17,애자일 방법론에 해당하지 않는 것은?,,기능중심 개발,스크럼,익스트림 프로그래밍,모듈중심 개발,4,"애자일 방법론은 소프트웨어 개발 과정에서 유연성과 적응력을 높이기 위해 고안된 접근 방식입니다.  짧은 개발 주기(스프린트)를 통해 반복적으로 개발하고, 고객 피드백을 지속적으로 반영하여 변화하는 요구사항에 효과적으로 대응하는 것을 특징으로 합니다.  문제에서 제시된 1번 기능중심 개발, 2번 스크럼, 3번 익스트림 프로그래밍은 모두 애자일 방법론의 대표적인 예시입니다.  반면 4번 모듈중심 개발은 소프트웨어를 모듈 단위로 나누어 개발하는 방식으로, 애자일 방법론과는 직접적인 관련이 없습니다. 모듈 중심 개발은 애자일의 원칙과는 별개로, 소프트웨어의 구조와 관리를 효율적으로 하기 위한 일반적인 설계 기법입니다. 따라서 애자일 방법론에 해당하지 않는 것은 모듈중심 개발입니다.",68,102
218,3,18,클라이언트와 서버 간의 통신을 담당하는 시스템 소프트웨어를 무엇이라고 하는가?,,웨어러블,하이웨어,미들웨어,응용 소프트웨어,3,"클라이언트와 서버 간의 통신을 원활하게 중계해주는 시스템 소프트웨어를 미들웨어라고 합니다.  쉽게 말해, 서로 다른 시스템이나 프로그램들이 서로 소통할 수 있도록 다리 역할을 하는 소프트웨어입니다.  예를 들어, 웹 브라우저(클라이언트)가 웹 서버에 요청을 보내면, 미들웨어는 이 요청을 받아서 서버가 이해할 수 있는 형태로 변환하고, 서버의 응답을 다시 클라이언트가 이해할 수 있는 형태로 변환하여 전달하는 역할을 합니다.  따라서 클라이언트와 서버는 각자의 언어와 방식으로 통신하지 않고, 미들웨어라는 중간 매개체를 통해 효율적이고 안정적으로 통신할 수 있습니다.  웨어러블은 착용 가능한 기기, 하이웨어는 하드웨어를 의미하며, 응용 소프트웨어는 특정 작업을 수행하는 소프트웨어이므로 문제의 질문과는 관련이 없습니다.",92,110
219,3,19,GoF(Gangs of Four) 디자인 패턴 분류에 해당하지 않는 것은?,,생성 패턴,구조 패턴,행위 패턴,추상 패턴,4,"GoF 디자인 패턴은 객체지향 설계에서 자주 발생하는 문제들을 해결하기 위한 디자인 패턴들을 모아놓은 책 ""Design Patterns: Elements of Reusable Object-Oriented Software""에서 제시된 23가지 디자인 패턴들을 말합니다.  이 패턴들은 크게 생성 패턴, 구조 패턴, 행위 패턴으로 분류됩니다.  생성 패턴은 객체 생성 과정을 제어하는 패턴이고, 구조 패턴은 클래스나 객체를 구성하여 더 큰 구조를 만드는 패턴이며, 행위 패턴은 객체 간의 상호 작용과 책임 분배를 다루는 패턴입니다.  ""추상 패턴""은 GoF 디자인 패턴 분류에 포함되지 않는 개념입니다. 추상 패턴이라는 용어는 객체지향 설계에서 추상 클래스나 인터페이스를 사용하는 일반적인 설계 원칙을 의미할 수 있지만, GoF 디자인 패턴의 공식적인 분류에는 해당하지 않습니다. 따라서 GoF 디자인 패턴 분류에 해당하지 않는 것은 4번, 추상 패턴입니다.",83,107
220,3,20,바람직한 소프트웨어 설계 지침이 아닌 것은?,,적당한 모듈의 크기를 유지한다.,모듈 간의 접속 관계를 분석하여 복잡도와 중복을 줄인다.,모듈 간의 결합도는 강할수록 바람직하다.,모듈 간의 효과적인 제어를 위해 설계에서 계층적 자료 조직이 제시되어야 한다.,3,"소프트웨어 설계에서 모듈은 프로그램을 구성하는 작은 단위를 의미합니다.  모듈 간의 결합도는 서로 얼마나 의존적인지를 나타내는 척도입니다. 결합도가 높다는 것은 모듈들이 서로 복잡하게 얽혀있다는 뜻이며,  하나의 모듈을 변경할 때 다른 모듈에도 영향을 미칠 가능성이 높아 유지보수가 어려워집니다.  반대로 결합도가 낮으면 모듈 간의 의존성이 낮아 변경에 따른 영향이 적고, 유지보수가 용이해집니다. 따라서 바람직한 소프트웨어 설계는 모듈 간의 결합도를 낮추는 방향으로 설계하는 것이 좋습니다. 문제에서 3번은 ""모듈 간의 결합도는 강할수록 바람직하다""라고 되어 있는데, 이는 앞서 설명한 바와 같이 소프트웨어 유지보수의 어려움을 야기하므로 바람직하지 않은 설계 지침입니다.  나머지 1, 2, 4번은 모듈의 크기 조절, 모듈 간 관계 분석을 통한 복잡도 감소, 계층적 자료 조직을 통한 효율적인 제어 등 모두 좋은 소프트웨어 설계 원칙에 부합합니다.",93,106
221,3,21,소프트웨어 패키징 도구 활용 시 고려 사항으로 틀린 것은?,,반드시 내부 콘텐츠에 대한 암호화 및 보안을 고려한다.,보안을 위하여 이기종 연동을 고려하지 않아도 된다.,사용자 편의성을 위한 복잡성 및 비효율성 문제를 고려한다.,제품 소프트웨어 종류에 적합한 암호화 알고리즘을 적용한다.,2,"소프트웨어 패키징은 개발된 소프트웨어를 사용자가 쉽게 설치하고 사용할 수 있도록 포장하는 과정입니다.  문제에서 틀린 것은 2번입니다.  보안을 위해 이기종 연동을 고려하지 않아도 된다는 것은 잘못된 생각입니다.  실제로 다양한 운영체제나 플랫폼에서 소프트웨어를 사용할 수 있도록 하기 위해서는 이기종 시스템 간의 연동을 고려해야 합니다.  오히려 이기종 연동을 고려하지 않으면 소프트웨어의 활용 범위가 제한될 수 있고, 사용자에게 불편을 초래할 수 있습니다.  나머지 선택지는 모두 소프트웨어 패키징 과정에서 중요하게 고려해야 할 사항들입니다.  내부 콘텐츠 보안, 적절한 암호화 알고리즘 사용, 사용자 편의성 확보 등은 소프트웨어의 안전성과 사용성을 높이는 데 필수적입니다.",92,116
222,3,22,EAI(Enterprise Application Integration) 구축유형 중 Hybrid에 대한 설명으로 틀린 것은?,,Hub & Spoke와 Message Bus의 혼합방식이다.,필요한 경우 한 가지 방식으로 EAI구현이 가능하다.,데이터 병목현상을 최소화할 수 있다.,중간에 미들웨어를 두지 않고 각 애플리케이션을 point to point로 연결한다.,4,"EAI(Enterprise Application Integration)는 여러 기업 애플리케이션들을 서로 연결하여 데이터를 공유하고 업무 프로세스를 통합하는 기술입니다.  Hybrid 방식은 여러 EAI 구축 유형 중 하나로, Hub & Spoke 방식과 Message Bus 방식을 혼합하여 사용하는 것을 의미합니다. Hub & Spoke는 중앙 허브 시스템을 통해 여러 애플리케이션이 연결되는 방식이고, Message Bus는 애플리케이션들이 메시지를 주고받는 중개 시스템을 사용하는 방식입니다. Hybrid 방식은 각 방식의 장점을 결합하여 효율성을 높일 수 있습니다.  문제의 4번 선택지 ""중간에 미들웨어를 두지 않고 각 애플리케이션을 point to point로 연결한다""는 Hybrid 방식의 특징이 아닙니다. Hybrid 방식은 Hub & Spoke나 Message Bus와 같이 중간에 미들웨어를 사용하여 애플리케이션들을 연결하는 방식이기 때문입니다. Point-to-point 방식은 각 애플리케이션을 직접 연결하는 방식으로, 유지보수 및 확장성 측면에서 비효율적입니다. 따라서 4번이 틀린 설명입니다.",78,110
223,3,23,소스코드 품질분석 도구 중 정적분석 도구가 아닌 것은?,,pmd,checkstyle,valance,cppcheck,3,"소스코드 품질분석 도구는 개발된 소스코드의 품질을 분석하고 개선하는 데 사용되는 도구입니다.  정적 분석 도구는 코드를 실행하지 않고 코드 자체를 분석하여 버그나 취약점, 스타일 위반 등을 찾아내는 도구입니다.  PMD, Checkstyle, cppcheck는 모두 코드를 실행하지 않고 분석하는 정적 분석 도구입니다. 반면, Valance는 코드의 실행 결과를 분석하여 성능이나 안정성 등을 평가하는 동적 분석 도구입니다. 따라서 정적 분석 도구가 아닌 것은 Valance입니다.  쉽게 말해, 정적 분석 도구는 '코드를 보면서' 문제점을 찾는 것이고, 동적 분석 도구는 '코드를 돌려보면서' 문제점을 찾는 것입니다.  이 문제는 정적 분석 도구와 동적 분석 도구의 차이를 이해하고 있는지 묻는 문제입니다.",73,121
224,3,24,다음 Postfix 연산식에 대한 연산결과로 옳은 것은?,https://www.cbtbank.kr/images/iz/iz20200926/iz20200926m24.gif,35,42,77,360,2,"이 문제는 후위 표기법(Postfix notation)으로 표현된 연산식을 계산하는 문제입니다. 후위 표기법은 연산자가 피연산자 뒤에 오는 표기법으로, 괄호 없이 연산 순서를 명확하게 나타낼 수 있습니다.  문제의 연산식 ""3 4 * 5 6 * +""를 계산하는 과정은 다음과 같습니다.",88,111
225,3,25,인터페이스 보안을 위해 네트워크 영역에 적용될 수 있는 것으로 거리가 먼 것은?,,IPSec,SSL,SMTP,S-HTTP,3,"이 문제는 네트워크 영역에서 인터페이스 보안을 위해 사용되는 기술들을 묻고 있습니다.  IPSec과 SSL은 네트워크 통신의 보안을 담당하는 대표적인 프로토콜입니다. IPSec은 IP 패킷 자체를 암호화하여 네트워크 계층에서 보안을 제공하고, SSL(Secure Sockets Layer)은 애플리케이션 계층에서 데이터 암호화 및 인증을 제공하여 웹 통신 등에서 안전한 연결을 보장합니다.  S-HTTP(Secure HTTP)는 HTTP 프로토콜의 보안 버전으로, 웹 서버와 클라이언트 간의 안전한 통신을 위해 사용됩니다. 반면 SMTP(Simple Mail Transfer Protocol)는 이메일 전송 프로토콜로,  자체적으로 데이터 암호화 기능을 제공하지 않습니다. 따라서 네트워크 영역의 인터페이스 보안을 위해 직접적으로 사용되는 기술이 아니므로 정답은 SMTP입니다.  SMTP는 이메일 전송을 위한 프로토콜이지, 네트워크 통신 자체의 보안을 위한 프로토콜이 아니기 때문에 네트워크 영역의 인터페이스 보안과는 거리가 멉니다.  다른 선택지들은 모두 네트워크 통신의 보안을 강화하는 데 사용되는 기술입니다.",80,123
226,3,26,"검증(Validation) 검사 기법 중 개발자의 장소에서 사용자가 개발자 앞에서 행해지며, 오류와 사용상의 문제점을 사용자와 개발자가 함께 확인하면서 검사하는 기법은?",,디버깅 검사,형상 검사,자료구조 검사,알파 검사,4,"문제에서 설명하는 검사 기법은 개발자가 만든 프로그램을 사용자가 직접 사용해보면서 오류나 불편한 점을 찾는 과정입니다.  개발자의 장소에서 사용자가 직접 프로그램을 사용하고, 개발자는 옆에서 사용자의 행동을 관찰하며 문제점을 함께 확인합니다. 이러한 검사 기법은  '알파 검사'라고 합니다.  알파 검사는 소프트웨어 개발의 마지막 단계에서 사용자의 피드백을 받아 제품의 완성도를 높이는 데 중요한 역할을 합니다.  디버깅 검사는 개발자가 코드 내 오류를 찾는 과정이고, 형상 검사는 소프트웨어의 버전 관리 및 변경 사항 추적에 관한 것이며, 자료구조 검사는 프로그램의 데이터 구조 자체의 효율성을 검증하는 과정입니다. 따라서 사용자의 참여와 직접적인 사용 경험을 바탕으로 하는 검사 기법은 알파 검사가 가장 적절합니다.",88,119
227,3,27,다음 초기 자료에 대하여 삽입 정렬(Insertion Sort)을 이용하여 오름차순 정렬할 경우 1회전 후의 결과는?,https://www.cbtbank.kr/images/iz/iz20200926/iz20200926m27.gif,"3, 4, 8, 7, 9","3, 4, 9, 7, 8","7, 8, 3, 4, 9","3, 8, 4, 9, 7",4,"삽입 정렬(Insertion Sort)은 이미 정렬된 부분과 정렬되지 않은 부분으로 나누어 정렬하는 알고리즘입니다.  정렬되지 않은 부분의 첫 번째 원소를 선택하여 이미 정렬된 부분에서 적절한 위치를 찾아 삽입하는 과정을 반복합니다.  초기 자료가 8, 3, 4, 9, 7 이라고 할 때, 1회전은 첫 번째 원소인 8을 제외한 나머지 3, 4, 9, 7을 정렬된 부분으로 간주하고, 8을 이 부분에 삽입하는 과정입니다.  하지만 삽입 정렬은 첫 번째 원소를 기준으로 정렬을 시작하므로, 첫 번째 원소(8)는 이미 정렬된 것으로 간주하고 두 번째 원소(3)부터 시작합니다.  두 번째 원소 3을 첫 번째 원소 8과 비교하여 3이 8보다 작으므로 3을 8 앞으로 이동시킵니다.  그 결과 3, 8, 4, 9, 7이 됩니다. 따라서 1회전 후의 결과는 3, 8, 4, 9, 7 입니다.  문제의 정답 4번과 일치합니다.",77,111
228,3,28,소프트웨어 설치 매뉴얼에 대한 설명으로 틀린 것은?,,설치과정에서 표시될 수 있는 예외상황에 관련 내용을 별도로 구분하여 설명한다.,설치 시작부터 완료할 때까지의 전 과정을 빠짐없이 순서대로 설명한다.,설치 매뉴얼은 개발자 기준으로 작성한다.,"설치 매뉴얼에는 목차, 개요, 기본사항 등이 기본적으로 포함되어야 한다.",3,"소프트웨어 설치 매뉴얼은 사용자가 소프트웨어를 설치하는 과정을 안내하는 문서입니다.  따라서 사용자의 입장에서 명확하고 이해하기 쉽게 작성되어야 합니다. 1번은 예외 상황을 별도로 설명하여 사용자가 문제 발생 시 대처할 수 있도록 돕는 것이고, 2번은 설치 과정을 빠짐없이 순서대로 설명하여 사용자가 혼란 없이 설치를 진행할 수 있도록 합니다. 4번은 매뉴얼의 기본적인 구성 요소를 제시합니다. 하지만 3번은 개발자의 관점에서 작성하는 것이 아니라, 사용자(설치자)의 관점에서 작성되어야 합니다. 개발자가 알고 있는 내용을 전제로 작성하면 사용자가 이해하기 어려울 수 있기 때문입니다. 따라서 사용자 친화적인 설명과 설치 과정에 대한 명확한 안내가 중요합니다.  정답은 3번입니다.",93,117
229,3,29,인터페이스 구현 검증 도구가 아닌 것은?,,ESB,xUnit,STAF,NTAF,1,"이 문제는 인터페이스 구현 검증 도구를 묻고 있습니다.  ESB(Enterprise Service Bus)는 여러 시스템 간의 통합을 위한 미들웨어로, 시스템 간의 인터페이스를 연결하고 관리하는 역할을 합니다.  하지만 ESB 자체가 인터페이스 구현을 *검증*하는 도구는 아닙니다.  반면 xUnit, STAF, NTAF는 모두 소프트웨어 테스트를 위한 프레임워크 또는 도구로, 인터페이스 구현의 정확성과 기능을 검증하는 데 사용될 수 있습니다. xUnit은 단위 테스트 프레임워크의 대표적인 예시이며, STAF(Software Testing Automation Framework)와 NTAF(Network Testing Automation Framework)는 각각 소프트웨어 및 네트워크 테스트 자동화를 위한 프레임워크입니다. 따라서 인터페이스 구현 검증 도구가 아닌 것은 ESB입니다.  ESB는 검증 도구가 아니라 검증 대상인 인터페이스를 연결하는 역할을 수행하는 것이죠.",65,124
230,3,30,소프트웨어 형상 관리에서 관리 항목에 포함되지 않는 것은?,,프로젝트 요구 분석서,소스 코드,운영 및 설치 지침서,프로젝트 개발 비용,4,"소프트웨어 형상 관리(Software Configuration Management, SCM)는 소프트웨어 개발 과정에서 생성되는 모든 산출물을 체계적으로 관리하는 것을 말합니다.  프로젝트 요구 분석서, 소스 코드, 운영 및 설치 지침서와 같은 문서들은 소프트웨어 개발 과정에서 필수적으로 생성되고 관리되어야 하는 산출물입니다.  반면, 프로젝트 개발 비용은 소프트웨어 자체의 구성 요소가 아니고, 프로젝트의 재정적인 측면을 나타내는 정보이기 때문에 소프트웨어 형상 관리의 관리 항목에 포함되지 않습니다.  소프트웨어 형상 관리는 소프트웨어의 개발, 유지보수, 배포 등 전 과정에서 발생하는 변경 사항을 추적하고 관리하여 소프트웨어의 품질을 보장하는 데 목적이 있습니다. 따라서 개발 비용은 이러한 목적과 직접적으로 관련이 없다고 볼 수 있습니다.",82,115
231,3,31,다음 설명에 해당하는 것은?,https://www.cbtbank.kr/images/iz/iz20200926/iz20200926m31.gif,외부 스키마,내부 스키마,개념 스키마,슈퍼 스키마,2,"데이터베이스는 우리가 흔히 사용하는 프로그램(예: 쇼핑몰, 은행 시스템)의 데이터를 저장하고 관리하는 시스템입니다.  이 데이터베이스를 물리적인 저장장치(하드디스크, SSD 등) 관점에서 어떻게 저장하고 관리할지에 대한 구조를 '내부 스키마'라고 합니다.  문제에서 설명하는 것처럼, 실제 레코드(데이터 한 줄)의 형식, 데이터 항목 표현 방법, 저장 순서 등을 정의하는 것이 바로 내부 스키마의 역할입니다.  외부 스키마는 사용자가 데이터베이스를 보는 관점이고, 개념 스키마는 전체 데이터베이스의 개념적인 설계를 나타냅니다. 슈퍼 스키마는 여러 데이터베이스를 통합 관리할 때 사용하는 개념입니다. 따라서 물리적 저장 장치 관점에서 데이터베이스 구조를 정의하는 것은 내부 스키마에 해당합니다.",74,132
232,3,32,다음 트리에 대한 INORDER 운행 결과는?,https://www.cbtbank.kr/images/iz/iz20200926/iz20200926m32.gif,D B A E C F,A B D C E F,D B E C F A,A B C D E F,1,이 문제는 이진 트리의 순회(Traversal) 방법 중 하나인 inorder 순회를 이해하고 있는지 묻는 문제입니다.  inorder 순회는 왼쪽 서브트리 -> 루트 노드 -> 오른쪽 서브트리 순서로 노드를 방문하는 방법입니다.  주어진 트리를 inorder 순회로 방문해 보겠습니다.,75,111
233,3,33,n 개의 노드로 구성된 무방향 그래프의 최대 간선수는?,,n－1,n／2,n(n－1)／2,n(n＋1),3,"n개의 노드로 구성된 무방향 그래프에서 최대 간선 수를 구하는 문제입니다. 무방향 그래프란, 노드 간 연결이 방향성을 갖지 않는 그래프입니다.  예를 들어, A 노드와 B 노드가 연결되어 있다면, A에서 B로만 이동 가능하거나 B에서 A로만 이동 가능한 것이 아니라, A와 B는 서로 양방향으로 이동이 가능합니다.",80,111
234,3,34,다음이 설명하는 테스트 용어는?,https://www.cbtbank.kr/images/iz/iz20200926/iz20200926m34.gif,테스트 케이스,테스트 시나리오,테스트 오라클,테스트 데이터,3,"문제에서 설명하는 테스트 용어는 '테스트 오라클'입니다.  테스트 오라클은 소프트웨어 테스트에서 프로그램의 결과가 올바른지 판단하기 위해 미리 정해놓은 기준(참값)을 의미합니다.  예를 들어, 1+1의 결과가 2인지 확인하기 위해 2라는 참값을 미리 정의해두고, 프로그램의 결과와 비교하는 것이죠.  문제에서 언급된 '참값을 입력하여 비교하는 기법'이 바로 테스트 오라클의 핵심 기능입니다.  '참', '샘플링', '휴리스틱', '일관성 검사'는 테스트 오라클을 구현하는 다양한 방법들을 나타냅니다.  즉, 참값을 어떻게 얻고 비교할 것인가에 대한 여러 접근 방식을 의미하는 것입니다.",63,119
235,3,35,빌드 자동화 도구에 대한 설명으로 틀린 것은?,,Gradle은 실행할 처리 명령들을 모아 태스크로 만든 후 태스크 단위로 실행한다.,빌드 자동화 도구는 지속적인 통합개발환경 에 서 유용하게 활용된다.,"빌드 자동화 도구에는 Ant, Gradle, Jenkins등이 있다.",Jenkins는 Groovy 기반으로 한 오픈소스로 안드로이드 앱 개발 환경에서 사용된다.,4,"문제에서 제시된 4번 선택지 ""Jenkins는 Groovy 기반으로 한 오픈소스로 안드로이드 앱 개발 환경에서 사용된다""는 잘못된 설명입니다. Jenkins는 Groovy 기반이 아닌 Java 기반의 오픈소스 빌드 자동화 도구이며, 안드로이드 앱 개발 환경뿐 아니라 다양한 소프트웨어 개발 환경에서 사용됩니다.  다른 선택지들은 빌드 자동화 도구의 특징과 활용에 대한 정확한 설명을 제시하고 있습니다. Gradle은 태스크 기반으로 작업을 수행하고, 빌드 자동화 도구는 지속적인 통합(CI) 개발 환경에서 효율성을 높이는 데 중요한 역할을 합니다. Ant 또한 널리 사용되는 빌드 자동화 도구 중 하나입니다. 따라서 4번 선택지가 틀린 설명이 되는 것입니다.",69,118
236,3,36,저작권 관리 구성 요소에 대한 설명이 틀린 것은?,,콘텐츠 제공자(Contents Provider) : 콘텐츠를 제공하는 저작권자,콘텐츠 분배자(Contents Distributor) : 콘텐츠를 메타 데이터와 함께 배포 가능한 단위로 묶는 기능,클리어링 하우스(Clearing House) : 키 관리 및 라이선스 발급 관리,DRM 컨트롤러 : 배포된 콘텐츠의 이용 권한을 통제,2,"저작권 관리 구성 요소에 대한 설명 중 틀린 것은 2번입니다.  콘텐츠 분배자는 콘텐츠를 배포 가능한 단위로 묶는 역할을 하지만,  메타데이터와 함께 묶는다는 설명은 정확하지 않습니다. 메타데이터는 콘텐츠를 설명하는 정보(제목, 저자, 저작권 정보 등)이며, 콘텐츠 분배자는 콘텐츠 자체를 배포 가능한 형태(예: 파일 형식, 패키지)로 만들고 배포하는 역할을 합니다.  메타데이터는 콘텐츠와 함께 제공될 수 있지만, 콘텐츠 분배자의 주요 기능이 메타데이터와의 결합은 아닙니다.  나머지 1, 3, 4번은 저작권 관리에서 각 요소의 역할을 정확하게 설명하고 있습니다. 콘텐츠 제공자는 저작권을 가진 콘텐츠를 제공하고, 클리어링 하우스는 키 관리 및 라이선스 발급을 관리하며, DRM 컨트롤러는 콘텐츠 이용 권한을 통제합니다. 따라서 2번이 잘못된 설명입니다.",72,116
237,3,37,블랙박스 테스트 기법으로 거리가 먼 것은?,,기초 경로 검사,동치 클래스 분해,경계값 분석,원인 결과 그래프,1,"블랙박스 테스트는 소프트웨어의 내부 구조를 알지 못하고, 입력값과 출력값만을 가지고 테스트하는 기법입니다.  기초 경로 검사는 소프트웨어의 제어 흐름을 분석하여 테스트 케이스를 설계하는 기법으로, 소프트웨어의 내부 구조에 대한 지식을 필요로 합니다. 따라서 블랙박스 테스트 기법이라고 보기 어렵습니다. 반면 동치 클래스 분할, 경계값 분석, 원인 결과 그래프는 모두 소프트웨어의 내부 구조를 알 필요 없이 입력값과 출력값의 관계를 중심으로 테스트 케이스를 설계하는 블랙박스 테스트 기법입니다.  쉽게 말해, 블랙박스 테스트는 '상자 안을 들여다보지 않고 상자의 기능만 확인하는 것'과 같습니다. 기초 경로 검사는 상자 안을 들여다보면서 테스트하는 방법이기 때문에 다른 선택지들과 다릅니다.",72,119
238,3,38,"해싱함수 중 레코드 키를 여러 부분으로 나누고, 나눈 부분의 각 숫자를 더하거나 XOR한 값을 홈 주소로 사용하는 방식은?",,제산법,폴딩법,기수변환법,숫자분석법,2,"해싱 함수는 레코드의 키 값을 이용하여 레코드가 저장될 메모리 주소(홈 주소)를 계산하는 함수입니다.  문제에서 제시된 폴딩법은 레코드 키를 여러 부분으로 나누고, 각 부분의 숫자들을 더하거나 XOR 연산을 통해 하나의 값으로 합쳐서 홈 주소로 사용하는 방법입니다.  예를 들어, 레코드 키가 ""12345678""이라면, 이를 ""1234""와 ""5678""로 나누고, 두 값을 더하거나 XOR 연산하여 홈 주소를 계산합니다.  더하기 연산을 사용하면 1234 + 5678 = 6912가 홈 주소가 되고, XOR 연산을 사용하면 1234 XOR 5678이 홈 주소가 됩니다.  이처럼 폴딩법은 레코드 키의 일부분만을 사용하여 홈 주소를 계산하기 때문에, 키 값이 길더라도 효율적으로 홈 주소를 계산할 수 있습니다. 다른 선택지들은 레코드 키를 다른 방식으로 처리하는 해싱 기법입니다. 제산법은 나머지 연산을 이용하고, 기수변환법은 키 값의 진수를 변환하며, 숫자분석법은 키 값의 특정 패턴을 분석하여 홈 주소를 계산합니다.",61,111
239,3,39,다음에서 설명하는 클린 코드 작성 원칙은?,https://www.cbtbank.kr/images/iz/iz20200926/iz20200926m39.gif,다형성,단순성,추상화,의존성,2,"문제에서 제시된 클린 코드 작성 원칙은 ""한 번에 한 가지 처리만 수행한다""와 ""클래스/메소드/함수를 최소 단위로 분리한다""입니다. 이는 코드의 단순성을 추구하는 원칙입니다.  복잡한 작업을 작고 간결한 단위로 나누어 처리함으로써 코드의 가독성과 유지보수성을 높이고, 오류 발생 가능성을 줄이는 것을 목표로 합니다.  다형성, 추상화, 의존성은 객체지향 프로그래밍의 중요한 개념이지만, 문제에서 제시된 원칙과 직접적으로 연결되지 않습니다. 따라서 정답은 단순성입니다.  쉽게 말해,  복잡한 요리 레시피를  각 재료 손질, 볶기, 끓이기 등의 작은 단계로 나누어서 만드는 것과 같습니다. 각 단계가 간단하고 명확하면 전체 요리 과정을 이해하고 관리하기 쉬운 것처럼, 코드도 마찬가지입니다.",86,107
240,3,40,디지털 저작권 관리(DRM) 기술과 거리가 먼 것은?,,콘텐츠 암호화 및 키 관리,콘텐츠 식별체계 표현,콘텐츠 오류 감지 및 복구,라이선스 발급 및 관리,3,"디지털 저작권 관리(DRM) 기술은 디지털 콘텐츠의 저작권을 보호하기 위한 기술입니다.  콘텐츠 암호화 및 키 관리를 통해 콘텐츠 접근을 제어하고, 콘텐츠 식별체계 표현으로 콘텐츠의 출처와 권한을 명확히 하며, 라이선스 발급 및 관리를 통해 콘텐츠 이용 조건을 설정하고 관리합니다.  반면, 콘텐츠 오류 감지 및 복구는 콘텐츠의 무결성을 유지하는 기술이지만, 저작권 보호와는 직접적인 관련이 없습니다.  DRM은 콘텐츠의 불법 복제 및 배포를 막는 데 초점을 맞추고 있기 때문에, 콘텐츠 자체의 오류 수정은 DRM의 핵심 기능이 아닙니다. 따라서 DRM 기술과 거리가 먼 것은 콘텐츠 오류 감지 및 복구입니다.",81,116
241,3,41,다음 설명과 관련 있는 트랜잭션의 특징은?,https://www.cbtbank.kr/images/iz/iz20200926/iz20200926m41.gif,Durability,Isolation,Consistency,Atomicity,4,"문제에서 제시된 설명은 트랜잭션의 특징 중 '원자성(Atomicity)'을 설명하고 있습니다.  원자성이란 트랜잭션을 구성하는 여러 연산들이 하나의 논리적 작업 단위로 취급되어, 모든 연산이 성공적으로 완료되면 트랜잭션이 성공하고, 하나라도 실패하면 모든 연산의 결과가 취소되어 트랜잭션이 실패하는 것을 의미합니다.  마치 원자처럼 더 이상 나눌 수 없는 최소 단위의 작업으로 처리되는 것을 보장하는 것이죠.  예를 들어, 계좌 이체 트랜잭션의 경우 출금 계좌에서 돈을 빼고 입금 계좌에 돈을 넣는 두 가지 연산이 포함됩니다. 원자성 덕분에 출금은 성공했지만 입금은 실패하는 상황은 발생하지 않고, 두 연산이 모두 성공하거나 모두 실패합니다.  따라서 문제의 정답은 원자성(Atomicity)인 4번입니다.",73,127
242,3,42,"데이터베이스에 영향을 주는 생성, 읽기, 갱신, 삭제 연산으로 프로세스와 테이블 간에 매트릭스를 만들어서 트랜잭션을 분석하는 것은?",,CASE 분석,일치 분석,CRUD 분석,연관성 분석,3,"데이터베이스를 다루는 작업은 크게 생성(Create), 읽기(Read), 갱신(Update), 삭제(Delete)의 네 가지 연산으로 이루어집니다.  CRUD 분석은 이 네 가지 연산(Create, Read, Update, Delete)을 이용하여 데이터베이스와 상호작용하는 프로세스와 테이블 간의 관계를 매트릭스 형태로 나타내어 분석하는 기법입니다.  예를 들어, 특정 프로세스가 어떤 테이블에 대해 어떤 CRUD 연산을 수행하는지 표로 정리하여 데이터베이스의 변경 내용을 추적하고 분석할 수 있습니다. 이를 통해 데이터베이스의 무결성을 유지하고, 시스템의 효율성을 높이는 데 도움이 됩니다.  문제에서 제시된 ""프로세스와 테이블 간에 매트릭스를 만들어 트랜잭션을 분석""하는 것은 바로 이 CRUD 분석 기법을 설명하는 것입니다.  CASE 분석, 일치 분석, 연관성 분석은 데이터 분석의 다른 기법으로, 데이터베이스의 CRUD 연산과 직접적으로 관련이 없습니다.",75,134
243,3,43,"정규화된 엔티티, 속성, 관계를 시스템의 성능 향상과 개발 운영의 단순화를 위해 중복, 통합, 분리 등을 수행하는 데이터 모델링 기법은?",,인덱스정규화,반정규화,집단화,머징,2,"데이터베이스 설계에서 시스템 성능 향상과 개발 운영의 단순화를 위해 데이터 중복을 줄이고, 데이터 무결성을 높이는 기법이 정규화입니다.  반대로, 정규화를 통해 데이터베이스의 성능이 저하될 경우,  의도적으로 정규화된 데이터를 비정규화하여 성능을 향상시키는 기법이 반정규화입니다.  문제에서 언급된 ""중복, 통합, 분리""는 데이터를 효율적으로 관리하기 위한 과정이며, 이러한 과정을 통해 데이터 중복을 제거하고 성능을 향상시키는 목표를 달성하는 기법이 바로 반정규화입니다.  인덱스 정규화는 데이터베이스 검색 성능을 향상시키는 기법이지만, 데이터 모델링 자체의 중복, 통합, 분리와는 직접적인 관련이 없습니다. 집단화와 머징은 데이터의 그룹화 또는 합병과 관련된 개념이지만, 데이터 모델링의 중복 제거 및 성능 향상과는 다소 거리가 있습니다. 따라서, 시스템 성능 향상과 개발 운영 단순화를 위해 데이터 모델링에서 중복, 통합, 분리를 수행하는 기법은 반정규화입니다.",70,133
244,3,44,"학생 테이블을 생성한 후, 성별 필드가 누락되어 이를 추가하려고 한다. 이에 적합한 SQL 명령어는?",,INSERT,ALTER,DROP,MODIFY,2,"학생 테이블에 성별 필드가 없는데 추가해야 하는 상황입니다.  SQL 명령어 중에서 테이블의 구조(컬럼)을 변경하는 명령어는 `ALTER TABLE`입니다.  `INSERT`는 새로운 행(레코드)을 추가하는 명령어이고, `DROP`은 테이블 자체를 삭제하는 명령어이며, `MODIFY`는 기존 컬럼의 속성을 변경하는 명령어이지만,  새로운 컬럼을 추가하는 용도로는 사용되지 않습니다. 따라서 학생 테이블에 성별 필드를 추가하려면 `ALTER TABLE` 명령어를 사용하여 테이블 구조를 변경해야 합니다.  예를 들어,  `ALTER TABLE 학생 테이블 ADD 성별 VARCHAR(10);` 와 같이 사용할 수 있습니다. 이 명령어는 학생 테이블에 '성별'이라는 이름의 문자열 타입(VARCHAR) 컬럼을 추가하고, 최대 10자까지 저장할 수 있도록 설정합니다.",75,127
245,3,45,정규화의 필요성으로 거리가 먼 것은?,,데이터 구조의 안정성 최대화,중복 데이터의 활성화,"수정, 삭제 시 이상현상의 최소화",테이블 불일치 위험의 최소화,2,"정규화는 데이터베이스의 중복을 최소화하고 데이터 무결성을 유지하기 위한 데이터베이스 설계 기법입니다.  중복된 데이터가 많으면 데이터 수정 시 모든 곳을 일일이 수정해야 하는 번거로움이 발생하고,  데이터의 불일치가 생길 위험도 높아집니다.  정규화를 통해 데이터 구조를 안정적으로 만들고, 수정이나 삭제 시 발생하는 이상 현상을 최소화하며, 테이블 간 불일치 위험도 줄일 수 있습니다.  따라서 문제에서 제시된 보기 중 '중복 데이터의 활성화'는 정규화의 목표와 정반대되는 개념입니다. 정규화는 중복 데이터를 제거하여 데이터베이스의 효율성과 무결성을 높이는 것이 목표이기 때문입니다.  데이터 구조의 안정성을 높이고, 수정/삭제 시 이상 현상을 최소화하며, 테이블 불일치 위험을 최소화하는 것은 모두 정규화를 통해 얻을 수 있는 이점입니다.",90,130
246,3,46,개체-관계 모델의 E-R 다이어그램에서 사용되는 기호와 그 의미의 연결이 틀린 것은?,,사각형 - 개체 타입,삼각형 - 속성,선 - 개체타입과 속성을 연결,마름모 - 관계 타입,2,"E-R 다이어그램은 개체-관계 모델을 시각적으로 표현하는 도구입니다.  문제에서 제시된 기호들은 각각 다음과 같은 의미를 가집니다. 사각형은 개체 타입(예: 고객, 상품), 마름모는 관계 타입(예: 주문), 선은 개체 타입과 속성 또는 개체 타입과 관계 타입을 연결하는 역할을 합니다.  하지만 삼각형은 속성을 나타내는 기호가 아닙니다.  속성은 개체 타입 안에 텍스트로 표현됩니다.  예를 들어 '고객'이라는 사각형 안에 '고객 이름', '주소', '전화번호'와 같은 속성이 텍스트로 표시됩니다. 따라서 삼각형이 속성을 나타낸다는 설명은 틀렸습니다.",87,130
247,3,47,다음 SQL문에서 빈칸에 들어갈 내용으로 옳은 것은?,https://www.cbtbank.kr/images/iz/iz20200926/iz20200926m47.gif,FROM,SET,INTO,TO,2,"SQL의 UPDATE문은 데이터베이스 내의 테이블에 있는 데이터를 수정하는 명령어입니다.  문제의 SQL문은 `회원` 테이블의 `회원번호`가 'N4'인 레코드의 `전화번호`를 '010-14'로 변경하는 것을 목표로 합니다.  UPDATE문의 기본 구조는 `UPDATE 테이블명 SET 컬럼명 = 새로운 값 WHERE 조건` 입니다.  여기서 `SET`절은 어떤 컬럼의 값을 변경할 것인지 지정하는 부분입니다. 따라서 빈칸에는 `SET`이 들어가야 `전화번호` 컬럼의 값을 '010-14'로 변경하라는 명령을 제대로 수행할 수 있습니다.  다른 선택지들은 UPDATE문의 구조와 맞지 않습니다.  `FROM`은 SELECT문에서 데이터를 가져올 테이블을 지정하는 데 사용되고, `INTO`는 INSERT문에서 새로운 데이터를 삽입할 테이블을 지정하는 데 사용되며, `TO`는 UPDATE문에서 사용되지 않습니다.",82,126
248,3,48,릴레이션에 있는 모든 튜플에 대해 유일성은 만족시키지만 최소성은 만족시키지 못하는 키는?,,후보키,기본키,슈퍼키,외래키,3,"릴레이션(관계)에서 키는 특정 튜플(레코드)을 유일하게 식별하는 속성(또는 속성들의 집합)입니다.  문제에서 ""모든 튜플에 대해 유일성은 만족시키지만 최소성은 만족시키지 못하는 키""를 묻고 있습니다.  유일성이란 키를 구성하는 속성값들의 조합이 모든 튜플에서 중복되지 않음을 의미하고, 최소성이란 키를 구성하는 속성의 개수가 최소여야 함을 의미합니다.  즉,  최소성을 만족하지 못한다는 것은 키를 구성하는 속성 중 불필요한 속성이 포함되어 있다는 뜻입니다.  후보키는 최소성을 만족하는 유일한 키이고, 기본키는 후보키 중 하나를 선택한 것입니다.  슈퍼키는 후보키에 불필요한 속성을 추가하여 유일성만 만족하는 키입니다. 따라서 문제의 조건에 부합하는 것은 슈퍼키입니다. 외래키는 다른 테이블의 기본키를 참조하는 키이므로 문제의 조건과는 무관합니다.",77,129
249,3,49,DBA가 사용자 PARK에게 테이블 [STUDENT]의 데이터를 갱신할 수 있는 시스템 권한을 부여하고자 하는 SQL문을 작성하고자 한다. 다음에 주어진 SQL문의 빈칸을 알맞게 채운 것은?,https://www.cbtbank.kr/images/iz/iz20200926/iz20200926m49.gif,"㉠ INSERT, ㉡ INTO","㉠ ALTER, ㉡ TO","㉠ UPDATE, ㉡ ON","㉠ REPLACE, ㉡ IN",3,"이 문제는 데이터베이스 관리자(DBA)가 특정 사용자에게 테이블에 대한 특정 권한을 부여하는 SQL 문을 작성하는 문제입니다.  SQL에서 `GRANT` 명령어는 사용자에게 권한을 부여하는 데 사용됩니다.  문제에서 DBA는 사용자 PARK에게 STUDENT 테이블의 데이터를 갱신할 수 있는 권한을 주고자 합니다. 데이터 갱신은 `UPDATE` 명령어를 통해 이루어지므로,  `GRANT UPDATE`가 필요합니다. 또한, 어떤 테이블에 대한 갱신 권한인지 명시해야 하므로 `ON STUDENT`를 사용합니다. 따라서 정답은 3번, `GRANT UPDATE, ON STUDENT TO PARK;`가 됩니다.  `UPDATE`는 테이블의 데이터를 수정하는 권한을 의미하고, `ON`은 그 권한이 적용될 테이블을 지정하며, `TO`는 권한을 부여받을 사용자를 지정합니다. 다른 선택지들은 의미가 맞지 않습니다. 예를 들어, `INSERT`는 새로운 데이터를 추가하는 권한이고, `ALTER`는 테이블 구조 자체를 변경하는 권한입니다.",76,125
250,3,50,관계대수에 대한 설명으로 틀린 것은?,,주어진 릴레이션 조작을 위한 연산의 집합이다.,일반 집합 연산과 순수 관계 연산으로 구분된다.,질의에 대한 해를 구하기 위해 수행해야 할 연산의 순서를 명시한다.,원하는 정보와 그 정보를 어떻게 유도하는가를 기술하는 비절차적방법이다.,4,"관계대수는 데이터베이스에서 데이터를 조작하기 위한 방법 중 하나입니다.  4번 보기에서 '원하는 정보와 그 정보를 어떻게 유도하는가를 기술하는 비절차적 방법이다'라고 설명하고 있는데, 이는 관계대수의 특징을 정확하게 나타내지 못합니다. 관계대수는 어떤 연산을 순서대로 수행해야 하는지 명시하는 절차적인 측면이 있습니다.  예를 들어, 두 개의 테이블을 결합(JOIN)하고 특정 조건을 만족하는 행만 선택하는 작업을 한다고 가정해 봅시다. 관계대수는 JOIN 연산과 선택(SELECTION) 연산을 어떤 순서로 수행해야 하는지 명확하게 지정합니다.  따라서 원하는 결과를 얻기 위한 연산 순서를 명시하는 절차적인 측면이 존재하며, 단순히 '원하는 정보와 그 정보를 어떻게 유도하는가'만 기술하는 비절차적인 방법이라고 할 수 없습니다.  다른 보기들은 관계대수의 특징을 잘 나타내고 있습니다. 1번은 관계대수가 릴레이션(테이블)을 조작하는 연산들의 집합임을, 2번은 일반 집합 연산(합집합, 교집합 등)과 관계 연산(선택, 투영, 조인 등)으로 구분됨을, 3번은 질의를 처리하기 위한 연산 순서를 정의함을 보여줍니다. 따라서 4번이 틀린 설명입니다.",81,129
251,3,51,다음 SQL문의 실행 결과는?,https://www.cbtbank.kr/images/iz/iz20200926/iz20200926m51.gif,https://www.cbtbank.kr/images/iz/iz20200926/iz20200926m51b1.gif,https://www.cbtbank.kr/images/iz/iz20200926/iz20200926m51b2.gif,https://www.cbtbank.kr/images/iz/iz20200926/iz20200926m51b3.gif,https://www.cbtbank.kr/images/iz/iz20200926/iz20200926m51b4.gif,3,"문제에서 제시된 SQL 문은 특정 테이블의 '과목이름' 컬럼의 데이터를 보여주는 것으로 추정됩니다.  제공된 4가지 실행 결과 예시를 살펴보면, 각각 'DB'라는 과목이름이 몇 번 등장하는지, 그리고 '운영체제'라는 과목이름이 포함되는지 여부가 다릅니다.  정답으로 제시된 3번의 경우 'DB', 'DB', '운영체제'가 각각 한 번씩 나타납니다. 이는 어떤 테이블에 'DB'라는 과목이름이 두 개 이상 존재하고, '운영체제'라는 과목이름이 적어도 하나 이상 존재함을 의미합니다.  따라서,  SQL문은  '과목이름' 컬럼에 'DB'가 여러 번, '운영체제'가 적어도 한 번 기록된 데이터를 조회하는 쿼리일 가능성이 높습니다.  정확한 SQL 문이 없어 추측에 의존하지만,  제공된 선택지 중 3번만이 이러한 조건을 만족합니다.  정보처리기사 시험에서는 SQL 문의 실행 결과를 예측하는 문제가 자주 출제되며,  테이블의 데이터 구조와 SQL 문의 기능을 정확히 이해하는 것이 중요합니다.",73,127
252,3,52,로킹(Locking) 기법에 대한 설명으로 틀린 것은?,,로킹의 대상이 되는 객체의 크기를 로킹 단위라고 한다.,로킹 단위가 작아지면 병행성 수준이 낮아진다.,데이터베이스도 로킹 단위가 될 수 있다.,로킹 단위가 커지면 로크 수가 작아 로킹 오버헤드가 감소한다.,2,"로킹(Locking)은 데이터베이스나 파일 시스템에서 여러 사용자가 동시에 같은 데이터를 접근하여 변경하는 것을 막기 위해 사용하는 기법입니다.  특정 사용자가 데이터를 수정하는 동안 다른 사용자의 접근을 제한하여 데이터의 일관성을 유지하는 것이죠.  문제에서 틀린 것은 2번입니다. 로킹 단위가 작아지면,  데이터의 작은 부분만 잠금이 걸리기 때문에 여러 사용자가 동시에 다른 부분의 데이터를 접근하고 수정할 수 있습니다.  즉, 병행성 수준이 높아지는 것이지 낮아지는 것이 아닙니다.  예를 들어,  한 레코드 전체를 로킹 단위로 하는 것보다,  레코드의 특정 필드만을 로킹 단위로 하면 더 많은 사용자가 동시에 작업할 수 있습니다.  나머지 보기들은 모두 로킹 기법의 특징을 잘 나타내고 있습니다. 1번은 로킹 단위의 정의를, 3번은 로킹 단위의 예시를, 4번은 로킹 단위가 커질 때의 장점을 설명하고 있습니다.",79,129
253,3,53,사용자 X1에게 department 테이블에 대한 검색 연산을 회수하는 명령은?,,delete select on department to X1;,remove select on department from X1;,revoke select on department from X1;,grant select on department from X1;,3,"이 문제는 데이터베이스의 접근 권한을 관리하는 SQL 명령어에 대한 이해를 묻는 문제입니다.  문제에서 사용자 X1에게 department 테이블에 대한 검색(select) 권한을 *회수*하는 명령어를 찾아야 합니다.  SQL에서 권한을 부여하는 명령어는 `GRANT`이고, 권한을 회수하는 명령어는 `REVOKE`입니다. 따라서 정답은 3번 `REVOKE select on department from X1;` 입니다. 1번과 2번은 SQL 명령어로 존재하지 않으며, 4번은 사용자에게 권한을 부여하는 명령어이므로 틀렸습니다.  `REVOKE` 명령어는 특정 사용자에게 부여된 권한을 취소하는 데 사용됩니다.  `select on department` 부분은 department 테이블에 대한 검색 권한을 의미하고, `from X1`은 사용자 X1에게서 권한을 회수한다는 것을 의미합니다.",86,127
254,3,54,뷰(VIEW)에 대한 설명으로 틀린 것은?,,뷰 위에 또 다른 뷰를 정의할 수 있다.,"뷰에 대한 조작에서 삽입, 갱신, 삭제 연산은 제약이 따른다.",뷰의 정의는 기본 테이블과 같이 ALTER문을 이용하여 변경한다.,뷰가 정의된 기본 테이블이 제거되면 뷰도 자동적으로 제거된다.,3,"뷰(VIEW)는 기존 테이블의 데이터를 기반으로 만들어진 가상 테이블입니다.  쉽게 말해, 특정 테이블의 일부분만 보여주거나, 여러 테이블의 데이터를 하나로 합쳐서 보여주는 역할을 합니다.  마치 원본 테이블의 '보기'와 같은 것이죠.  문제에서 틀린 것은 3번입니다. 뷰는 기본 테이블과 달리 `ALTER` 문으로 직접 변경할 수 없습니다. 뷰를 변경하려면 뷰 자체를 삭제하고 새롭게 정의해야 합니다.  1번은 뷰 위에 또 다른 뷰를 만들 수 있으므로 맞는 설명이고, 2번은 뷰를 통해 데이터를 삽입, 갱신, 삭제하는 경우 원본 테이블의 구조와 제약 조건에 따라 제한이 있을 수 있으므로 맞는 설명입니다. 4번은 뷰가 기본 테이블에 의존하기 때문에 기본 테이블이 삭제되면 뷰도 함께 삭제되는 것이 맞습니다. 따라서 3번이 틀린 설명입니다. 정보처리기사 공식 교재에서는 뷰의 정의 및 관리 방법에 대한 자세한 설명과 함께 예시를 통해 뷰를 생성하고 조작하는 방법을 다루고 있을 것입니다.",65,128
255,3,55,데이터 모델에 표시해야 할 요소로 거리가 먼 것은?,,논리적 데이터 구조,출력 구조,연산,제약조건,2,"데이터 모델은 데이터베이스의 구조와 내용을 표현하는 것입니다.  논리적 데이터 구조는 데이터베이스에 어떤 데이터가 어떻게 저장될지를 정의하는 것이고, 제약조건은 데이터의 무결성을 유지하기 위한 규칙입니다. 연산은 데이터를 조작하는 방법을 나타냅니다.  반면 출력 구조는 데이터베이스에서 데이터를 *어떻게 보여줄 것인가*에 대한 부분으로, 데이터 모델 자체에 포함되는 요소는 아닙니다. 데이터 모델은 데이터 자체의 구조와 제약 조건에 집중하며, 어떻게 사용자에게 보여지는지는 별개의 문제입니다.  따라서 데이터 모델에 표시해야 할 요소로 거리가 먼 것은 출력 구조입니다.  마치 건물의 설계도(데이터 모델)에 건물의 조명이나 인테리어 디자인(출력 구조)이 포함되지 않는 것과 같습니다.",51,130
256,3,56,제 3정규형에서 보이스코드 정규형(BCNF)으로 정규화하기 위한 작업은?,,원자 값이 아닌 도메인을 분해,부분 함수 종속 제거,이행 함수 종속 제거,결정자가 후보키가 아닌 함수 종속 제거,4,"제3정규형(3NF)은 부분 함수 종속을 제거하여 데이터 중복을 최소화한 정규화 단계입니다.  하지만 3NF는 이행 함수 종속(transitive functional dependency) 문제를 완전히 해결하지 못합니다. 보이스코드 정규형(BCNF)은 3NF보다 더 강력한 정규화 단계로, 이행 함수 종속을 포함하여 모든 함수 종속에서 결정자가 후보키(candidate key)가 되도록 합니다.  문제에서 제시된 4번 선택지 ""결정자가 후보키가 아닌 함수 종속 제거""는 바로 이 BCNF의 핵심 개념을 나타냅니다.  결정자가 후보키가 아닌 함수 종속이 존재한다면, 그 함수 종속을 제거하여 데이터 중복을 더욱 줄이고 데이터 무결성을 향상시킬 수 있습니다.  다른 선택지들은 3NF에서 BCNF로 정규화하는 과정과는 직접적인 관련이 없습니다. 원자 값이 아닌 도메인을 분해하는 것은 정규화의 기본적인 단계이지만, 3NF에서 BCNF로의 전환을 위한 핵심적인 작업은 아닙니다. 부분 함수 종속과 이행 함수 종속은 3NF에서 이미 처리되는 문제입니다. 따라서 3NF를 BCNF로 정규화하기 위해서는 결정자가 후보키가 아닌 함수 종속을 찾아 제거하는 작업이 필수적입니다.",81,130
257,3,57,"A1, A2, A3 3개 속성을 갖는 한 릴레이션에서 A1의 도메인은 3개 값, A2의 도메인은 2개 값, A3의 도메인은 4개 값을 갖는다. 이 릴레이션에 존재할 수 있는 가능한 튜플(Tuple)의 최대 수는?",,24,12,8,9,1,"이 문제는 릴레이션(관계)에 존재할 수 있는 튜플(데이터 레코드)의 최대 개수를 구하는 문제입니다.  A1, A2, A3 세 개의 속성을 가진 릴레이션에서 각 속성의 도메인(값의 집합)이 각각 3개, 2개, 4개의 값을 가진다고 합니다.  각 속성은 서로 독립적으로 값을 가질 수 있으므로,  A1의 값을 선택하는 경우의 수는 3가지, A2의 값을 선택하는 경우의 수는 2가지, A3의 값을 선택하는 경우의 수는 4가지입니다. 따라서, 총 가능한 튜플의 최대 개수는 각 경우의 수를 모두 곱한 값이 됩니다.  즉, 3 × 2 × 4 = 24 입니다.  따라서 정답은 1번, 24개 입니다.",79,129
258,3,58,데이터베이스 설계 시 물리적 설계 단계에서 수행하는 사항이 아닌 것은?,,저장 레코드 양식 설계,레코드 집중의 분석 및 설계,접근 경로 설계,목표 DBMS에 맞는 스키마 설계,4,"데이터베이스 물리적 설계는 논리적 설계를 바탕으로 실제 데이터베이스 시스템에 구현하기 위한 구체적인 계획을 세우는 단계입니다.  저장 레코드 양식 설계는 데이터를 어떤 형태로 저장할지, 레코드 집중의 분석 및 설계는 데이터 중복을 최소화하고 효율적인 저장을 위해 어떻게 데이터를 배치할지, 접근 경로 설계는 데이터에 빠르게 접근하기 위한 인덱스 등을 어떻게 구성할지를 결정하는 단계입니다.  반면, 목표 DBMS에 맞는 스키마 설계는 논리적 설계 단계에서 이미 완료되어야 하는 부분입니다. 물리적 설계는 이미 정해진 논리적 스키마를 특정 DBMS 환경에 맞게 최적화하는 작업이지, 스키마 자체를 새로 설계하는 단계가 아니기 때문입니다.  따라서,  목표 DBMS에 맞는 스키마 설계는 물리적 설계 단계에서 수행하는 사항이 아닙니다.  이는 논리적 설계 단계에서 이미 DBMS의 종류를 고려하여 설계가 이루어져야 하기 때문입니다.",71,133
259,3,59,"한 릴레이션 스키마가 4개 속성, 2개 후보키 그리고 그 스키마의 대응 릴레이션 인스턴스가 7개 튜플을 갖는다면 그 릴레이션의 차수(degree)는?",,1,2,4,7,3,"릴레이션의 차수(degree)는 릴레이션을 구성하는 속성(attribute)의 개수를 의미합니다. 문제에서 주어진 릴레이션 스키마는 4개의 속성을 가지고 있다고 명시되어 있습니다.  후보키의 개수나 튜플의 개수는 릴레이션의 차수와는 무관합니다. 따라서, 이 릴레이션의 차수는 4입니다.  정답 3번은 잘못된 답변입니다. 문제의 정답은 4번입니다.",71,129
260,3,60,데이터웨어하우스의 기본적인 OLAP(on-line analytical processing) 연산이 아닌 것은?,,translate,roll-up,dicing,drill-down,1,"OLAP(온라인 분석 처리)는 데이터 웨어하우스에 저장된 데이터를 다차원적으로 분석하기 위한 기술입니다.  roll-up, dicing, drill-down은 모두 데이터를 요약하거나 상세화하여 분석하는 OLAP의 기본 연산입니다.  roll-up은 데이터를 상위 레벨로 요약하는 연산이고(예: 개별 상품 판매량에서 지역별 판매량으로 요약), dicing은 특정 조건에 맞는 데이터만 선택하여 분석하는 연산이며(예: 특정 지역, 특정 기간의 판매량만 추출), drill-down은 데이터를 하위 레벨로 상세화하는 연산입니다(예: 지역별 판매량에서 개별 상품 판매량으로 상세화).  반면, translate는 데이터의 의미나 형식을 변환하는 연산으로 OLAP의 핵심 기능과는 관련이 없습니다.  따라서 데이터 웨어하우스의 기본적인 OLAP 연산이 아닌 것은 translate입니다.",59,129
261,3,61,UNIX SHELL 환경 변수를 출력하는 명령어가 아닌 것은?,,configenv,printenv,env,setenv,1,"문제에서 제시된 명령어들은 모두 UNIX 계열 운영체제에서 환경 변수를 다루는 명령어입니다.  `printenv`는 환경 변수 목록을 출력하고, `env`는 현재 설정된 환경 변수들을 보여주며, `setenv`는 새로운 환경 변수를 설정하거나 기존 환경 변수의 값을 변경하는 명령어입니다.  하지만 `configenv`라는 명령어는 일반적인 UNIX 계열 운영체제의 표준 명령어가 아니며, 특정 시스템이나 배포판에서만 사용될 수 있는 비표준 명령어일 가능성이 높습니다. 따라서 UNIX SHELL 환경 변수를 출력하는 명령어가 아닌 것은 `configenv`입니다. 정보처리기사 공식 교재에서는 표준 명령어들을 중심으로 다루기 때문에 `printenv`와 `env`는 자주 등장하지만 `configenv`는 다루지 않을 가능성이 높습니다.",52,144
262,3,62,Java 프로그래밍 언어의 정수 데이터 타입 중 'long'의 크기는?,,1byte,2byte,4byte,8byte,4,"Java에서 `long` 타입은 64비트(8바이트) 정수형 변수를 나타냅니다.  문제에서 정답으로 제시된 4바이트는 잘못된 정보입니다.  정보처리기사 공식 교재를 참고하더라도 `long` 타입의 크기는 8바이트임을 확인할 수 있습니다.  Java는 기본적으로 정수형 변수를 표현하는 데 byte(바이트) 단위를 사용하며, `long`은 `int`(4바이트)보다 더 큰 범위의 정수를 저장하기 위해 8바이트를 할당합니다. 따라서 문제의 정답은 8바이트(4번)가 되어야 합니다.  제공된 정답 4(4바이트)는 `int` 타입의 크기이며, 문제의 질문과 정답이 일치하지 않습니다.",80,141
263,3,63,Java에서 사용되는 출력 함수가 아닌 것은?,,System.out.print( ),System.out.println( ),System.out.printing( ),System.out.printf( ),3,"Java에서 출력을 담당하는 System.out 객체는 print(), println(), printf() 메서드를 제공합니다.  System.out.print()는 출력 내용을 콘솔에 출력하고 다음 줄로 넘어가지 않습니다. System.out.println()은 출력 내용을 콘솔에 출력하고 다음 줄로 넘어갑니다. System.out.printf()는 서식 문자열을 사용하여 출력 내용을 콘솔에 출력합니다. 문제에서 제시된 System.out.printing()은 Java 표준 라이브러리에 존재하지 않는 메서드입니다. 따라서 Java에서 사용되는 출력 함수가 아닌 것은 System.out.printing()입니다.",87,141
264,3,64,운영체제에서 커널의 기능이 아닌 것은?,,"프로세스 생성, 종료",사용자 인터페이스,"기억 장치 할당, 회수",파일 시스템 관리,2,"운영체제(OS)의 커널은 컴퓨터 시스템의 핵심적인 부분으로, 하드웨어와 응용 프로그램 사이에서 중개자 역할을 합니다.  프로세스 생성 및 종료, 기억 장치(메모리) 할당 및 회수, 파일 시스템 관리 등은 모두 커널이 직접 담당하는 중요한 기능입니다.  하지만 사용자 인터페이스(UI)는 커널의 직접적인 기능이 아닙니다. UI는 사용자가 컴퓨터와 상호 작용하는 방식을 제공하는 부분으로, 운영체제의 여러 구성 요소 중 하나일 뿐 커널 자체가 아닙니다.  커널은 시스템의 기본적인 동작을 관리하는 데 집중하고, UI는 사용자에게 편리한 환경을 제공하는 데 초점을 맞춥니다.  따라서 커널의 기능이 아닌 것은 사용자 인터페이스입니다. 정보처리기사 공식 교재에서는 커널의 기능을 자세히 설명하고 있으며,  UI는 일반적으로 커널 위에 구축된 응용 프로그램이나 라이브러리에 의해 제공됩니다.",73,144
265,3,65,OSI 7계층에서 단말기 사이에 오류 수정과 흐름제어를 수행하여 신뢰성 있고 명확한 데이터를 전달하는 계층은?,,전송 계층,응용 계층,세션 계층,표현 계층,1,"OSI 7계층은 네트워크 통신을 7개의 계층으로 나누어 각 계층이 특정 기능을 담당하도록 설계된 모델입니다.  데이터는 응용 계층에서 시작하여 물리 계층을 거쳐 목적지까지 전달되고, 다시 물리 계층에서 응용 계층으로 되돌아옵니다.  각 계층은 상위 계층에 서비스를 제공하고 하위 계층의 서비스를 이용합니다.  문제에서 언급된 오류 수정과 흐름 제어는 데이터 전송의 신뢰성을 보장하는 중요한 기능입니다.  오류 수정은 전송 중 발생할 수 있는 데이터 손상을 감지하고 복구하는 기능이고, 흐름 제어는 송신측과 수신측의 속도 차이로 인해 발생할 수 있는 데이터 손실을 방지하는 기능입니다.  이러한 오류 수정과 흐름 제어 기능을 주로 담당하는 계층이 바로 전송 계층입니다. 전송 계층은 데이터의 신뢰성 있는 전달을 위해 다양한 프로토콜(예: TCP)을 사용하여 데이터를 분할하고, 순서대로 재조립하며, 오류를 검출하고 수정하고, 흐름을 제어합니다.  따라서 단말기 사이에 오류 수정과 흐름 제어를 수행하여 신뢰성 있고 명확한 데이터를 전달하는 계층은 전송 계층입니다.",85,145
266,3,66,다음 쉘 스크립트의 의미로 옳은 것은?,https://www.cbtbank.kr/images/iz/iz20200926/iz20200926m66.gif,wow 사용자가 로그인한 경우에만 반복문을 수행한다.,wow 사용자가 로그인할 때까지 반복문을 수행한다.,wow 문자열을 복사한다.,wow 사용자에 대한 정보를 무한 반복하여 출력한다.,2,"이 쉘 스크립트는 `until` 반복문을 사용합니다.  `until` 문은 조건이 참이 될 때까지 코드 블록을 반복 실행하는데, 이 스크립트에서는 `who | grep wow` 명령어의 결과가 참(wow 사용자가 로그인되어 있음)이 될 때까지 반복문이 계속됩니다.  `who` 명령어는 현재 로그인한 사용자 목록을 출력하고, `grep wow` 명령어는 그 목록에서 ""wow""라는 문자열을 포함하는 줄(wow 사용자가 로그인한 경우)을 찾습니다.  만약 wow 사용자가 로그인되어 있지 않다면, `grep wow`는 아무것도 출력하지 않고(거짓), `until` 문은 `sleep 5` 명령어(5초간 대기)를 실행한 후 다시 `who | grep wow`를 확인합니다.  wow 사용자가 로그인하면 `grep wow`가 wow 사용자 정보를 출력하고(참), 반복문이 종료됩니다. 따라서, wow 사용자가 로그인할 때까지 5초 간격으로 계속 확인하는 스크립트입니다.  1번은 wow 사용자가 로그인된 *경우에만* 반복문을 수행한다는 의미로, 반복문의 조건과 반대입니다. 3번은 문자열 복사와는 관련이 없고, 4번은 무한 반복이 아니라 wow 사용자가 로그인하면 종료됩니다.",75,144
267,3,67,다음 자바 코드를 실행한 결과는?,https://www.cbtbank.kr/images/iz/iz20200926/iz20200926m67.gif,x＝7 y＝0,x＝6 y＝-1,x＝7 y＝-1,Unresolved compilation problem 오류 발생,4,"제시된 자바 코드가 없으므로 실행 결과를 예측할 수 없습니다.  문제에서 ""Unresolved compilation problem"" 오류가 발생한다는 것은 코드에 컴파일러가 인식하지 못하는 오류가 있다는 의미입니다.  자바 코드에서 컴파일 오류가 발생하는 가장 흔한 원인은 변수 선언 누락, 타입 불일치, 문법 오류 등입니다.  문제에서 제공된 정보만으로는 어떤 오류가 발생했는지 특정할 수 없지만,  코드에 컴파일 오류가 있어 실행 자체가 불가능하다는 것을 알 수 있습니다. 따라서 정답은 4번 ""Unresolved compilation problem 오류 발생""이 됩니다.  정보처리기사 시험에서는 이처럼 코드의 문법적 오류나 컴파일 오류를 파악하는 능력도 중요하게 평가됩니다.  실제 코드를 보았다면 더 정확한 해설을 드릴 수 있었을 텐데, 아쉽습니다.",69,141
268,3,68,다음 파이썬으로 구현된 프로그램의 실행 결과로 옳은 것은?,https://www.cbtbank.kr/images/iz/iz20200926/iz20200926m68.gif,"[20, 60]","[60, 20]","[0, 20, 40, 60]","[10, 30, 50, 70]",3,"파이썬 리스트 a는 `[0, 10, 20, 30, 40, 50, 60, 70, 80, 90]` 입니다.  `a[:7:2]` 는 리스트 슬라이싱을 이용한 표현입니다.  리스트 슬라이싱은 `[시작:끝:간격]` 의 형태로 사용되며, 시작 인덱스는 0부터, 끝 인덱스는 슬라이싱 범위의 마지막 요소의 바로 다음 인덱스를 의미합니다. 간격은 리스트 요소를 건너뛰는 간격을 나타냅니다.",73,111
269,3,69,공통모듈의 재사용 범위에 따른 분류가 아닌 것은?,,컴포넌트 재사용,더미코드 재사용,함수와 객체 재사용,애플리케이션 재사용,2,"이 문제는 공통 모듈의 재사용 범위에 대한 이해도를 묻는 문제입니다.  소프트웨어 개발에서 공통 모듈이란 여러 프로그램에서 반복적으로 사용되는 코드 부분을 말합니다.  컴포넌트, 함수, 객체, 애플리케이션 등은 모두 재사용 가능한 단위로 볼 수 있습니다.  하지만 '더미코드'는 실제 기능을 수행하지 않는, 테스트나 자리표시를 위한 코드입니다. 따라서 재사용의 목적으로 만들어진 것이 아니므로, 공통 모듈의 재사용 범위에 따른 분류에 포함되지 않습니다.  다른 선택지들은 모두 실제 기능을 가지고 여러 곳에서 재사용될 수 있는 코드 단위를 나타냅니다.",74,106
270,3,70,"다음과 같은 프로세스가 차례로 큐에 도착하였을 때, SJF(Shortest Job First) 정책을 사용할 경우 가장 먼저 처리되는 작업은?",https://www.cbtbank.kr/images/iz/iz20200926/iz20200926m70.gif,P1,P2,P3,P4,4,"이 문제는 프로세스 스케줄링 알고리즘 중 하나인 SJF(Shortest Job First) 알고리즘을 이해하고 있는지 묻는 문제입니다. SJF 알고리즘은 가장 짧은 실행 시간을 가진 프로세스를 먼저 처리하는 방식입니다.  문제에서 주어진 프로세스들의 실행 시간을 보면 P1은 6, P2는 8, P3는 4, P4는 3입니다.  가장 짧은 실행 시간을 가진 프로세스는 P4(3)이므로, SJF 알고리즘을 사용할 경우 가장 먼저 처리되는 작업은 P4입니다. 따라서 정답은 4번입니다.  쉽게 말해, 가장 빨리 끝나는 작업부터 먼저 처리하는 방식이라고 생각하시면 됩니다.",86,111
271,3,71,"4개의 페이지를 수용할 수 있는 주기억장치가 있으며, 초기에는 모두 비어 있다고 가정한다. 다음의 순서로 페이지 참조가 발생할 때, FIFO 페이지 교체 알고리즘을 사용할 경우 페이지 결함의 발생 횟수는?",https://www.cbtbank.kr/images/iz/iz20200926/iz20200926m71.gif,6회,7회,8회,9회,1,"이 문제는 운영체제의 메모리 관리 중 페이지 교체 알고리즘에 대한 이해를 묻는 문제입니다.  주기억장치(메모리)의 크기가 제한되어 있을 때, 필요한 페이지를 메모리에 적재하는 과정에서 모든 페이지를 메모리에 올릴 수 없다면, 어떤 페이지를 메모리에서 내보낼지 결정하는 알고리즘이 필요합니다. FIFO(First-In, First-Out) 알고리즘은 가장 먼저 들어온 페이지를 가장 먼저 내보내는 방식입니다.",69,144
272,3,72,"TCP 흐름제어기법 중 프레임이 손실되었을 때, 손실된 프레임 1개를 전송하고 수신자의 응답을 기다리는 방식으로 한 번에 프레임 1개만 전송할 수 있는 기법은?",,Slow Start,Sliding Window,Stop and Wait,Congestion Avoidance,3,"TCP 흐름 제어 기법 중 'Stop and Wait'는 한 번에 하나의 프레임만 전송하고, 수신 확인(ACK)을 받은 후에 다음 프레임을 전송하는 방식입니다.  마치 한 번에 한 개의 물건만 주고받는 것과 같습니다.  프레임이 손실되면 송신측은 수신 확인을 받지 못하고, 손실된 프레임을 다시 전송하며 수신 확인을 기다립니다.  다른 기법들과 달리,  'Stop and Wait'는  한 번에 하나의 프레임만 전송하므로 효율성은 떨어지지만, 손실된 프레임을 쉽게 관리할 수 있는 장점이 있습니다.  'Sliding Window'는 여러 개의 프레임을 동시에 전송할 수 있고, 'Slow Start'와 'Congestion Avoidance'는 네트워크 혼잡을 방지하는 기법으로,  문제에서 요구하는 '손실된 프레임 1개를 전송하고 수신자의 응답을 기다리는 방식'과는 다릅니다. 따라서 정답은 3번 'Stop and Wait'입니다.",86,145
273,3,73,결합도(Coupling)에 대한 설명으로 틀린 것은?,,"데이터 결합도(Data Coupling)는 두 모듈이 매개변수로 자료를 전달할 때, 자료구조 형태로 전달되어 이용될 때 데이터가 결합되어 있다고 한다.",내용 결합도(Content Coupling)는 하나의 모듈이 직접적으로 다른 모듈의 내용을 참조할 때 두 모듈은 내용적으로 결합되어 있다고 한다.,공통 결합도(Common Coupling)는 두 모듈이 동일한 전역 데이터를 접근한다면 공통결합 되어 있다고 한다.,"결합도(Coupling)는 두 모듈간의 상호작용, 또는 의존도 정도를 나타내는 것이다.",1,"결합도(Coupling)는 모듈 간의 의존성 정도를 나타내는 척도입니다.  결합도가 높다는 것은 모듈 간의 상호 의존성이 크다는 것을 의미하며,  하나의 모듈을 변경할 때 다른 모듈에도 영향을 미칠 가능성이 높아 유지보수가 어려워집니다. 반대로 결합도가 낮으면 모듈 간의 독립성이 높아 유지보수가 용이합니다.  문제의 1번은 데이터 결합도에 대한 설명인데,  ""자료구조 형태로 전달되어 이용될 때""라는 부분이 잘못되었습니다. 데이터 결합도는 단순한 데이터 값을 매개변수로 전달하는 것을 의미하며, 복잡한 자료구조 전체를 전달하는 것은  더 높은 결합도를 나타냅니다.  따라서 자료구조 형태로 전달하는 것은 데이터 결합도의 정의에 부합하지 않습니다.  나머지 2, 3, 4번은 모두 결합도의 종류와 정의를 올바르게 설명하고 있습니다.  2번은 내용 결합도(하나의 모듈이 다른 모듈의 내부를 직접 참조), 3번은 공통 결합도(두 모듈이 같은 전역 변수를 사용), 4번은 결합도의 일반적인 정의를 설명하고 있습니다.",56,106
274,3,74,"응집도의 종류 중 서로 간에 어떠한 의미 있는 연관관계도 지니지 않은 기능 요소로 구성되는 경우이며, 서로 다른 상위 모듈에 의해 호출되어 처리상의 연관성이 없는 서로 다른 기능을 수행하는 경우의 응집도는?",,Functional Cohesion,Sequential Cohesion,Logical Cohesion,Coincidental Cohesion,4,"응집도는 모듈 내부 요소들의 관련성을 나타내는 척도입니다.  높은 응집도는 모듈의 기능을 명확하게 하고, 유지보수 및 재사용성을 높입니다.  반대로 낮은 응집도는 모듈의 기능이 모호하고, 이해하기 어렵게 만들어 유지보수가 어려워집니다.  문제에서 설명하는 ""서로 간에 어떠한 의미 있는 연관관계도 지니지 않은 기능 요소로 구성되는 경우""는  응집도가 가장 낮은 수준을 의미합니다. 이러한 경우를 우연 응집도(Coincidental Cohesion)라고 합니다.  마치 서로 다른 목적으로 만들어진 여러 기능들이 우연히 하나의 모듈에 섞여 있는 것과 같습니다.  따라서 정답은 4번, Coincidental Cohesion입니다.  다른 선택지들은 각 요소들이 어느 정도 연관성을 가지는 경우를 나타냅니다.",64,106
275,3,75,자바에서 사용하는 접근제어자의 종류가 아닌 것은?,,internal,private,default,public,1,"자바에서 접근 제어자는 클래스나 클래스 멤버(변수, 메서드)에 대한 접근 권한을 제어하는 역할을 합니다.  `public`, `private`, `default`는 자바에서 사용하는 접근 제어자입니다.  `public`은 모든 곳에서 접근 가능하고, `private`는 같은 클래스 내에서만 접근 가능하며, `default` (접근 제어자가 명시적으로 지정되지 않은 경우)는 같은 패키지 내에서만 접근 가능합니다.  반면 `internal`은 자바의 접근 제어자에 포함되지 않습니다.  `internal`은 C#과 같은 다른 언어에서 사용되는 접근 제어자로, 같은 어셈블리(assembly) 내에서만 접근을 허용합니다. 따라서 자바에서 사용하는 접근 제어자가 아닌 것은 `internal`입니다.",74,107
276,3,76,UDP 특성에 해당되는 것은?,,"데이터 전송 후, ACK를 받는다.",송신 중에 링크를 유지 관리하므로 신뢰성이 높다.,흐름제어나 순서제어가 없어 전송속도가 빠르다.,제어를 위한 오버헤드가 크다.,3,"UDP(User Datagram Protocol)는 TCP와 달리 연결을 설정하지 않고 데이터를 패킷 단위로 전송하는 비연결형 프로토콜입니다.  TCP는 데이터 전송 전에 송수신 측 간의 연결을 확립하고, 데이터 전송 후 확인 응답(ACK)을 주고받으며 데이터의 정확한 전달을 보장합니다.  반면 UDP는 연결 없이 데이터를 전송하므로, ACK를 기다리지 않고 빠르게 전송할 수 있습니다.  또한, TCP처럼 흐름 제어나 순서 제어 기능이 없어 오버헤드가 적고 전송 속도가 빠릅니다.  따라서 1번과 2번은 TCP의 특징이며, 4번은 UDP의 특징이 아니고 TCP에 비해 오버헤드가 작다는 점이 UDP의 장점입니다.  3번은 UDP의 핵심적인 특징을 잘 나타내고 있습니다.  즉, 흐름 제어나 순서 제어가 없기 때문에 전송 속도가 빠른 것입니다.",74,145
277,3,77,"다음과 같은 세그먼트 테이블을 가지는 시스템에서 논리 주소(2, 176)에 대한 물리 주소는?",https://www.cbtbank.kr/images/iz/iz20200926/iz20200926m77.gif,398,400,1928,1930,1,"이 문제는 논리 주소를 물리 주소로 변환하는 방법을 묻고 있습니다.  세그먼트 테이블은 논리 주소를 구성하는 세그먼트 번호와 오프셋을 이용하여 실제 물리 메모리 주소를 찾는 데 사용됩니다.  문제에서 주어진 논리 주소는 (2, 176)입니다.  이는 세그먼트 번호가 2이고, 오프셋이 176임을 의미합니다. 세그먼트 테이블을 보면 세그먼트 번호 2는 시작 주소 222이고 길이가 198바이트입니다.  따라서 세그먼트 2의 논리 주소 176은 물리 주소로 변환하려면 시작 주소 222에 오프셋 176을 더하면 됩니다.  222 + 176 = 398 이므로 정답은 398입니다.",71,129
278,3,78,TCP/IP에서 사용되는 논리주소를 물리주소로 변환시켜 주는 프로토콜은?,,TCP,ARP,FTP,IP,2,"TCP/IP 네트워크에서 컴퓨터는 논리 주소(IP 주소)를 사용하여 서로 통신합니다.  하지만 실제 네트워크 카드(NIC)는 물리 주소(MAC 주소)를 사용하여 데이터를 주고받습니다.  IP 주소는 사람이 이해하기 쉽도록 숫자로 표현된 주소이고, MAC 주소는 네트워크 카드마다 고유하게 부여된 물리적인 주소입니다.  ARP(Address Resolution Protocol) 프로토콜은 이 두 주소 체계를 연결하는 역할을 합니다.  즉, 컴퓨터가 특정 IP 주소를 가진 컴퓨터에 데이터를 전송하려면, 먼저 해당 IP 주소에 해당하는 MAC 주소를 알아야 하는데, 이때 ARP 프로토콜을 사용하여 IP 주소를 MAC 주소로 변환하는 것입니다.  마치 전화번호부(IP 주소)를 이용하여 실제 주소(MAC 주소)를 찾는 것과 같습니다.  따라서 TCP, FTP, IP는 모두 네트워크 통신에 관련된 프로토콜이지만, IP 주소를 MAC 주소로 변환하는 기능은 ARP 프로토콜이 담당합니다.",76,145
279,3,79,C언어에서 구조체를 사용하여 데이터를 처리할 때 사용하는 것은?,,for,scanf,struct,abstract,3,"C언어에서 구조체(struct)는 여러 개의 변수들을 하나의 묶음으로 묶어서 관리하는 방법입니다.  예를 들어, 학생의 정보를 관리한다고 생각해 봅시다. 학생의 이름, 학번, 성적 등 여러 가지 정보를 각각 따로 변수로 선언하는 대신, 구조체를 사용하면 이러한 정보들을 하나의 '학생'이라는 구조체 변수로 묶어서 관리할 수 있습니다. 이렇게 하면 코드를 더욱 효율적으로 작성하고, 관련된 데이터를 쉽게 관리할 수 있습니다.  문제에서 제시된 다른 선택지들은 C언어에서 사용되는 문법이나 기능이지만, 여러 데이터를 하나의 단위로 묶어 관리하는 목적에는 구조체가 가장 적합합니다.  `for`는 반복문, `scanf`는 입력 함수, `abstract`는 추상적인 개념을 나타내는 키워드입니다. 따라서 구조체를 사용하여 데이터를 처리하는 것이 가장 적절한 방법입니다.",83,111
280,3,80,PHP에서 사용 가능한 연산자가 아닌 것은?,,@,#,＜＞,===,2,"PHP는 웹 서버 측에서 동작하는 스크립트 언어입니다.  문제에서 제시된 연산자들을 살펴보면,  `@`는 PHP에서 에러 억제 연산자로 사용되어 에러 메시지를 표시하지 않고 실행을 계속 진행하게 합니다. `< >`는 크기 비교 연산자이고, `===`는 값과 자료형까지 완전히 일치하는지 비교하는 연산자입니다.  반면 `#`는 PHP에서는 주석을 나타내는 기호로, 실제 연산에 사용되지 않습니다.  따라서 PHP에서 사용 가능한 연산자가 아닌 것은 `#`입니다.  `#`는 다른 프로그래밍 언어(예: C, C++, Python)에서는 전처리기 지시자나 주석으로 사용되지만, PHP에서는 주석으로만 사용됩니다.",58,141
281,3,81,이용자가 인터넷과 같은 공중망에 사설망을 구축하여 마치 전용망을 사용하는 효과를 가지는 보안 솔루션은?,,ZIGBEE,KDD,IDS,VPN,4,"이용자가 인터넷과 같은 공중망을 통해 사설망을 구축하여 마치 전용망처럼 안전하게 데이터를 주고받을 수 있도록 하는 보안 솔루션이 VPN(Virtual Private Network, 가상 사설망)입니다.  VPN은 공중망을 통신 경로로 사용하지만, 데이터를 암호화하여 전송하고, 가상 터널을 생성하여 다른 네트워크와 분리된 안전한 통신 환경을 제공합니다.  마치 인터넷 속에 개인적인 전용선을 깔아놓은 것과 같은 효과를 내는 것이죠.  따라서 인터넷을 통해 회사 내부망에 접속하거나, 공용 와이파이에서 안전하게 업무를 처리하는 등의 목적으로 널리 사용됩니다.  반면 ZIGBEE는 근거리 무선 통신 기술, KDD는 지식 발견 데이터베이스(Knowledge Discovery in Databases)의 약자로 데이터 마이닝과 관련된 개념, IDS는 침입 탐지 시스템으로 네트워크의 이상 활동을 감지하는 보안 시스템입니다. 이들은 모두 VPN과는 다른 기능을 수행합니다.",84,156
282,3,82,CMM(Capability Maturity Model) 모델의 레벨로 옳지 않은 것은?,,최적단계,관리단계,계획단계,정의단계,3,"CMM(Capability Maturity Model)은 소프트웨어 개발 조직의 성숙도를 5단계로 평가하는 모델입니다.  각 단계는 소프트웨어 개발 프로세스의 안정성과 예측 가능성을 나타냅니다.  1단계는 초기 단계(Initial), 2단계는 관리 단계(Managed), 3단계는 정의 단계(Defined), 4단계는 관리 단계(Managed), 5단계는 최적 단계(Optimizing)입니다. 문제에서 제시된 옵션 중 '계획 단계'는 CMM의 공식적인 레벨이 아니므로 옳지 않은 것입니다.  CMM은 단계별로 프로세스를 정의하고 관리하는 수준을 평가하는 것이지, 단순히 '계획'만을 따로 단계로 구분하지 않습니다.  '계획'은 각 단계에서 필수적인 요소이지, 단계 자체가 되는 것은 아닙니다.",54,147
283,3,83,다음 설명에 해당하는 생명주기 모형으로 가장 옳은 것은?,https://www.cbtbank.kr/images/iz/iz20200926/iz20200926m83.gif,패키지 모형,코코모 모형,폭포수 모형,관계형 모델,3,"문제에서 설명하는 생명주기 모형은 가장 오래된 형태로, 각 단계가 순차적으로 진행되고 이전 단계가 완료되어야만 다음 단계로 넘어갈 수 있는 특징을 가지고 있습니다.  이는 마치 폭포가 위에서 아래로 떨어지는 것과 같다고 하여 '폭포수 모형'이라고 불립니다. 요구사항 변경이 어렵다는 점 또한 폭포수 모형의 단점으로 잘 알려져 있습니다.  패키지 모형이나 코코모 모형은 소프트웨어 개발의 비용이나 일정을 추정하는 모델이고, 관계형 모델은 데이터베이스 설계에 관련된 모델이므로 문제의 설명과는 맞지 않습니다. 따라서 정답은 3번 폭포수 모형입니다.",90,147
284,3,84,서비스 지향 아키텍처 기반 애플리케이션을 구성하는 층이 아닌 것은?,,표현층,프로세스층,제어 클래스층,비즈니스층,3,"서비스 지향 아키텍처(SOA)는 여러 개의 독립적인 서비스들을 조합하여 애플리케이션을 구성하는 아키텍처입니다.  SOA 기반 애플리케이션은 일반적으로 표현 계층(Presentation Layer), 비즈니스 계층(Business Layer), 프로세스 계층(Process Layer)으로 구성됩니다.  표현 계층은 사용자 인터페이스를 담당하고, 비즈니스 계층은 애플리케이션의 핵심 비즈니스 로직을 처리하며, 프로세스 계층은 여러 서비스들을 조정하고 관리하는 역할을 합니다.  문제에서 제시된 '제어 클래스층'은 SOA의 표준적인 계층 구조에 포함되지 않는 개념입니다.  따라서 SOA 기반 애플리케이션을 구성하는 층이 아닌 것은 3번, 제어 클래스층입니다.  쉽게 말해,  SOA는 레고 블록처럼 여러 서비스(블록)들을 조립해서 애플리케이션을 만드는 방식인데, '제어 클래스층'은 이 레고 블록 조립 과정에 없는 부품과 같은 것입니다.",48,106
285,3,85,다음 내용이 설명하는 스토리지 시스템은?,https://www.cbtbank.kr/images/iz/iz20200926/iz20200926m85.gif,DAS,NAS,N-SCREEN,NFC,1,"문제에서 설명하는 스토리지 시스템은 DAS(Direct Attached Storage)입니다. DAS는 하드디스크와 같은 저장장치를 호스트 버스 어댑터(HBA)에 직접 연결하는 방식으로, 저장장치와 호스트 기기(서버 등) 사이에 네트워크 장비가 개입하지 않습니다.  쉽게 말해, 컴퓨터 본체에 직접 하드디스크를 연결하는 것과 같은 방식입니다.  NAS(Network Attached Storage)는 네트워크를 통해 접근하는 저장장치이고, N-SCREEN이나 NFC는 저장장치와는 관련이 없는 다른 기술입니다. 따라서 문제의 설명에 부합하는 것은 DAS입니다.",75,151
286,3,86,소프트웨어 개발 프레임워크의 적용 효과로 볼 수 없는 것은?,,공통 컴포넌트 재사용으로 중복 예산 절감,기술종속으로 인한 선행사업자 의존도 증대,표준화된 연계모듈 활용으로 상호 운용성 향상,개발표준에 의한 모듈화로 유지보수 용이,2,"소프트웨어 개발 프레임워크는 소프트웨어 개발 과정에서 반복적으로 사용되는 부분들을 미리 만들어 놓은 틀이나 구조라고 생각하면 됩니다.  마치 레고 블록처럼, 이미 만들어진 블록들을 조립하여 새로운 것을 만드는 것과 같습니다.  문제에서 제시된 1, 3, 4번은 모두 프레임워크를 사용했을 때 얻을 수 있는 장점입니다.  공통 컴포넌트를 재사용하면 비용을 절감하고(1), 표준화된 부품을 사용하면 서로 호환이 잘 되고(3),  모듈화된 구조는 유지보수를 쉽게 해줍니다(4).  하지만 2번의 경우, 특정 프레임워크에 종속되면 그 프레임워크를 제공하는 업체에 의존하게 되어 개발의 자유도가 떨어지고,  선행 사업자에게 의존하는 상황이 발생할 수 있습니다.  즉, 프레임워크를 사용하는 것이 오히려 개발의 제약이 될 수 있다는 의미입니다. 따라서 프레임워크 적용의 부정적 효과를 나타내는 보기는 2번입니다.",86,148
287,3,87,SoftTech사에서 개발된 것으로 구조적 요구 분석을 하기 위해 블록 다이어그램을 채택한 자동화 도구는?,,SREM,PSL/PSA,HIPO,SADT,4,"문제에서 제시된 자동화 도구는 구조적 요구 분석을 위해 블록 다이어그램을 사용합니다.  블록 다이어그램은 시스템을 여러 개의 블록으로 나누어 각 블록의 기능과 블록 간의 관계를 시각적으로 표현하는 방법입니다.  선택지 중 SADT(Structured Analysis and Design Technique)는 구조적 분석 및 설계 기법으로, 시스템을 계층적인 블록 다이어그램으로 표현하여 시스템의 요구사항을 분석하고 설계하는 데 사용됩니다. SoftTech사에서 개발되었다는 점도 SADT의 특징과 일치합니다.  다른 선택지들은 SADT와 달리 블록 다이어그램을 주요 분석 도구로 사용하지 않습니다.  따라서 정답은 SADT입니다.",55,103
288,3,88,익스트림 프로그래밍 (eXtreme Programming)의 5가지 가치에 속하지 않는 것은?,,의사소통,단순성,피드백,고객 배제,4,"익스트림 프로그래밍(XP)은 소프트웨어 개발 방법론 중 하나로,  변화에 빠르게 적응하고 고품질의 소프트웨어를 개발하기 위해 고안되었습니다.  XP의 핵심 가치는 의사소통, 단순성, 피드백, 용기, 존중입니다.  문제에서 제시된 보기 중 '고객 배제'는 XP의 가치와 정반대되는 개념입니다. XP는 고객과의 지속적인 소통과 협력을 매우 중요하게 생각하며, 고객의 피드백을 통해 개발 방향을 수시로 조정합니다. 따라서 고객을 배제하는 것은 XP의 기본 원칙에 어긋납니다.  다른 보기인 의사소통, 단순성, 피드백은 모두 XP에서 강조하는 중요한 가치입니다.",90,102
289,3,89,다음은 정보의 접근통제 정책에 대한 설명이다. (ㄱ)에 들어갈 내용으로 옳은 것은?,https://www.cbtbank.kr/images/iz/iz20200926/iz20200926m89.gif,NAC,MAC,SDAC,AAC,2,"이 문제는 정보 시스템의 접근 통제 정책 중 MAC(Mandatory Access Control), DAC(Discretionary Access Control), RBAC(Role-Based Access Control)의 특징을 비교하는 문제입니다.  표에서 (ㄱ)에 해당하는 것은 접근 통제 정책의 종류를 나타내는 부분입니다.  MAC은 보안 등급(Label)을 기반으로 접근을 제어하는 정책으로, 시스템 관리자가 보안 등급을 설정하고, 사용자는 자신의 보안 등급에 따라 접근 권한이 결정됩니다.  문제의 표에서 (ㄱ)에 MAC이 들어가야  권한 부여, 접근 결정, 정책 변경, 장점 등의 내용이 일관성 있게 설명됩니다.  따라서 정답은 2번 MAC입니다.  NAC, SDAC, AAC는 접근 통제 정책의 종류가 아닙니다.",69,155
290,3,90,소프트웨어 개발 모델 중 나선형 모델의 4가지 주요 활동이 순서대로 나열된 것은?,https://www.cbtbank.kr/images/iz/iz20200926/iz20200926m90.gif,Ⓐ-Ⓑ-Ⓓ-Ⓒ순으로 반복,Ⓐ-Ⓓ-Ⓒ-Ⓑ순으로 반복,Ⓐ-Ⓑ-Ⓒ-Ⓓ순으로 반복,Ⓐ-Ⓒ-Ⓑ-Ⓓ순으로 반복,2,"나선형 모델은 소프트웨어 개발 과정을 여러 단계의 반복적인 사이클로 진행하는 모델입니다. 각 사이클은 계획 수립, 위험 분석, 개발 및 검증, 고객 평가의 네 가지 주요 활동으로 구성됩니다.  먼저, 계획을 수립하고(①)  잠재적인 위험을 분석하여(④)  해결 방안을 마련합니다. 그 후, 소프트웨어를 개발하고 검증하며(③),  마지막으로 고객의 평가를 받아(②) 다음 사이클을 위한 피드백을 얻습니다. 이러한 과정을 반복하며 점진적으로 소프트웨어를 완성해 나가는 것이 나선형 모델의 특징입니다. 따라서 문제에서 제시된 순서대로 진행하면 Ⓐ(계획 수립) → Ⓓ(위험 분석) → Ⓒ(개발 및 검증) → Ⓑ(고객 평가) 순서로 반복하는 것이 나선형 모델의 핵심 활동 순서가 됩니다.",82,147
291,3,91,소프트웨어 비용 추정모형(estimation models)이 아닌 것은?,,COCOMO,Putnam,Function-Point,PERT,4,"이 문제는 소프트웨어 개발 비용을 추정하는 다양한 모델 중에서 어떤 것이 **소프트웨어 비용 추정 모델이 아닌지** 묻고 있습니다.  COCOMO, Putnam, Function-Point는 모두 소프트웨어 개발 프로젝트의 비용을 예측하는 데 사용되는 잘 알려진 모델입니다.  반면 PERT (Program Evaluation and Review Technique)는 프로젝트의 일정 관리 및 위험 관리에 사용되는 기법으로, 소프트웨어 비용 추정에는 직접적으로 사용되지 않습니다. PERT는 각 작업의 완료 시간을 확률적으로 추정하여 전체 프로젝트 일정을 예측하는 데 초점을 맞추기 때문입니다. 따라서 정답은 4번, PERT입니다.",68,147
292,3,92,공개키 암호화 방식에 대한 설명으로 틀린 것은?,,공개키로 암호화된 메시지는 반드시 공개키로 복호화 해야 한다.,비대칭 암호기법이라고도 한다.,대표적인 기법은 RSA 기법이 있다.,"키 분배가 용이하고, 관리해야 할 키 개수가 적다.",1,"공개키 암호화 방식은 두 개의 키, 즉 공개키와 개인키를 사용하는 암호화 방식입니다.  공개키는 누구에게나 공개해도 되지만, 개인키는 소유자만 알고 있어야 합니다.  메시지를 암호화할 때는 상대방의 공개키를 사용하고, 복호화할 때는 자신의 개인키를 사용합니다.  따라서 1번의 설명처럼 공개키로 암호화된 메시지는 공개키로 복호화할 수 없습니다.  공개키로 암호화된 메시지는 반드시 **개인키**로 복호화해야 합니다.  나머지 설명들은 공개키 암호화 방식의 특징을 잘 나타내고 있습니다. 비대칭 암호기법이라는 것은 공개키와 개인키가 서로 다른 키를 사용한다는 것을 의미하며, RSA는 대표적인 공개키 암호화 알고리즘입니다.  키 분배가 용이한 이유는 공개키를 공개적으로 배포할 수 있기 때문이며, 관리해야 할 키 개수가 적은 이유는 각 사용자가 공개키와 개인키 두 개만 관리하면 되기 때문입니다.",67,154
293,3,93,다음이 설명하는 다중화 기술은?,https://www.cbtbank.kr/images/iz/iz20200926/iz20200926m93.gif,Wavelength Division Multiplexing,Frequency Division Multiplexing,Code Division Multiplexing,Time Division Multiplexing,1,"문제에서 설명하는 다중화 기술은 광섬유를 이용하여 여러 개의 광신호를 동시에 전송하는 기술입니다.  각 광신호는 서로 다른 파장(색깔)의 빛을 사용하는데, 이는 빛의 파장이 다르면 서로 간섭하지 않는다는 성질을 이용한 것입니다.  마치 여러 개의 차선을 가진 고속도로처럼, 각 파장의 빛이 독립적인 차선을 이용하여 동시에 정보를 전달하는 것이죠.  문제에서 제시된 옵션 중 Wavelength Division Multiplexing(WDM)은 파장 분할 다중화를 의미하며, 바로 이러한 원리를 이용한 기술입니다.  다른 옵션들은 주파수, 코드, 시간을 이용한 다중화 방식으로, 광섬유 통신과는 직접적인 관련이 없습니다. 따라서 정답은 1번 Wavelength Division Multiplexing입니다.",82,149
294,3,94,"웹페이지에 악의적인 스크립트를 포함시켜 사용자 측에서 실행되게 유도함으로써, 정보유출 등의 공격을 유발할 수 있는 취약점은?",,Ransomware,Pharming,Phishing,XSS,4,"웹 페이지에 악의적인 스크립트를 삽입하여 사용자의 브라우저에서 실행되도록 유도하는 공격을 XSS(Cross-Site Scripting) 공격이라고 합니다.  사용자가 악성 스크립트가 포함된 웹 페이지를 방문하면, 브라우저는 해당 스크립트를 사용자의 컴퓨터에서 실행하게 되는데, 이를 통해 공격자는 사용자의 쿠키, 세션 정보 등 중요한 정보를 탈취하거나, 사용자의 컴퓨터를 제어할 수 있습니다.  예를 들어, 사용자의 계정 정보를 입력하는 웹 페이지에 악성 스크립트가 숨겨져 있다면, 사용자가 정보를 입력하는 순간 그 정보가 공격자에게 전송될 수 있습니다.  따라서 XSS는 사용자의 개인 정보 유출 및 시스템 손상을 야기할 수 있는 매우 위험한 취약점입니다.  다른 선택지들은 다른 유형의 사이버 공격을 나타냅니다. 랜섬웨어(Ransomware)는 컴퓨터 시스템을 잠그고 돈을 요구하는 악성 프로그램이고, 파밍(Pharming)은 사용자를 가짜 웹사이트로 유도하는 공격이며, 피싱(Phishing)은 가짜 이메일이나 웹사이트를 통해 개인 정보를 빼내는 공격입니다.",60,153
295,3,95,CBD(Component Based Development) 에 대한 설명으로 틀린 것은?,,개발 기간 단축으로 인한 생산성 향상,새로운 기능 추가가 쉬운 확장성,소프트웨어 재사용이 가능,1960년대까지 가장 많이 적용되었던 소프트웨어 개발 방법,4,"CBD(Component Based Development)는 구성요소 기반 개발 방식을 의미합니다.  미리 만들어 놓은 소프트웨어 구성요소(컴포넌트)들을 조립하듯이 연결하여 새로운 소프트웨어 시스템을 만드는 방법이죠.  마치 레고 블록을 조립하듯이, 각각의 기능을 담당하는 컴포넌트들을 연결하여 원하는 시스템을 구축하는 것입니다.  따라서 개발 시간을 단축하고 생산성을 높일 수 있으며, 새로운 기능을 추가하거나 변경하기도 용이합니다.  기존에 만들어진 컴포넌트를 재사용할 수 있다는 장점도 있습니다.  하지만 문제의 4번 보기처럼, CBD는 1960년대가 아닌, 객체지향 프로그래밍과 소프트웨어 재사용 개념이 발전한 훨씬 최근에 본격적으로 활용되기 시작한 방법론입니다.  1960년대에는 주로 절차적 프로그래밍 방식이 주류였습니다.",83,106
296,3,96,소프트웨어 정의 데이터센터(SDDC : Software Defined Data Center)에 대한 설명으로 틀린 것은?,,"컴퓨팅, 네트워킹, 스토리지, 관리 등을 모두 소프트웨어로 정의한다.",인력 개입 없이 소프트웨어 조작만으로 자동 제어 관리한다.,데이터센터 내 모든 자원을 가상화하여 서비스한다.,특정 하드웨어 에 종속되어 특화된 업무를 서비스하기에 적합하다.,4,"소프트웨어 정의 데이터센터(SDDC)는 컴퓨팅, 네트워킹, 스토리지 등 데이터센터의 모든 자원을 소프트웨어로 제어하고 관리하는 방식입니다.  1번과 2번, 3번은 SDDC의 주요 특징을 잘 나타내고 있습니다.  1번은 모든 자원을 소프트웨어로 정의한다는 점, 2번은 자동화된 관리를 강조하며, 3번은 가상화를 통해 자원을 효율적으로 사용한다는 점을 보여줍니다. 하지만 4번은 SDDC의 개념과 반대되는 내용입니다. SDDC는 특정 하드웨어에 종속되지 않고, 소프트웨어를 통해 하드웨어를 추상화하여 다양한 환경에서 유연하게 운영될 수 있도록 설계됩니다.  즉, 특정 하드웨어에 종속되어 특화된 업무만 서비스하는 것은 SDDC의 장점이 아닌 단점이 됩니다.  SDDC의 목표는 하드웨어 의존성을 줄이고, 유연성과 확장성을 높이는 데 있습니다. 따라서 4번이 틀린 설명입니다.",64,151
297,3,97,컴퓨터 운영체제의 커널에 보안 기능을 추가한 것으로 운영체제의 보안상 결함으로 인하여 발생 가능한 각종 해킹으로부터 시스템을 보호하기 위하여 사용되는 것은?,,GPIB,CentOS,XSS,Secure OS,4,"이 문제는 컴퓨터 운영체제의 보안에 대한 이해를 묻고 있습니다.  운영체제(OS)는 컴퓨터의 모든 하드웨어와 소프트웨어를 관리하는 핵심 프로그램입니다.  만약 운영체제에 보안 취약점이 있다면, 해커가 시스템에 침입하여 중요한 데이터를 탈취하거나 시스템을 파괴할 수 있습니다.  Secure OS는 이러한 위험을 줄이기 위해 운영체제의 커널(OS의 핵심 부분)에 보안 기능을 추가하여 개발된 운영체제입니다.  따라서 운영체제의 보안 결함으로 인한 해킹으로부터 시스템을 보호하기 위해 사용되는 것은 Secure OS입니다.  나머지 선택지는  GPIB(일반 목적의 계측기 버스), CentOS(리눅스 배포판), XSS(크로스 사이트 스크립팅, 웹 보안 취약점)로 운영체제 자체의 보안 강화와는 직접적인 관련이 없습니다.",84,151
298,3,98,NS(Nassi-Schneiderman) chart에 대한 설명으로 거리가 먼 것은?,,논리의 기술에 중점을 둔 도형식 표현 방법이다.,"연속, 선택 및 다중 선택, 반복 등의 제어논리 구조로 표현한다.",주로 화살표를 사용하여 논리적인 제어구조로 흐름을 표현한다.,조건이 복합되어 있는 곳의 처리를 시각적으로 명확히 식별하는데 적합하다.,3,"NS 차트는 프로그램의 논리 흐름을 도형으로 표현하는 방법입니다.  직사각형, 마름모꼴 등의 도형을 사용하여 순차 처리, 조건 분기, 반복 등의 제어 구조를 시각적으로 나타냅니다.  3번 보기는 ""주로 화살표를 사용하여 논리적인 제어구조로 흐름을 표현한다""라고 되어 있는데, NS 차트는 화살표를 사용하기는 하지만,  흐름을 표현하는 주된 방법은 도형의 배치와 연결입니다.  화살표는 도형 간의 연결을 보조하는 역할일 뿐, 흐름 자체를 화살표로 표현하는 것은 아닙니다.  따라서 NS 차트의 특징과 거리가 먼 설명입니다.  다른 보기들은 모두 NS 차트의 주요 특징을 잘 나타내고 있습니다.  논리 흐름을 도형으로 명확하게 표현하여 복잡한 조건 처리 부분도 시각적으로 쉽게 이해할 수 있도록 돕는 것이 NS 차트의 장점입니다.",64,103
299,3,99,다음 내용에 적합한 용어는?,https://www.cbtbank.kr/images/iz/iz20200926/iz20200926m99.gif,MapReduce,SQL,Hijacking,Logs,1,"문제에서 제시된 설명은 대용량 데이터를 효율적으로 처리하기 위한 프로그래밍 모델인 MapReduce를 정확하게 설명하고 있습니다.  MapReduce는 Google에서 개발한 기술로, 대량의 데이터를 여러 개의 작은 조각으로 나누어(Map 단계) 각 조각을 병렬적으로 처리한 후(Reduce 단계) 결과를 합쳐 최종 결과를 얻는 방식입니다.  임의의 순서로 정렬된 데이터를 처리한다는 설명 또한 MapReduce의 특징을 잘 나타냅니다. SQL은 데이터베이스 질의어 언어이고, Hijacking은 시스템 장악을 의미하며, Logs는 로그 기록을 의미하므로 문제의 설명과는 전혀 관련이 없습니다. 따라서 정답은 MapReduce(1번)입니다.",74,131
300,3,100,소프트웨어 프로세스에 대한 개선 및 능력 측정 기준에 대한 국제 표준은?,,ISO 14001,IEEE 802.5,IEEE 488,SPICE,4,"소프트웨어 프로세스 개선 및 능력 측정 기준에 대한 국제 표준을 묻는 문제입니다.  ISO 14001은 환경경영시스템, IEEE 802.5는 토큰 링 네트워크, IEEE 488은 GPIB(General Purpose Interface Bus)에 관한 표준입니다.  반면 SPICE(SPICE - Software Process Improvement and Capability dEtermination)는 소프트웨어 프로세스 개선 및 능력 성숙도 평가를 위한 국제 표준 프레임워크입니다.  따라서 소프트웨어 프로세스 개선과 능력 측정에 초점을 맞춘 질문에는 SPICE가 가장 적절한 답변입니다. SPICE는 소프트웨어 개발 조직의 프로세스 성숙도를 평가하고 개선하는 데 사용되는 표준으로,  조직의 소프트웨어 개발 능력을 측정하고 향상시키는 데 도움을 줍니다.",73,147
301,4,1,"운영체제 분석을 위해 리눅스에서 버전을 확인하고자 할 때 사용되는 명령어는?(문제 오류로 가답안 발표시 4번으로 발표되었지만 확정답안 발표시 2, 4번이 정답처리 되었습니다. 여기서는 가답안인 4번을 누르시면 정답 처리 됩니다.)",,ls,cat,pwd,uname,4,"리눅스 운영체제의 버전을 확인하는 명령어는 `uname`입니다.  `uname` 명령어는 시스템의 여러 정보를 출력하는데,  `-a` 옵션을 사용하면 운영체제의 커널 이름, 호스트 이름, 커널 버전, CPU 아키텍처 등 자세한 시스템 정보를 확인할 수 있습니다.  예를 들어, `uname -a` 명령어를 실행하면  Linux 시스템의 커널 버전,  시스템의 이름,  프로세서 아키텍처 등의 정보가 출력됩니다.  문제에서 제시된 다른 명령어들은 각각 다른 기능을 수행합니다. `ls`는 디렉토리 내의 파일 목록을 표시하고, `cat`은 파일의 내용을 출력하며, `pwd`는 현재 디렉토리의 경로를 표시합니다. 따라서 리눅스 버전 확인에는 `uname` 명령어가 가장 적합합니다.  정보처리기사 시험에서는 운영체제의 기본적인 명령어 사용법을 숙지하고 있어야 하므로,  `uname` 명령어의 기능과 사용법을 정확히 이해하는 것이 중요합니다.",86,101
302,4,2,"통신을 위한 프로그램을 생성하여 포트를 할당하고, 클라이언트의 통신 요청 시 클라이언트와 연결하는 내·외부 송·수신 연계기술은?",,DB링크 기술,소켓 기술,스크럼 기술,프로토타입 기술,2,"문제에서 요구하는 것은 클라이언트와 서버 간의 통신을 위한 프로그램을 만들 때, 서로 연결하고 데이터를 주고받는 기술입니다.  여기서 포트 할당이라는 키워드가 중요한데, 포트는 서버가 특정 서비스를 제공하기 위해 사용하는 통신 경로의 일종입니다.  클라이언트가 특정 서비스를 요청하면, 지정된 포트를 통해 서버와 연결하여 데이터를 송수신하게 됩니다.  DB 링크 기술은 데이터베이스에 접근하는 기술이고, 스크럼이나 프로토타입 기술은 소프트웨어 개발 방법론에 해당합니다. 소켓 기술은 네트워크 통신을 위한 프로그래밍 인터페이스로, 서버가 특정 포트를 열어 클라이언트의 연결을 기다리고, 연결이 수립되면 데이터를 송수신하는 역할을 합니다. 따라서 클라이언트의 통신 요청 시 클라이언트와 연결하는 내·외부 송·수신 연계 기술로는 소켓 기술이 가장 적합합니다. 정보처리기사 시험에서는 네트워크 프로그래밍에 대한 이해를 묻는 문제로, 소켓 프로그래밍에 대한 지식이 필요합니다.",81,110
303,4,3,객체지향 개념에서 연관된 데이터와 함수를 함께 묶어 외부와 경계를 만들고 필요한 인터페이스만을 밖으로 드러내는 과정은?,,메시지(Message),캡슐화(Encapsulation),다형성(Polymorphism),상속(Inheritance),2,"객체지향 프로그래밍(OOP)에서 캡슐화는 데이터(변수)와 그 데이터를 처리하는 함수(메서드)를 하나의 단위로 묶는 것을 의미합니다.  마치 상자에 물건을 담고 뚜껑을 닫는 것과 같습니다.  외부에서는 상자(객체)의 뚜껑에 있는 작은 구멍(인터페이스)을 통해서만 상자 안의 내용물에 접근할 수 있습니다.  외부에서는 상자 내부의 구조나 동작 방식을 알 필요가 없고,  인터페이스를 통해 제공되는 기능만을 사용하면 됩니다. 이렇게 함으로써 데이터의 무결성을 보장하고, 코드의 복잡성을 줄이며, 유지보수를 용이하게 합니다.  문제에서 언급된 ""연관된 데이터와 함수를 함께 묶어 외부와 경계를 만들고 필요한 인터페이스만을 밖으로 드러내는 과정""은 바로 이 캡슐화 과정을 설명하는 것입니다.  메시지는 객체 간의 통신 방식, 다형성은 여러 객체가 같은 메서드 이름을 가지고 다른 동작을 하는 것, 상속은 객체의 특성을 다른 객체에 물려주는 것을 의미하므로 문제의 설명과는 일치하지 않습니다.",92,107
304,4,4,GoF(Gangs of Four) 디자인 패턴의 생성패턴에 속하지 않는 것은?,,추상 팩토리(Abstract Factory),빌더(Builder),어댑터(Adapter),싱글턴(Singleton),3,"GoF 디자인 패턴은 객체지향 설계에서 자주 발생하는 문제들을 해결하기 위한 디자인 패턴들을 모아놓은 책 ""Design Patterns: Elements of Reusable Object-Oriented Software""에서 제시된 23가지 디자인 패턴들을 말합니다.  이 중 생성 패턴은 객체의 생성 과정을 제어하는 패턴들을 의미하며, 추상 팩토리, 빌더, 싱글턴 등이 대표적인 예시입니다.  어댑터 패턴은 기존의 클래스를 다른 클래스와 호환되도록 변환하는 패턴으로, 객체의 생성과는 직접적인 관련이 없습니다. 따라서 GoF 디자인 패턴의 생성 패턴에 속하지 않는 것은 어댑터 패턴입니다.  쉽게 말해, 생성 패턴은 ""어떻게 객체를 만들까?""에 대한 해답을 제공하는 반면, 어댑터 패턴은 ""기존 객체를 어떻게 활용할까?""에 대한 해답을 제공합니다.",73,107
305,4,5,응용프로그램의 프로시저를 사용하여 원격 프로시저를 로컬 프로시저처럼 호출하는 방식의 미들웨어는?,,WAS(Web Application Server),MOM(Message Oriented Middleware),RPC(Remote Procedure Call),ORB(Object Request Broker),3,"이 문제는 응용 프로그램에서 원격 프로시저(다른 컴퓨터에 있는 프로시저)를 마치 로컬 프로시저(자신의 컴퓨터에 있는 프로시저)처럼 호출하는 미들웨어를 묻고 있습니다.  RPC(Remote Procedure Call)는 바로 이러한 기능을 제공하는 미들웨어입니다.  쉽게 말해, 다른 컴퓨터에 있는 함수를 내 컴퓨터에서 직접 호출하는 것처럼 편리하게 사용할 수 있도록 해주는 기술이라고 생각하면 됩니다.  마치 다른 도시에 있는 친구에게 전화를 걸어 이야기하는 것처럼,  내 컴퓨터가 다른 컴퓨터의 프로시저를 직접 호출하여 데이터를 주고받을 수 있게 해주는 역할을 합니다.  WAS, MOM, ORB는 각각 웹 애플리케이션 서버, 메시지 지향 미들웨어, 객체 요청 브로커로 RPC와는 다른 기능을 수행합니다.",83,110
306,4,6,바람직한 소프트웨어 설계 지침이 아닌 것은?,,모듈의 기능을 예측할 수 있도록 정의한다.,이식성을 고려한다.,적당한 모듈의 크기를 유지한다.,가능한 모듈을 독립적으로 생성하고 결합도를 최대화한다.,4,"소프트웨어 설계에서 모듈화는 프로그램을 여러 개의 작은 단위(모듈)로 나누어 개발하는 것을 말합니다.  각 모듈은 특정 기능을 담당하며, 독립적으로 개발하고 테스트할 수 있도록 설계되어야 합니다.  문제의 4번 지문은 ""가능한 모듈을 독립적으로 생성하고 결합도를 최대화한다""라고 되어 있는데,  결합도(Coupling)는 모듈 간의 상호 의존성을 나타내는 척도입니다.  결합도가 높다는 것은 모듈 간의 의존성이 높다는 뜻이며, 이는 유지보수 및 변경이 어려워지고 오류 발생 가능성을 높입니다.  따라서 좋은 소프트웨어 설계는 결합도를 최소화하고 응집도(Cohesion, 모듈 내부 요소들의 관련성)를 최대화하는 것을 목표로 합니다.  4번 지문은 결합도를 최대화하라고 하므로 바람직한 소프트웨어 설계 지침이 아닙니다.  결합도를 최소화하여 모듈 간의 독립성을 높여야 유지보수가 용이하고, 오류 수정이나 기능 추가가 쉬워집니다.  다른 지문들은 모듈의 기능 명확화, 이식성 고려, 적절한 모듈 크기 유지 등 소프트웨어 설계의 기본 원칙을 잘 나타내고 있습니다.",92,106
307,4,7,객체지향 분석 방법론 중 Coad-Yourdon 방법에 해당하는 것은?,,E-R 다이어그램을 사용하여 객체의 행위를 데이터 모델링하는데 초점을 둔 방법이다.,"객체, 동적, 기능 모델로 나누어 수행하는 방법이다.",미시적 개발 프로세스와 거시적 개발 프로세스를 모두 사용하는 방법이다.,Use-Case를 강조하여 사용하는 방법이다.,1,"Coad-Yourdon 방법은 객체지향 분석 방법론 중 하나로,  E-R 다이어그램(Entity-Relationship Diagram)을 활용하여 시스템을 구성하는 객체들의 속성(데이터)과 객체 간의 관계를 중점적으로 모델링하는 방법입니다.  쉽게 말해, 시스템을 이루는 '사람', '물건', '정보' 등의 객체들을 그림으로 표현하고, 이들 간의 관계(예: '고객'이 '주문'을 한다)를 나타내는 데 초점을 맞춥니다.  객체의 행위(어떤 일을 하는가)보다는 객체 자체와 그 관계에 대한 데이터 모델링에 더 큰 비중을 둡니다. 따라서 1번 선택지가 Coad-Yourdon 방법의 특징을 가장 잘 나타내고 있습니다. 다른 선택지는 다른 객체지향 분석 방법론(예: 객체, 동적, 기능 모델을 사용하는 방법은 여러 방법론에서 공통적으로 사용될 수 있음)의 특징을 설명하고 있습니다.",73,107
308,4,8,다음은 어떤 프로그램 구조를 나타낸다. 모듈 F에서의 fan-in과 fan-out의 수는 얼마인가?,https://www.cbtbank.kr/images/iz/iz20210307/iz20210307m8.gif,"fan-in : 2, fan-out : 3","fan-in : 3, fan-out : 2","fan-in : 1, fan-out : 2","fan-in : 2, fan-out : 1",2,"문제에서 제시된 그림(텍스트로 변환되지 않아 내용을 알 수 없으나, 모듈 F의 fan-in과 fan-out을 묻는 문제임을 알 수 있습니다)을 통해 모듈 F로 들어오는 화살표(입력)의 개수가 fan-in, 모듈 F에서 나가는 화살표(출력)의 개수가 fan-out입니다.  문제의 정답이 2번(fan-in: 3, fan-out: 2)이라고 하였으므로, 그림에서는 모듈 F로 3개의 모듈이 입력을 제공하고, 모듈 F는 2개의 모듈로 출력을 제공하는 구조를 가지고 있음을 의미합니다.  즉, 모듈 F는 3개의 다른 모듈로부터 입력을 받고(fan-in = 3), 2개의 다른 모듈에 출력을 제공(fan-out = 2)하는 것입니다.  만약 그림이 없더라도, 문제에서 제시된 정답을 통해 모듈 F의 입력과 출력 개수를 유추할 수 있습니다.  이는 소프트웨어 설계에서 모듈 간의 연결 관계를 분석하는 기본적인 개념입니다.",88,106
309,4,9,현행 시스템 분석에서 고려하지 않아도 되는 항목은?,,DBMS 분석,네트워크 분석,운영체제 분석,인적 자원 분석,4,"현행 시스템 분석은 기존 시스템의 기능, 성능, 구조 등을 분석하여 새로운 시스템 개발에 필요한 정보를 수집하는 단계입니다.  DBMS 분석은 데이터베이스의 구조와 기능을 분석하는 것이고, 네트워크 분석은 시스템의 네트워크 구성과 성능을 분석하는 것이며, 운영체제 분석은 시스템의 운영체제 환경을 분석하는 것입니다.  반면 인적 자원 분석은 시스템 개발에 참여하는 사람들의 역량이나 조직 구조 등을 분석하는 것으로, 현행 시스템의 *기술적인* 측면을 분석하는 현행 시스템 분석에서는 고려 대상이 아닙니다.  현행 시스템 분석은 시스템 자체의 기술적인 요소에 집중하기 때문에, 사람 중심의 자원 분석은 다음 단계인 새로운 시스템 설계나 개발 단계에서 고려될 사항입니다.",85,101
310,4,10,"분산 컴퓨팅 환경에서 서로 다른 기종 간의 하드웨어나 프로토콜, 통신환경 등을 연결하여 응용프로그램과 운영환경 간에 원만한 통신이 이루어질 수 있게 서비스를 제공하는 소프트웨어는?",,미들웨어,하드웨어,오픈허브웨어,그레이웨어,1,"문제에서 설명하는 소프트웨어는 서로 다른 종류의 컴퓨터 시스템(하드웨어)과 통신 방식(프로토콜), 그리고 다양한 통신 환경에서도 원활한 소통을 가능하게 해주는 역할을 합니다. 마치 여러 나라 사람들이 서로 다른 언어를 사용하더라도 통역가(미들웨어)를 통해 의사소통을 할 수 있는 것과 같습니다.  미들웨어는 응용 프로그램과 운영 환경 사이에서 중개자 역할을 수행하며, 서로 다른 시스템 간의 차이를 해결하고 호환성을 제공하여 원활한 데이터 교환과 통신을 가능하게 합니다.  하드웨어는 물리적인 기계 장치이고, 오픈허브웨어나 그레이웨어는 일반적인 용어가 아닙니다. 따라서 분산 컴퓨팅 환경에서 서로 다른 기종 간의 호환성을 제공하는 소프트웨어는 미들웨어입니다.",93,110
311,4,11,CASE(Computer Aided Software Engineering)에 대한 설명으로 틀린 것은?,,소프트웨어 모듈의 재사용성이 향상된다.,자동화된 기법을 통해 소프트웨어 품질이 향상된다.,소프트웨어 사용자들에게 사용 방법을 신속히 숙지시키기 위해 사용된다.,소프트웨어 유지보수를 간편하게 수행할 수 있다.,3,"CASE(Computer Aided Software Engineering)는 소프트웨어 개발 과정을 자동화하고 효율적으로 관리하기 위한 도구와 기법들을 통칭합니다.  CASE 도구를 사용하면 소프트웨어 모듈을 재사용하여 개발 시간을 단축하고, 자동화된 검증 과정을 통해 소프트웨어 품질을 향상시킬 수 있습니다. 또한, 일관된 개발 표준을 적용하여 소프트웨어 유지보수를 용이하게 만들 수 있습니다. 하지만 CASE는 소프트웨어 사용자에게 사용 방법을 신속히 숙지시키기 위한 도구가 아닙니다. 사용자 교육은 별도의 매뉴얼이나 교육 과정을 통해 이루어져야 합니다. 따라서 3번이 틀린 설명입니다.  쉽게 말해, CASE는 개발자를 위한 도구이지, 사용자를 위한 도구는 아닙니다.",85,106
312,4,12,UML(Unified Modeling Language)에 대한 설명 중 틀린 것은?,,"기능적 모델은 사용자 측면에서 본 시스템 기능이며, UML에서는 Use case Diagram을 사용한다.","정적 모델은 객체, 속성, 연관관계, 오퍼레이션의 시스템의 구조를 나타내며, UML에서는 Class Diagram을 사용한다.","동적 모델은 시스템의 내부 동작을 말하며, UML에서는 Sequence Diagram, State Diagram, Activity Diagram을 사용한다.","State Diagram은 객체들 사이의 메시지 교환을 나타내며, Sequence Diagram은 하나의 객체가 가진 상태와 그 상태의 변화에 의한 동작순서를 나타낸다.",4,"문제에서 틀린 것은 4번입니다.  4번 설명은 Sequence Diagram과 State Diagram의 기능을 서로 뒤바꿔 설명하고 있습니다.  Sequence Diagram은 여러 객체 간의 상호 작용(메시지 교환)을 시간 순서대로 보여주는 그림이고, State Diagram은 하나의 객체가 가질 수 있는 상태와 상태 변화에 따른 동작을 나타내는 그림입니다.  쉽게 말해, Sequence Diagram은 객체들이 서로 어떻게 소통하는지 보여주는 그림이고, State Diagram은 하나의 객체가 어떤 상황에 따라 어떻게 행동하는지 보여주는 그림입니다.  따라서 4번 설명은 두 다이어그램의 기능을 정확하게 이해하지 못한 설명입니다.  나머지 1, 2, 3번은 UML 다이어그램의 종류와 용도를 정확하게 설명하고 있습니다.",66,102
313,4,13,기본 유스케이스 수행 시 특별한 조건을 만족할 때 수행하는 유스케이스는?,,연관,확장,선택,특화,2,"유스케이스는 시스템의 기능을 사용자의 관점에서 설명하는 하나의 단위입니다.  기본 유스케이스는 시스템의 주요 기능을 나타내는 가장 일반적인 시나리오를 보여줍니다.  하지만, 특정 조건이 만족될 때만 수행되는 기능이 있을 수 있습니다.  이러한 경우, 기본 유스케이스에 추가적인 기능을 확장하여  특별한 조건을 처리하는 유스케이스를 ""확장 유스케이스""라고 합니다.  예를 들어, ""계좌 이체""라는 기본 유스케이스가 있다면, ""잔액 부족""이라는 특별한 조건이 발생했을 때 수행되는 ""잔액 부족 처리"" 유스케이스가 확장 유스케이스가 될 수 있습니다.  따라서, 기본 유스케이스 수행 시 특별한 조건을 만족할 때 수행하는 유스케이스는 확장 유스케이스입니다.  연관, 선택, 특화 유스케이스는 다른 유스케이스와의 관계를 나타내는 개념으로, 특정 조건에 따른 추가적인 기능 수행과는 다릅니다.",63,102
314,4,14,다음 중 요구사항 모델링에 활용되지 않는 것은?,,애자일(Agile) 방법,유스케이스 다이어그램(Use Case Diagram),시컨스 다이어그램(Sequence Diagram),단계 다이어그램(Phase Diagram),4,"이 문제는 요구사항 모델링에 사용되는 다이어그램과 방법론을 묻고 있습니다. 요구사항 모델링이란, 사용자의 요구를 시스템 개발에 반영하기 위해 사용자의 요구를 분석하고 문서화하는 과정입니다.  애자일 방법은 반복적인 개발과 고객 피드백을 통해 요구사항을 명확히 하는 방법론이고, 유스케이스 다이어그램은 사용자의 시스템 사용 방식을 시각적으로 보여주는 다이어그램이며, 시퀀스 다이어그램은 시스템 내 객체들의 상호 작용을 시간 순서대로 보여주는 다이어그램입니다. 이들은 모두 요구사항을 명확히 하고 시스템 설계에 반영하는 데 사용됩니다. 반면 단계 다이어그램(Phase Diagram)은 주로 물리적 시스템의 상태 변화를 나타내는 데 사용되는 다이어그램으로, 소프트웨어 요구사항 모델링에는 적합하지 않습니다. 따라서 요구사항 모델링에 활용되지 않는 것은 단계 다이어그램입니다.",66,102
315,4,15,디자인 패턴을 이용한 소프트웨어 재사용으로 얻어지는 장점이 아닌 것은?,,소프트웨어 코드의 품질을 향상시킬 수 있다.,개발 프로세스를 무시할 수 있다.,개발자들 사이의 의사소통을 원활하게 할 수 있다.,소프트웨어의 품질과 생산성을 향상시킬 수 있다.,2,"디자인 패턴을 사용하면 소프트웨어 개발 과정에서 반복적으로 사용되는 코드들을 재사용할 수 있게 됩니다. 이를 통해 코드의 중복을 줄이고, 개발 시간을 단축하며, 코드의 일관성을 유지할 수 있습니다.  결과적으로 소프트웨어 품질 향상과 생산성 증대에 기여합니다.  개발자들은 이미 검증된 패턴을 사용함으로써 의사소통도 원활해집니다. 하지만 디자인 패턴은 개발 프로세스 자체를 대체하거나 무시할 수 있는 수단이 아닙니다.  디자인 패턴은 개발 프로세스 내에서 효율적인 코드 작성을 위한 하나의 도구일 뿐,  소프트웨어 개발의 전 과정을 대체할 수는 없습니다.  따라서 개발 프로세스를 무시할 수 있다는 주장은 잘못된 것입니다.",94,107
316,4,16,"럼바우(Rumbaugh) 분석기법에서 정보모델링이라고도 하며, 시스템에서 요구되는 객체를 찾아내어 속성과 연산 식별 및 객체들 간의 관계를 규정하여 다이어그램을 표시하는 모델링은?",,Object,Dynamic,Function,Static,1,"럼바우 분석 기법은 객체지향 분석 기법의 하나로, 시스템을 구성하는 객체들을 중심으로 분석하는 방법입니다.  문제에서 설명하는 것처럼 시스템에 필요한 객체들을 찾고, 각 객체의 속성(데이터)과 연산(행위)을 정의하며, 객체들 간의 관계를 파악하여 다이어그램으로 표현하는 모델링을 **객체(Object) 모델링**이라고 합니다.  객체 모델링은 시스템의 구조를 시각적으로 보여주고 이해하기 쉽게 만들어주며,  후속 설계 및 구현 단계에 중요한 기반을 제공합니다.  다른 선택지인 Dynamic 모델링은 시스템의 시간에 따른 변화를 나타내는 모델링이고, Function 모델링은 시스템의 기능을 중심으로 모델링하는 것이며, Static 모델링은 시스템의 정적인 구조를 나타내는 모델링입니다.  따라서 객체(Object) 모델링이 럼바우 분석 기법에서 정보 모델링에 해당하는 가장 적절한 답입니다.",77,103
317,4,17,"소프트웨어를 개발하기 위한 비즈니스(업무)를 객체와 속성, 클래스와 멤버, 전체와 부분 등으로 나누어서 분석해 내는 기법은?",,객체지향 분석,구조적 분석,기능적 분석,실시간 분석,1,"소프트웨어 개발을 위한 업무를 분석하는 방법 중 하나로, 객체지향 분석은 시스템을 객체(object)라는 개념을 중심으로 분석하는 기법입니다.  객체는 속성(attribute)과 행위(method)를 가지고 있으며,  여러 객체들을 묶어 클래스(class)를 정의합니다.  클래스는 객체의 설계도와 같다고 생각하면 됩니다.  객체지향 분석은 복잡한 시스템을 작은 객체들로 나누어 분석하고, 객체들 간의 상호작용을 파악하여 시스템 전체의 구조를 이해하는 데 효과적입니다.  마치 레고 블록처럼 작은 조각들을 조립하여 큰 구조물을 만드는 것과 유사합니다.  전체 시스템을 부분으로 나누고, 각 부분의 역할과 관계를 명확히 하여 소프트웨어 개발의 효율성을 높이는 데 기여합니다.  구조적 분석이나 기능적 분석은 시스템의 전체적인 흐름이나 기능에 초점을 맞추는 반면, 객체지향 분석은 시스템을 구성하는 요소(객체)와 그 요소들 간의 관계에 초점을 맞춥니다.",64,102
318,4,18,애자일 소프트웨어 개발 기법의 가치가 아닌 것은?,,프로세스의 도구보다는 개인과 상호작용에 더 가치를 둔다.,계약 협상보다는 고객과의 협업에 더 가치를 둔다.,실제 작동하는 소프트웨어보다는 이해하기 좋은 문서에 더 가치를 둔다.,계획을 따르기보다는 변화에 대응하는 것에 더 가치를 둔다.,3,"애자일 소프트웨어 개발 기법은 빠르게 변화하는 요구사항에 유연하게 대처하고, 고객과의 긴밀한 협력을 통해 효율적인 소프트웨어 개발을 추구하는 방법론입니다.  1번은 프로세스보다 사람 중심의 개발을 강조하고, 2번은 고객과의 협력을 중요시하며, 4번은 계획보다 변화에 대한 적응력을 높이 평가하는 애자일의 핵심 가치를 보여줍니다.  반면 3번은 ""실제 작동하는 소프트웨어보다는 이해하기 좋은 문서에 더 가치를 둔다""라고 하는데, 애자일은 실제 작동하는 소프트웨어를 빠르게 만들고, 지속적으로 개선하는 것을 중시하기 때문에 3번은 애자일의 가치와는 맞지 않습니다.  문서보다는 작동하는 소프트웨어를 우선시하는 것이 애자일의 중요한 특징입니다. 따라서 3번이 정답입니다.",90,102
319,4,19,"UML 다이어그램 중 시스템 내 클래스의 정적 구조를 표현하고 클래스와 클래스, 클래스의 속성 사이의 관계를 나타내는 것은?",,Activity Diagram,Modea Diagram,State Diagram,Class Diagram,4,"UML(Unified Modeling Language) 다이어그램은 소프트웨어 시스템을 시각적으로 표현하는 표준 언어입니다. 여러 종류의 다이어그램이 있지만, 문제에서 묻고 있는 것은 시스템 내 클래스들의 구조와 관계를 나타내는 다이어그램입니다.  클래스는 객체지향 프로그래밍에서 데이터(속성)와 그 데이터를 처리하는 함수(메소드)를 묶어놓은 개념입니다.  Class Diagram은 이러한 클래스들 간의 관계(예: 상속, 포함, 연관)와 각 클래스의 속성, 메소드를 보여주는 다이어그램입니다.  Activity Diagram, Modea Diagram(정확한 용어는 아닌 것 같습니다.  혹시 Model Diagram을 잘못 적으신 것일 수 있습니다.), State Diagram은 각각 시스템의 동작 흐름, 데이터 모델, 객체의 상태 변화를 나타내는 다이어그램이므로 시스템의 정적 구조를 표현하는 Class Diagram과는 다릅니다. 따라서 시스템 내 클래스의 정적 구조와 클래스 간 관계를 나타내는 UML 다이어그램은 Class Diagram입니다.",81,102
320,4,20,소프트웨어 설계시 제일 상위에 있는 main user function에서 시작하여 기능을 하위 기능들로 분할해 가면서 설계하는 방식은?,,객체 지향 설계,데이터 흐름 설계,상향식 설계,하향식 설계,4,"소프트웨어 설계에서 하향식 설계(Top-down design)는 가장 상위 기능(main user function)부터 시작하여, 이를 점차 하위 기능으로 세분화하는 방식입니다.  마치 나무의 뿌리에서 가지가 뻗어나가는 것처럼, 큰 기능을 작고 관리하기 쉬운 여러 기능으로 나누어 설계하는 것이죠.  예를 들어, ""온라인 쇼핑몰""이라는 큰 기능을 ""상품 검색"", ""장바구니 추가"", ""결제"", ""배송"" 등의 하위 기능으로 나누는 것이 하향식 설계의 전형적인 예입니다.  반대로, 하위 기능부터 시작하여 상위 기능을 구성하는 방식은 상향식 설계라고 합니다.  문제에서 제시된 ""main user function에서 시작하여 기능을 하위 기능들로 분할""하는 방식은 바로 하향식 설계를 의미합니다.",88,106
321,4,21,구현 단계에서의 작업 절차를 순서에 맞게 나열한 것은?,https://www.cbtbank.kr/images/iz/iz20210307/iz20210307m21.gif,㉠-㉡-㉢-㉣,㉡-㉠-㉣-㉢,㉢-㉠-㉡-㉣,㉣-㉡-㉠-㉢,2,"소프트웨어를 구현하는 단계는 크게 계획, 코딩, 컴파일, 테스트의 과정을 거칩니다.  먼저 무엇을 어떻게 코딩할지 계획을 세우는 단계(② 코딩작업을 계획한다)가 가장 먼저 와야 합니다.  계획이 세워진 후에 실제로 코드를 작성하는 단계(① 코딩한다)가 이어집니다.  작성된 코드는 컴퓨터가 이해할 수 있는 기계어로 변환하는 컴파일 과정(④ 컴파일한다)을 거치고, 마지막으로 오류가 없는지, 제대로 작동하는지 확인하는 테스트 단계(③ 코드를 테스트한다)를 거치게 됩니다. 따라서 정답은 ㉡-㉠-㉣-㉢ 순서인 2번입니다.",89,114
322,4,22,다음 자료에 대하여 “Selection Sort”를 사용하여 오름차순으로 정렬한 경우 PASS 3의 결과는?,https://www.cbtbank.kr/images/iz/iz20210307/iz20210307m22.gif,"3, 4, 7, 9, 8","3, 4, 8, 9, 7","3, 8, 4, 9, 7","3, 4, 7, 8, 9",1,"Selection Sort는 가장 작은 값을 찾아서 앞으로 보내는 정렬 알고리즘입니다.  주어진 자료 8, 3, 4, 9, 7을 오름차순으로 정렬하는 과정을 살펴보겠습니다.",60,111
323,4,23,하향식 통합시험을 위해 일시적으로 필요한 조건만을 가지고 임시로 제공되는 시험용 모듈은?,,Stub,Driver,Procedure,Function,1,"하향식 통합 시험은 상위 모듈부터 통합하여 테스트하는 방식입니다.  이때, 아직 구현되지 않은 하위 모듈을 대체하기 위해 임시로 기능을 제공하는 더미 모듈이 필요한데, 이를 Stub이라고 합니다.  Stub은 하위 모듈이 호출될 때 미리 정의된 값을 반환하거나, 특정 동작을 시뮬레이션하여 상위 모듈의 테스트를 가능하게 합니다.  Driver는 상위 모듈을 테스트하기 위해 하위 모듈을 호출하는 역할을 하며, Procedure와 Function은 일반적인 프로그램 구성 요소이지 하향식 통합 시험을 위해 일시적으로 필요한 조건만을 가지고 임시로 제공되는 시험용 모듈은 아닙니다. 따라서 하향식 통합 시험에서 일시적으로 필요한 모듈은 Stub입니다.",83,114
324,4,24,다음 전위식(prefix)을 후위식(postfix)으로 옳게 표현한 것은?,https://www.cbtbank.kr/images/iz/iz20210307/iz20210307m24.gif,A B C + D / * E -,A B * C D / + E -,A B * C + D / E -,A B C + * D / E -,4,"이 문제는 전위 표기법(prefix notation)으로 표현된 수식을 후위 표기법(postfix notation)으로 변환하는 문제입니다. 전위 표기법은 연산자가 피연산자 앞에 오는 표기법이고, 후위 표기법은 연산자가 피연산자 뒤에 오는 표기법입니다.  문제에서 주어진 전위 표기식 ""- / * A + B C D E""를 후위 표기식으로 바꾸는 과정을 살펴보겠습니다.  전위 표기식은 연산을 오른쪽에서 왼쪽으로 처리합니다.",65,111
325,4,25,"그래프의 특수한 형태로 노드(Node)와 선분(Branch)으로 되어 있고, 정점 사이에 사이클(Cycle)이 형성되어 있지 않으며, 자료 사이의 관계성이 계층 형식으로 나타나는 비선형 구조는?",,tree,network,stack,distributed,1,"문제에서 제시된 조건들을 하나씩 살펴보겠습니다.  ""그래프의 특수한 형태로 노드(Node)와 선분(Branch)으로 되어 있다""는 것은 그래프 구조임을 나타냅니다. ""정점 사이에 사이클(Cycle)이 형성되어 있지 않다""는 것은 순환 구조가 없다는 의미이며, ""자료 사이의 관계성이 계층 형식으로 나타나는 비선형 구조""는 계층적인 구조를 가지고 있음을 의미합니다. 이러한 조건들을 모두 만족하는 자료구조는 트리(Tree)입니다. 트리는 계층적인 구조를 가지며, 루트 노드에서 시작하여 가지(Branch)를 통해 하위 노드로 연결됩니다.  사이클이 없다는 것은 어떤 노드에서 출발하여 다시 그 노드로 돌아오는 경로가 없다는 것을 의미하며, 이는 트리의 특징입니다. 네트워크는 사이클이 존재할 수 있으며, 스택은 선형 구조, 분산 시스템은 여러 노드로 구성된 시스템을 의미하므로 문제의 조건과 일치하지 않습니다. 따라서 정답은 1번 트리(Tree)입니다.",86,111
326,4,26,스택에 대한 설명으로 틀린 것은?,,입출력이 한쪽 끝으로만 제한된 리스트이다.,Head(front)와 Tail(rear)의 2개 포인터를 갖고 있다.,LIFO 구조이다.,더 이상 삭제할 데이터가 없는 상태에서 데이터를 삭제하면 언더플로(Underflow)가 발생한다.,2,"스택(Stack)은 데이터를 쌓아 올리는 구조를 가진 자료구조입니다.  마치 접시를 쌓아 올리는 것처럼, 가장 나중에 쌓은 접시를 가장 먼저 꺼내야 합니다. 이러한 특징을 LIFO(Last-In, First-Out)라고 합니다. 문제에서 틀린 것은 2번입니다. 스택은 데이터를 한쪽 끝(top)에서만 추가(push)하고 삭제(pop)하기 때문에, Head(front)와 Tail(rear)이라는 두 개의 포인터를 사용하지 않습니다.  큐(Queue)와 같은 자료구조에서 Head와 Tail 포인터를 사용합니다. 1번은 스택의 특징을 잘 나타내고 있으며, 3번은 LIFO 구조라는 스택의 기본 원리를 설명하고 있습니다. 4번은 스택에서 더 이상 삭제할 데이터가 없는데 삭제 연산을 시도하면 발생하는 언더플로우(Underflow) 현상을 설명하고 있습니다. 따라서 2번이 스택에 대한 잘못된 설명입니다.",75,111
327,4,27,디지털 저작권 관리(DRM)에 사용되는 기술요소가 아닌 것은?,,키관리,방화벽,암호화,크랙방지,2,"디지털 저작권 관리(DRM)은 디지털 콘텐츠의 불법 복제 및 배포를 막기 위해 사용되는 기술입니다.  문제에서 제시된 키 관리, 암호화, 크랙 방지는 모두 DRM에 사용되는 핵심 기술 요소입니다. 키 관리는 콘텐츠 접근을 제어하는 암호키를 안전하게 관리하는 것을 의미하고, 암호화는 콘텐츠 자체를 암호화하여 무단 접근을 차단하는 기술이며, 크랙 방지는 불법적인 해킹이나 크랙 시도를 방지하는 기술입니다.  반면 방화벽은 외부로부터의 불법적인 접근을 차단하는 네트워크 보안 기술로, DRM 시스템의 보안을 강화하는 데 도움을 줄 수는 있지만 DRM 기술 자체의 요소는 아닙니다. DRM은 콘텐츠 자체의 보호에 초점을 맞추는 반면, 방화벽은 네트워크 전체의 보안에 초점을 맞추기 때문입니다. 따라서 DRM에 사용되는 기술 요소가 아닌 것은 방화벽입니다.",83,116
328,4,28,여러 개의 선택 항목 중 하나의 선택만 가능한 경우 사용하는 사용자 인터페이스(UI)요소는?,,토글 버튼,텍스트 박스,라디오 버튼,체크 박스,3,"여러 개의 선택지 중에서 단 하나만 선택할 수 있도록 하는 사용자 인터페이스 요소를 묻는 문제입니다.  라디오 버튼(Radio Button)은 여러 개의 선택지 중 오직 하나만 선택할 수 있도록 원형 버튼으로 제공되는 UI 요소입니다.  토글 버튼은 켜기/끄기와 같이 두 가지 상태를 전환하는 데 사용되고, 텍스트 박스는 사용자가 텍스트를 입력하는 데 사용됩니다. 체크 박스는 여러 개의 선택지를 동시에 선택할 수 있도록 허용합니다. 따라서 문제에서 요구하는 '하나의 선택만 가능'한 조건을 만족하는 것은 라디오 버튼입니다.",79,104
329,4,29,소프트웨어의 일부분을 다른 시스템에서 사용할 수 있는 정도를 의미하는 것은?,,신뢰성(Reliability),유지보수성(Maintainability),가시성(Visibility),재사용성(Reusability),4,"소프트웨어의 재사용성(Reusability)은 이미 개발된 소프트웨어의 일부 또는 전체를 다른 시스템이나 프로젝트에서 다시 사용할 수 있는 정도를 의미합니다.  마치 레고 블록처럼, 기존에 만들어 놓은 블록들을 조합하여 새로운 것을 만들 수 있는 것과 같습니다.  재사용성이 높은 소프트웨어는 개발 시간과 비용을 절감하고, 개발의 효율성을 높일 수 있습니다.  문제에서 제시된 ""소프트웨어의 일부분을 다른 시스템에서 사용할 수 있는 정도""라는 설명은 바로 이 재사용성을 정확하게 나타내고 있습니다. 신뢰성은 소프트웨어가 얼마나 안정적으로 동작하는지를, 유지보수성은 소프트웨어를 얼마나 쉽게 수정하고 관리할 수 있는지를, 가시성은 소프트웨어의 내부 동작을 얼마나 쉽게 이해할 수 있는지를 나타내는 개념이므로 문제의 질문과는 부합하지 않습니다.",86,106
330,4,30,자료구조에 대한 설명으로 틀린 것은?,,큐는 비선형구조에 해당한다.,큐는 First In – First Out 처리를 수행한다.,스택은 Last In – First out 처리를 수행한다.,"스택은 서브루틴 호출, 인터럽트 처리, 수식 계산 및 수식 표기법에 응용된다.",1,"자료구조에서 큐(Queue)는 데이터를 먼저 들어온 순서대로 먼저 나가는(FIFO: First In First Out) 방식의 선형 자료구조입니다.  반면, 스택(Stack)은 먼저 들어온 데이터가 나중에 나가고, 나중에 들어온 데이터가 먼저 나가는(LIFO: Last In First Out) 방식의 선형 자료구조입니다.  문제에서 1번은 큐가 비선형 구조라고 했는데, 이는 잘못된 설명입니다. 큐는 데이터가 순서대로 나열되는 선형 구조에 해당합니다.  따라서 1번이 틀린 설명입니다.  2번과 3번은 큐와 스택의 특징을 정확하게 설명하고 있으며, 4번은 스택의 실제 응용 분야를 제시하고 있습니다.",80,111
331,4,31,다음 중 블랙박스 검사 기법은?,,경계값 분석,조건 검사,기초 경로 검사,루프 검사,1,"블랙박스 검사는 소프트웨어의 내부 구조를 알지 못하고, 외부에서 입력값을 주고 출력값을 확인하여 소프트웨어의 동작을 검증하는 테스트 기법입니다.  경계값 분석은 이러한 블랙박스 검사 기법 중 하나로, 입력값의 경계(최소값, 최대값, 그리고 그 바로 근처 값들)를 이용하여 테스트 케이스를 설계하는 방법입니다.  경계값에서 오류가 발생하는 경우가 많기 때문에 효율적인 검사 방법으로 사용됩니다.  반면, 조건 검사, 기초 경로 검사, 루프 검사는 소프트웨어의 내부 구조를 어느 정도 알고 있어야 테스트 케이스를 설계할 수 있는 화이트박스 검사 기법 또는 그레이박스 검사 기법에 속합니다. 따라서 문제에서 묻는 블랙박스 검사 기법에 해당하는 것은 경계값 분석입니다.",78,119
332,4,32,이진 검색 알고리즘에 대한 설명으로 틀린 것은?,,탐색 효율이 좋고 탐색 시간이 적게 소요된다.,검색할 데이터가 정렬되어 있어야 한다.,피보나치 수열에 따라 다음에 비교할 대상을 선정하여 검색한다.,비교횟수를 거듭할 때마다 검색 대상이 되는 데이터의 수가 절반으로 줄어든다.,3,"이진 검색 알고리즘은 정렬된 데이터에서 특정 값을 찾는 효율적인 방법입니다.  마치 전화번호부에서 이름을 찾는 것과 같습니다.  전화번호부는 알파벳 순서로 정렬되어 있으므로,  중간 부분을 펼쳐서 찾고자 하는 이름이 중간 값보다 앞인지 뒤인지 확인합니다.  앞이라면 앞쪽 절반만, 뒤라면 뒤쪽 절반만 다시 검색합니다. 이 과정을 반복하여 찾고자 하는 값을 찾을 때까지 검색 범위를 절반씩 줄여나갑니다.  따라서 1번과 4번은 이진 검색의 특징을 잘 나타내고 있습니다.  2번 역시 정렬된 데이터가 필수적이라는 점을 명확히 하고 있습니다.  하지만 3번은 잘못된 설명입니다. 이진 검색은 피보나치 수열을 사용하지 않습니다.  피보나치 수열은 0, 1, 1, 2, 3, 5, 8… 과 같이 앞의 두 수를 더하여 다음 수를 만드는 수열인데, 이진 검색은 데이터를 절반씩 나누어 검색하는 방식이지 피보나치 수열을 따르지 않습니다.",67,111
333,4,33,소프트웨어 품질목표 중 쉽게 배우고 사용할 수 있는 정도를 나타내는 것은?,,Correctness,Reliability,Usability,Integrity,3,"소프트웨어 품질 목표는 소프트웨어가 얼마나 잘 만들어졌는지를 평가하는 기준입니다.  문제에서 제시된 옵션들을 살펴보면, Correctness는 소프트웨어가 얼마나 정확하게 요구사항을 충족하는지를 나타내고, Reliability는 얼마나 안정적으로 동작하는지를, Integrity는 데이터의 무결성을 의미합니다.  Usability는 사용자 친화적인 정도, 즉 쉽게 배우고 사용할 수 있는 정도를 나타냅니다. 따라서, 쉽게 배우고 사용할 수 있는 정도를 나타내는 소프트웨어 품질 목표는 Usability입니다.  정보처리기사 시험에서는 소프트웨어 품질 특성에 대한 이해를 묻는 문제가 자주 출제되므로,  Correctness, Reliability, Usability, Integrity 등의 의미를 정확하게 숙지하는 것이 중요합니다.",86,117
334,4,34,테스트 케이스에 일반적으로 포함되는 항목이 아닌 것은?,,테스트 조건,테스트 데이터,테스트 비용,예상 결과,3,"테스트 케이스는 소프트웨어의 기능을 검증하기 위해 설계된 일련의 입력값, 실행 조건, 그리고 예상 결과를 포함합니다.  테스트 조건은 어떤 상황에서 테스트를 수행할지, 테스트 데이터는 테스트에 사용될 입력값, 예상 결과는 테스트가 성공적으로 수행되었는지 확인하기 위한 기준이 됩니다.  하지만 테스트 비용은 테스트를 수행하는 데 드는 비용으로, 테스트 케이스 자체에 포함되는 항목은 아닙니다. 테스트 케이스는 소프트웨어의 기능적 동작을 검증하는 데 초점을 맞추고, 비용은 프로젝트 관리 측면에서 고려되는 사항이기 때문입니다.  따라서 테스트 케이스에 일반적으로 포함되지 않는 항목은 테스트 비용입니다.",82,119
335,4,35,소프트웨어 설치 매뉴얼에 포함될 항목이 아닌 것은?,,제품 소프트웨어 개요,설치 관련 파일,프로그램 삭제,소프트웨어 개발 기간,4,"소프트웨어 설치 매뉴얼은 사용자가 소프트웨어를 설치하고 사용하는 데 필요한 모든 정보를 담고 있습니다.  제품 소프트웨어 개요는 소프트웨어가 무엇인지, 어떤 기능을 하는지 설명하고, 설치 관련 파일은 설치에 필요한 파일들을 목록으로 제시하며, 프로그램 삭제 방법은 설치된 소프트웨어를 제거하는 방법을 안내합니다.  하지만 소프트웨어 개발 기간은 사용자에게 직접적으로 필요한 정보가 아니므로 설치 매뉴얼에 포함될 필요가 없습니다.  사용자는 소프트웨어를 어떻게 설치하고 사용하며 삭제하는지 알고 싶어하지, 소프트웨어를 만드는 데 얼마나 시간이 걸렸는지는 궁금해하지 않기 때문입니다.",89,117
336,4,36,소프트웨어 형상관리(Configuration management)에 관한 설명으로 틀린 것은?,,소프트웨어에서 일어나는 수정이나 변경을 알아내고 제어하는 것을 의미한다.,"소프트웨어 개발의 전체 비용을 줄이고, 개발 과정의 여러 방해 요인이 최소화되도록 보증하는 것을 목적으로 한다.",형상관리를 위하여 구성된 팀을 “chief programmer team”이라고 한다.,형상관리의 기능 중 하나는 버전 제어 기술이다.,3,"소프트웨어 형상관리는 소프트웨어 개발 과정에서 발생하는 변경 사항을 추적하고 관리하는 체계적인 방법입니다.  1번과 2번은 소프트웨어 형상관리의 주요 목표와 기능을 정확하게 설명하고 있습니다.  소프트웨어 형상관리는 변경을 추적하고 제어하여 개발 비용을 절감하고, 오류를 최소화하며, 개발 과정의 혼란을 방지하는 데 도움을 줍니다. 4번 또한 소프트웨어 형상관리의 중요한 기능인 버전 제어를 언급하고 있습니다.  하지만 3번은 잘못된 설명입니다.  ""chief programmer team""은 소프트웨어 개발 조직의 한 유형이지만, 형상관리를 위해 특별히 구성된 팀을 의미하는 용어는 아닙니다. 형상관리는 별도의 팀이나 도구를 통해 관리될 수 있으며,  ""chief programmer team""은 형상관리와 직접적인 관련이 없습니다. 따라서 3번이 틀린 설명입니다.",69,115
337,4,37,퀵 정렬에 관한 설명으로 옳은 것은?,,레코드의 키 값을 분석하여 같은 값끼리 그 순서에 맞는 버킷에 분배하였다가 버킷의 순서대로 레코드를 꺼내어 정렬한다.,주어진 파일에서 인접한 두 개의 레코드 키 값을 비교하여 그 크기에 따라 레코드 위치를 서로 교환한다.,레코드의 많은 자료 이동을 없애고 하나의 파일을 부분적으로 나누어 가면서 정렬한다.,임의의 레코드 키와 매개변수(h)값만큼 떨어진 곳의 레코드 키를 비교하여 서로 교환해 가면서 정렬한다.,3,"퀵 정렬은 기준 값(피벗)을 정하고, 이 기준 값보다 작은 값들은 왼쪽, 큰 값들은 오른쪽으로 나누는 방식으로 정렬하는 알고리즘입니다.  1번은 버킷 정렬, 2번은 버블 정렬, 4번은 쉘 정렬의 설명입니다.  퀵 정렬은 하나의 파일 전체를 한꺼번에 처리하는 것이 아니라, 파일을 부분적으로 나누어 정렬하는 분할 정복(Divide and Conquer) 전략을 사용합니다.  따라서 레코드의 많은 자료 이동을 줄일 수 있습니다.  3번이 퀵 정렬의 특징을 가장 잘 나타내는 설명입니다.  마치 큰 문제를 작은 문제로 나누어 해결하는 것과 같습니다.  예를 들어, 100개의 숫자를 정렬해야 한다면, 퀵 정렬은 이를 50개씩 두 부분으로 나누고, 각 부분을 다시 나누는 방식으로 정렬합니다.  이 과정을 통해 전체적인 자료 이동을 최소화하여 효율적인 정렬을 수행합니다.",53,111
338,4,38,해싱 함수(Hashing Function)의 종류가 아닌 것은?,,제곱법(mid-square),숫자분석법(digit analysis),개방주소법(open addressing),제산법(division),3,"해싱 함수는 데이터를 고정된 크기의 해시 값으로 변환하는 함수입니다.  제곱법, 숫자분석법, 제산법은 모두 해싱 함수의 종류 중 하나로, 입력 데이터를 특정 알고리즘을 통해 해시 값으로 변환하는 방법을 제시합니다.  반면, 개방주소법(open addressing)은 해싱 충돌(여러 데이터가 같은 해시 값을 갖는 경우)을 해결하기 위한 충돌 해결 기법 중 하나입니다.  즉, 해싱 함수 자체가 아니라 해싱 함수를 사용할 때 발생하는 문제를 해결하는 방법론이죠. 따라서 해싱 함수의 종류가 아닌 것은 개방주소법입니다.  쉽게 말해, 해싱 함수는 요리법이고, 개방주소법은 요리 중 재료가 부족할 때 대처하는 방법과 같은 것입니다.",65,111
339,4,39,필드 테스팅(field testing)이라고도 불리며 개발자 없이 고객의 사용 환경에 소프트웨어를 설치하여 검사를 수행하는 인수검사 기법은?,,베타 검사,알파 검사,형상 검사,복구 검사,1,"필드 테스팅, 즉 현장 테스트는 개발이 완료된 소프트웨어를 실제 사용 환경에서 고객이 직접 사용해 보도록 하고, 그 결과를 바탕으로 소프트웨어의 문제점을 발견하고 개선하는 인수검사 기법입니다.  알파 테스트는 개발 회사 내부에서, 베타 테스트는 개발 회사 외부의 실제 사용자들이 참여하여 진행되는데, 문제에서 설명하는 ""개발자 없이 고객의 사용 환경에 소프트웨어를 설치하여 검사를 수행하는"" 부분은 베타 테스트의 특징을 정확히 나타냅니다.  따라서 정답은 베타 검사입니다.  알파 검사는 개발팀 내부에서 진행되므로 개발자의 참여가 필수적이며, 형상 검사와 복구 검사는 소프트웨어의 다른 측면을 검사하는 기법입니다.",81,119
340,4,40,다음 트리를 Preorder 운행법으로 운행할 경우 다섯 번째로 탐색되는 것은?,https://www.cbtbank.kr/images/iz/iz20210307/iz20210307m40.gif,C,E,G,H,2,Preorder 트리 순회는 트리의 노드를 방문하는 방법 중 하나입니다.  Preorder 순회는 다음과 같은 세 가지 단계를 반복적으로 수행합니다.,87,111
341,4,41,결과 값이 아래와 같을 때 SQL 질의로 옳은 것은?,https://www.cbtbank.kr/images/iz/iz20210307/iz20210307m41.gif,SELECT * FROM 공급자 WHERE,공급자명 LIKE '%신%';,SELECT * FROM 공급자 WHERE,공급자명 LIKE '%대%';,1,"문제에서 제시된 SQL 질의는 `공급자` 테이블에서 특정 조건에 맞는 데이터를 선택하는 것을 목표로 합니다.  1번과 2번, 3번, 4번 질의 모두 `SELECT * FROM 공급자` 부분은 공급자 테이블의 모든 열을 선택하라는 의미입니다.  차이점은 `WHERE` 절에 있는 조건입니다.  `WHERE` 절은 특정 조건을 만족하는 행만 선택하도록 필터링하는 역할을 합니다.  2번 질의는 `공급자명`에 '신'자가 포함된 공급자를 선택하고, 3번 질의는 `공급자명`에 '대'자가 포함된 공급자를 선택합니다.  4번 질의는 `공급자명`에 '대'자가 포함된 공급자를 선택합니다. 문제에서 제시된 결과는 '대신공업사'(공급자번호 16)와 '신촌상사'(공급자번호 70) 두 개의 행을 보여줍니다.  '대신공업사'는 '대'자가 포함되어 있고, '신촌상사'는 '신'자가 포함되어 있습니다. 따라서,  '대' 또는 '신'자가 포함된 공급자명을 모두 찾아야 합니다.  1번 질의는 `WHERE` 절이 없으므로 테이블의 모든 행을 반환합니다.  따라서, 문제의 결과와 일치하는 유일한 질의는 1번입니다.  결과값에 '대신공업사'와 '신촌상사'만 나오는 이유는 문제의 의도가 '대' 또는 '신'자가 포함된 공급자를 찾는 것이 아니라,  단순히 1번 질의의 결과가 무엇인지 묻는 것이기 때문입니다.  따라서 1번 질의가 정답입니다.",88,126
342,4,42,다음에서 설명하는 스키마(Schema)는?,https://www.cbtbank.kr/images/iz/iz20210307/iz20210307m42.gif,개념 스키마,내부 스키마,외부 스키마,내용 스키마,1,"문제에서 설명하는 스키마는 데이터베이스 전체를 정의하는 개념입니다.  데이터베이스의 개체, 그들 간의 관계, 데이터 무결성을 유지하기 위한 제약 조건, 접근 권한 등 데이터베이스의 전반적인 구조와 규칙을 명세한 것이죠.  마치 건물의 설계도면과 같다고 생각하면 됩니다.  설계도면에는 건물의 각 부분(데이터 개체), 부분들 간의 연결(관계), 안전을 위한 규칙(제약 조건), 누가 어떤 부분에 접근할 수 있는지(접근 권한) 등이 모두 포함되어 있죠. 이와 같이 데이터베이스 전체의 구조와 규칙을 정의하는 스키마를 개념 스키마라고 합니다.  내부 스키마는 실제 데이터베이스의 물리적 저장 구조를, 외부 스키마는 특정 사용자 그룹이 보는 데이터베이스의 논리적 구조를 나타내는 것이므로 문제의 설명과는 맞지 않습니다.  내용 스키마는 데이터베이스에 실제 저장된 데이터 자체를 의미합니다. 따라서 정답은 데이터베이스 전체 구조를 정의하는 개념 스키마인 1번입니다.",78,129
343,4,43,"데이터베이스 설계 단계 중 저장 레코드 양식설계, 레코드 집중의 분석 및 설계, 접근 경로 설계와 관계되는 것은?",,논리적 설계,요구 조건 분석,개념적 설계,물리적 설계,4,"데이터베이스 설계는 크게 개념적 설계, 논리적 설계, 물리적 설계의 세 단계로 나뉩니다.  개념적 설계는 사용자의 요구사항을 분석하여 데이터베이스의 전반적인 구조를 개략적으로 정의하는 단계이고, 논리적 설계는 개념적 설계를 바탕으로 데이터베이스의 구조를 표현하는 단계입니다.  반면, **물리적 설계는 논리적 설계 단계에서 정의된 데이터베이스를 실제로 구현하기 위한 단계**입니다.  문제에서 언급된 저장 레코드 양식 설계, 레코드 집중의 분석 및 설계, 접근 경로 설계는 모두 실제 데이터베이스를 구현하는 데 필요한 세부적인 사항들입니다.  레코드 양식은 데이터를 어떻게 저장할지, 레코드 집중은 데이터 중복을 어떻게 줄일지, 접근 경로는 데이터에 효율적으로 접근하는 방법을 정의하는 것이므로, 이러한 작업들은 물리적 설계 단계에서 수행됩니다. 따라서 정답은 4번, 물리적 설계입니다.",66,132
344,4,44,다음 릴레이션의 카디널리티와 차수가 옳게 나타낸 것은?,https://www.cbtbank.kr/images/iz/iz20210307/iz20210307m44.gif,"카디널리티 : 4, 차수 : 4","카디널리티 : 4, 차수 : 6","카디널리티 : 6, 차수 : 4","카디널리티 : 6, 차수 : 6",2,"문제에서 주어진 표는 '아이디', '성명', '나이', '등급', '적립금', '가입년도' 라는 6개의 속성(attribute)을 가지는 릴레이션(relation)을 나타냅니다.  릴레이션의 카디널리티(cardinality)는 릴레이션에 포함된 튜플(tuple)의 개수를 의미합니다. 튜플은 표의 한 행을 의미하며, 이 경우 총 4개의 행이 있으므로 카디널리티는 4입니다.  차수(degree)는 릴레이션이 가지는 속성(attribute)의 개수를 의미합니다.  주어진 표는 6개의 속성을 가지므로 차수는 6입니다. 따라서 정답은 카디널리티 4, 차수 6 입니다.",76,129
345,4,45,다음과 같은 트랙잭션의 특성은?,https://www.cbtbank.kr/images/iz/iz20210307/iz20210307m45.gif,원자성(atomicity),일관성(consistency),격리성(isolation),영속성(durability),2,"문제에서 제시된 트랜잭션의 특성은 ""시스템이 가지고 있는 고정요소는 트랜잭션 수행 전과 트랜잭션 수행 완료 후의 상태가 같아야 한다"" 입니다.  이는 데이터베이스의 일관성(Consistency)을 의미합니다.  트랜잭션이 시작되기 전의 데이터베이스 상태와 트랜잭션이 완료된 후의 데이터베이스 상태가 일관성을 유지해야 함을 나타냅니다.  즉, 트랜잭션이 성공적으로 완료되면 데이터베이스는 유효한 상태를 유지하고, 실패하면 원래 상태로 되돌아가야 합니다.  다른 선택지인 원자성(Atomicity)은 트랜잭션의 모든 작업이 하나의 단위로 처리되어 완료되거나 전혀 완료되지 않음을 의미하고, 격리성(Isolation)은 여러 트랜잭션이 동시에 실행될 때 서로의 작업에 영향을 받지 않도록 하는 것을 의미하며, 영속성(Durability)은 성공적으로 완료된 트랜잭션의 결과가 영구적으로 저장됨을 의미합니다.  문제에서 제시된 내용은 이러한 특성들 중 일관성(Consistency)을 가장 잘 설명하고 있습니다.",79,127
346,4,46,병행제어의 로킹(Locking) 단위에 대한 설명으로 옳지 않은 것은?,,"데이터베이스, 파일, 레코드 등은 로킹 단위가 될 수 있다.",로킹 단위가 작아지면 로킹 오버헤드가 증가한다.,한꺼번에 로킹할 수 있는 단위를 로킹단위라고 한다.,로킹 단위가 작아지면 병행성 수준이 낮아진다.,4,"이 문제는 데이터베이스의 병행 제어에서 로킹(Locking) 단위의 크기가 병행성에 미치는 영향을 묻고 있습니다.  로킹이란 여러 사용자가 동시에 데이터베이스를 접근하여 데이터를 변경하는 것을 막기 위해 특정 데이터 영역에 대한 접근을 제한하는 기법입니다.  로킹 단위는 한 번에 잠글 수 있는 데이터의 크기를 의미하며, 데이터베이스 전체, 파일, 레코드 등 다양한 크기로 설정될 수 있습니다.",83,131
347,4,47,뷰(VIEW)에 대한 설명으로 옳지 않은 것은?,,DBA는 보안 측면에서 뷰를 활용할 수 있다.,뷰 위에 또 다른 뷰를 정의할 수 있다.,"뷰에 대한 삽입, 갱신, 삭제 연산 시 제약사항이 따르지 않는다.",독립적인 인덱스를 가질 수 없다.,3,"뷰(VIEW)는 기존 테이블의 데이터를 기반으로 새롭게 정의된 가상 테이블입니다.  쉽게 말해, 복잡한 SQL 쿼리를 간단한 이름으로 만들어 사용할 수 있도록 하는 편리한 기능이라고 생각하면 됩니다.  DBA(데이터베이스 관리자)는 뷰를 이용하여 특정 사용자에게는 특정 데이터만 보이도록 제한함으로써 보안을 강화할 수 있습니다(1번). 또한, 이미 만들어진 뷰를 기반으로 또 다른 뷰를 만들 수도 있습니다(2번).  하지만 뷰는 실제 데이터를 저장하는 것이 아니라 기존 테이블의 데이터를 참조하기 때문에, 뷰에 데이터를 삽입하거나 갱신, 삭제하는 작업에는 제약이 따릅니다.  예를 들어, 뷰에 특정 조건을 걸어서 만들었다면, 그 조건을 만족하지 않는 데이터는 삽입할 수 없습니다.  따라서 3번은 옳지 않은 설명입니다.  마지막으로, 뷰는 독립적인 인덱스를 가질 수 없습니다(4번).  뷰는 기존 테이블의 데이터를 참조하기 때문에, 인덱스도 기존 테이블의 인덱스를 사용합니다.",79,128
348,4,48,다음 정의에서 말하는 기본 정규형은?,https://www.cbtbank.kr/images/iz/iz20210307/iz20210307m48.gif,제1정규형(1NF),제2정규형(2NF),제3정규형(3NF),보이스/코드 정규형(BCNF),1,"문제에서 설명하는 ""어떤 릴레이션 R에 속한 모든 도메인이 원자값(Atomic Value)만으로 되어 있다""는 것은,  데이터베이스의 테이블(릴레이션 R) 안에 있는 각각의 칸(도메인)에 더 이상 쪼갤 수 없는 하나의 값만 들어있다는 의미입니다.  예를 들어, 주소라는 칸에 ""서울시 강남구 역삼동 123-45"" 와 같이 여러 정보가 함께 들어있는 것이 아니라, ""123-45"" 와 같이 하나의 값만 들어있어야 한다는 것입니다.  이러한 조건을 만족하는 가장 기본적인 정규화 형태가 바로 제1정규형(1NF)입니다.  제2정규형 이상은 부분 함수 종속이나 이행 종속성과 같은 추가적인 조건을 만족해야 하므로, 문제에서 제시된 조건만으로는 제1정규형만 확실하게 판단할 수 있습니다. 따라서 정답은 1번입니다.",84,129
349,4,49,릴레이션 R1에 속한 애튜리뷰트의 조합인 외래키를 변경하려면 이를 참조하고 있는 릴레이션 R2의 기본키도 변경해야 하는데 이를 무엇이라 하는가?,,정보 무결성,고유 무결성,널 제약성,참조 무결성,4,"릴레이션 R1의 외래키는 다른 릴레이션 R2의 기본키를 참조합니다.  외래키는 R1의 데이터가 R2의 데이터와 일관성을 유지하도록 하는 역할을 합니다.  만약 R1의 외래키를 변경한다면, R1에서 참조하는 R2의 기본키 정보도 일치하도록 변경되어야 데이터의 무결성을 유지할 수 있습니다. 이러한 데이터 무결성을 유지하는 제약 조건을  '참조 무결성'이라고 합니다.  쉽게 말해, 주소록에서 '회사'라는 테이블(R2)과 '직원'이라는 테이블(R1)이 있다고 가정해 봅시다. '직원' 테이블의 '회사 ID'는 '회사' 테이블의 '회사 ID'를 참조하는 외래키입니다. 만약 '회사' 테이블의 '회사 ID'를 변경한다면, '직원' 테이블의 해당 '회사 ID'도 함께 변경되어야 합니다. 그렇지 않으면 직원의 회사 정보가 잘못된 참조를 하게 되어 데이터의 일관성이 깨지게 됩니다. 이러한 일관성을 유지하는 것이 참조 무결성의 핵심입니다.",88,129
350,4,50,시스템 카탈로그에 대한 설명으로 틀린 것은?,,시스템 카탈로그의 갱신은 무결성 유지를 위하여 SQL을 이용하여 사용자가 직접 갱신하여야 한다.,데이터베이스에 포함되는 데이터 객체에 대한 정의나 명세에 대한 정보를 유지관리한다.,DBMS가 스스로 생성하고 유지하는 데이터베이스 내의 특별한 테이블의 집합체이다.,카탈로그에 저장된 정보를 메타 데이터라고도 한다.,1,"시스템 카탈로그는 데이터베이스 시스템의 구성 요소에 대한 정보를 저장하는 일종의 '목록' 또는 '사전'이라고 생각하면 됩니다.  데이터베이스에 어떤 테이블이 있고, 각 테이블의 컬럼은 무엇이며, 어떤 데이터 타입을 가지는지 등의 정보를 담고 있죠.  DBMS(데이터베이스 관리 시스템)는 이 카탈로그를 스스로 관리하며, 사용자가 직접 SQL을 이용하여 수정할 필요가 없습니다.  1번 보기는 이러한 DBMS의 자동 관리 기능을 잘못 이해하고 있는 것이므로 틀린 설명입니다.  사용자가 직접 시스템 카탈로그를 수정하면 데이터베이스의 무결성에 심각한 문제가 발생할 수 있기 때문입니다.  2, 3, 4번 보기는 시스템 카탈로그의 정확한 기능과 역할을 설명하고 있습니다. 메타데이터는 데이터에 대한 데이터를 의미하며, 시스템 카탈로그에 저장된 정보가 바로 메타데이터입니다.",80,129
351,4,51,"조건을 만족하는 릴레이션의 수평적 부분집합으로 구성하며, 연산자의 기호는 그리스 문자 시그마(σ)를 사용하는 관계대수 연산은?",,Select,Project,Join,Division,1,"관계대수는 관계형 데이터베이스를 조작하는 데 사용되는 수학적 언어입니다.  문제에서 제시된 연산은 릴레이션(관계)의 수평적 부분집합을 구성하는 연산을 찾는 것입니다.  수평적 부분집합이란, 원래 릴레이션의 일부 행(row)만을 선택하여 새로운 릴레이션을 만드는 것을 의미합니다.  Select 연산은 조건에 맞는 행만을 선택하여 새로운 릴레이션을 생성하므로, 릴레이션의 수평적 부분집합을 만드는 연산입니다.  Project 연산은 특정 속성(column)만을 선택하여 새로운 릴레이션을 생성하므로 수직적 부분집합을 만듭니다. Join 연산은 두 개의 릴레이션을 결합하는 연산이고, Division 연산은 두 개의 릴레이션으로부터 특정 속성의 값을 나누는 연산입니다. 따라서, 문제에서 요구하는 ""릴레이션의 수평적 부분집합으로 구성""하는 연산은 Select 연산입니다.  σ(시그마) 기호는 관계대수에서 선택 연산(Selection)을 나타내는 기호로 사용됩니다.  예를 들어, σ(나이>20)(학생) 이라는 표현은 학생 릴레이션에서 나이가 20살보다 큰 학생들의 정보만을 선택하는 연산을 의미합니다.",75,128
352,4,52,"SQL에서 스키마(schema), 도메인(domain), 테이블(table), 뷰(view), 인덱스(index)를 정의하거나 변경 또는 삭제할 때 사용하는 언어는?",,DML(Data Manipulation Language),DDL(Data Definition Language),DCL(Data Control Language),IDL(Interactive Data Language),2,"SQL(Structured Query Language)은 데이터베이스를 관리하고 조작하는 데 사용되는 표준 언어입니다.  SQL은 크게 DDL(Data Definition Language), DML(Data Manipulation Language), DCL(Data Control Language) 세 가지로 나뉘는데,  문제에서 언급된 스키마, 도메인, 테이블, 뷰, 인덱스는 데이터베이스의 구조를 정의하고 변경하는 데 사용됩니다.  이러한 작업은 데이터를 조작하는 것이 아니라 데이터베이스의 *구조* 자체를 정의하거나 변경하는 것이므로 DDL(Data Definition Language, 데이터 정의 언어)에 속합니다.  DML은 데이터의 삽입, 수정, 삭제, 조회 등을 담당하고, DCL은 데이터베이스 접근 권한을 관리하는 역할을 합니다. 따라서 스키마, 도메인, 테이블, 뷰, 인덱스를 정의하거나 변경, 삭제하는 데 사용되는 언어는 DDL입니다.",77,127
353,4,53,정규화를 거치지 않아 발생하게 되는 이상(anomaly) 현상의 종류에 대한 설명으로 옳지 않은 것은?,,삭제 이상이란 릴레이션에서 한 튜플을 삭제할 때 의도와는 상관없는 값들도 함께 삭제되는 연쇄 삭제 현상이다.,삽입 이상이란 릴레이션에서 데이터를 삽입할 때 의도와는 상관없이 원하지 않는 값들도 함께 삽입되는 현상이다.,갱신 이상이란 릴레이션에서 튜플에 있는 속성값을 갱신할 때 일부 튜플의 정보만 갱신되어 정보에 모순이 생기는 현상이다.,종속 이상이란 하나의 릴레이션에 하나 이상의 함수적 종속성이 존재하는 현상이다.,4,"정규화는 데이터베이스의 중복을 제거하고 데이터 무결성을 유지하기 위해 테이블을 여러 개의 작은 테이블로 분해하는 과정입니다.  정규화를 하지 않으면 데이터 중복으로 인해 여러 가지 이상 현상이 발생하는데, 문제에서 제시된 1, 2, 3번은 모두 정규화를 하지 않아 발생하는 대표적인 이상 현상입니다.  1번 삭제 이상은 특정 데이터를 삭제하려 할 때, 관련된 다른 데이터까지 함께 삭제되는 현상이고, 2번 삽입 이상은 특정 데이터를 삽입하려 할 때, 관련 없는 다른 데이터도 함께 삽입해야 하는 현상이며, 3번 갱신 이상은 특정 데이터를 수정하려 할 때, 일부 데이터만 수정되어 데이터의 일관성이 깨지는 현상입니다.  반면 4번 종속 이상은 하나의 릴레이션에 여러 함수적 종속성이 존재하는 것을 의미하는데, 이것은 정규화의 필요성을 보여주는 현상이지 정규화를 하지 않아서 발생하는 이상 현상은 아닙니다.  종속 이상 자체가 정규화를 통해 해결해야 할 문제이기 때문에 정규화를 거치지 않아 발생하는 이상 현상이라고 보기 어렵습니다. 따라서 4번이 옳지 않은 설명입니다.",73,130
354,4,54,관계 데이터 모델에서 릴레이션(relation)에 관한 설명으로 옳은 것은?,,"릴레이션의 각 행을 스키마(schema)라 하며, 예로 도서 릴레이션을 구성하는 스키마에서는 도서번호, 도서명, 저자, 가격 등이 있다.","릴레이션의 각 열을 튜플(tuple)이라 하며, 하나의 튜플은 각 속성에서 정의된 값을 이용하여 구성된다.",도메인(domain)은 하나의 속성이 가질 수 있는 같은 타입의 모든 값의 집합으로 각 속성의 도메인은 원자값을 갖는다.,속성(attribute)은 한 개의 릴레이션의 논리적인 구조를 정의한 것으로 릴레이션의 이름과 릴레이션에 포함된 속성들의 집합을 의미한다.,3,"이 문제는 관계 데이터 모델에서 릴레이션의 구성 요소와 특징을 이해하고 있는지 묻는 문제입니다.  각 보기를 살펴보면, 1번은 릴레이션의 행을 스키마라고 잘못 설명하고 있습니다.  릴레이션의 행은 튜플(tuple)이고, 스키마(schema)는 릴레이션의 구조(속성들의 이름과 데이터 타입)를 정의하는 것입니다. 2번은 릴레이션의 열을 튜플이라고 잘못 설명하고 있습니다. 릴레이션의 열은 속성(attribute)이고, 튜플은 행을 의미합니다. 4번은 속성을 릴레이션의 논리적 구조 전체로 잘못 설명하고 있습니다. 속성은 릴레이션을 구성하는 하나의 열을 의미합니다.  정답인 3번은 도메인(domain)을 정확하게 설명하고 있습니다. 도메인은 특정 속성이 가질 수 있는 값들의 집합으로, 각 값은 원자값(더 이상 나눌 수 없는 값)을 가져야 합니다. 예를 들어, '도서번호' 속성의 도메인은 숫자의 집합이 될 수 있고, '도서명' 속성의 도메인은 문자열의 집합이 될 수 있습니다.  각 속성은 하나의 도메인을 가지며, 그 도메인 내의 값만 가질 수 있습니다.",66,127
355,4,55,3NF에서 BCNF가 되기 위한 조건은?,,이행적 함수 종속 제거,부분적 함수 종속 제거,다치 종속 제거,결정자이면서 후보 키가 아닌 것 제거,4,"BCNF(Boyce-Codd Normal Form)는 3NF보다 더 강력한 정규화 형태입니다.  3NF는 이행적 함수 종속을 허용하지만, BCNF는 결정자(determinant)가 반드시 후보 키여야 한다는 조건을 추가합니다.  쉽게 말해, 어떤 속성(A)이 다른 속성(B)을 결정한다면(A → B), A는 반드시 테이블의 후보 키여야 합니다.  만약 A가 후보 키가 아니라면, BCNF를 만족하지 못하고, 테이블을 분할하여 BCNF를 만족하도록 해야 합니다.  문제에서 제시된 4번 선택지 ""결정자이면서 후보 키가 아닌 것 제거""는 바로 이 BCNF의 조건을 설명하는 것입니다.  결정자이면서 후보 키가 아닌 속성이 존재한다면, 그 속성을 포함한 부분을 분리하여 새로운 테이블을 만들어야 BCNF를 만족하게 됩니다.  따라서 3NF에서 BCNF로 가기 위해서는 결정자이면서 후보 키가 아닌 것을 제거해야 합니다.  다른 선택지는 3NF를 만족하기 위한 조건이거나, BCNF를 만족하는 과정에서 고려될 수 있는 부분이지만, BCNF가 되기 위한 *핵심 조건*은 아닙니다.",77,130
356,4,56,"데이터베이스 성능에 많은 영향을 주는 DBMS의 구성 요소로 테이블과 클러스터에 연관되어 독립적인 저장 공간을 보유하며, 데이터베이스에 저장된 자료를 더욱 빠르게 조회하기 위하여 사용되는 것은?",,인덱스(Index),트랙잭션(Transaction),역정규화(Denormalization),트리거(Trigger),1,"데이터베이스에 저장된 방대한 양의 데이터에서 원하는 정보를 빠르게 찾는 것은 매우 중요합니다.  인덱스는 책의 목차와 같이 데이터베이스 내부에 특정 열(컬럼)의 값을 기준으로 데이터의 위치를 미리 저장해 놓은 일종의 '주소록'입니다.  데이터베이스 시스템은 인덱스를 이용하여 원하는 데이터를 찾을 때 전체 데이터를 순차적으로 검색하는 대신, 인덱스를 통해 바로 데이터의 위치를 찾아갈 수 있습니다.  이는 마치 책에서 목차를 보고 원하는 페이지를 바로 찾는 것과 같습니다.  따라서 테이블과 클러스터에 연관되어 독립적인 저장 공간을 가지고 있으며, 데이터 조회 속도를 향상시키는 DBMS 구성 요소는 인덱스입니다. 트랙잭션은 데이터베이스의 일관성을 유지하는 작업 단위이고, 역정규화는 데이터 중복을 허용하여 조회 속도를 높이는 기법이지만 인덱스처럼 독립적인 저장 공간을 가지는 것은 아닙니다. 트리거는 특정 이벤트 발생 시 자동으로 실행되는 프로시저입니다.",75,128
357,4,57,아래의 SQL문을 실행한 결과는?,https://www.cbtbank.kr/images/iz/iz20210307/iz20210307m57.gif,https://www.cbtbank.kr/images/iz/iz20210307/iz20210307m57b1.gif,https://www.cbtbank.kr/images/iz/iz20210307/iz20210307m57b2.gif,https://www.cbtbank.kr/images/iz/iz20210307/iz20210307m57b3.gif,https://www.cbtbank.kr/images/iz/iz20210307/iz20210307m57b4.gif,2,"이 SQL 문은 두 개의 테이블, R1(학생 정보)과 R2(수강 정보)를 사용합니다.  목표는 과목번호가 'C100'인 과목을 수강한 학생들의 이름을 R1 테이블에서 찾는 것입니다.  `WHERE 학번 IN (SELECT 학번 FROM R2 WHERE 과목번호 = 'C100')` 부분이 핵심입니다.  먼저 안쪽의 `SELECT` 문(`SELECT 학번 FROM R2 WHERE 과목번호 = 'C100'`)이 'C100' 과목을 수강한 학생들의 학번 목록을 가져옵니다.  그리고 바깥쪽 `WHERE` 절의 `IN` 연산자는 이 목록에 있는 학번을 가진 학생들만 R1 테이블에서 선택하도록 합니다.  R2 테이블에서 과목번호 'C100'을 수강한 학생의 학번은 1000번과 3000번, 4000번입니다. 따라서 R1 테이블에서 이 학번에 해당하는 이름인 홍길동, 강남길, 오일자를 출력합니다.  따라서 정답은 2번입니다.  문제에서 오일자는 오말자로 잘못 기재되어 있으나, SQL문의 결과는 오일자를 출력합니다.",87,128
358,4,58,『회원』테이블 생성 후 『주소』 필드(컬럼)가 누락되어 이를 추가하려고 한다. 이에 적합한 SQL명령어는?,,DELETE,RESTORE,ALTER,ACCESS,3,"회원' 테이블이 이미 생성된 상태에서 '주소' 필드가 빠졌다는 것을 알게 되었습니다.  테이블을 새로 만드는 것이 아니라, 기존 테이블에 새로운 필드를 추가해야 합니다.  SQL 명령어 중에서 테이블 구조를 변경하는 명령어는 ALTER TABLE입니다.  DELETE는 데이터를 삭제하는 명령어이고, RESTORE는 백업 데이터를 복원하는 명령어이며, ACCESS는 데이터베이스에 접근하는 권한을 관리하는 명령어이므로 문제의 상황과 맞지 않습니다. 따라서 기존 테이블에 '주소' 필드를 추가하기 위해서는 ALTER TABLE 명령어를 사용해야 합니다. 예를 들어, '주소' 필드의 데이터 타입을 VARCHAR(100)으로 설정하려면  `ALTER TABLE 회원 ADD 주소 VARCHAR(100);` 와 같은 SQL 문을 사용합니다.",88,127
359,4,59,트랙잭션을 수행하는 도중 장애로 인해 손상된 데이터베이스를 손상되기 이전에 정상적인 상태로 복구시키는 작업은?,,Recovery,Commit,Abort,Restart,1,"데이터베이스 트랜잭션이란 여러 작업을 하나의 단위로 묶어서 처리하는 것을 말합니다.  예를 들어, 은행 계좌 이체를 생각해보면,  'A 계좌에서 돈을 빼고 B 계좌에 돈을 넣는' 작업이 하나의 트랜잭션입니다. 이 과정 중에 전기가 나가거나 시스템 오류가 발생하면 A 계좌에서만 돈이 빠져나가고 B 계좌에는 돈이 들어가지 않는 등 데이터가 불일치하게 될 수 있습니다.  'Recovery'는 바로 이러한 상황에서 트랜잭션이 수행되던 중 장애가 발생했을 때, 장애 발생 이전의 정상적인 데이터베이스 상태로 되돌리는 작업을 의미합니다.  데이터베이스 시스템은 이러한 상황을 대비하여 트랜잭션 로그(Transaction Log)라는 기록을 남기는데, 이 로그를 이용하여 데이터베이스를 이전의 안전한 상태로 복구하는 것입니다.  Commit은 트랜잭션이 성공적으로 완료되었음을 나타내고, Abort는 트랜잭션이 실패하여 취소되었음을 나타냅니다. Restart는 시스템 전체를 재시작하는 것을 의미하며, 문제 상황 해결에 직접적으로 도움이 되지는 않습니다. 따라서 트랜잭션 도중 장애로 인해 손상된 데이터베이스를 이전의 정상적인 상태로 복구하는 작업은 Recovery입니다.",85,127
360,4,60,E-R 다이어그램의 표기법으로 옳지 않은 것은?,,개체타입 - 사각형,속성 - 타원,관계집합 - 삼각형,개체타입과 속성을 연결 – 선,3,"E-R 다이어그램은 데이터베이스 설계에서 사용하는 도구로, 데이터베이스에 저장될 개체(Entity)와 그 개체들 간의 관계(Relationship)를 시각적으로 표현합니다.  문제에서 제시된 표기법 중 옳지 않은 것은 관계집합을 삼각형으로 표현하는 3번입니다.  E-R 다이어그램에서 개체 타입은 사각형, 속성은 타원으로 표현하고, 개체 타입과 속성은 선으로 연결하는 것이 일반적인 표기법입니다. 관계집합은 마름모 또는 다이아몬드 모양으로 표현합니다. 따라서 관계집합을 삼각형으로 표현하는 것은 잘못된 표기법입니다.  쉽게 말해,  E-R 다이어그램은 데이터베이스의 설계도와 같은 것인데,  그 설계도의 기호가 잘못 쓰인 것을 찾는 문제입니다.  삼각형은 관계집합을 나타내는 기호가 아니기 때문에 틀린 것입니다.",85,130
361,4,61,다음 중 응집도가 가장 높은 것은?,,절차적 응집도,순차적 응집도,우연적 응집도,논리적 응집도,2,"응집도는 모듈 내부 요소들의 관련성을 나타내는 척도입니다.  응집도가 높다는 것은 모듈 내부 요소들이 서로 밀접하게 관련되어 하나의 목적을 위해 함께 동작한다는 의미이며,  반대로 응집도가 낮다는 것은 모듈 내부 요소들이 서로 관련성이 적거나 아예 무관하다는 것을 의미합니다.  문제에서 제시된 응집도 종류들을 살펴보면, 순차적 응집도는 한 작업의 결과가 다음 작업의 입력으로 사용되는 등 순차적인 처리 과정을 갖는 경우를 말합니다.  이는 가장 높은 응집도를 나타냅니다.  절차적 응집도는 순차적 응집도보다 낮은 응집도로, 여러 작업이 순차적으로 수행되지만, 각 작업이 독립적인 경우입니다. 논리적 응집도는 여러 기능을 하나의 모듈로 묶었지만, 서로 관련성이 적은 경우이며, 우연적 응집도는 모듈 내 요소들이 아무런 관련성이 없는 경우로 가장 낮은 응집도를 나타냅니다. 따라서, 주어진 보기 중 가장 높은 응집도를 가진 것은 순차적 응집도(2번)입니다.",63,106
362,4,62,"OSI 7계층에서 물리적 연결을 이용해 신뢰성 있는 정보를 전송하려고 동기화, 오류제어, 흐름제어 등의 전송에러를 제어하는 계층은?",,데이터 링크 계층,물리 계층,응용 계층,표현 계층,1,"OSI 7계층은 네트워크 통신을 7개의 계층으로 나누어 각 계층이 특정 기능을 담당하도록 설계된 모델입니다.  물리 계층은 가장 하위 계층으로 케이블과 같은 물리적인 매체를 통해 데이터를 전송하는 역할을 합니다.  응용 계층은 사용자가 직접적으로 사용하는 계층이며, 표현 계층은 데이터의 형식을 변환하는 역할을 합니다.  데이터 링크 계층은 물리 계층 위에 위치하며, 물리적 연결을 이용하여 신뢰성 있는 데이터 전송을 보장합니다.  이를 위해 데이터 링크 계층에서는  데이터 전송의 동기화, 오류 제어(오류 검출 및 재전송), 흐름 제어(데이터 전송 속도 조절) 등의 기능을 수행하여 전송 에러를 최소화합니다.  따라서 물리적 연결을 이용해 신뢰성 있는 정보를 전송하고 전송 에러를 제어하는 계층은 데이터 링크 계층입니다.  쉽게 말해, 데이터 링크 계층은 물리 계층에서 전송된 데이터가 정확하게 목적지에 도착했는지 확인하고, 문제가 있으면 재전송하는 등의 역할을 수행하는 '택배 기사'와 같은 역할을 합니다.",71,145
363,4,63,운영체제를 기능에 따라 분류할 경우 제어 프로그램이 아닌 것은?,,데이터 관리 프로그램,서비스 프로그램,작업 제어 프로그램,감시 프로그램,2,"운영체제는 컴퓨터 시스템의 하드웨어와 응용 프로그램 사이에서 중개자 역할을 하는 소프트웨어입니다.  운영체제의 기능을 크게 제어 프로그램과 서비스 프로그램으로 나눌 수 있습니다.  제어 프로그램은 시스템 자원을 관리하고 시스템의 안정적인 동작을 유지하는 데 초점을 맞춥니다.  데이터 관리 프로그램, 작업 제어 프로그램, 감시 프로그램은 모두 시스템 자원을 효율적으로 관리하고 시스템의 안정성을 확보하는 데 기여하는 제어 프로그램의 예시입니다. 반면 서비스 프로그램은 사용자에게 직접적인 서비스를 제공하는 프로그램으로,  문제에서 제시된 보기 중 '서비스 프로그램'은 제어 프로그램이 아닌, 사용자에게 다양한 기능을 제공하는 프로그램을 의미합니다.  예를 들어, 프린터 드라이버, 네트워크 관리 프로그램 등이 서비스 프로그램에 해당합니다. 따라서 운영체제를 기능에 따라 분류할 때 제어 프로그램이 아닌 것은 서비스 프로그램입니다.",68,144
364,4,64,IEEE 802.3 LAN에서 사용되는 전송매체 접속제어(MAC) 방식은?,,CSMA/CD,Token Bus,Token Ring,Slotted Ring,1,"IEEE 802.3 LAN은 이더넷(Ethernet)을 정의하는 표준입니다.  이더넷은 여러 대의 컴퓨터가 하나의 네트워크에 연결되어 데이터를 주고받는 방식을 규정하는데,  여러 기기가 동시에 데이터를 전송하려 할 때 충돌이 발생할 수 있습니다.  CSMA/CD(Carrier Sense Multiple Access with Collision Detection)는 이러한 충돌을 감지하고 해결하는 접속 제어 방식입니다.  즉,  데이터를 전송하기 전에 네트워크 선로가 비어있는지 확인(Carrier Sense)하고,  만약 다른 기기가 데이터를 전송하고 있다면 기다렸다가 전송합니다.  만약 전송 중 충돌이 발생하면(Collision Detection), 충돌을 감지하고 일정 시간 후 다시 전송을 시도하는 방식입니다.  Token Bus나 Token Ring은 토큰이라는 특별한 신호를 사용하여 접속을 제어하는 방식으로,  IEEE 802.3(이더넷)에서는 사용되지 않습니다. Slotted Ring 역시 토큰 기반 방식의 하나입니다. 따라서 IEEE 802.3 LAN에서 사용되는 MAC 방식은 CSMA/CD입니다.",66,145
365,4,65,"기억공간이 15K, 23K, 22K, 21K 순으로 빈 공간이 있을 때 기억장치 배치 전력으로 “First Fit”을 사용하여 17K의 프로그램을 적재할 경우 내부단편화의 크기는 얼마인가?",,5K,6K,7K,8K,2,"First Fit 기억장치 배치 전략은 빈 공간 중 가장 먼저 발견되는 충분한 크기의 공간에 프로그램을 적재하는 방식입니다.  문제에서 17K의 프로그램을 적재해야 하고, 빈 공간은 15K, 23K, 22K, 21K 순서로 있습니다. First Fit 전략에 따라 가장 먼저 발견되는 17K 이상의 빈 공간은 23K입니다. 23K 공간에 17K 프로그램을 적재하면 남는 공간은 23K - 17K = 6K가 됩니다. 이 남는 6K 공간이 내부 단편화입니다. 따라서 17K 프로그램 적재 후 내부 단편화의 크기는 6K입니다. 정답은 2번입니다.",82,111
366,4,66,교착상태가 발생할 수 있는 조건이 아닌 것은?,,Mutual exclusion,Hold and wait,Non-preemption,Linear wait,4,"이 문제는 운영체제에서 다루는 교착상태(Deadlock)에 대한 이해를 묻는 문제입니다. 교착상태란 두 개 이상의 프로세스가 서로 상대방이 갖고 있는 자원을 기다리면서 영원히 진행되지 못하는 상황을 말합니다.  교착상태가 발생하기 위한 네 가지 필요충분조건(Coffman 조건)은 Mutual exclusion, Hold and wait, Non-preemption, Circular wait 입니다.  문제에서 묻고 있는 것은 교착상태 발생 조건이 *아닌 것*이므로,  네 가지 조건 중 하나가 빠지면 교착상태가 발생하지 않을 수 있습니다.  선택지 4번인 Linear wait는 순환 대기(Circular wait) 조건을 만족하지 않으므로 교착상태 발생 조건이 아닙니다.  Linear wait는 프로세스들이 자원을 요청하는 순서가 선형적으로 이루어져 순환적인 대기가 발생하지 않는 상황을 의미합니다.  나머지 Mutual exclusion(상호 배타), Hold and wait(점유 및 대기), Non-preemption(비선점)은 모두 교착상태 발생의 필요조건입니다.",60,144
367,4,67,IPv6에 대한 설명으로 틀린 것은?,,멀티캐스팅(Multicast) 대신 브로드캐스트(Broadcast)를 사용한다.,보안과 인증 확장 헤더를 사용함으로써 인터넷 계층의 보안기능을 강화하였다.,애니캐스트(Anycast)는 하나의 호스트에서 그룹 내의 가장 가까운 곳에 있는 수신자에게 전달하는 방식이다.,128비트 주소체계를 사용한다.,1,"IPv6는 인터넷 프로토콜 버전 6으로, 기존 IPv4의 주소 부족 문제를 해결하기 위해 개발된 차세대 인터넷 프로토콜입니다.  IPv4가 32비트 주소 체계를 사용하는 반면, IPv6는 128비트 주소 체계를 사용하여 훨씬 더 많은 주소를 제공합니다.  문제에서 틀린 것은 1번입니다. IPv6는 브로드캐스트를 지원하지 않고, 멀티캐스트를 사용합니다. 브로드캐스트는 네트워크 상의 모든 장치에 패킷을 전송하는 방식인데, IPv6에서는 보안 및 효율성 문제로 인해 제한적으로 사용되거나,  멀티캐스트로 대체됩니다. 멀티캐스트는 특정 그룹의 장치에만 패킷을 전송하는 방식으로, 브로드캐스트보다 효율적이고 보안성이 높습니다.  2번은 IPv6가 보안 확장 헤더를 통해 보안 기능을 강화한 것을 설명하고 있으며, 3번은 애니캐스트의 정확한 정의를 제시하고 있습니다. 4번은 IPv6의 128비트 주소 체계를 정확하게 설명하고 있습니다. 따라서 1번이 IPv6에 대한 잘못된 설명입니다.",77,145
368,4,68,TCP/IP 프로토콜에서 TCP가 해당하는 계층은?,,데이터 링크 계층,네트워크 계층,트랜스포트 계층,세션 계층,3,"TCP/IP 프로토콜은 네트워크 통신을 위한 표준 규약입니다.  마치 편지를 부치는 과정처럼, 데이터를 보내는 컴퓨터에서 받는 컴퓨터까지 데이터가 안전하게 전달되도록 여러 계층으로 나뉘어져 있습니다.  이 중 TCP(Transmission Control Protocol)는 데이터 전송의 신뢰성을 담당하는 계층인 트랜스포트 계층에 속합니다.  쉽게 말해, TCP는 데이터를 쪼개서 보내고, 순서대로 다시 조립하며, 데이터가 손상되었는지 확인하는 역할을 합니다.  데이터 링크 계층은 물리적인 네트워크 연결을, 네트워크 계층은 IP 주소를 이용한 경로 설정을, 세션 계층은 통신 세션 관리를 담당합니다. 따라서 TCP는 데이터의 안정적인 전송을 보장하는 트랜스포트 계층에 위치합니다. 정보처리기사 공식 교재에서는 TCP/IP 모델의 각 계층의 기능과 역할을 자세히 설명하고 있으며, TCP가 트랜스포트 계층에 속한다는 것을 명확히 제시하고 있습니다.",60,145
369,4,69,C언어에서 변수로 사용할 수 없는 것은?,,data02,int01,_sub,short,4,"C언어에서 변수를 선언할 때는 몇 가지 규칙을 따라야 합니다.  문제에서 제시된 옵션들을 살펴보면, `data02`, `int01`, `_sub`는 모두 C언어에서 허용되는 변수 이름의 형식입니다.  C언어 변수 이름은 영문자(대소문자 구분), 밑줄(_), 숫자로 구성될 수 있으며, 숫자로 시작할 수는 없습니다.  하지만 `short`는 자료형(데이터 타입)을 나타내는 키워드입니다.  변수를 선언할 때는 자료형을 먼저 적고 그 뒤에 변수 이름을 적어야 합니다. 예를 들어 `short num;` 과 같이 사용합니다. 따라서 `short` 자체는 변수가 될 수 없습니다.  정답은 4번입니다.",72,141
370,4,70,다음 JAVA 코드 출력문의 결과는?,https://www.cbtbank.kr/images/iz/iz20210307/iz20210307m70.gif,5 + 2 = 34<chal>5 + 2 = 34,5 + 2 + 3 + 4<chal>5 + 2 = 7,7 = 7<chal>7 + 7,5 + 2 = 34<chal>5 + 2 = 7,4,"JAVA는 문자열 연결 연산자 `+`를 사용합니다.  `System.out.println(""5 + 2 = "" + 3 + 4);` 에서는  ""+"" 연산자가 왼쪽에서 오른쪽으로 순차적으로 적용됩니다. 먼저 ""5 + 2 = "" 와 3이 문자열 연결 연산을 수행하여 ""5 + 2 = 3""이 되고,  다음으로 ""5 + 2 = 3"" 과 4가 문자열 연결 연산을 수행하여 최종적으로 ""5 + 2 = 34""가 출력됩니다.  반면에 `System.out.println(""5 + 2 = "" + (3 + 4));` 에서는 괄호 안의 `(3 + 4)`가 먼저 계산되어 7이 되고, 그 후 ""5 + 2 = "" 와 7이 문자열 연결 연산을 수행하여 ""5 + 2 = 7""이 출력됩니다. 따라서 두 println문의 출력 결과는 각각 ""5 + 2 = 34""와 ""5 + 2 = 7""이 됩니다.",79,141
371,4,71,C언어에서 문자열을 정수형으로 변환하는 라이브러리 함수는?,,atoi( ),atof( ),itoa( ),ceil( ),1,"C언어에서 문자열을 정수형으로 변환하는 함수는 `atoi()` 함수입니다.  `atoi()` 함수는 문자열(string)을 입력받아 해당 문자열을 정수(integer)로 변환하여 반환하는 역할을 합니다.  예를 들어, ""123""이라는 문자열을 `atoi()` 함수에 입력하면 123이라는 정수 값을 얻을 수 있습니다.  다른 선택지들은 각각 다른 기능을 합니다. `atof()`는 문자열을 부동소수점(실수)으로 변환하고, `itoa()`는 정수를 문자열로 변환하며, `ceil()`은 실수의 올림 값을 계산합니다. 따라서 문자열을 정수로 변환하는 목적에는 `atoi()` 함수가 가장 적합합니다.  정보처리기사 시험에서는 C언어의 기본적인 라이브러리 함수에 대한 이해를 묻는 문제가 자주 출제되므로, `atoi()`, `atof()`, `printf()`, `scanf()` 등의 함수의 기능과 사용법을 숙지하는 것이 중요합니다.",76,143
372,4,72,운영체제의 가상기억장치 관리에서 프로세스가 일정 시간동안 자주 참조하는 페이지들의 집합을 의미하는 것은?,,Locality,Deadlock,Thrashing,Working Set,4,"운영체제에서 가상기억장치는 실제 물리적인 메모리보다 더 큰 메모리 공간을 제공하는 기술입니다.  프로세스는 실행 중에 필요한 데이터와 명령어를 메모리에 적재하여 사용하는데,  메모리가 부족하면 가상기억장치가 활용됩니다.  이때, 프로세스가 특정 시간 동안 자주 접근하는 페이지들의 집합을  '작업 집합(Working Set)'이라고 합니다.  즉,  프로세스가 현재 작업을 수행하는 데 실제로 필요한 페이지들의 모임을 의미하며,  이 페이지들을 메모리에 유지함으로써 페이지 부재(페이지 폴트) 발생 횟수를 줄이고 시스템 성능을 향상시키는 데 중요한 역할을 합니다.  Locality는 메모리 참조의 지역성을 나타내는 개념이고, Deadlock은 교착상태, Thrashing은 쓰레싱(과도한 페이지 교체)을 의미합니다.",72,144
373,4,73,결합도가 낮은 것부터 높은 순으로 옳게 나열한 것은?,https://www.cbtbank.kr/images/iz/iz20210307/iz20210307m73.gif,(ㄱ) → (ㄴ) → (ㄹ) → (ㅂ) → (ㅁ) → (ㄷ),(ㄴ) → (ㄹ) → (ㅁ) → (ㅂ) → (ㄷ) → (ㄱ),(ㄴ) → (ㄹ) → (ㅂ) → (ㅁ) → (ㄷ) → (ㄱ),(ㄱ) → (ㄴ) → (ㄹ) → (ㅁ) → (ㅂ) → (ㄷ),3,"이 문제는 소프트웨어 공학에서 중요한 개념인 '결합도'의 종류를 이해하고, 그 강도를 비교하는 문제입니다. 결합도는 모듈 간의 상호 의존성을 나타내는 척도로, 결합도가 높을수록 모듈 간의 의존성이 강하고, 변경에 대한 영향이 커집니다.  낮은 결합도는 유지보수 및 재사용성에 유리합니다.  문제에서 제시된 결합도의 종류들을 낮은 결합도부터 높은 결합도 순서대로 정렬해야 합니다.",68,106
374,4,74,다음 설명의 ㉠과 ㉡에 들어갈 내용으로 옳은 것은?,https://www.cbtbank.kr/images/iz/iz20210307/iz20210307m74.gif,"㉠ : Paging, ㉡ : Segmentation","㉠ : Segmentation, ㉡ : Allocation","㉠ : Segmentation, ㉡ : Compaction","㉠ : Paging, ㉡ : Linking",1,"가상기억장치는 실제 물리적인 메모리보다 더 큰 메모리 공간을 사용하는 것처럼 보이도록 하는 기술입니다.  이를 구현하는 방법에는 크게 두 가지가 있는데,  하나는 프로그램을 고정된 크기의 블록(페이지)으로 나누어 관리하는 페이징(Paging) 기법이고, 다른 하나는 프로그램을 가변적인 크기의 블록(세그먼트)으로 나누어 관리하는 세그먼테이션(Segmentation) 기법입니다.  문제에서 ㉠과 ㉡에 각각 들어갈 내용을 묻고 있는데,  프로그램을 고정된 크기의 블록으로 나누는 기법은 페이징이고, 가변적인 크기의 블록으로 나누는 기법은 세그먼테이션이므로 정답은 1번입니다.  쉽게 말해, 페이징은 책을 일정한 크기의 장(페이지)으로 나누어 관리하는 것과 같고, 세그먼테이션은 책을 각 장의 크기가 다를 수 있도록(목차, 본문, 부록 등) 나누어 관리하는 것과 비슷합니다.",78,144
375,4,75,라이브러리의 개념과 구성에 대한 설명 중 틀린 것은?,,라이브러리란 필요할 때 찾아서 쓸 수 있도록 모듈화되어 제공되는 프로그램을 말한다.,"프로그래밍 언어에 따라 일반적으로 도움말, 설치 파일, 샘플 코드 등을 제공한다.","외부 라이브러리는 프로그래밍 언어가 기본적으로 가지고 있는 라이브러리를 의미하며, 표준 라이브러리는 별도의 파일 설치를 필요로 하는 라이브러리를 의미한다.","라이브러리는 모듈과 패키지를 총칭하며, 모듈이 개별 파일이라면 패키지는 파일들을 모아 놓은 폴더라고 볼 수 있다.",3,"문제에서 틀린 것은 3번입니다. 3번은 외부 라이브러리와 표준 라이브러리의 개념을 정반대로 설명하고 있습니다.  외부 라이브러리는 프로그램이 기본적으로 제공하지 않는 추가 기능을 제공하는 별도의 라이브러리이며,  표준 라이브러리는 프로그래밍 언어가 기본적으로 제공하는 라이브러리입니다.  즉, 외부 라이브러리는 별도의 설치가 필요하고, 표준 라이브러리는 별도의 설치 없이 사용할 수 있습니다.  1번과 4번은 라이브러리의 개념과 모듈, 패키지의 관계를 정확하게 설명하고 있으며, 2번은 일반적인 라이브러리의 구성 요소를 잘 나타내고 있습니다. 따라서 3번이 틀린 설명입니다.  정보처리기사 시험에서는 라이브러리의 개념과 종류를 정확하게 이해하는 것이 중요합니다.  프로그래밍 언어를 배우면서 다양한 라이브러리를 사용하게 되는데, 이 라이브러리들을 효율적으로 사용하기 위해서는 라이브러리의 개념과 구성에 대한 명확한 이해가 필요합니다.",84,143
376,4,76,C언어에서 산술 연산자가 아닌 것은?,,%,*,/,=,4,"C언어에서 산술 연산자는 덧셈(+), 뺄셈(-), 곱셈(*), 나눗셈(/), 나머지(%) 연산을 수행하는 연산자입니다.  문제에서 제시된 1번 %, 2번 *, 3번 / 는 모두 산술 연산자에 해당합니다.  반면 4번 = 는 대입 연산자로, 변수에 값을 할당하는 역할을 합니다.  산술 연산을 통해 값을 계산하는 것이 아니라, 값을 저장하는 연산이므로 산술 연산자가 아닙니다. 따라서 정답은 4번 = 입니다.",80,141
377,4,77,UDP 특성에 해당되는 것은?,,양방향 연결형 서비스를 제공한다.,송신중에 링크를 유지관리하므로 신뢰성이 높다.,"순서제어, 오류제어, 흐름제어 기능을 한다.",흐름제어나 순서제어가 없어 전송속도가 빠르다.,4,"UDP(User Datagram Protocol)는 TCP와 달리 연결을 미리 설정하지 않고 데이터를 패킷 단위로 전송하는 비연결형 프로토콜입니다.  TCP는 데이터 전송 전에 송신측과 수신측 간의 연결을 확립하고, 데이터 전송 후 연결을 해제하는 과정을 거치며, 순서대로 데이터를 전송하고 오류를 검출하여 재전송하는 등의 신뢰성 있는 전송을 보장합니다.  반면 UDP는 이러한 연결 설정 및 관리 과정이 없기 때문에 오버헤드가 적고 전송 속도가 빠릅니다.  하지만 데이터 전달의 신뢰성은 낮아 데이터 손실이나 순서 변경이 발생할 수 있습니다.  문제에서 제시된 1, 2, 3번 선택지는 TCP의 특징이며, 4번 선택지 ""흐름제어나 순서제어가 없어 전송속도가 빠르다""는 UDP의 가장 큰 특징을 잘 나타냅니다. 따라서 정답은 4번입니다.  UDP는 실시간성이 중요한 애플리케이션(예: 온라인 게임, VoIP)에 적합합니다.  데이터 손실이 허용되거나 재전송보다 빠른 전송이 중요한 경우 UDP를 사용하는 것이 효율적입니다.",75,145
378,4,78,JAVA에서 변수와 자료형에 대한 설명으로 틀린 것은?,,변수는 어떤 값을 주기억 장치에 기억하기 위해서 사용하는 공간이다.,변수의 자료형에 따라 저장할 수 있는 값의 종류와 범위가 달라진다.,char 자료형은 나열된 여러 개의 문자를 저장하고자 할 때 사용한다.,boolean 자료형은 조건이 참인지 거짓인지 판단하고자 할 때 사용한다.,3,"JAVA에서 변수는 값을 저장하는 메모리 공간을 의미합니다.  1번은 변수의 기본적인 역할을 정확하게 설명하고 있습니다. 2번 또한 자료형에 따라 저장 가능한 값의 종류(정수, 실수, 문자 등)와 크기(범위)가 다르다는 것을 올바르게 나타냅니다. 4번은 boolean 자료형이 참(true) 또는 거짓(false) 값을 저장하여 조건 판단에 사용됨을 정확히 설명합니다.  하지만 3번은 잘못되었습니다. char 자료형은 단 하나의 문자만 저장할 수 있습니다. 여러 개의 문자를 저장하려면 문자열을 나타내는 String 자료형이나 문자 배열(char[])을 사용해야 합니다. 따라서 틀린 것은 3번입니다.",75,141
379,4,79,다음은 파이썬으로 만들어진 반복문 코드이다. 이 코드의 결과는?,https://www.cbtbank.kr/images/iz/iz20210307/iz20210307m79.gif,"A, B, C 출력이 반복된다.","A, B, C 까지만 출력된다.","A, B, C, D 출력이 반복된다.","A, B, C, D 까지만 출력된다.",1,"이 파이썬 코드는 `while(True)` 루프를 사용하여 무한 루프를 만듭니다.  루프 안에서는 'A', 'B', 'C'를 차례로 출력하고 `continue`문을 만납니다. `continue`문은 현재 반복의 나머지 부분을 건너뛰고 다음 반복으로 넘어가도록 합니다. 따라서 'D'를 출력하는 `print('D')` 문은 실행되지 않습니다.  결과적으로 'A', 'B', 'C'가 무한히 반복 출력됩니다.  `while(True)`는 조건이 항상 참이므로 루프가 종료되지 않고 계속 실행됩니다.",70,141
380,4,80,WAS(Web Application Server)가 아닌 것은?,,JEUS,JVM,Tomcat,WebSphere,2,"이 문제는 웹 애플리케이션 서버(WAS)에 대한 이해도를 묻는 문제입니다. WAS는 웹 애플리케이션을 실행하고 관리하는 서버 소프트웨어입니다.  JEUS, Tomcat, WebSphere는 모두 대표적인 WAS의 예시입니다.  반면 JVM(Java Virtual Machine)은 자바 바이트코드를 실행하는 가상 머신으로, WAS가 동작하는 데 필요한 환경을 제공하지만 WAS 자체는 아닙니다.  WAS는 웹 애플리케이션을 실행하는 데 필요한 다양한 기능(웹 서버 기능, 애플리케이션 관리 기능 등)을 제공하는 반면, JVM은 자바 프로그램을 실행하는 데 필요한 환경만 제공합니다.  따라서 WAS가 아닌 것은 JVM입니다.  쉽게 말해, WAS는 집이고, JVM은 집 안에 있는 전기 시설과 같은 것입니다. 집이 없어도 전기 시설은 있을 수 있지만, 전기 시설만으로는 집의 기능을 할 수 없습니다.",66,138
381,4,81,다음 암호 알고리즘 중 성격이 다른 하나는?,,MD4,MD5,SHA-1,AES,4,"MD4, MD5, SHA-1은 모두 해시 함수 알고리즘입니다. 해시 함수는 임의 길이의 입력 데이터를 고정 길이의 해시 값으로 변환하는 일방향 함수입니다.  즉, 입력값을 알고 있더라도 해시값으로부터 원래 입력값을 복원할 수 없습니다.  이러한 특징 때문에 데이터 무결성 검증이나 디지털 서명 등에 사용됩니다.  반면 AES(Advanced Encryption Standard)는 대칭키 암호 알고리즘입니다. 대칭키 암호 알고리즘은 암호화와 복호화에 동일한 키를 사용하며, 데이터의 기밀성을 보장하는 데 사용됩니다. 따라서 다른 세 가지 알고리즘과는 목적과 기능이 다릅니다.  MD4, MD5, SHA-1은 데이터의 무결성을 검증하는 데 사용되지만, AES는 데이터를 암호화하여 기밀성을 유지하는 데 사용됩니다.  문제에서 묻는 것은 성격이 다른 하나이므로, 해시 함수인 MD4, MD5, SHA-1과 달리 암호화 알고리즘인 AES가 정답입니다.",71,154
382,4,82,"크래커가 침입하여 백도어를 만들어 놓거나, 설정파일을 변경했을 때 분석하는 도구는?",,tripwire,tcpdump,cron,netcat,1,"문제에서 제시된 상황은 크래커가 시스템에 침입하여 백도어를 생성하거나 설정 파일을 변경하는 등의 악의적인 행위를 했을 때 이를 분석하는 도구를 묻고 있습니다.  Tripwire는 시스템 파일의 무결성을 감시하는 도구입니다.  즉, 시스템의 파일들이 변경되었는지(크래커가 파일을 변경했는지)를 감시하고, 변경이 감지되면 관리자에게 알려줍니다.  따라서 크래커가 백도어를 만들거나 설정 파일을 변경했을 경우, Tripwire는 이러한 변경 사항을 감지하여 시스템의 이상 징후를 알려주는 역할을 합니다.  반면, tcpdump는 네트워크 패킷을 캡처하는 도구이고, cron은 시스템에서 주기적으로 작업을 실행하는 스케줄러이며, netcat은 네트워크 연결을 위한 유틸리티입니다. 이들은 시스템 파일의 무결성 변화를 직접 감지하지 못합니다. 따라서 크래커의 침입 흔적을 분석하는 데는 Tripwire가 가장 적합합니다.",73,156
383,4,83,다음 내용이 설명하는 것은?,https://www.cbtbank.kr/images/iz/iz20210307/iz20210307m83.gif,GRID,TELNET,GPN,MQTT,4,"문제에서 설명하는 것은 MQTT(Message Queuing Telemetry Transport)입니다. MQTT는 사물 인터넷(IoT) 환경에서 많이 사용되는 경량 메시지 전송 프로토콜입니다.  대역폭이 제한적인 환경(예:  센서 네트워크)에서 효율적으로 작동하도록 설계되었으며,  메시지 브로커(중개자)를 통해 송신자(Publisher)가 메시지를 발행(Publish)하고, 수신자(Subscriber)가 메시지를 구독(Subscribe)하는 방식으로 동작합니다.  IBM이 주도하여 개발되었다는 점도 특징입니다.  GRID, TELNET, GPN은 네트워크 관련 기술이지만, MQTT처럼 경량 메시징에 특화된 프로토콜은 아닙니다.  따라서 정답은 MQTT입니다.",68,145
384,4,84,나선형(Spiral) 모형의 주요 태스크에 해당되지 않는 것은?,,버전 관리,위험 분석,개발,평가,1,"나선형(Spiral) 모형은 소프트웨어 개발 과정에서 위험을 관리하고 점진적으로 개발하는 방법론입니다.  각 단계마다 계획, 위험 분석, 엔지니어링, 평가를 반복하며 진행합니다.  버전 관리는 소프트웨어 개발의 중요한 부분이지만, 나선형 모형의 *주요 태스크*는 아닙니다. 버전 관리는 각 단계의 결과물을 관리하는 활동이지, 나선형 모형 자체의 핵심적인 단계는 아니기 때문입니다.  나선형 모형의 핵심은 위험을 줄이면서 점진적으로 시스템을 개발하는 것이며, 이를 위해 위험 분석, 개발, 평가 단계가 반복적으로 수행됩니다.  버전 관리는 이러한 과정을 지원하는 부수적인 활동으로 볼 수 있습니다.",71,147
385,4,85,정보 보안을 위한 접근통제 정책 종류에 해당하지 않는 것은?,,임의적 접근 통제,데이터 전환 접근 통제,강제적 접근 통제,역할 기반 접근 통제,2,"정보 보안을 위한 접근 통제 정책은 시스템의 자원에 대한 접근을 제어하는 정책을 말합니다.  임의적 접근 통제는 소유자의 재량에 따라 접근 권한을 부여하는 방식이고, 강제적 접근 통제는 시스템 관리자가 미리 정의한 보안 정책에 따라 접근 권한을 부여하는 방식이며, 역할 기반 접근 통제는 사용자의 역할에 따라 접근 권한을 부여하는 방식입니다.  반면, '데이터 전환 접근 통제'라는 용어는 정보처리기사 공식 교재에서 다루는 일반적인 접근 통제 정책의 종류에는 해당하지 않습니다. 데이터 전환은 데이터의 형식이나 위치를 바꾸는 과정을 의미하며, 접근 통제와는 직접적인 관련이 없습니다. 따라서 정답은 2번입니다.",59,155
386,4,86,"LOC기법에 의하여 예측된 총 라인수가 36,000라인, 개발에 참여할 프로그래머가 6명, 프로그래머들의 평균 생산성이 월간 300라인일 때 개발에 소요되는 기간은?",,5개월,10개월,15개월,20개월,4,"문제에서 주어진 정보는 총 라인 수(36,000라인), 프로그래머 수(6명), 프로그래머 월별 생산성(300라인/명)입니다.  먼저 6명의 프로그래머가 한 달에 생산하는 총 라인 수를 구해봅시다. 6명 * 300라인/명 = 1800라인입니다.  총 36,000라인을 개발하려면 1800라인/월로 나누면 됩니다. 36,000라인 / 1800라인/월 = 20개월이 소요됩니다. 따라서 개발에 소요되는 기간은 20개월입니다.",88,147
387,4,87,"정형화된 분석 절차에 따라 사용자 요구사항을 파악, 문서화하는 체계적 분석방법으로 자료흐름도, 자료사전, 소단위명세서의 특징을 갖는 것은?",,구조적 개발 방법론,객체지향 개발 방법론,정보공학 방법론,CBD 방법론,1,"문제에서 제시된 ""정형화된 분석 절차에 따라 사용자 요구사항을 파악, 문서화하는 체계적 분석방법으로 자료흐름도, 자료사전, 소단위명세서의 특징을 갖는 것""은 구조적 개발 방법론을 의미합니다.  구조적 개발 방법론은 시스템을 여러 개의 작은 모듈로 나누어 계층적으로 설계하고, 각 모듈의 기능을 명확하게 정의하여 개발하는 방법론입니다. 자료흐름도는 시스템 내 데이터의 흐름을 시각적으로 표현하고, 자료사전은 데이터의 구조와 의미를 정의하며, 소단위명세서는 각 모듈의 기능을 상세하게 기술하는 문서입니다. 이러한 도구들은 사용자 요구사항을 정확하게 파악하고 문서화하는 데 효과적이며, 구조적 개발 방법론의 핵심적인 특징입니다.  객체지향 개발 방법론은 객체를 중심으로 시스템을 설계하는 반면, 구조적 개발 방법론은 데이터 흐름과 기능 분해에 초점을 맞춥니다. 정보공학 방법론은 데이터 모델링에 중점을 두고 있으며, CBD(Component-Based Development) 방법론은 기존의 구성요소를 재사용하는 데 중점을 둡니다. 따라서 자료흐름도, 자료사전, 소단위명세서를 사용하는 체계적인 분석 방법론은 구조적 개발 방법론이 가장 적합합니다.",61,102
388,4,88,정보보호를 위한 암호화에 대한 설명으로 틀린 것은?,,평문 – 암호화되기 전의 원본 메시지,암호문 – 암호화가 적용된 메시지,복호화 – 평문을 암호문으로 바꾸는 작업,키(Key) - 적절한 암호화를 위하여 사용하는 값,3,"암호화는 평문(원본 메시지)을 암호문(해독하기 어려운 형태로 변환된 메시지)으로 바꾸는 과정입니다.  복호화는 반대로 암호문을 다시 평문으로 바꾸는 작업이죠.  문제에서 3번은 ""복호화 – 평문을 암호문으로 바꾸는 작업""이라고 되어 있는데, 이는 복호화의 정의와 반대입니다. 복호화는 암호문을 평문으로 바꾸는 것이지, 평문을 암호문으로 바꾸는 것이 아니기 때문에 틀린 설명입니다.  키(Key)는 암호화와 복호화 과정에서 사용되는 비밀 값으로,  적절한 키를 사용해야 안전하게 암호화 및 복호화를 할 수 있습니다.",84,154
389,4,89,다음 내용이 설명하는 것은?,https://www.cbtbank.kr/images/iz/iz20210307/iz20210307m89.gif,OTT,Baas,SDDC,Wi-SUN,2,"문제에서 설명하는 것은 BaaS(Blockchain as a Service)입니다.  BaaS는 블록체인 기술을 클라우드 기반으로 서비스하는 것을 의미합니다.  마치 클라우드에서 데이터베이스를 서비스 받듯이, 블록체인 네트워크를 직접 구축하고 관리할 필요 없이 클라우드 제공업체가 제공하는 플랫폼을 통해 블록체인 기반 애플리케이션을 개발하고 운영할 수 있습니다.  따라서 노드 추가 및 제거가 용이하고, 블록체인의 기본 인프라를 추상화하여 개발자가 블록체인 기술의 복잡성에 얽매이지 않고 응용 프로그램 개발에 집중할 수 있도록 지원하는 것이 특징입니다.  OTT는 온라인 동영상 서비스, SDDC는 소프트웨어 정의 데이터센터, Wi-SUN은 저전력 광역 통신 기술을 의미하므로 문제의 설명과는 관련이 없습니다.",69,138
390,4,90,"소프트웨어 비용 산정 기법 중 개발 유형으로 organic, semi-detach, embedded로 구분되는 것은?",,PUTNAM,COCOMO,FP,SLIM,2,"소프트웨어 비용 산정 기법 중 COCOMO(Constructive Cost Model) 모델은 소프트웨어 개발 규모를 Organic, Semi-detached, Embedded 세 가지 유형으로 나누어 비용을 산정하는 기법입니다.  Organic 유형은 소규모 개발팀이 잘 이해하는 프로젝트, Semi-detached 유형은 중간 규모의 프로젝트, Embedded 유형은 하드웨어와 밀접하게 연관된 복잡한 프로젝트를 의미합니다. 각 유형에 따라 개발 노력, 개발 기간, 비용 등을 다르게 추정하여 더욱 정확한 비용 산정을 가능하게 합니다.  문제에서 제시된 다른 선택지들은 다른 소프트웨어 비용 산정 기법들을 나타냅니다.  PUTNAM은 개발 기간과 노력을 예측하는 모델이고, FP(Function Point)는 기능 점수를 기반으로 비용을 산정하며, SLIM은 소프트웨어 개발 프로젝트의 위험을 관리하는 데 초점을 맞춘 모델입니다. 따라서, Organic, Semi-detached, Embedded 유형으로 개발 유형을 구분하는 소프트웨어 비용 산정 기법은 COCOMO입니다.",83,147
391,4,91,다음 LAN의 네트워크 토폴로지는 어떤 형인가?,https://www.cbtbank.kr/images/iz/iz20210307/iz20210307m91.gif,그물형,십자형,버스형,링형,3,"그림에서 보이는 네트워크 토폴로지는 모든 스테이션이 하나의 통신선(버스)에 연결되어 있는 형태입니다.  데이터는 이 버스를 통해 모든 스테이션으로 전송되며, 한 스테이션이 데이터를 전송하면 다른 모든 스테이션은 그 데이터를 수신하게 됩니다. 이러한 구조는 버스형 토폴로지의 특징입니다.  그물형은 여러 경로를 통해 데이터가 전송되는 형태이고, 십자형은 버스형의 변형으로 교차점이 있는 형태, 링형은 데이터가 링 형태로 순환하는 형태이므로 그림과 일치하지 않습니다. 따라서 정답은 3번 버스형입니다.",88,145
392,4,92,"전기 및 정보통신기술을 활용하여 전력망을 지능화, 고도화함으로써 고품질의 전력서비스를 제공하고 에너지 이용효율을 극대화하는 전력망은?",,사물 인터넷,스마트 그리드,디지털 아카이빙,미디어 빅뱅,2,"스마트 그리드는 전력망에 정보통신기술(ICT)을 접목하여 전력 생산, 송전, 배전, 소비 전 과정을 지능적으로 관리하는 시스템입니다.  사물 인터넷(IoT) 기술을 활용하여 전력망의 각 구성 요소(발전소, 변전소, 송전선로, 스마트미터 등)를 실시간으로 모니터링하고 제어하여 전력 수요와 공급을 효율적으로 관리함으로써 전력 품질을 향상시키고 에너지 효율을 극대화하는 것을 목표로 합니다.  즉, 전기 및 정보통신기술을 활용하여 전력망을 지능화, 고도화하여 고품질의 전력 서비스를 제공하고 에너지 이용 효율을 극대화하는 전력망이 바로 스마트 그리드입니다.  다른 선택지는 전력망과 직접적인 관련이 없습니다. 사물 인터넷은 스마트 그리드의 구성 요소 중 하나일 뿐이며, 디지털 아카이빙과 미디어 빅뱅은 전혀 다른 분야의 개념입니다.",75,149
393,4,93,다음 내용이 설명하는 소프트웨어 개발 모형은?,https://www.cbtbank.kr/images/iz/iz20210307/iz20210307m93.gif,프로토타입 모형,나선형 모형,폭포수 모형,RAD 모형,3,"문제에서 설명하는 소프트웨어 개발 모형은 폭포수 모형(Waterfall Model)입니다.  폭포수 모형은 소프트웨어 개발 과정을 여러 단계로 나누어 순차적으로 진행하는 전통적인 방법론입니다.  마치 폭포수가 위에서 아래로 흐르듯이, 각 단계가 완료되어야만 다음 단계로 진행할 수 있습니다.  문제에서 언급된 '타당성 검토, 계획, 요구사항 분석, 설계, 구현, 테스트, 유지보수' 단계들은 폭포수 모형의 전형적인 단계들을 보여줍니다.  각 단계는 명확하게 구분되며, 이전 단계로 돌아가는 것은 제한적입니다.  따라서, 문제의 설명과 일치하는 소프트웨어 개발 모형은 폭포수 모형입니다. 다른 모형들은 반복적인 개발이나 병렬적인 개발을 특징으로 하기 때문에 문제의 설명과 부합하지 않습니다.",81,147
394,4,94,스트림 암호화 방식의 설명으로 옳지 않은 것은?,,비트/바이트/단어들을 순차적으로 암호화한다.,해쉬 함수를 이용한 해쉬 암호화 방식을 사용한다.,RC4는 스트림 암호화 방식에 해당한다.,대칭키 암호화 방식이다.,2,"스트림 암호화 방식은 데이터를 비트, 바이트 또는 단어 단위로 순차적으로 암호화하는 방식입니다.  마치 물줄기(스트림)처럼 데이터가 끊임없이 암호화되는 것이죠.  RC4처럼 대칭키 암호화 방식을 사용하는 것이 특징입니다.  대칭키 암호화는 암호화와 복호화에 같은 키를 사용하는 방식입니다.  하지만, 해쉬 함수는 데이터의 무결성을 검증하거나 데이터를 요약하는 데 사용되는 일방향 함수이지, 스트림처럼 순차적으로 데이터를 암호화하는 데 사용되지 않습니다. 따라서 2번이 옳지 않은 설명입니다.",48,154
395,4,95,세션 하이재킹을 탐지하는 방법으로 거리가 먼 것은?,,FTP SYN SEGNENT 탐지,비동기화 상태 탐지,ACK STORM 탐지,패킷의 유실 및 재전송 증가 탐지,1,"세션 하이재킹은 다른 사용자의 세션을 가로채는 공격입니다.  정상적인 사용자의 세션 ID를 탈취하여 마치 그 사용자인 것처럼 시스템에 접근하는 것입니다.  문제에서 제시된 탐지 방법들을 살펴보면, 비동기화 상태, ACK STORM, 패킷의 유실 및 재전송 증가는 모두 네트워크 통신의 이상 현상으로 세션 하이재킹과 같은 공격을 탐지하는 데 사용될 수 있습니다.  비동기화 상태는 정상적인 통신 순서가 깨진 것을, ACK STORM은 과도한 ACK 패킷이 발생하는 것을, 패킷 유실 및 재전송 증가는 통신의 불안정성을 나타냅니다. 이러한 현상들은 세션 하이재킹 공격 시 발생할 가능성이 높습니다. 반면, FTP SYN SEGMENT 탐지는 FTP 프로토콜의 특정 부분을 분석하는 것으로, 세션 하이재킹 자체를 직접적으로 탐지하는 방법은 아닙니다.  FTP는 세션 하이재킹의 대상이 될 수 있지만, FTP SYN 세그먼트만으로 세션 하이재킹을 탐지하는 것은 불충분합니다. 따라서 FTP SYN SEGMENT 탐지는 세션 하이재킹 탐지 방법으로 적절하지 않습니다.",41,153
396,4,96,소프트웨어공학에 대한 설명으로 거리가 먼 것은?,,"소프트웨어공학이란 소프트웨어의 개발, 운용, 유지보수 및 파기에 대한 체계적인 접근 방법이다.",소프트웨어공학은 소프트웨어 제품의 품질을 향상시키고 소프트웨어 생산성과 작업 만족도를 증대시키는 것이 목적이다.,소프트웨어공학의 궁극적 목표는 최대의 비용으로 계획된 일정보다 가능한 빠른 시일 내에 소프트웨어를 개발하는 것이다.,소프트웨어공학은 신뢰성 있는 소프트웨어를 경제적인 비용으로 획득하기 위해 공학적 원리를 정립하고 이를 이용하는 것이다.,3,"문제에서 제시된 1, 2, 4번 보기는 모두 소프트웨어공학의 목표와 정의를 올바르게 설명하고 있습니다.  소프트웨어공학은 소프트웨어 개발 과정 전반에 걸쳐 체계적인 접근 방식을 적용하여 품질 향상, 생산성 증대, 비용 절감을 추구하는 학문 분야입니다.  하지만 3번 보기는 ""최대의 비용으로 계획된 일정보다 가능한 빠른 시일 내에 소프트웨어를 개발하는 것""을 목표로 제시하고 있는데, 이는 소프트웨어공학의 기본 원리에 어긋납니다. 소프트웨어공학은 효율적인 비용으로, 계획된 일정 내에, 그리고 무엇보다도 품질 높은 소프트웨어를 개발하는 것을 목표로 합니다.  따라서 최대의 비용을 들이는 것은 소프트웨어공학의 목표와 상반되는 개념입니다.",87,147
397,4,97,소프트웨어 개발 방법론 중 CBD(Component Based Development)에 대한 설명으로 틀린 것은?,,"생산성과 품질을 높이고, 유지보수 비용을 최소화할 수 있다.",컴포넌트 제작 기법을 통해 재사용성을 향상시킨다.,모듈의 분할과 정복에 의한 하향식 설계방식이다.,독립적인 컴포넌트 단위의 관리로 복잡성을 최소화할 수 있다.,3,"CBD(Component Based Development)는 컴포넌트 기반 개발 방법론입니다.  미리 만들어 놓은 소프트웨어 컴포넌트(부품)들을 조립하듯이 연결하여 새로운 소프트웨어 시스템을 만드는 방식이죠.  마치 레고 블록을 조립하는 것과 비슷하다고 생각하면 이해하기 쉽습니다.  각 컴포넌트는 독립적으로 개발되고, 테스트되며, 재사용이 가능하다는 장점이 있습니다.  따라서 생산성과 품질 향상, 유지보수 비용 절감에 효과적입니다.  컴포넌트 단위로 관리하기 때문에 시스템의 복잡성도 줄일 수 있습니다. 하지만 CBD는 하향식 설계 방식이라고 단정 지을 수 없습니다.  하향식 설계는 전체 시스템을 먼저 설계하고, 점차 세부적인 부분으로 나누는 방식인데, CBD는 이미 만들어진 컴포넌트들을 조합하는 방식이므로, 상향식 설계 또는 혼합적인 접근 방식을 사용할 수도 있습니다. 따라서 3번 선택지가 틀린 설명입니다.",81,147
398,4,98,정보 보안의 3요소에 해당하지 않는 것은?,,기밀성,무결성,가용성,휘발성,4,"정보 보안의 3요소는 기밀성, 무결성, 가용성입니다.  기밀성은 정보에 대한 접근을 허가된 사용자에게만 허용하는 것을 의미하고, 무결성은 정보의 정확성과 신뢰성을 유지하는 것을 의미하며, 가용성은 정보가 필요한 사용자에게 언제든지 이용 가능하도록 하는 것을 의미합니다.  문제에서 제시된 휘발성은 정보가 전원이 꺼지면 사라지는 성질을 의미하는데, 이는 정보 보안의 핵심 요소와는 관련이 없습니다. 따라서 정보 보안의 3요소에 해당하지 않는 것은 휘발성입니다. 정보처리기사 시험에서는 정보보안의 기본 개념을 숙지하는 것이 중요하며,  기밀성, 무결성, 가용성의 개념을 정확하게 이해하고 있어야 합니다.",86,153
399,4,99,"소셜 네트워크에서 악의적인 사용자가 지인 또는 특정 유명인으로 가장하여 활동하는 공격 기법은?(문제 오류로 가답안 발표시 1번으로 발표되었지만 확정답안 발표시 1, 2번이 정답처리 되었습니다. 여기서는 가답안인 1번을 누르시면 정답 처리 됩니다.)",,Evil Twin Attack,Phishing,Logic Bomb,Cyberbullying,1,"이 문제는 소셜 네트워크에서 발생하는 악의적인 행위에 대한 이해를 묻고 있습니다.  Evil Twin Attack은 악의적인 사용자가 자신을 지인이나 특정 유명인으로 가장하여 다른 사용자를 속이는 공격 기법입니다.  가령,  A라는 유명인의 계정을 사칭하여 B라는 사용자에게 접근하여 개인정보를 빼내거나 악성코드를 유포하는 등의 행위를 할 수 있습니다.  Phishing은 악의적인 목적으로 이메일이나 메시지를 통해 개인정보를 빼내는 공격 기법이고, Logic Bomb은 특정 조건이 충족될 때 시스템에 손상을 입히는 악성코드이며, Cyberbullying은 사이버상에서의 괴롭힘을 의미합니다.  문제에서 제시된 상황, 즉 지인이나 특정 유명인으로 가장하여 활동하는 공격 기법에 가장 적합한 것은 Evil Twin Attack입니다.  다른 선택지는 공격 목표나 수법이 다릅니다.",80,155
400,4,100,공개키 암호에 대한 설명으로 틀린 것은?,,10명이 공개키 암호를 사용할 경우 5개의 키가 필요하다.,복호화키는 비공개 되어 있다.,송신자는 수신자의 공개키로 문서를 암호화한다.,공개키 암호로 널리 알려진 알고리즘은 RSA가 있다.,1,"공개키 암호는 두 개의 키, 즉 공개키와 비밀키(개인키)를 사용하는 암호 방식입니다.  공개키는 누구에게나 공개해도 되지만, 비밀키는 자신만 알고 있어야 합니다.  문서를 암호화할 때는 상대방의 공개키를 사용하고, 복호화할 때는 자신의 비밀키를 사용합니다.  문제에서 1번은 10명이 서로 통신하려면 각자 공개키와 비밀키를 하나씩 가지므로 총 20개의 키가 필요하다는 것을 의미합니다. 5개의 키만으로는 10명 모두 안전하게 통신할 수 없습니다.  2번은 공개키 암호의 기본 원리이며, 3번은 송신자가 수신자의 공개키로 문서를 암호화하는 것이 공개키 암호의 핵심적인 과정입니다. 4번은 RSA 알고리즘이 대표적인 공개키 암호 알고리즘이라는 사실을 나타냅니다. 따라서 1번이 틀린 설명입니다.",74,154
401,5,1,시스템의 구성요소로 볼 수 없는 것은?,,Process,Feedback,Maintenance,Control,3,"시스템의 구성요소는 시스템을 이루는 기본적인 요소들을 말합니다.  문제에서 제시된 1번 Process(프로세스), 2번 Feedback(피드백), 4번 Control(제어)은 모두 시스템의 작동과 관련된 중요한 요소입니다. 프로세스는 시스템 내에서 수행되는 작업 단위이고, 피드백은 시스템의 출력 결과를 다시 입력으로 사용하여 시스템의 동작을 조정하는 과정이며, 제어는 시스템의 동작을 감시하고 조절하는 기능입니다.  반면, 3번 Maintenance(유지보수)는 시스템이 이미 구축된 후에 시스템의 성능을 유지하고 문제를 해결하기 위해 수행하는 활동입니다.  시스템의 *구성* 요소라기보다는 시스템 *운영*의 한 측면이라고 볼 수 있죠.  따라서 시스템을 구성하는 기본적인 요소로 보기는 어렵습니다.  마치 자동차의 구성요소가 엔진, 바퀴, 섀시 등인데, 정비(유지보수)는 자동차를 운행하는 데 필요한 활동이지만 자동차 자체의 구성요소는 아닌 것과 같습니다.",67,100
402,5,2,유스케이스(Usecase)에 대한 설명 중 옳은 것은?,,유스케이스 다이어그램은 개발자의 요구를 추출하고 분석하기 위해 주로 사용한다.,액터는 대상 시스템과 상호 작용하는 사람이나 다른 시스템에 의한 역할이다.,사용자 액터는 본 시스템과 데이터를 주고받는 연동 시스템을 의미한다.,연동의 개념은 일방적으로 데이터를 파일이나 정해진 형식으로 넘겨주는 것을 의미한다.,2,"유스케이스(Use Case)는 시스템이 사용자 또는 다른 시스템과 어떻게 상호 작용하는지를 설명하는 하나의 시나리오입니다.  쉽게 말해, 시스템을 사용하는 사람(또는 다른 시스템)이 어떤 목적을 달성하기 위해 시스템과 어떤 단계를 거치는지 보여주는 일종의 '사용 설명서'와 같은 것입니다.  문제에서 옳은 것은 2번입니다. 2번은 액터(Actor)에 대한 설명인데, 액터는 시스템과 상호작용하는 주체를 의미하며, 사람일 수도 있고 다른 시스템일 수도 있습니다.  1번은 유스케이스 다이어그램의 용도를 잘못 설명하고 있습니다. 개발자의 요구를 추출하는 데 사용되기는 하지만, 그 외에도 사용자의 요구사항을 분석하고 시스템의 기능을 명확히 하는 데에도 중요한 역할을 합니다. 3번은 사용자 액터를 잘못 정의하고 있으며, 4번은 연동의 개념을 지나치게 단순화하여 설명하고 있습니다. 따라서 정답은 2번입니다.",63,102
403,5,3,요구사항 개발 프로세스의 순서로 옳은 것은?,https://www.cbtbank.kr/images/iz/iz20210515/iz20210515m3.gif,㉠ - ㉡ - ㉢ - ㉣,㉠ - ㉢ - ㉡ - ㉣,㉠ - ㉣ - ㉡ - ㉢,㉠ - ㉡ - ㉣ - ㉢,1,"요구사항 개발 프로세스는 사용자의 요구를 정확하게 파악하고 시스템에 반영하는 과정입니다.  먼저 사용자로부터 요구사항을 도출(Elicitation)하고, 그 요구사항을 분석(Analysis)하여 시스템에 필요한 기능과 성능을 명확히 합니다.  분석된 요구사항을 명세(Specification)로 정리하여 시스템 개발팀과 사용자 간의 오해를 방지하고, 마지막으로 명세된 요구사항이 사용자의 요구를 정확하게 반영하는지 확인(Validation)하는 단계를 거칩니다. 따라서, 요구사항 개발 프로세스의 올바른 순서는 도출 → 분석 → 명세 → 확인 입니다.  문제에서 제시된 1번 답변 (㉠ - ㉡ - ㉢ - ㉣)이 바로 이 순서를 따르고 있습니다.",80,102
404,5,4,객체지향 기법에서 같은 클래스에 속한 각각의 객체를 의미하는 것은?,,instance,message,method,module,1,"객체지향 기법은 현실 세계의 개념을 컴퓨터 프로그램으로 모델링하는 방법입니다.  클래스는 객체의 설계도와 같다고 생각하면 됩니다.  예를 들어 ""자동차""라는 클래스가 있다면,  ""빨간색 자동차"", ""파란색 자동차"", ""검은색 자동차"" 등이 각각의 객체(instance)가 됩니다.  즉, 클래스는 객체를 만드는 틀이고, 객체는 그 틀을 이용하여 실제로 만들어진 개별적인 존재입니다.  문제에서 묻는 것은 같은 클래스(자동차)에서 만들어진 각각의 개별적인 자동차(빨간색, 파란색, 검은색 등)를 의미하는 용어이며, 이것이 바로 instance입니다. message는 객체 간의 통신, method는 객체가 수행하는 동작, module은 프로그램의 구성 요소를 의미합니다.",77,107
405,5,5,"객체지향 설계에서 객체가 가지고 있는 속성과 오퍼레이션의 일부를 감추어서 객체의 외부에서는 접근이 불가능하게 하는 개념은? (문제 오류로 가답안 발표시 3번으로 발표되었지만 확정 답안 발표시 2, 3번이 정답처리 되었습니다. 여기서는 가답안인 3번을 누르면 정답 처리 됩니다.)",,조직화(Organizing),캡슐화(Encapsulation),정보은닉(Infomation Hiding),구조화(Structuralization),3,"객체지향 설계에서 객체는 속성(데이터)과 오퍼레이션(동작)으로 구성됩니다.  정보은닉(Information Hiding) 또는 캡슐화(Encapsulation)는 객체의 내부 구현(속성과 오퍼레이션의 일부)을 외부에서 직접 접근하지 못하도록 감추는 개념입니다.  마치 컴퓨터의 내부 부품을 직접 만지지 않고, 외부 케이스와 버튼만을 통해 조작하는 것과 같습니다.  외부에서 객체의 속성을 직접 변경하거나 오퍼레이션의 내부 동작 방식을 알 필요 없이, 제공된 인터페이스(메서드)를 통해서만 객체와 상호작용할 수 있도록 함으로써, 객체의 내부 구현 변경에 따른 외부 시스템의 영향을 최소화하고, 시스템의 안정성과 유지보수성을 높이는 데 중요한 역할을 합니다.  정보은닉과 캡슐화는 매우 유사한 개념으로, 정보은닉이 캡슐화의 한 측면으로 볼 수 있습니다.  문제에서 가답안으로 3번(정보은닉)이 제시되었고, 최종적으로 2번(캡슐화)과 3번이 모두 정답으로 처리되었다는 점을 고려하면, 두 개념의 밀접한 관계를 이해하는 것이 중요합니다.",88,107
406,5,6,GoF (Gangs of Four) 디자인 패턴에 대한 설명으로 틀린 것은?,,"factory method pattern은 상위클래스에서 객체를 생성하는 인터페이스를 정의하고, 하위클래스에서 인스턴스를 생성하도록 하는 방식이다.",prototype pattern은 prototype을 먼저 생성하고 인스턴스를 복제하여 사용하는 구조이다.,bridge pattern은 기존에 구현되어 있는 클래스에 기능 발생 시 기존 클래스를 재사용할 수 있도록 중간에서 맞춰주는 역할을 한다.,mediator pattern은 객체간의 통제와 지시의 역할을 하는 중재자를 두어 객체지향의 목표를 달성하게 해준다.,3,"GoF 디자인 패턴 중 Bridge 패턴은 추상화와 구현을 분리하여 각각 독립적으로 변화시킬 수 있도록 하는 패턴입니다.  문제에서 설명하는 것처럼 기존 클래스를 재사용하는 데 초점을 맞춘 것이 아니라,  추상화된 인터페이스와 구현 클래스를 분리하여 서로 다른 구현을 쉽게 교체하고 확장할 수 있도록 하는 데 목적이 있습니다.  따라서 3번 설명은 Bridge 패턴의 핵심 개념을 잘못 이해하고 있는 것입니다.  Factory Method는 상위 클래스에서 객체 생성 방식을 정의하고 하위 클래스에서 실제 객체를 생성하는 방식이며, Prototype은 기존 객체를 복제하여 새로운 객체를 생성하는 방식, Mediator는 여러 객체 간의 상호작용을 중재하는 객체를 두어 복잡성을 줄이는 패턴입니다.  3번은 이러한 패턴들의 특징을 제대로 반영하지 못하고 있습니다.",59,107
407,5,7,요구사항 분석이 어려운 이유가 아닌 것은?,,개발자와 사용자 간의 지식이나 표현의 차이가 커서 상호 이해가 쉽지 않다.,사용자의 요구는 예외가 거의 없어 열거와 구조화가 어렵지 않다.,사용자의 요구사항이 모호하고 불명확하다.,소프트웨어 개발 과정 중에 요구사항이 계속 변할 수 있다.,2,"요구사항 분석이 어려운 이유를 묻는 문제입니다.  선택지 1, 3, 4는 모두 요구사항 분석의 어려움을 잘 나타내는 예시입니다. 개발자와 사용자 간의 의사소통 문제(1), 모호하고 불명확한 요구사항(3), 그리고 개발 과정 중 변하는 요구사항(4)은 모두 요구사항 분석을 어렵게 만드는 요인입니다.  반면, 선택지 2는 사용자의 요구사항에 예외가 거의 없다는 것을 전제로 하므로, 오히려 요구사항 분석을 쉽게 만드는 조건입니다.  예외가 없다면, 요구사항을 체계적으로 정리하고 구조화하는 것이 용이하기 때문입니다. 따라서 요구사항 분석이 어렵지 않은 이유는 2번입니다.",89,102
408,5,8,소프트웨어 아키텍처 설계에서 시스템 품질속성이 아닌 것은?,,가용성 (Availability),독립성 (Isolation),변경 용이성 (Modifiability),사용성(Usability),2,"소프트웨어 아키텍처 설계에서 시스템의 품질 속성은 사용자에게 제공되는 시스템의 성능과 관련된 특징들을 의미합니다.  가용성(Availability)은 시스템이 필요할 때 사용 가능한 정도를 나타내고, 변경 용이성(Modifiability)은 시스템을 변경하거나 업데이트하기 쉬운 정도를 나타내며, 사용성(Usability)은 사용자가 시스템을 얼마나 쉽고 효율적으로 사용할 수 있는지를 나타냅니다.  반면 독립성(Isolation)은 시스템 구성 요소 간의 상호 의존성을 낮추는 개념으로, 시스템의 품질 속성보다는 시스템 설계의 원칙이나 전략에 더 가깝습니다.  독립성이 높으면 시스템의 특정 부분을 변경하거나 업데이트할 때 다른 부분에 영향을 미치는 것을 최소화할 수 있지만,  그 자체가 직접적으로 사용자에게 보이는 시스템의 품질 특성은 아니기 때문에 정답이 2번인 것입니다.  즉, 독립성은 좋은 시스템을 만들기 위한 설계 원칙이지, 사용자에게 직접적으로 체감되는 품질 속성은 아닙니다.",60,106
409,5,9,다음 설명에 해당하는 시스템으로 옳은 것은?,https://www.cbtbank.kr/images/iz/iz20210515/iz20210515m9.gif,연계 서버,중계 서버,송신 시스템,수신 시스템,3,"문제에서 설명하는 시스템은 데이터베이스나 애플리케이션으로부터 데이터를 가져와서 다른 시스템으로 보내는 역할을 합니다.  마치 우체국처럼 데이터를 받아서 목적지로 배달하는 것이죠.  1번 연계 서버는 여러 시스템을 연결하는 역할이지만, 데이터를 생성하고 송신하는 기능까지 명시적으로 언급하지 않습니다. 2번 중계 서버는 데이터를 중간에서 전달하는 역할이지만, 데이터 생성 부분은 포함하지 않습니다. 4번 수신 시스템은 데이터를 받는 시스템이지, 데이터를 생성하고 송신하는 시스템이 아닙니다. 따라서 데이터를 생성하고 송신하는 기능을 명확히 가지고 있는 3번 송신 시스템이 가장 적절한 답입니다.",78,109
410,5,10,CASE(Computer-Aided Software Engineering)의 원천 기술이 아닌 것은?,,구조적 기법,프로토타이핑 기술,정보 저장소 기술,일괄처리 기술,4,"CASE(Computer-Aided Software Engineering)는 소프트웨어 개발 과정을 자동화하고 효율성을 높이기 위한 도구와 기법들을 통칭합니다.  구조적 기법은 소프트웨어를 모듈화하고 계층적으로 설계하는 방법론으로 CASE의 핵심 원천 기술입니다. 프로토타이핑 기술은 초기 단계에서 시스템의 모형을 만들어 사용자 피드백을 받아 개발 방향을 수정하는 기법으로 CASE에서 중요한 역할을 합니다. 정보 저장소 기술은 소프트웨어 개발 과정에서 생성되는 다양한 정보(요구사항, 설계 문서, 코드 등)를 효율적으로 관리하고 재사용하기 위한 기술이며, CASE 도구의 기반이 됩니다. 반면 일괄처리 기술은 특정 시점에 일정량의 데이터를 한꺼번에 처리하는 방식으로, 소프트웨어 개발 과정 전반에 걸쳐 사용되는 기술이 아니며 CASE의 원천 기술이라고 보기 어렵습니다.  CASE는 소프트웨어 개발의 전 과정을 지원하는 것이 목표이기 때문에, 특정 시점의 일괄 처리보다는 지속적인 개발 및 관리를 위한 다양한 기술들을 필요로 합니다. 따라서 일괄처리 기술은 CASE의 원천 기술이라고 할 수 없습니다.",57,102
411,5,11,객체에게 어떤 행위를 하도록 지시하는 명령은?,,Class,Package,Object,Message,4,"객체지향 프로그래밍에서 객체(Object)는 데이터(속성)와 그 데이터를 처리하는 함수(메소드)를 묶어놓은 것입니다.  객체에게 어떤 행위를 하도록 지시하는 명령은 바로 ""메시지(Message)""입니다.  예를 들어, ""자동차""라는 객체가 있다면, ""시동을 걸어라"", ""속도를 높여라"", ""브레이크를 밟아라"" 와 같은 명령이 메시지에 해당합니다.  메시지를 통해 객체는 내부적으로 자신의 메소드를 실행하여 명령을 수행합니다.  Class는 객체의 설계도이고, Package는 관련 클래스들을 묶어 관리하는 단위이며, Object는 메시지를 받아 처리하는 실체입니다. 따라서 객체에게 행위를 지시하는 것은 메시지(Message)입니다.",84,107
412,5,12,서브시스템이 입력 데이터를 받아 처리하고 결과를 다른 시스템에 보내는 작업이 반복되는 아키텍처 스타일은?,,클라이언트 서버 구조,계층 구조,MVC 구조,파이프 필터 구조,4,"이 문제는 서브시스템들이 데이터를 순차적으로 처리하는 아키텍처 스타일을 묻고 있습니다.  마치 공장의 조립라인처럼, 각 서브시스템(필터)이 입력 데이터를 받아 특정 작업을 수행하고, 그 결과를 다음 서브시스템에 전달하는 방식입니다.  클라이언트-서버 구조는 클라이언트의 요청에 서버가 응답하는 구조이고, 계층 구조는 여러 계층으로 나뉘어 처리하지만 순차적 처리를 강조하지 않습니다. MVC 구조는 모델, 뷰, 컨트롤러의 상호작용을 중시하며, 역시 순차적인 데이터 처리 방식을 명시적으로 나타내지는 않습니다.  반면 파이프-필터 구조는 데이터가 파이프를 따라 이동하며 각 필터(서브시스템)에서 처리되는 특징을 가지고 있어 문제의 상황과 정확히 일치합니다.  따라서 정답은 파이프-필터 구조입니다.  쉽게 생각하면, 데이터가 파이프를 타고 흐르면서 여러 필터(정수기, 냉장고 등)를 거쳐 최종 결과물이 나오는 과정과 유사합니다.",75,106
413,5,13,럼바우(Rumbaugh)의 객체지향 분석에서 사용하는 분석 활동으로 옳은 것은?,,"객체 모델링, 동적 모델링, 정적 모델링","객체 모델링, 동적 모델링, 기능 모델링","동적 모델링, 기능 모델링, 정적 모델링","정적 모델링, 객체 모델링, 기능 모델링",2,"럼바우의 객체지향 분석은 시스템을 객체들의 상호작용으로 모델링하는 방법입니다.  문제에서 제시된 옵션들을 살펴보면, 객체 모델링은 시스템을 구성하는 객체들과 그 관계를 정의하는 활동입니다. 동적 모델링은 객체들 간의 상호작용과 시간에 따른 변화를 나타내는 활동이고, 기능 모델링은 시스템이 수행하는 기능들을 중심으로 모델링하는 활동이며, 정적 모델링은 시스템의 구조와 구성요소 간의 관계를 시간에 무관하게 나타내는 활동입니다. 럼바우의 객체지향 분석에서는 시스템의 구조(객체 모델링), 객체들의 상호작용(동적 모델링), 그리고 시스템의 기능(기능 모델링)을 모두 고려하여 분석합니다. 따라서 객체 모델링, 동적 모델링, 기능 모델링이 럼바우의 객체지향 분석 활동으로 가장 적절합니다.  정적 모델링은 객체 모델링과 밀접한 관련이 있지만, 럼바우 방법론에서 독립적인 주요 분석 활동으로 분류되지는 않습니다.",90,102
414,5,14,UML 다이어그램이 아닌 것은?,,액티비티 다이어그램(Activity diagram),절차 다이어그램(Procedural diagram),클래스 다이어그램(Class diagram),시퀀스 다이어그램(Sequence diagram),2,"UML(Unified Modeling Language)은 소프트웨어 시스템을 시각적으로 표현하는 표준 모델링 언어입니다.  문제에서 제시된 1번 액티비티 다이어그램, 3번 클래스 다이어그램, 4번 시퀀스 다이어그램은 모두 UML 다이어그램의 종류입니다.  액티비티 다이어그램은 시스템의 동작 흐름을, 클래스 다이어그램은 시스템의 클래스와 클래스 간의 관계를, 시퀀스 다이어그램은 객체 간의 상호 작용을 시각적으로 보여줍니다.  반면, 2번 절차 다이어그램은 UML 표준에 포함되지 않은 다이어그램입니다.  절차 다이어그램은 일반적으로 순서도와 같은 형태로 프로그램의 실행 순서를 나타내는 데 사용되며, UML의 객체 지향적인 관점과는 다릅니다. 따라서 UML 다이어그램이 아닌 것은 2번 절차 다이어그램입니다.",63,102
415,5,15,UML 모델에서 한 객체가 다른 객체에게 오퍼레이션을 수행하도록 지정하는 의미적 관계로 옳은 것은?,,Dependency,Realization,Generalization,Association,2,"UML(Unified Modeling Language) 모델에서 객체 간의 관계를 나타내는 다양한 다이어그램이 존재합니다.  문제에서 묻고 있는 것은 한 객체가 다른 객체에게 특정 작업(오퍼레이션)을 요청하는 관계입니다.  이러한 관계를 가장 잘 나타내는 UML 관계는 **Realization(실현)**입니다.  Realization은 인터페이스와 클래스 간의 관계를 나타내는데,  한 클래스가 특정 인터페이스에 정의된 오퍼레이션을 구현(실현)한다는 것을 의미합니다.  즉,  A 객체가 B 객체의 인터페이스를 Realization하고 있다면, A 객체는 B 객체가 제공하는 오퍼레이션을 수행할 수 있도록 설계된 것입니다.  다른 선택지들은 다음과 같은 의미를 지닙니다. Dependency(의존성)는 한 객체가 다른 객체의 변화에 영향을 받는 느슨한 관계이고, Generalization(일반화)은 상속 관계를 나타내며, Association(연관)은 객체 간의 일반적인 관계를 나타냅니다. 따라서, 한 객체가 다른 객체의 오퍼레이션을 수행하도록 명시적으로 지정하는 관계는 Realization이 가장 적절합니다.  예를 들어,  '자동차' 객체가 '엔진' 객체의 '시동' 오퍼레이션을 수행하도록 하는 경우, '자동차' 객체는 '엔진' 객체의 인터페이스를 Realization하는 것으로 표현할 수 있습니다.",47,102
416,5,16,다음 중 상위 CASE 도구가 지원하는 주요기능으로 볼 수 없는 것은?,,모델들 사이의 모순검사 기능,전체 소스코드 생성 기능,모델의 오류검증 기능,자료흐름도 작성 기능,2,"CASE(Computer-Aided Software Engineering) 도구는 소프트웨어 개발 과정을 자동화하고 효율성을 높이기 위한 도구입니다.  상위 CASE 도구는 시스템 분석 및 설계 단계에서 사용되는 도구로, 시스템의 모델을 생성하고 분석하는 기능을 제공합니다.  문제에서 제시된 선택지들을 살펴보면, 모델 간의 모순 검사, 모델의 오류 검증, 자료 흐름도 작성 등은 모두 상위 CASE 도구가 제공하는 일반적인 기능입니다. 하지만 전체 소스코드 생성 기능은 상위 CASE 도구의 주요 기능이 아닙니다. 상위 CASE 도구는 시스템의 설계 및 모델링에 집중하며, 실제 소스코드 생성은 하위 CASE 도구 또는 프로그래밍 언어를 통해 이루어집니다. 상위 CASE 도구는 설계 단계에서 생성된 모델을 바탕으로 소스코드 생성을 지원할 수는 있지만,  전체 소스코드를 자동으로 생성하는 것은 아닙니다. 따라서 정답은 2번입니다.",72,103
417,5,17,요구사항 관리 도구의 필요성으로 틀린 것은?,,요구사항 변경으로 인한 비용 편익 분석,기존 시스템과 신규 시스템의 성능 비교,요구사항 변경의 추적,요구사항 변경에 따른 영향 평가,2,"요구사항 관리 도구는 소프트웨어 개발 과정에서 발생하는 요구사항의 변경을 효율적으로 관리하기 위한 도구입니다.  1번의 요구사항 변경으로 인한 비용 편익 분석, 3번의 요구사항 변경의 추적, 4번의 요구사항 변경에 따른 영향 평가는 모두 요구사항 변경 관리에 필수적인 요소입니다.  하지만 2번의 기존 시스템과 신규 시스템의 성능 비교는 요구사항 관리 도구의 직접적인 기능이 아닙니다.  성능 비교는 시스템 분석 단계에서 기존 시스템의 성능을 파악하고 신규 시스템의 성능 목표를 설정하는 데 필요한 활동이지, 요구사항 자체의 변경을 관리하는 도구의 기능과는 관련이 없습니다.  요구사항 관리 도구는 요구사항의 변경 내용을 기록하고 추적하며, 변경으로 인한 영향을 분석하고 비용 편익을 평가하는 데 사용됩니다.  따라서 기존 시스템과 신규 시스템의 성능 비교는 요구사항 관리 도구의 필요성과는 무관합니다.",62,103
418,5,18,애자일 개발 방법론이 아닌 것은?,,스크럼(Scrum),"익스트림 프로그래밍(XP, eXtreme Programming)","기능 주도 개발(FDD, Feature Driven Development)",하둡(Hadoop),4,"이 문제는 애자일 개발 방법론에 대한 이해도를 묻는 문제입니다. 애자일 개발 방법론은 소프트웨어 개발 과정에서 유연성과 적응력을 강조하는 접근 방식으로,  반복적인 개발과 고객 피드백을 통해 제품을 점진적으로 개선해 나가는 것을 특징으로 합니다.  스크럼, 익스트림 프로그래밍, 기능 주도 개발은 모두 대표적인 애자일 개발 방법론입니다. 반면, 하둡(Hadoop)은 분산 저장 및 처리를 위한 오픈소스 프레임워크로, 소프트웨어 개발 방법론과는 관련이 없습니다. 따라서 애자일 개발 방법론이 아닌 것은 하둡입니다.",84,147
419,5,19,GoF(Gangs of Four) 디자인 패턴 중 생성패턴으로 옳은 것은?,,singleton pattern,adapter pattern,decorator pattern,state pattern,1,"GoF(Gang of Four) 디자인 패턴은 객체지향 설계에서 자주 발생하는 문제들을 해결하기 위한 디자인 템플릿입니다.  생성 패턴은 객체의 생성 과정을 제어하는 패턴들을 말합니다.  Singleton 패턴은 특정 클래스의 인스턴스가 오직 하나만 생성되도록 보장하는 패턴입니다.  즉, 어떤 시스템에서 단 하나의 객체만 필요할 때 사용합니다. 예를 들어, 데이터베이스 연결 객체나 로그 관리 객체 등이 이에 해당합니다.  반면, Adapter, Decorator, State 패턴은 객체의 생성 방식보다는 객체의 역할이나 동작에 초점을 맞춘 패턴들입니다.  Adapter 패턴은 서로 다른 인터페이스를 가진 객체들을 연결하는 데 사용하고, Decorator 패턴은 객체에 기능을 추가하는 데 사용하며, State 패턴은 객체의 상태에 따라 동작을 변경하는 데 사용합니다. 따라서, 생성 패턴에 해당하는 것은 Singleton 패턴입니다.",76,107
420,5,20,사용자 인터페이스(UI)의 특징으로 틀린 것은?,,구현하고자 하는 결과의 오류를 최소화한다.,사용자의 편의성을 높임으로써 작업시간을 증가시킨다.,막연한 작업 기능에 대해 구체적인 방법을 제시하여 준다.,사용자 중심의 상호 작용이 되도록 한다.,2,"사용자 인터페이스(UI)는 사용자가 컴퓨터나 기계와 상호 작용하는 방식을 디자인하는 것을 말합니다. 좋은 UI는 사용자가 원하는 작업을 쉽고 효율적으로 수행할 수 있도록 돕는 것이 목표입니다.  문제에서 제시된 보기들을 살펴보면, 1번은 UI의 중요한 목표 중 하나입니다. 오류를 최소화하여 사용자의 혼란을 줄이는 것은 좋은 UI 설계의 기본입니다. 3번 또한 좋은 UI의 특징입니다. 복잡한 기능을 사용자가 이해하기 쉽도록 단계적으로 안내하는 것은 사용자 경험을 향상시키는 데 중요합니다. 4번 역시 사용자 중심 디자인의 핵심 개념입니다. 사용자의 요구와 편의성을 최우선으로 고려하여 설계해야 합니다.  하지만 2번은 잘못된 설명입니다. 좋은 UI는 사용자의 편의성을 높여 작업 시간을 *단축*시키는 것을 목표로 합니다. 작업 시간을 증가시키는 것은 UI 설계의 실패를 의미합니다. 따라서 2번이 틀린 설명입니다.",90,104
421,5,21,힙 정렬(Heap Sort)에 대한 설명으로 틀린것은?,,정렬할 입력 레코드들로 힙을 구성하고 가장 큰 키 값을 갖는 루트 노드를 제거하는 과정을 반복하여 정렬하는 기법이다.,평균 수행 시간은 O(nlog2n)이다.,완전 이진트리(complete binary tree)로 입력자료의 레코드를 구성한다.,최악의 수행 시간은 O(2n4)이다.,4,"힙 정렬은 우선 데이터들을 힙(Heap)이라는 특수한 이진 트리 형태로 구성하는 정렬 알고리즘입니다.  힙은 완전 이진 트리의 일종으로, 부모 노드의 값이 자식 노드의 값보다 항상 크거나(최대 힙) 작거나(최소 힙) 같은 특징을 가지고 있습니다.  힙 정렬은 최대 힙을 이용하여 가장 큰 값(루트 노드)을 먼저 꺼내 정렬된 배열의 끝에 놓고, 다시 힙을 재구성하는 과정을 반복합니다.  이 과정을 통해 데이터들이 큰 값부터 차례로 정렬됩니다.  문제의 4번 선택지 ""최악의 수행 시간은 O(2n4)이다""가 틀린 이유는 힙 정렬의 최악의 시간 복잡도가 O(n log n)이기 때문입니다. O(2n4)는 힙 정렬의 시간 복잡도를 훨씬 초과하는 값입니다.  평균 및 최선의 경우에도 O(n log n)의 시간 복잡도를 가집니다. 따라서 4번 선택지는 힙 정렬의 시간 복잡도에 대한 잘못된 정보를 제공합니다.",72,111
422,5,22,다음 중 단위 테스트를 통해 발견할 수 있는 오류가 아닌 것은?,,알고리즘 오류에 따른 원치 않는 결과,탈출구가 없는 반복문의 사용,모듈 간의 비정상적 상호작용으로 인한 원치 않는 결과,틀린 계산 수식에 의한 잘못된 결과,3,"단위 테스트는 소프트웨어의 가장 작은 단위인 모듈(함수 또는 클래스)을 개별적으로 테스트하는 방법입니다.  1번, 2번, 그리고 4번의 경우는 각각의 모듈 내부의 알고리즘, 반복문, 계산 수식의 오류를 찾아낼 수 있습니다.  단위 테스트는 각 모듈을 독립적으로 테스트하기 때문에, 모듈 내부의 문제는 발견 가능합니다. 하지만 3번의 경우는 모듈 간의 상호작용 문제이기 때문에, 단위 테스트만으로는 발견하기 어렵습니다.  단위 테스트는 각 모듈이 제대로 작동하는지 확인하는 것이지, 모듈들이 서로 어떻게 상호작용하는지 확인하는 것은 아니기 때문입니다.  모듈 간의 상호작용 문제는 통합 테스트(Integration Test) 단계에서 발견하는 것이 적절합니다.",65,114
423,5,23,다음 설명의 소프트웨어 테스트의 기본원칙은?,https://www.cbtbank.kr/images/iz/iz20210515/iz20210515m23.gif,살충제 패러독스,결함 집중,오류 부재의 궤변,완벽한 테스팅은 불가능,2,"소프트웨어 테스트에서 '결함 집중' 원칙은 소수의 모듈에 대부분의 결함이 집중되어 있다는 것을 의미합니다.  문제에서 제시된 설명처럼 파레토 법칙(80/20 법칙)과 유사하게,  애플리케이션의 결함은 특정 모듈에 집중적으로 나타나고, 그 모듈에서 추가적인 결함이 발생할 가능성이 높다는 것입니다.  따라서 테스트는 이러한 결함이 집중된 모듈에 집중적으로 수행되어야 효율적인 테스트가 가능합니다.  다른 선택지들은 소프트웨어 테스트의 다른 중요한 원칙이나 현상을 나타내지만, 문제에서 제시된 설명과 가장 잘 부합하는 것은 결함 집중입니다.  살충제 패러독스는 같은 테스트 방법을 반복하면 새로운 결함을 찾지 못하는 현상이고, 오류 부재의 궤변은 테스트를 충분히 하지 않았음에도 불구하고 발견된 결함이 없다는 이유로 소프트웨어에 결함이 없다고 주장하는 오류를 말하며, 완벽한 테스팅은 불가능하다는 것은 소프트웨어 테스트의 한계를 나타내는 말입니다.",82,119
424,5,24,버전 관리 항목 중 저장소에 새로운 버전의 파일로 갱신하는 것을 의미하는 용어는?,,형상 감사(Configuration Audit),롤백 (Rollback),단위 테스트(Unit Test),체크인(Check-In),4,"저장소에 새로운 버전의 파일을 업로드하는 것을 의미하는 용어가 체크인(Check-In)입니다.  버전 관리 시스템을 사용하면 여러 사람이 동시에 하나의 프로젝트에 참여하여 파일을 수정할 수 있습니다.  각자 수정한 내용을 저장소에 업로드(체크인) 하면, 저장소에는 파일의 변경 이력이 버전별로 관리됩니다.  마치 문서의 수정본을 차곡차곡 보관하는 것과 같습니다.  따라서 새로운 버전의 파일을 저장소에 반영하는 행위는 체크인이라고 부릅니다.  다른 선택지는 버전 관리와 직접적인 관련이 없습니다. 형상 감사는 시스템의 상태를 점검하는 것이고, 롤백은 이전 버전으로 되돌리는 것이며, 단위 테스트는 코드의 일부분을 검증하는 것입니다.",77,115
425,5,25,소프트웨어 테스트와 관련한 설명으로 틀린것은?,,화이트 박스 테스트는 모듈의 논리적인 구조를 체계적으로 점검할 수 있다.,블랙박스 테스트는 프로그램의 구조를 고려하지 않는다.,"테스트 케이스에는 일반적으로 시험 조건,테스트 데이터, 예상 결과가 포함되어야한다.",화이트박스 테스트에서 기본 경로(BasisPath)란 흐름 그래프의 시작 노드에서 종료노드까지의 서로 독립된 경로로 싸이클을 허용하지 않는 경로를 말한다.,4,"문제에서 틀린 것은 4번입니다.  화이트박스 테스트의 기본 경로(Basis Path)는 흐름 그래프의 시작 노드에서 종료 노드까지의 모든 독립적인 경로를 의미합니다.  단, 4번 설명처럼 '싸이클을 허용하지 않는 경로'라는 조건은 잘못되었습니다.  기본 경로는 루프(반복문)를 포함한 모든 경로를 고려하여 테스트 케이스를 설계하는 데 사용됩니다.  루프를 포함하지 않으면 테스트의 완전성이 떨어지기 때문입니다.  따라서 4번 설명은 화이트박스 테스트의 기본 경로에 대한 정의를 잘못 이해하고 있는 것입니다.  나머지 1, 2, 3번은 소프트웨어 테스트에 대한 정확한 설명입니다. 화이트박스 테스트는 코드 내부 구조를 파악하여 테스트하며, 블랙박스 테스트는 외부 동작만을 확인합니다.  테스트 케이스는 테스트 조건, 입력 데이터, 예상 결과를 포함하여 테스트를 체계적으로 수행하도록 합니다.",63,119
426,5,26,"애플리케이션의 처리량, 응답시간, 경과시간, 자원사용률에 대해 가상의 사용자를 생성하고 테스트를 수행함으로써 성능 목표를 달성하였는지를 확인하는 테스트 자동화 도구는?",,명세 기반 테스트 설계 도구,코드 기반 테스트 설계 도구,기능 테스트 수행 도구,성능 테스트 도구,4,"애플리케이션의 성능을 평가하는 데에는 여러 가지 요소가 있습니다.  처리량(얼마나 많은 요청을 처리할 수 있는지), 응답시간(요청에 대한 응답이 얼마나 빨리 돌아오는지), 경과시간(전체 작업이 완료되는 데 걸리는 시간), 그리고 자원사용률(CPU, 메모리 등 시스템 자원을 얼마나 사용하는지) 등이 중요한 지표입니다.  문제에서 언급된 테스트는 가상의 사용자를 생성하여 실제 사용 환경과 유사하게 애플리케이션을 작동시키고, 위의 지표들을 측정하여 애플리케이션이 목표 성능을 달성했는지 확인하는 것입니다. 이러한 테스트를 자동화하는 도구가 바로 '성능 테스트 도구'입니다.  성능 테스트 도구는 다양한 부하 조건 하에서 애플리케이션의 성능을 측정하고 분석하여 성능 병목 지점을 찾아 개선하는 데 사용됩니다.  따라서 정답은 4번, 성능 테스트 도구입니다.",82,120
427,5,27,소프트웨어 형상 관리에 대한 설명으로 거리가 먼 것은?,,소프트웨어에 가해지는 변경을 제어하고 관리한다.,"프로젝트 계획, 분석서, 설계서, 프로그램, 테스트 케이스 모두 관리 대상이다.","대표적인 형상관리 도구로 Ant, Maven, Gradle 등이 있다.",유지 보수 단계뿐만 아니라 개발 단계에도 적용할 수 있다.,3,"소프트웨어 형상 관리(Software Configuration Management, SCM)는 소프트웨어 개발 과정에서 발생하는 모든 변경 사항을 체계적으로 관리하고 추적하는 것을 말합니다.  1번과 2번은 소프트웨어 형상 관리의 주요 목표와 관리 대상을 정확하게 설명하고 있습니다. 4번 또한 소프트웨어 개발 전 단계에 걸쳐 형상 관리가 적용될 수 있다는 점을 보여줍니다. 하지만 3번은 잘못된 정보입니다. Ant, Maven, Gradle은 소프트웨어 빌드 자동화 도구이며, 소프트웨어 형상 관리 도구는 Git, SVN, Mercurial 등과 같은 버전 관리 시스템입니다.  빌드 자동화 도구는 소프트웨어를 컴파일하고 패키징하는 데 사용되지만, 소프트웨어의 변경 사항을 추적하고 관리하는 형상 관리 도구와는 그 역할이 다릅니다. 따라서 소프트웨어 형상 관리에 대한 설명으로 거리가 먼 것은 3번입니다.",67,115
428,5,28,디지털 저작권 관리(DRM) 구성 요소가 아닌 것은?,,Dataware house,DRM Controller,Packager,Contents Distributor,1,"디지털 저작권 관리(DRM)은 디지털 콘텐츠의 저작권을 보호하기 위한 기술입니다.  DRM 시스템은 콘텐츠의 복제, 배포, 사용을 제한하여 저작권자의 권리를 보호하는 역할을 합니다. 문제에서 제시된 선택지들을 살펴보면, DRM Controller는 DRM 시스템의 핵심 요소로 콘텐츠 접근을 제어하고 관리하는 역할을 합니다. Packager는 콘텐츠를 DRM 시스템에 맞게 포장하고 암호화하는 역할을 하며, Contents Distributor는 DRM으로 보호된 콘텐츠를 배포하는 역할을 합니다. 반면 Data warehouse는  데이터를 저장하고 분석하는 대규모 데이터 저장소로, DRM 시스템의 구성 요소가 아닙니다.  DRM은 콘텐츠의 저작권 보호에 초점을 맞추는 반면, 데이터 웨어하우스는 데이터 분석 및 활용에 초점을 맞추기 때문입니다. 따라서 DRM 구성 요소가 아닌 것은 Data warehouse입니다.",62,116
429,5,29,다음 설명의 소프트웨어 버전 관리도구 방식은?,https://www.cbtbank.kr/images/iz/iz20210515/iz20210515m29.gif,단일 저장소 방식,분산 저장소 방식,공유폴더 방식,클라이언트·서버 방식,2,"문제에서 설명하는 소프트웨어 버전 관리 도구는 원격 저장소와 로컬 저장소를 모두 사용하는 방식입니다.  원격 저장소는 여러 개발자가 공유하는 중앙 저장소이고, 로컬 저장소는 각 개발자의 컴퓨터에 있는 개인 저장소입니다.  이 방식은 로컬 저장소에서 버전 관리가 가능하므로, 원격 저장소에 문제가 발생하더라도 로컬 저장소의 자료를 이용하여 작업을 계속 진행할 수 있다는 장점이 있습니다.  이는 단일 저장소 방식(원격 저장소만 사용)이나 클라이언트-서버 방식(원격 저장소 중심)과는 다르게, 각 개발자가 원격 저장소의 복사본을 로컬에 가지고 있고 독립적으로 작업할 수 있다는 것을 의미합니다.  따라서, 설명에 부합하는 방식은 분산 저장소 방식입니다. Git은 대표적인 분산 버전 관리 시스템으로, 이 문제의 설명과 일치합니다.  공유 폴더 방식은 버전 관리 기능이 없으므로 적절하지 않습니다.",78,118
430,5,30,블랙박스 테스트를 이용하여 발견할 수 있는 오류가 아닌 것은?,,비정상적인 자료를 입력해도 오류 처리를 수행하지 않는 경우,정상적인 자료를 입력해도 요구된 기능이 제대로 수행되지 않는 경우,반복 조건을 만족하는데도 루프 내의 문장이 수행되지 않는 경우,경계값을 입력할 경우 요구된 출력 결과가 나오지 않는 경우,3,"블랙박스 테스트는 소프트웨어의 내부 구조를 알지 못한 채, 입력값과 출력값만을 가지고 테스트하는 방법입니다.  문제에서 제시된 1, 2, 4번 선택지는 모두 블랙박스 테스트를 통해 발견 가능한 오류입니다.  1번은 비정상적인 입력에 대한 오류 처리 기능의 부재, 2번은 정상적인 입력에도 기능이 제대로 작동하지 않는 문제, 4번은 경계값(예: 최대값, 최소값) 입력 시 예상되는 결과가 나오지 않는 문제를 의미합니다.  하지만 3번의 경우, 루프 내부의 문장이 수행되지 않는다는 것은 소프트웨어의 내부 로직(반복 조건, 루프 구조 등)에 문제가 있다는 것을 의미합니다. 블랙박스 테스트는 내부 로직을 직접 확인하지 않기 때문에 이러한 오류는 블랙박스 테스트만으로는 발견하기 어렵습니다.  내부 구조를 파악해야만 그 원인을 찾을 수 있으므로 화이트박스 테스트가 더 적합합니다. 따라서 블랙박스 테스트로는 3번 오류를 발견할 수 없습니다.",72,119
431,5,31,다음 자료를 버블 정렬을 이용하여 오름차순으로 정렬할 경우 Pass 2의 결과는?,https://www.cbtbank.kr/images/iz/iz20210515/iz20210515m31.gif,"3, 5, 6, 7, 9","6, 7, 3, 5, 9","3, 5, 9, 6, 7","6, 3, 5, 7, 9",4,"버블 정렬은 인접한 두 원소를 비교하여 크기 순서대로 자리를 바꾸는 정렬 알고리즘입니다.  주어진 자료 9, 6, 7, 3, 5를 오름차순으로 정렬하는 과정을 Pass 2까지 살펴보겠습니다.",66,111
432,5,32,정렬된 N개의 데이터를 처리하는 데 O(Nlog2N)의 시간이 소요되는 정렬 알고리즘은?,,합병정렬,버블정렬,선택정렬,삽입정렬,1,"이 문제는 정렬 알고리즘의 시간 복잡도를 묻고 있습니다.  시간 복잡도는 알고리즘의 효율성을 나타내는 지표로, 입력 데이터의 크기(N)에 따라 알고리즘이 얼마나 오래 걸리는지를 나타냅니다. O(Nlog₂N)은 입력 데이터의 크기가 커질수록 처리 시간이 N의 로그값에 비례하여 증가함을 의미합니다.  여러 정렬 알고리즘 중에서 합병 정렬(Merge Sort)은 데이터를 반으로 계속 나누어 정렬한 후 합치는 방식으로, 항상 O(Nlog₂N)의 시간 복잡도를 가지는 대표적인 알고리즘입니다. 반면 버블 정렬, 선택 정렬, 삽입 정렬은 최악의 경우 O(N²)의 시간 복잡도를 가지므로, 데이터의 크기가 커지면 처리 시간이 훨씬 오래 걸립니다. 따라서 정렬된 N개의 데이터를 처리하는 데 O(Nlog₂N)의 시간이 소요되는 정렬 알고리즘은 합병 정렬입니다. 정보처리기사 시험에서는 알고리즘의 시간 복잡도를 이해하고, 각 알고리즘의 특징을 비교하는 능력을 평가합니다.",72,121
433,5,33,다음 postfix로 표현된 연산식의 연산 결과로 옳은 것은?,https://www.cbtbank.kr/images/iz/iz20210515/iz20210515m33.gif,35,42,81,360,2,"이 문제는 후위 표기법(postfix notation)으로 표현된 연산식을 계산하는 문제입니다. 후위 표기법은 연산자가 피연산자 뒤에 오는 표기법으로, 괄호 없이 연산 순서를 명확하게 나타낼 수 있습니다.  문제에서 주어진 연산식 ""3 4 * 5 6 * +""는 다음과 같이 계산됩니다.",85,111
434,5,34,"EAI(Enterprise Application Integration) 구축 유형에서 애플리케이션 사이에 미들웨어를 두어 처리하는 것은? (문제 오류로 가답안 발표시 1번으로 발표되었지만 확정 답안 발표시 1, 3, 4번이 정답처리 되었습니다. 여기서는 가답안인 1번을 누르면 정답 처리 됩니다.)",,Message Bus,Point-to-point,Hub & Spoke,Hybrid,1,"EAI(Enterprise Application Integration)는 여러 기업용 애플리케이션들을 서로 연결하고 통합하여 데이터와 프로세스를 공유할 수 있도록 하는 기술입니다.  문제에서 제시된 네 가지 구축 유형은 애플리케이션 간의 통신 방식을 나타냅니다.  Message Bus는 여러 애플리케이션이 메시지를 주고받을 수 있는 중앙 허브 역할을 하는 미들웨어입니다.  Point-to-point는 애플리케이션 간에 직접적인 연결을 설정하는 방식이고, Hub & Spoke는 중앙 허브를 통해 여러 애플리케이션이 연결되는 방식이며, Hybrid는 위 방식들을 혼합하여 사용하는 방식입니다.  문제에서 애플리케이션 사이에 미들웨어를 두어 처리하는 방식을 묻고 있으므로,  Message Bus가 가장 적합한 답변입니다. Message Bus는 중앙의 미들웨어를 통해 애플리케이션 간의 통신을 관리하고,  비동기적 통신을 지원하여 애플리케이션의 독립성과 유연성을 높여줍니다.  가답안 발표 시 1번만 정답으로 발표되었지만,  실제 정답은 1, 3, 4번으로 확장된 것은  EAI 구축 방식이 다양하게 조합될 수 있음을 보여줍니다. 하지만 문제의 질문 의도에 가장 부합하는 것은 Message Bus입니다.",83,110
435,5,35,인터페이스 구현 검증 도구가 아닌 것은?,,Foxbase,STAF,watir,xUnit,1,"문제에서 제시된 선택지들은 모두 소프트웨어 테스트나 인터페이스 검증에 사용되는 도구들입니다.  STAF(Software Testing Automation Framework), Watir(Web Application Testing in Ruby), xUnit(단위 테스트 프레임워크)는 모두 소프트웨어의 기능이나 인터페이스를 자동화된 방식으로 테스트하기 위해 사용되는 도구입니다.  반면 Foxbase는 데이터베이스 관리 시스템(DBMS)으로,  소프트웨어의 인터페이스를 직접 검증하는 도구는 아닙니다.  Foxbase는 데이터를 저장하고 관리하는 데 사용되며, 인터페이스 구현 검증에는 다른 도구들이 필요합니다. 따라서 인터페이스 구현 검증 도구가 아닌 것은 Foxbase입니다.",61,124
436,5,36,클린코드 작성원칙에 대한 설명으로 틀린 것은?,,코드의 중복을 최소화 한다.,코드가 다른 모듈에 미치는 영향을 최대화하도록 작성한다.,누구든지 코드를 쉽게 읽을 수 있도록 작성한다.,간단하게 코드를 작성한다.,2,"클린 코드 작성 원칙은 코드의 가독성과 유지보수성을 높이기 위한 지침입니다.  1번은 코드 중복을 줄여 코드의 크기를 줄이고 가독성을 높이며, 유지보수를 용이하게 하므로 올바른 원칙입니다. 3번은 코드를 누구나 쉽게 이해할 수 있도록 작성하는 것이 중요하며, 주석을 잘 달고 변수명을 명확하게 하는 등의 노력이 필요합니다. 4번은 간결한 코드를 작성하는 것이 좋지만, 가독성을 희생해서까지 간결하게 작성할 필요는 없습니다.  반면 2번은 코드가 다른 모듈에 미치는 영향을 최대화하도록 작성하는 것은 잘못된 원칙입니다.  소프트웨어 개발에서는 모듈 간의 결합도를 최소화하여 하나의 모듈 변경이 다른 모듈에 미치는 영향을 최소화하는 것이 중요합니다.  모듈 간의 의존성이 높으면 유지보수가 어려워지고, 오류 발생 시 문제 해결이 복잡해집니다. 따라서 코드는 다른 모듈과의 의존성을 최소화하고 독립적으로 동작하도록 설계되어야 합니다.  결론적으로, 다른 모듈에 미치는 영향을 최대화하는 것은 클린 코드의 원칙에 어긋납니다.",87,106
437,5,37,소프트웨어 패키징에 대한 설명으로 틀린 것은?,,패키징은 개발자 중심으로 진행한다.,"신규 및 변경 개발소스를 식별하고, 이를 모듈화하여 상용제품으로 패키징 한다.",고객의 편의성을 위해 매뉴얼 및 버전관리를 지속적으로 한다.,범용 환경에서 사용이 가능하도록 일반적인 배포 형태로 패키징이 진행된다.,1,"소프트웨어 패키징은 개발된 소프트웨어를 사용자가 쉽게 설치하고 사용할 수 있도록 포장하는 과정입니다.  1번 보기 ""패키징은 개발자 중심으로 진행한다""는 잘못된 설명입니다.  패키징은 개발자의 편의성보다는 최종 사용자인 고객의 편의성을 최우선으로 고려하여 진행되어야 합니다.  고객이 쉽게 설치하고 사용할 수 있도록  설치 프로그램, 사용 설명서, 필요한 라이브러리 등을 포함하여 배포하는 것이 중요하기 때문입니다.  따라서 사용자 인터페이스(UI)의 직관성, 설치 과정의 간편함, 다양한 운영체제 및 환경과의 호환성 등을 고려하여 고객 중심으로 진행되어야 합니다.  나머지 보기들은 소프트웨어 패키징의 일반적인 특징을 잘 나타내고 있습니다.  2번은 소스코드 관리와 모듈화를 강조하고, 3번은 고객 편의를 위한 매뉴얼과 버전 관리의 중요성을, 4번은 범용성을 강조하고 있습니다.",87,116
438,5,38,공학적으로 잘된 소프트웨어(Well Engineered Software)의 설명 중 틀린 것은?,,소프트웨어는 유지보수가 용이해야 한다.,소프트웨어는 신뢰성이 높아야 한다.,소프트웨어는 사용자 수준에 무관하게 일관된 인터페이스를 제공해야 한다.,소프트웨어는 충분한 테스팅을 거쳐야 한다.,3,"잘 설계된 소프트웨어는 여러 가지 중요한 특징을 가지고 있습니다.  유지보수가 용이해야 나중에 수정이나 업데이트가 쉽고, 신뢰성이 높아야 오류 없이 안정적으로 작동해야 합니다. 또한, 충분한 테스트를 거쳐야 실제 사용 환경에서 문제가 발생할 가능성을 줄일 수 있습니다.  하지만 3번의 경우, 사용자 수준에 관계없이 *항상* 일관된 인터페이스를 제공해야 한다는 것은 현실적으로 어려울 수 있습니다.  초보 사용자에게는 간단한 인터페이스가 필요하지만, 전문가에게는 더욱 세밀한 제어 기능이 필요할 수 있기 때문입니다.  따라서 사용자 수준에 따라 인터페이스의 복잡성이나 기능을 조절하는 것이 더욱 효율적일 수 있습니다.  즉, 모든 사용자에게 동일한 인터페이스를 제공하는 것이 항상 최선의 방법은 아니라는 점을 고려해야 합니다.  따라서 3번이 잘못된 설명입니다.",90,117
439,5,39,테스트와 디버그의 목적으로 옳은 것은?,,테스트는 오류를 찾는 작업이고 디버깅은 오류를 수정하는 작업이다.,테스트는 오류를 수정하는 작업이고 디버깅은 오류를 찾는 작업이다.,둘 다 소프트웨어의 오류를 찾는 작업으로 오류 수정은 하지 않는다.,"둘 다 소프트웨어 오류의 발견, 수정과 무관하다.",1,"소프트웨어 테스트와 디버깅은 모두 소프트웨어의 오류를 다루는 작업이지만, 그 목적과 방법이 다릅니다. 테스트는 소프트웨어에 오류가 있는지 *찾는* 과정이고, 디버깅은 테스트를 통해 발견된 오류를 *수정하는* 과정입니다.  1번 선택지가 정답인 이유는 바로 이러한 테스트와 디버깅의 역할을 정확하게 구분하고 있기 때문입니다.  테스트는 오류를 발견하는 활동이고, 디버깅은 그 발견된 오류를 해결하는 활동입니다.  마치 의사가 환자의 병을 진단(테스트)하고 치료(디버깅)하는 것과 같습니다.  다른 선택지는 이러한 두 과정의 차이점을 제대로 반영하지 못하고 있습니다.",78,114
440,5,40,다음 중 스택을 이용한 연산과 거리가 먼 것은?,,선택정렬,재귀호출,후위표현(Post-fix expression)의 연산,깊이우선탐색,1,"스택은 후입선출(LIFO, Last-In-First-Out) 방식으로 데이터를 저장하고 처리하는 자료구조입니다.  마치 접시를 쌓아놓고 맨 위에 놓은 접시부터 꺼내는 것과 같습니다.  재귀호출은 함수가 자기 자신을 호출하는 기법인데, 함수 호출 시 스택을 이용하여 호출 순서를 관리합니다. 후위 표현식의 연산 또한 스택을 이용하여 연산 순서를 제어합니다. 깊이 우선 탐색(DFS, Depth-First Search)은 그래프 탐색 알고리즘으로, 스택을 이용하여 탐색 경로를 관리합니다.  반면, 선택 정렬은 배열의 요소들을 비교하여 정렬하는 알고리즘으로, 스택을 사용하지 않습니다.  따라서 스택을 이용한 연산과 거리가 먼 것은 선택 정렬입니다.  선택 정렬은 배열의 요소들을 순차적으로 비교하며 가장 작은(혹은 큰) 요소를 찾아서 앞쪽으로 이동시키는 방식으로 동작하기 때문에 스택과 같은 자료구조가 필요하지 않습니다.",54,111
441,5,41,병렬 데이터베이스 환경 중 수평 분할에서 활용되는 분할 기법이 아닌 것은?,,라운드-로빈,범위 분할,예측 분할,해시 분할,3,"병렬 데이터베이스는 여러 대의 서버에 데이터를 분산 저장하여 처리 속도를 높이는 기술입니다.  수평 분할은 데이터베이스를 여러 서버에 나누어 저장하는 방식인데, 이때 데이터를 어떻게 나눌지를 결정하는 기법이 여러 가지 있습니다.  라운드 로빈은 데이터를 순서대로 서버에 할당하는 방식이고, 범위 분할은 데이터의 특정 범위(예: 고객 ID 1000~2000)를 특정 서버에 할당하는 방식이며, 해시 분할은 해시 함수를 이용하여 데이터를 서버에 분산하는 방식입니다.  반면, 예측 분할은 수평 분할에서 사용되는 기법이 아닙니다. 예측 분할은 데이터의 미래 성장을 예측하여 저장 공간을 미리 할당하는 기법으로, 데이터를 여러 서버에 분산하는 수평 분할과는 목적이 다릅니다. 따라서 수평 분할에서 활용되는 분할 기법이 아닌 것은 예측 분할입니다.",44,131
442,5,42,시스템 카탈로그에 대한 설명으로 옳지 않은 것은?,,사용자가 직접 시스템 카탈로그의 내용을 갱신하여 데이터베이스 무결성을 유지한다.,시스템 자신이 필요로 하는 스키마 및 여러가지 객체에 관한 정보를 포함하고 있는 시스템 데이터베이스이다.,시스템 카탈로그에 저장되는 내용을 메타데이터라고도 한다.,시스템 카탈로그는 DBMS가 스스로 생성하고 유지한다.,1,"시스템 카탈로그는 데이터베이스 관리 시스템(DBMS)이 데이터베이스의 구조와 내용에 대한 정보를 저장하는 시스템 데이터베이스입니다.  마치 도서관의 카드 카탈로그처럼, 데이터베이스의 테이블, 컬럼, 인덱스 등의 정보를 담고 있어 DBMS가 데이터베이스를 효율적으로 관리하고 운영하는 데 필수적인 역할을 합니다.  1번 보기는 사용자가 직접 시스템 카탈로그를 수정한다는 내용인데, 이는 잘못된 설명입니다. 시스템 카탈로그는 DBMS가 자동으로 생성하고 관리하며, 사용자가 직접 수정하면 데이터베이스의 무결성에 심각한 문제가 발생할 수 있기 때문입니다.  2, 3, 4번 보기는 시스템 카탈로그의 정확한 기능과 역할을 설명하고 있습니다.  메타데이터(metadata)란 데이터에 대한 정보를 의미하며, 시스템 카탈로그에 저장되는 내용이 바로 메타데이터입니다.  따라서 시스템 카탈로그는 DBMS가 스스로 생성하고 유지 관리하는 시스템 데이터베이스이며, 그 안에는 데이터베이스 객체에 대한 정보(메타데이터)가 저장됩니다.  사용자가 직접 수정하는 것이 아니라 DBMS가 자동으로 관리하는 것이 시스템 카탈로그의 핵심적인 특징입니다.",73,129
443,5,43,SQL 문에서 SELECT에 대한 설명으로 옳지않은 것은?,,FROM 절에는 질의에 의해 검색될 데이터들을 포함하는 테이블명을 기술한다.,검색결과에 중복되는 레코드를 없애기위해서는 WHERE 절에 'DISTINCT'키워드를 사용한다.,"HAVING 절은 GROUP BY 절과 함께 사용되며, 그룹에 대한 조건을 지정한다.",ORDER BY 절은 특정 속성을 기준으로 정렬하여 검색할 때 사용한다.,2,"SQL에서 SELECT 문은 데이터베이스에서 원하는 정보를 가져오는 데 사용하는 명령어입니다.  문제에서 제시된 1, 3, 4번 선택지는 모두 SELECT 문과 관련된 올바른 설명입니다.  1번은 FROM 절이 데이터가 저장된 테이블을 지정하는 역할을 한다는 것을, 3번은 HAVING 절이 GROUP BY 절과 함께 사용되어 그룹화된 데이터에 조건을 적용한다는 것을, 4번은 ORDER BY 절이 결과를 특정 열을 기준으로 정렬한다는 것을 각각 설명하고 있습니다.  하지만 2번 선택지는 잘못되었습니다.  중복되는 레코드를 제거하려면 WHERE 절이 아닌 SELECT 절에 DISTINCT 키워드를 사용해야 합니다.  WHERE 절은 레코드를 필터링하는 역할을 하지만, 중복 제거는 SELECT 절의 DISTINCT 키워드가 담당합니다.  따라서 DISTINCT 키워드를 WHERE 절에 사용하는 것은 잘못된 SQL 문법입니다.",70,126
444,5,44,SQL에서 VIEW를 삭제할 때 사용하는 명령은?,,ERASE,KILL,DROP,DELETE,3,"SQL에서 VIEW는 테이블처럼 보이는 가상 테이블입니다.  실제 데이터를 저장하는 것이 아니라, 기존 테이블의 데이터를 특정 조건이나 방식으로 보여주는 역할을 합니다.  VIEW를 삭제하려면 `DROP` 명령어를 사용합니다.  `DROP` 명령어는 데이터베이스 객체(테이블, VIEW, 인덱스 등)를 완전히 삭제하는 명령어입니다.  문제에서 제시된 다른 옵션들은 VIEW 삭제와는 관련이 없습니다. `ERASE`나 `KILL`은 일반적으로 파일이나 프로세스를 삭제하는 데 사용되며, `DELETE`는 테이블의 특정 행을 삭제하는 명령어입니다. 따라서 VIEW를 삭제하기 위해서는 `DROP VIEW` 명령어를 사용해야 합니다. 예를 들어, 'myview'라는 VIEW를 삭제하려면 `DROP VIEW myview;` 와 같이 작성합니다.",80,128
445,5,45,"DDL(Data Define Language)의 명령어 중 스키마, 도메인, 인덱스 등을 정의할 때 사용하는 SQL문은?",,ALTER,SELECT,CREATE,INSERT,3,"DDL(Data Definition Language)은 데이터베이스의 구조를 정의하는 데 사용되는 SQL 명령어 집합입니다.  스키마, 도메인, 인덱스는 모두 데이터베이스의 구조적 요소이므로, 이들을 정의하기 위해서는 데이터베이스의 구조를 생성하거나 변경하는 명령어가 필요합니다.  제공된 선택지 중 CREATE 명령어는 새로운 데이터베이스 객체(테이블, 스키마, 인덱스 등)를 생성하는 데 사용됩니다.  ALTER 명령어는 이미 존재하는 데이터베이스 객체를 수정하는 데 사용되고, SELECT 명령어는 데이터를 조회하는 데, INSERT 명령어는 데이터를 삽입하는 데 사용됩니다. 따라서 스키마, 도메인, 인덱스와 같은 데이터베이스 구조를 정의하기 위해서는 CREATE 명령어를 사용하는 것이 적절합니다. 예를 들어, 새로운 테이블을 생성하려면 CREATE TABLE 명령어를, 새로운 인덱스를 생성하려면 CREATE INDEX 명령어를 사용합니다.",74,127
446,5,46,"테이블 R1, R2에 대하여 다음 SQL문의결과는?",https://www.cbtbank.kr/images/iz/iz20210515/iz20210515m46.gif,https://www.cbtbank.kr/images/iz/iz20210515/iz20210515m46b1.gif,https://www.cbtbank.kr/images/iz/iz20210515/iz20210515m46b2.gif,https://www.cbtbank.kr/images/iz/iz20210515/iz20210515m46b3.gif,https://www.cbtbank.kr/images/iz/iz20210515/iz20210515m46b4.gif,2,"이 문제는 SQL의 집합 연산자 중 하나인 INTERSECT를 이해하고 있는지 묻는 문제입니다.  INTERSECT 연산자는 두 개의 SELECT 문의 결과 집합에서 중복되는 데이터만을 결과로 반환합니다.  문제에서 (SELECT 학번 FROM R1)은 R1 테이블의 학번 열에서 학번 값들을 가져오는 쿼리이고, (SELECT 학번 FROM R2)는 R2 테이블의 학번 열에서 학번 값들을 가져오는 쿼리입니다.  따라서 INTERSECT 연산자는 R1과 R2 테이블에 모두 존재하는 학번을 찾습니다.",62,128
447,5,47,데이터베이스 설계 시 물리적 설계 단계에서 수행하는 사항이 아닌 것은?,,레코드 집중의 분석 및 설계,접근 경로 설계,저장 레코드의 양식 설계,목표 DBMS에 맞는 스키마 설계,4,"데이터베이스 물리적 설계는 논리적 설계 결과를 바탕으로 실제 데이터베이스 시스템에 구현하기 위한 구체적인 계획을 세우는 단계입니다.  레코드 집중 분석, 접근 경로 설계, 저장 레코드 양식 설계는 모두 물리적인 저장 방식, 데이터 접근 방법 등을 결정하는 작업에 해당합니다.  하지만 '목표 DBMS에 맞는 스키마 설계'는 논리적 설계 단계에서 이미 완료되어야 할 작업입니다.  물리적 설계는 논리적 설계에서 정의된 스키마를 어떻게 효율적으로 구현할지에 초점을 맞추는 것이지, 스키마 자체를 새롭게 설계하는 단계가 아니기 때문입니다.  즉, 어떤 DBMS(예: Oracle, MySQL, SQL Server)를 사용할지는 논리 설계 전에 결정되고, 그 DBMS의 특징을 고려하여 논리적 스키마를 설계해야 합니다. 물리적 설계는 이미 정해진 논리적 스키마를 바탕으로,  해당 DBMS 환경에 최적화된 저장 구조, 인덱스, 파티셔닝 등을 결정하는 단계입니다. 따라서 4번은 물리적 설계 단계의 작업이 아닙니다.",72,133
448,5,48,릴레이션에서 기본 키를 구성하는 속성은　널(Null)값이나 중복 값을 가질 수 없다는　것을 의미하는 제약조건은?,,참조 무결성,보안 무결성,개체 무결성,정보 무결성,3,"릴레이션(관계)에서 기본 키는 해당 테이블의 각 행(튜플)을 유일하게 식별하는 속성 또는 속성들의 집합입니다.  기본 키를 구성하는 속성들은 절대 중복될 수 없고,  널(Null) 값도 가질 수 없습니다.  만약 기본 키 속성에 널 값이나 중복 값이 있다면, 각 행을 유일하게 구분할 수 없게 되어 데이터베이스의 무결성이 깨지게 됩니다.  따라서 기본 키의 널 값과 중복 값 허용 불가는 데이터베이스의 개체 무결성을 유지하기 위한 필수적인 제약 조건입니다.  개체 무결성은 데이터베이스 내의 각 개체(행)가 유일하고 정확하게 식별될 수 있도록 보장하는 것을 의미합니다.  다른 선택지들은 데이터베이스의 무결성과 관련은 있지만, 기본 키의 널 값과 중복 값 제약 조건을 직접적으로 설명하는 것은 개체 무결성입니다.",81,133
449,5,49,병행제어 기법의 종류가 아닌 것은?,,로킹 기법,시분할 기법,타임 스탬프 기법,다중 버전 기법,2,"병행 제어 기법은 여러 프로세스가 동시에 시스템 자원(메모리, 파일 등)에 접근할 때 발생하는 문제(데이터의 일관성 유지, 자원의 공유 문제 등)를 해결하기 위한 기법입니다.  로킹 기법은 특정 자원에 접근할 때 잠금 장치를 걸어 다른 프로세스의 접근을 막아 데이터의 일관성을 유지하는 방법이고, 타임 스탬프 기법은 각 프로세스에 시간 값을 부여하여 자원 접근 순서를 결정하는 방법이며, 다중 버전 기법은 여러 버전의 데이터를 유지하여 동시 접근 문제를 해결하는 방법입니다.  반면 시분할 기법은 CPU 시간을 여러 프로세스에 나누어 할당하는 기법으로, 병행 제어 자체가 아닌 프로세스 스케줄링 기법입니다. 따라서 병행 제어 기법이 아닌 것은 시분할 기법입니다.  쉽게 말해, 병행 제어는 여러 사람이 동시에 같은 문서를 편집할 때 생기는 혼란을 막는 방법이고, 시분할 기법은 여러 사람이 컴퓨터를 번갈아 사용하는 방법과 같은 차이입니다.",47,144
450,5,50,다음 R1과 R2의 테이블에서 아래의　실행 결과를 얻기 위한 SQL문은?,https://www.cbtbank.kr/images/iz/iz20210515/iz20210515m50.gif,"SELECT 과목번호, 과목이름 FROM RI, R2 WHERE R1.학번 = R2. 학번 AND R1.학과='전자공학' AND R1.이름 = '강남길’;","SELECT 과목번호, 과목이름 FROM RI, R2 WHERE R1.학번 = R2.학번 OR R1.학과='전자공학' OR R1.이름 = '홍길동';","SELECT 과목번호, 과목이름 FROM R1, R2 WHERE R1.학번 = R2.학번 AND R1.학과=‘컴퓨터공학' AND R1.이름 '강남길’;","SELECT 과목번호, 과목이름 FROM R1, R2 WHERE R1.학번 = R2.학번 OR R1.학과='컴퓨터공학' OR R1.이름 = '홍길동';",1,"이 문제는 두 개의 테이블, R1(학생 정보)과 R2(수강 정보)를 조인하여 특정 조건을 만족하는 과목 정보를 추출하는 SQL 문을 작성하는 문제입니다.  문제에서 요구하는 실행 결과는 '강남길' 학생이 수강한 과목의 과목번호와 과목이름입니다.  제공된 선택지 중 1번 쿼리만이 이 조건을 정확하게 만족합니다. 1번 쿼리는 R1 테이블과 R2 테이블을 학번을 기준으로 조인하고,  '전자공학' 과에 속하며 '강남길' 이라는 이름을 가진 학생의 정보만을 필터링하여 결과를 반환합니다. 다른 선택지는 조건이 잘못 설정되어 있어 '강남길' 학생이 수강한 과목만을 정확하게 출력하지 못합니다.  예를 들어 2번과 4번은 OR 연산자를 사용하여 조건이 너무 넓어져 원하는 결과를 얻을 수 없습니다. 3번은 '강남길' 학생이 컴퓨터공학과에 속해있다는 잘못된 가정을 하고 있습니다. 따라서 정답은 1번입니다.",72,125
451,5,51,다음 관계 대수 중 순수 관계 연산자가 아닌 것은?,,차집합(difference),프로젝트(project),조인(join),디비전 (division),1,"관계 대수는 관계형 데이터베이스를 조작하는 데 사용되는 수학적 언어입니다.  문제에서 제시된 연산자들은 모두 데이터베이스 테이블을 조작하는 데 사용되지만,  순수 관계 연산자는 테이블 간의 관계만을 이용하여 새로운 테이블을 생성하는 연산자를 의미합니다.  차집합(difference) 연산은 두 테이블에서 공통적으로 존재하지 않는 튜플(행)만을 남기는 연산입니다.  즉,  두 테이블의 내용을 비교하여 결과를 도출하는 것이지, 테이블 간의 관계 자체를 이용하는 것이 아닙니다.  반면, 프로젝트(project), 조인(join), 디비전(division) 연산은 테이블 간의 관계를 이용하여 새로운 테이블을 생성합니다.  따라서, 순수 관계 연산자가 아닌 것은 차집합입니다.",71,128
452,5,52,관계형 데이터 모델의 릴레이션에 대한 설명으로 틀린 것은?,,모든 속성 값은 원자 값을 갖는다.,한 릴레이션에 포함된 튜플은 모두 상이하다.,한 릴레이 션에 포함된 튜플 사이에는 순서가 없다.,한 릴레이션을 구성하는 속성 사이에는 순서가 존재한다.,4,"관계형 데이터 모델에서 릴레이션은 표와 같은 구조를 가지는데,  각 행은 튜플(tuple), 각 열은 속성(attribute)이라고 합니다. 문제에서 틀린 것은 4번입니다.  릴레이션을 구성하는 속성(열)들은 순서가 없습니다.  데이터베이스 시스템은 속성의 순서에 의존하지 않고, 속성의 이름으로 데이터를 접근합니다.  예를 들어, 학생 정보를 담은 릴레이션에서 '학번', '이름', '전공'이라는 속성이 있다면,  '이름', '학번', '전공' 순서로 데이터를 저장하더라도 데이터베이스는 '학번'을 통해 학생 정보에 접근할 수 있습니다.  다른 선택지들은 모두 관계형 데이터 모델의 릴레이션의 특징을 잘 나타내고 있습니다. 1번은 각 셀(속성 값)은 하나의 값만 가져야 한다는 의미이고, 2번은 중복된 행이 없어야 한다는 의미이며, 3번은 행의 순서는 중요하지 않다는 의미입니다. 따라서 4번이 관계형 데이터 모델의 릴레이션에 대한 잘못된 설명입니다.",73,127
453,5,53,"릴레이션 R의 차수가 4이고 카디널리티가 5이며, 릴레이션 S의 차수가 6이고 카디널리티가 7일 때, 두 개의 릴레이션을 카티션 프로덕트한 결과의 새로운 릴레이 션의 차수와 카디널리티는 얼마인가?",,"24, 35","24, 12","10, 35","10, 12",3,"릴레이션 R과 릴레이션 S를 카티션 프로덕트(Cartesian Product) 한다는 것은 두 릴레이션의 모든 튜플(tuple)들을 서로 조합하여 새로운 릴레이션을 만드는 것을 의미합니다.  릴레이션 R의 차수는 속성(attribute)의 개수를 나타내고, 카디널리티는 튜플의 개수를 나타냅니다.  R의 차수가 4이고 카디널리티가 5이므로 R은 4개의 속성을 가지고 5개의 튜플로 구성되어 있습니다.  마찬가지로 S의 차수는 6이고 카디널리티는 7이므로 S는 6개의 속성을 가지고 7개의 튜플로 구성되어 있습니다.",66,129
454,5,54,속성(attribute)에 대한 설명으로 틀린 것은?,,속성은 개체의 특성을 기술한다.,속성은 데이터베이스를 구성하는 가장 작은 논리적 단위이다.,속성은 파일 구조상 데이터 항목 또는 데이터 필드에 해당된다.,"속성의 수를 ""cardinality"" 라고 한다.",4,"속성(attribute)은 데이터베이스에서 특정 개체(entity)를 설명하는 특징이나 성질을 나타내는 최소 단위입니다. 예를 들어, '학생'이라는 개체가 있다면, '학생 이름', '학번', '전공' 등이 속성이 됩니다.  문제에서 1번은 속성의 정의를 잘 설명하고 있으며, 2번은 속성이 데이터베이스를 구성하는 가장 작은 논리적 단위라는 점을 정확히 지적하고 있습니다. 3번 또한 속성이 파일 구조 상의 데이터 항목이나 필드에 해당한다는 점을 설명하여 맞는 설명입니다.  하지만 4번은 틀렸습니다. 속성의 수를 나타내는 용어는 'cardinality'가 아니라 'attribute count' 또는 'number of attributes' 등으로 표현합니다. 'cardinality'는 관계 데이터베이스에서 특정 속성 값에 대응하는 개체의 수를 나타내는 용어입니다. 따라서 4번이 틀린 설명입니다.",75,129
455,5,55,다음 SQL 문에서 ( ) 안에 들어갈 내용으로 옳은 것은?,https://www.cbtbank.kr/images/iz/iz20210515/iz20210515m55.gif,SET,FROM,INTO,IN,1,"UPDATE 문은 데이터베이스의 테이블에 있는 데이터를 수정하는 SQL 명령어입니다.  문제에서 `UPDATE 인사급여 ( ) 호봉=15 WHERE 성명='홍길동';`  이라고 되어 있는데,  괄호 안에는 어떤 값을  '호봉' 컬럼에 15라는 값으로 업데이트할지 지정하는 부분입니다.  SQL에서 이러한 지정을 위해 사용하는 키워드가 바로 `SET`입니다.  `SET` 키워드 뒤에  `컬럼명 = 새로운 값` 의 형태로 수정할 내용을 명시합니다. 따라서 괄호 안에는 `SET`이 들어가야  '홍길동'이라는 성명을 가진 사람의 호봉을 15로 변경하는 SQL 문이 완성됩니다. 다른 선택지들은 SQL 문의 문법에 맞지 않습니다. `FROM`은 데이터를 가져올 테이블을 지정할 때, `INTO`는 데이터를 삽입할 때, `IN`은 조건절에서 사용됩니다.",81,125
456,5,56,관계 데이터베이스 모델에서 차수(Degree)의 의미는?,,튜플의 수,테이블의 수,데이터베이스의 수,애트리뷰트의 수,4,"관계 데이터베이스 모델에서 차수(Degree)는 테이블의 속성(Attribute) 개수를 의미합니다.  쉽게 말해, 테이블에 있는 열(column)의 개수를 말하는 것입니다. 예를 들어, 학생 정보 테이블에 학생 이름, 학번, 학과, 나이 등 네 개의 열이 있다면, 이 테이블의 차수는 4입니다.  튜플은 테이블의 행(row)을 의미하고, 데이터베이스는 여러 테이블의 집합을 의미하므로, 문제에서 묻는 차수와는 관련이 없습니다.",70,129
457,5,57,개체-관계 모델(E-R)의 그래픽 표현으로 옳지 않은 것은?,,개체타입 – 사각형,속성 - 원형,관계타입 - 마름모,연결 - 삼각형,4,"개체-관계 모델(E-R 모델)은 데이터베이스를 설계할 때 사용하는 그래픽 표현 방법입니다.  개체는 사각형, 속성은 타원형(원형이 아닌 경우도 있음), 관계는 마름모로 표현하는 것이 일반적입니다.  문제에서 4번 선택지인 '연결 - 삼각형'은 E-R 다이어그램에서 사용하지 않는 표현입니다.  개체와 관계를 연결하는 선은 단순한 선으로 표현하며,  삼각형은 E-R 다이어그램의 표준적인 요소가 아니기 때문에 옳지 않은 표현입니다.  따라서 정답은 4번입니다.",86,130
458,5,58,트랜잭션의 실행이 실패하였음을 알리는 연산자로 트랜잭션이 수행한 결과를 원래의 상태로 원상 복귀 시키는 연산은?,,COMMIT 연산,BACKUP 연산,LOG 연산,ROLLBACK 연산,4,"트랜잭션(Transaction)은 데이터베이스에서 여러 작업을 하나의 논리적 단위로 묶어서 처리하는 것을 말합니다.  예를 들어, 은행 계좌 이체를 생각해보면,  'A 계좌에서 1000원 출금'과 'B 계좌에 1000원 입금'이라는 두 가지 작업이 하나의 트랜잭션으로 묶입니다.  이때, 두 작업 중 하나라도 실패하면 전체 트랜잭션이 실패해야 데이터베이스의 일관성을 유지할 수 있습니다.  ROLLBACK 연산은 바로 이러한 상황에서 사용됩니다. 트랜잭션 실행 중 문제가 발생하여 실패하면, ROLLBACK 연산을 통해 트랜잭션이 수행했던 모든 변경 사항을 취소하고 데이터베이스를 원래 상태로 되돌립니다.  마치 '되돌리기' 기능처럼 작동하는 것이죠.  COMMIT 연산은 트랜잭션이 성공적으로 완료되었을 때 데이터베이스에 변경 사항을 영구적으로 반영하는 연산입니다.  BACKUP과 LOG는 데이터베이스 백업 및 로그 관리와 관련된 연산으로, 트랜잭션의 실패를 처리하는 직접적인 연산은 아닙니다. 따라서 트랜잭션의 실패를 알리고 원래 상태로 되돌리는 연산은 ROLLBACK입니다.",88,127
459,5,59,"데이터 속성 간의 종속성에 대한 엄밀한 고려없이 잘못 설계된 데이터베이스에서는 데이터 처리 연산 수행 시 각종 이상 현상이 발생할 수 있는데, 이러한 이상 현상이 아닌 것은?",,검색 이상,삽입 이상,삭제 이상,갱신 이상,1,"데이터베이스 설계에서 데이터 속성 간의 종속성을 제대로 고려하지 않으면 데이터를 삽입, 삭제, 갱신할 때 문제가 발생합니다.  예를 들어, 학생과 수강 과목 정보를 저장하는 데이터베이스를 생각해 봅시다.  학생 정보와 수강 과목 정보가 잘못 연결되어 있다면,  새로운 학생을 추가할 때(삽입 이상),  특정 학생의 정보를 삭제할 때(삭제 이상),  학생의 이름을 수정할 때(갱신 이상) 데이터에 불일치가 생기거나,  원치 않는 데이터가 삭제될 수 있습니다.  하지만 검색 이상은 데이터베이스의 잘못된 설계로 인해 발생하는 문제가 아니고,  데이터베이스에 존재하는 데이터를 찾는 과정에서 발생하는 문제입니다.  따라서 검색 이상은 데이터베이스 설계의 문제가 아닌, 검색 조건이나 데이터베이스의 성능 문제와 관련이 있습니다.  잘못된 설계로 인해 발생하는 이상 현상은 삽입, 삭제, 갱신 이상입니다.",73,129
460,5,60,제3정규형 (3NF)에서 BCNF(Boyce-Codd Normal Form)가 되기 위한 조건은?,,결정자가 후보키가 아닌 함수 종속 제거,이행적 함수 종속 제거,부분적 함수 종속 제거,원자값이 아닌 도메인 분해,1,"제3정규형(3NF)은 데이터 중복을 최소화하여 데이터 무결성을 높이는 정규화 과정의 한 단계입니다.  3NF는 부분적 함수 종속을 제거하는 것을 목표로 합니다.  BCNF는 3NF보다 더 강력한 정규화 형태로, 3NF의 조건을 만족하면서 추가적으로 결정자가 후보키가 아닌 함수 종속을 제거해야 합니다.  쉽게 말해, 3NF에서는 어떤 속성이 다른 속성에 의해 결정될 때, 그 결정자가 후보키가 아니어도 괜찮지만, BCNF에서는 반드시 결정자가 후보키여야 합니다.  문제에서 제시된 옵션 중 '결정자가 후보키가 아닌 함수 종속 제거'는 바로 이 BCNF의 조건을 나타냅니다. 다른 옵션들은 3NF를 만족하기 위한 조건이거나, 정규화와 관련 없는 내용입니다. 따라서 3NF에서 BCNF가 되려면 결정자가 후보키가 아닌 함수 종속을 제거해야 합니다.",76,130
461,5,61,다음 설명에 해당하는 방식은?,https://www.cbtbank.kr/images/iz/iz20210515/iz20210515m61.gif,STA,Collision Domain,CSMA/CA,CSMA/CD,3,"문제에서 설명하는 방식은 CSMA/CA(Carrier Sense Multiple Access/Collision Avoidance)입니다.  무선랜(Wi-Fi)에서 데이터를 전송할 때,  데이터를 보내기 전에 통신 채널(매체)이 비어있는지 확인하는 것을 'Carrier Sense'라고 합니다. 만약 채널이 비어있다면 데이터를 전송하지만, 채널이 사용 중이라면 충돌을 피하기 위해 임의의 시간(랜덤 백오프)을 기다린 후 다시 채널을 확인하고 전송을 시도합니다.  CSMA/CD(Carrier Sense Multiple Access/Collision Detection)와는 달리,  데이터 전송 후 충돌을 감지하는 것이 아니라, 충돌을 미리 예방하는 방식입니다.  문제에서 언급된 ""확인 신호를 전송한다""는 부분은 CSMA/CA에서 사용되는 RTS/CTS(Request to Send/Clear to Send)와 같은 제어 메커니즘을 의미합니다.  데이터 전송 전에 송신측이 RTS 신호를 보내고, 수신측이 채널이 사용 가능하면 CTS 신호를 보내 충돌을 방지하는 것입니다.  즉, CSMA/CA는 충돌을 사전에 예방하는 무선 네트워크의 접근 제어 방식입니다.",62,145
462,5,62,다음 중 가장 약한 결합도(Coupling)는?,,Common Coupling,Content Coupling,External Coupling,Stamp Coupling,4,"결합도(Coupling)는 모듈 간의 상호 의존성 정도를 나타내는 척도입니다. 결합도가 높다는 것은 모듈 간의 의존성이 강하다는 의미이며,  결합도가 낮다는 것은 모듈 간의 의존성이 약하다는 의미입니다.  문제에서 제시된 네 가지 결합도 유형 중에서 가장 약한 결합도는 Stamp Coupling입니다.",64,106
463,5,63,다음 C언어 프로그램이 실행되었을 때의 결과는?,https://www.cbtbank.kr/images/iz/iz20210515/iz20210515m63.gif,3,4,7,10,3,"이 C언어 프로그램은 비트 연산자 중 하나인 '비트 OR 연산자(|)'를 사용하고 있습니다.  비트 OR 연산은 두 피연산자의 각 비트를 비교하여, 하나라도 1이면 결과는 1, 둘 다 0이면 결과는 0이 되는 연산입니다.",62,141
464,5,64,다음 파이썬(Python) 프로그램이 실행되었을 때의 결과는?,https://www.cbtbank.kr/images/iz/iz20210515/iz20210515m64.gif,0,2,4,6,4,"이 파이썬 코드는 간단한 계산기를 만드는 예제입니다.  `FourCal`이라는 클래스를 정의하고,  `setdata` 메서드는 계산에 사용할 두 개의 숫자(fir, sec)를 저장하는 역할을 합니다. `add` 메서드는 저장된 두 숫자를 더한 결과를 반환합니다.  `a`라는 객체를 생성하고 `setdata(4, 2)`를 통해 4와 2를 저장한 후, `a.add()`를 호출하여 두 수의 합인 6을 계산하고 출력하는데, 코드에서 `sel`이라는 매개변수 이름을 사용했지만,  `self`로 수정해야 올바르게 동작합니다.  문제의 코드는 `self` 대신 `sel`을 사용하여 오류가 발생했고,  실행 결과는 6이 아닌 4가 나오는 것처럼 보이지만,  `sel`을 `self`로 수정하면 정상적으로 6이 출력됩니다.  따라서 문제의 코드는 오류가 있고,  오류를 수정하면 정답은 6이 됩니다.  하지만 문제에서 제시된 코드와 정답을 고려하면,  문제 출제자가 `self`를 `sel`로 잘못 작성했고,  그 오류를 고려하지 않고 답을 4로 설정했을 가능성이 높습니다.  만약 `sel`을 `self`로 수정하지 않고 실행하면,  `AttributeError`가 발생할 수 있습니다.  문제의 의도는 객체지향 프로그래밍의 기본 개념을 묻는 것이라고 볼 수 있습니다.",76,107
465,5,65,교착상태의 해결 방법 중 은행원 알고리즘(Banker's Algorithm)이 해당되는 기법은?,,Detection,Avoidance,Recovery,Prevention,2,"은행원 알고리즘(Banker's Algorithm)은 운영체제에서 자원 할당 문제를 다루는 알고리즘입니다.  여러 개의 프로세스가 제한된 자원을 동시에 사용하려 할 때, 교착상태(Deadlock)가 발생할 수 있는데, 이를 사전에 예방하는 기법 중 하나가 바로 교착상태 회피(Avoidance)입니다.  은행원 알고리즘은 각 프로세스가 요청할 수 있는 최대 자원량을 미리 알고, 안전하게 자원을 할당하여 교착상태 발생 가능성을 미리 차단하는 방식입니다.  즉, 자원 할당 전에 안전성 검사를 수행하여 교착상태에 빠질 가능성이 있는 자원 요청은 거부함으로써 교착상태를 회피하는 것입니다.  Detection은 교착상태가 이미 발생했는지 확인하는 것이고, Recovery는 교착상태가 발생했을 때 이를 해결하는 것이며, Prevention은 교착상태가 발생하지 않도록 사전에 조건 자체를 제거하는 것입니다. 따라서 은행원 알고리즘은 교착상태를 사전에 예방하는 Avoidance 기법에 해당합니다.",75,121
466,5,66,"CIDR(Classless Inter-Domain Routing) 표기로 203.241.132.82/27과 같이 사용되었다면, 해당 주소의 서브넷 마스크(subnet mask)는?",,255.255.255.0,255.255.255.224,255.255.255.240,255.255.255.248,2,"CIDR 표기법에서 /27은 네트워크 주소의 비트 수를 나타냅니다. IP 주소는 32비트로 구성되어 있으며, 각 비트는 0 또는 1의 값을 가집니다.  /27은 앞에서 27비트가 네트워크 주소를 나타내고, 나머지 5비트가 호스트 주소를 나타낸다는 것을 의미합니다.  서브넷 마스크는 네트워크 주소 부분을 1로, 호스트 주소 부분을 0으로 표현한 32비트 값입니다. 따라서 /27의 서브넷 마스크는 앞의 27비트가 1이고 나머지 5비트가 0인 값이 됩니다. 이를 십진수로 표현하면 255.255.255.224가 됩니다.  255.255.255.224는 2의 27승 - 1 = 134217727을 의미하며, 이는 255.255.255.224와 같습니다. 다른 선택지는 /27의 서브넷 마스크가 아닙니다.  예를 들어, /24는 255.255.255.0, /26은 255.255.255.192, /28은 255.255.255.240 입니다.",61,145
467,5,67,다음 JAVA 프로그램이 실행되었을 때의 결과는?,https://www.cbtbank.kr/images/iz/iz20210515/iz20210515m67.gif,"5, 5, 5","5, 6, 5","6, 5, 5","5, 6, 4",1,"이 JAVA 프로그램은 증감 연산자(++ 와 --)의 동작 방식을 이해하는 문제입니다.  `x++`는 후위 증가 연산자로,  먼저 x의 값을 사용한 후에 1을 증가시킵니다.  `--x`는 전위 감소 연산자로, 먼저 x의 값을 1 감소시킨 후에 그 값을 사용합니다.",64,141
468,5,68,프로세스 적재 정책과 관련한 설명으로 틀린 것은?,,"반복, 스택, 부프로그램은 시간 지역성(Temporal Locality)과 관련이 있다.",공간 지역성(Spatial Locality)은 프로세스가 어떤 페이지를 참조했다면 이후 가상주소공간상 그 페이지와 인접한 페이지들을 참조할 가능성이 높음을 의미한다.,일반적으로 페이지 교환에 보내는 시간보다 프로세스 수행에 보내는 시간이 더 크면 스레싱(Thrashing)이 발생한다.,스레싱(Thrashing) 현상을 방지하기 위해서는 각 프로세스가 필요로 하는 프레임을 제공할 수 있어야 한다.,3,"문제에서 제시된 네 가지 설명 중 틀린 것은 3번입니다.  3번은 ""일반적으로 페이지 교환에 보내는 시간보다 프로세스 수행에 보내는 시간이 더 크면 스레싱(Thrashing)이 발생한다""라고 설명하고 있는데, 이는 사실과 다릅니다. 스레싱은 프로세스가 페이지 교환에 너무 많은 시간을 소비하여 실제 작업을 거의 수행하지 못하는 현상을 말합니다.  즉, 페이지 교환 시간이 프로세스 수행 시간보다 훨씬 크기 때문에 발생하는 것입니다.  프로세스 수행 시간이 더 크다는 것은 시스템이 효율적으로 동작하고 있다는 의미이며, 스레싱과는 반대되는 상황입니다.  나머지 1, 2, 4번 설명은 프로세스 적재 정책과 관련된 지역성(Locality)과 스레싱 현상에 대한 올바른 설명입니다.  시간 지역성은 과거에 접근했던 데이터에 다시 접근할 확률이 높다는 것이고, 공간 지역성은 특정 데이터 주변의 데이터에 접근할 확률이 높다는 것입니다. 스레싱을 방지하려면 충분한 메모리를 할당하여 페이지 교환을 최소화해야 합니다.",61,144
469,5,69,프레임워크(Framework)에 대한 설명으로 옳은 것은?,,소프트웨어 구성에 필요한 기본 구조를 제공함으로써 재사용이 가능하게 해준다,소프트웨어 개발 시 구조가 잡혀 있기 때문에 확장이 불가능하다.,소프트웨어 아키텍처(Architecture)와 동일한 개념이다.,모듈화(Modularity)가 불가능하다.,1,"프레임워크는 건물의 골조와 같습니다. 건물을 지을 때 벽돌이나 기둥을 하나하나 다 만들 필요 없이, 미리 만들어진 골조(프레임워크) 위에 벽돌을 쌓고 기둥을 세우면 훨씬 빠르고 효율적으로 건물을 완성할 수 있죠. 소프트웨어 개발도 마찬가지입니다. 프레임워크는 소프트웨어를 개발할 때 필요한 기본적인 구조와 기능을 미리 제공하여 개발자가 반복적인 작업을 줄이고,  핵심적인 기능 개발에 집중할 수 있도록 도와줍니다.  따라서 소프트웨어 구성에 필요한 기본 구조를 제공하여 재사용성을 높이는 것이 프레임워크의 주요 목적입니다. 2번은 프레임워크가 기본 구조를 제공하지만,  확장성을 제한하는 것이 아니고 오히려 확장성을 용이하게 합니다. 3번은 프레임워크와 아키텍처는 관련이 있지만 동일한 개념은 아닙니다. 아키텍처는 전체 시스템의 구조를 나타내는 큰 그림이고, 프레임워크는 그 아키텍처를 구현하기 위한 구체적인 도구 및 기본 구조라고 생각하면 됩니다. 4번은 프레임워크는 오히려 모듈화를 지원하고 장려합니다.",67,106
470,5,70,다음 JAVA 프로그램이 실행되었을 때의 결과는?,https://www.cbtbank.kr/images/iz/iz20210515/iz20210515m70.gif,2,3,4,5,1,"이 JAVA 프로그램은 `cnt`라는 변수를 사용하여 반복문과 조건문을 통해 값을 변경하는 과정을 보여줍니다.  `do-while` 문은 `cnt`가 0일 때부터 시작하여 `cnt`가 0보다 작을 때까지 반복됩니다.  하지만 `cnt`는 1씩 증가하므로, `cnt < 0` 조건은 처음부터 거짓이 되어 do-while문은 단 한 번만 실행됩니다.  그 결과 `cnt`는 1이 됩니다. 이후 `if`문에서 `cnt`가 1이므로 `cnt`는 1 증가하여 2가 됩니다. 따라서 최종적으로 출력되는 `cnt`의 값은 2입니다. 문제의 정답 1은 잘못된 답변입니다.  코드의 실행 흐름을 정확히 따라가면 답은 2가 나와야 합니다.  제공된 정답 1은 오류입니다.",55,141
471,5,71,리눅스 Bash 쉘(Shell)에서 export와 관련한 설명으로 틀린 것은?,,변수를 출력하고자 할 때는 export를 사용해야 한다.,export가 매개변수 없이 쓰일 경우 현재 설정된 환경변수들이 출력된다.,사용자가 생성하는 변수는 export 명령어 표시하지 않는 한 현재 쉘에 국한된다.,변수를 export 시키면 전역(Global)변수처럼 되어 끝까지 기억된다.,1,"리눅스 Bash 쉘에서 export 명령어는 변수의 scope(영역)을 변경하는 데 사용됩니다.  쉽게 말해, 특정 변수를 현재 쉘(터미널 창)에서만 사용할지, 아니면 다른 쉘이나 자식 프로세스에서도 사용할 수 있도록 할지를 결정하는 명령어입니다.",49,144
472,5,72,다음 C언어 프로그램이 실행되었을 때의 결과는?,https://www.cbtbank.kr/images/iz/iz20210515/iz20210515m72.gif,1,11,66,98,3,"이 C언어 프로그램은 문자 'A'에 1을 더하는 연산을 수행합니다.  C언어에서 문자는 ASCII 코드 값으로 저장됩니다. 'A'의 ASCII 코드 값은 65입니다. 따라서 'A' + 1은 65 + 1 = 66이 됩니다.  `printf(""%d"", a);` 는 변수 a의 값을 10진수 정수형태로 출력하는 명령어입니다.  결과적으로 프로그램은 66을 출력합니다.  문제에서 제시된 정답 3번의 66과 일치합니다.  하지만 문제의 보기에는 66이 없고 98이라는 보기가 있는데, 이는 ASCII 코드 값을 잘못 이해하거나 문제에 오류가 있는 것으로 보입니다.  만약 'A' + 1의 결과를 문자로 출력했다면 ('B'를 출력) 다른 결과가 나왔겠지만,  `%d` 형식 지정자 때문에 정수 값인 ASCII 코드 값이 출력됩니다.",70,141
473,5,73,다음 C언어 프로그램이 실행되었을 때의 결과는?,https://www.cbtbank.kr/images/iz/iz20210515/iz20210515m73.gif,55,77,121,132,3,"이 C언어 프로그램은 2x2 크기의 2차원 배열 `a`를 선언하고, 각 원소에 값을 할당합니다.  `p` 포인터는 `a[0]`의 주소를 가리키도록 초기화됩니다.  `for` 루프는 `i`가 1부터 3까지 반복하면서 `*(p + i)`를 `sum`에 더합니다.  `*(p + i)`는 `p` 포인터가 가리키는 위치에서 `i`만큼 이동한 위치의 값을 의미합니다.  즉, 배열 `a`의 원소들을 순차적으로 접근하여 더하는 것입니다.  `a` 배열은 메모리에 연속적으로 저장되므로, `p`는 `a[0][0]`, `*(p+1)`은 `a[0][1]`, `*(p+2)`는 `a[1][0]`, `*(p+3)`는 `a[1][1]`을 가리키게 됩니다. 따라서 루프는 `a[0][1](22)`, `a[1][0](44)`, `a[1][1](55)`의 값을 더하게 되고, 최종적으로 `sum`은 22 + 44 + 55 = 121이 됩니다.  `printf` 함수는 `sum`의 값인 121을 출력합니다.",57,111
474,5,74,페이징 기법에서 페이지 크기가 작아질수록 발생하는 현상이 아닌 것은?,,기억장소 이용 효율이 증가한다.,입·출력 시간이 늘어난다.,내부 단편화가 감소한다.,페이지 맵 테이블의 크기가 감소한다.,4,"페이징 기법은 메모리에 저장된 프로그램이나 데이터를 여러 개의 작은 블록(페이지)으로 나누어 관리하는 기법입니다. 페이지 크기가 작아지면,  페이지 수는 증가하게 됩니다.  페이지 수가 증가하면,  각 페이지의 위치를 기억하는 페이지 맵 테이블의 크기도 커집니다.  또한, 작은 페이지 단위로 입출력이 이루어지므로 입출력 횟수가 증가하여 입출력 시간이 늘어나고,  기억장소 이용 효율은 페이지 크기가 작을수록 떨어집니다.  내부 단편화는 페이지 크기가 클수록 심해지므로, 페이지 크기가 작아지면 내부 단편화는 감소합니다. 따라서 페이지 크기가 작아질수록 발생하는 현상이 아닌 것은 페이지 맵 테이블의 크기가 감소하는 것입니다.  페이지 맵 테이블은 페이지의 위치 정보를 저장하는 테이블이므로, 페이지 수가 증가하면 테이블의 크기도 커집니다.",54,144
475,5,75,다음 중 가장 강한 응집도(Cohesion)는?,,Sequential Cohesion,Procedural Cohesion,Logical Cohesion,Coincidental Cohesion,1,"응집도(Cohesion)는 모듈 내부 요소들의 관련성을 나타내는 척도입니다.  응집도가 높다는 것은 모듈 내부 요소들이 서로 밀접하게 관련되어 하나의 목적을 위해 함께 동작한다는 의미이며,  낮다는 것은 요소들 간의 관련성이 낮아 모듈의 기능이 모호하고 유지보수가 어렵다는 것을 의미합니다.  문제에서 제시된 네 가지 응집도 유형 중에서 Sequential Cohesion(순차적 응집도)는 하나의 작업을 수행하기 위해 순차적으로 실행되는 여러 요소들로 구성되어 있습니다.  각 요소는 이전 요소의 결과를 입력으로 받아 다음 요소의 실행에 영향을 미치는 밀접한 관계를 갖습니다.  반면, Procedural Cohesion(절차적 응집도)는 여러 요소들이 순서대로 실행되지만, 각 요소 간의 연관성이 순차적 응집도보다 약합니다.  Logical Cohesion(논리적 응집도)은 여러 요소들이 비슷한 기능을 수행하지만, 서로 독립적으로 실행될 수 있습니다.  Coincidental Cohesion(우연적 응집도)는 요소들 간에 아무런 관련성이 없는 경우입니다. 따라서, 요소 간의 관련성이 가장 높은 것은 Sequential Cohesion입니다.  정보처리기사 시험에서는 모듈 설계의 중요한 개념으로 응집도와 결합도를 다루며, 높은 응집도와 낮은 결합도를 갖도록 설계하는 것이 중요하다고 강조합니다.",56,106
476,5,76,TCP 프로토콜과 관련한 설명으로 틀린 것은?,,인접한 노드 사이의 프레임 전송 및 오류를 제어한다.,흐름 제어(Flow Control)의 기능을 수행한다.,전이 중(Full Duplex) 방식의 양방향 가상회선을 제공한다.,전송 데이터와 응답 데이터를 함께 전송할 수 있다.,1,"TCP(Transmission Control Protocol)는 인터넷에서 데이터를 안정적으로 전송하기 위한 프로토콜입니다.  문제에서 틀린 것은 1번입니다.  1번은 ""인접한 노드 사이의 프레임 전송 및 오류를 제어한다""라고 되어 있는데, TCP는  **인접한 노드**가 아니라 **네트워크 상의 여러 노드** 사이에서 데이터를 전송하고 오류를 제어합니다.  TCP는 IP(Internet Protocol) 위에서 동작하며, IP는 노드 간 패킷 전달을 담당하고, TCP는 그 위에서 신뢰성 있는 데이터 전송을 보장합니다.  즉, TCP는 프레임 단위가 아닌, **세그먼트(segment)** 단위로 데이터를 전송하고 오류를 제어합니다.  나머지 2, 3, 4번은 모두 TCP의 특징을 정확하게 나타내고 있습니다. 2번은 흐름 제어를 통해 데이터 손실 없이 효율적인 전송을 보장하고, 3번은 양방향 통신을 지원하며, 4번은 데이터와 응답을 순차적으로 주고받는 방식으로 동작합니다. 따라서 1번이 틀린 설명입니다.",44,145
477,5,77,C언어에서 연산자 우선순위가 높은 것에서 낮은 것으로 바르게 나열된 것은?,https://www.cbtbank.kr/images/iz/iz20210515/iz20210515m77.gif,"㉠, ㉥, ㉣, ㉢, ㉡, ㉤","㉠, ㉣, ㉥, ㉢, ㉡, ㉤","㉠, ㉣, ㉥, ㉢, ㉤, ㉡","㉠, ㉥, ㉣, ㉤, ㉡, ㉢",1,"C언어에서 연산자의 우선순위는 연산이 수행되는 순서를 결정합니다.  우선순위가 높은 연산자는 낮은 우선순위 연산자보다 먼저 계산됩니다.  괄호 `()`는 가장 높은 우선순위를 가지며, 계산 순서를 명시적으로 지정할 수 있습니다.  그 다음으로는 산술 연산자(`/`, `*`, `%`, `+`, `-`)와 비트 연산자(`<<`, `>>`, `&`, `|`, `^`) 등이 높은 우선순위를 가지고, 비교 연산자(`==`, `!=`, `>`, `<`, `>=`, `<=`)는 그보다 낮은 우선순위를 가집니다. 논리 연산자(`&&`, `||`)는 가장 낮은 우선순위를 가지며,  왼쪽에서 오른쪽으로 순차적으로 계산됩니다.  문제에서 제시된 연산자들을 우선순위 순서대로 나열하면, 괄호 `()`가 가장 높고, 그 다음 비트 시프트 연산자 `<<`, 비교 연산자 `==`, 논리 OR 연산자 `||`, 비교 연산자 `<`, 나눗셈 연산자 `/` 순서가 됩니다. 따라서 정답은 1번 ㉠, ㉥, ㉣, ㉢, ㉡, ㉤ 입니다.  각 괄호 안의 연산은 먼저 계산되고, 비트 연산, 비교 연산, 논리 연산 순으로 계산됩니다.",48,141
478,5,78,C언어 라이브러리 중 stdlib.h에 대한설명으로 옳은 것은?,,문자열을 수치 데이터로 바꾸는 문자 변환함수와 수치를 문자열로 바꿔주는 변환함수 등이 있다.,문자열 처리 함수로 strlen()이 포함되어 있다.,표준 입출력 라이브러리이다.,"삼각 함수, 제곱근, 지수 등 수학적인 함수를 내장하고 있다.",1,"C언어에서 stdlib.h는 표준 라이브러리 헤더 파일 중 하나입니다.  이 헤더 파일에는 다양한 유용한 함수들이 포함되어 있는데, 그 중에서도 문자열을 숫자로, 숫자를 문자열로 변환하는 기능을 제공하는 함수들이 중요한 역할을 합니다.  예를 들어, 사용자가 입력한 숫자를 나타내는 문자열을 실제 숫자로 바꾸거나, 계산 결과로 얻은 숫자를 문자열 형태로 출력하고자 할 때 stdlib.h에 정의된 함수들을 사용합니다.  따라서 1번 선택지 ""문자열을 수치 데이터로 바꾸는 문자 변환함수와 수치를 문자열로 바꿔주는 변환함수 등이 있다""가 정답입니다.  2번은 string.h에 있는 함수이고, 3번은 stdio.h, 4번은 math.h에 해당하는 설명입니다.",55,143
479,5,79,자바스크립트(JavaScript)와 관련한 설명으로 틀린 것은? (문제 오류로 가답안 발표시 2번으로 발표되었지만 확정 답안 발표시 모두 정답처리 되었습니다. 여기서는 가답안인 2번을 누르면 정답 처리 됩니다.),,프로토타입(Prototype)의 개념이 존재한다.,클래스 기반으로 객체 상속을 지원한다.,Prototype Link와 Prototype Object를 활용할 수 있다.,객체지향 언어이다.,2,"자바스크립트는 객체지향 언어이지만, 클래스 기반의 상속을 직접적으로 지원하지 않는다는 점이 핵심입니다.  자바나 C++과 같은 언어는 클래스를 명시적으로 정의하고 상속을 통해 클래스의 속성과 메서드를 다른 클래스에 물려줄 수 있습니다. 하지만 자바스크립트는 프로토타입 기반의 상속을 사용합니다.  프로토타입이란 객체의 원형으로, 새로운 객체를 생성할 때 이 프로토타입을 기반으로 객체가 생성되고, 프로토타입의 속성과 메서드를 상속받습니다.  따라서 2번 문항 ""클래스 기반으로 객체 상속을 지원한다""는 자바스크립트의 특징과 맞지 않아 틀린 설명입니다.  1, 3, 4번은 자바스크립트의 프로토타입 기반 객체지향 프로그래밍 특징을 정확하게 설명하고 있습니다.  가답안으로 2번이 제시된 이유는 자바스크립트의 프로토타입 기반 상속이 클래스 기반 상속과 개념적으로 다르기 때문에, 클래스 기반 상속이라는 표현이 다소 모호하게 느껴질 수 있기 때문일 것입니다. 하지만 자바스크립트는 ES6(ECMAScript 2015)부터 클래스 문법을 도입하여 클래스처럼 보이는 문법을 제공하지만, 내부적으로는 여전히 프로토타입 기반으로 동작합니다.",83,107
480,5,80,OSI 7계층 중 네트워크 계층에 대한 설명으로 틀린 것은?,,패킷을 발신지로부터 최종 목적지까지 전달하는 책임을 진다.,한 노드로부터 다른 노드로 프레임을 전송하는 책임을 진다.,패킷에 발신지와 목적지의 논리 주소를 추가한다.,라우터 또는 교환기는 패킷 전달을 위해 경로를 지정하거나 교환 기능을 제공한다.,2,"OSI 7계층 중 네트워크 계층은 데이터를 논리적인 주소(IP 주소)를 이용하여 목적지까지 전달하는 역할을 합니다.  문제에서 틀린 것은 2번입니다. 네트워크 계층은 프레임을 다루지 않습니다. 프레임은 데이터링크 계층에서 다루는 단위입니다. 네트워크 계층은 데이터링크 계층으로부터 받은 데이터를 패킷으로 묶어 IP 주소를 추가하고, 라우터나 스위치를 통해 목적지까지 전달하는 역할을 합니다.  1번은 네트워크 계층의 주요 기능을 정확하게 설명하고 있으며, 3번은 IP 주소를 추가하는 네트워크 계층의 중요한 역할을 보여줍니다. 4번은 라우터와 스위치가 네트워크 계층에서 패킷 전달을 위해 어떻게 작동하는지 설명합니다. 따라서 2번만이 네트워크 계층의 기능과 일치하지 않습니다.",53,145
481,5,81,다음 내용이 설명하는 것은?,https://www.cbtbank.kr/images/iz/iz20210515/iz20210515m81.gif,SAN,MBR,NAC,NIC,1,"문제에서 설명하는 것은 SAN(Storage Area Network)입니다. SAN은 여러 서버가 공유하는 고속의 저장장치 네트워크입니다.  문제에서 언급된 ""광채널 스위치의 이점인 고속 전송과 장거리 연결 및 멀티 프로토콜 기능""은 SAN의 핵심적인 특징을 나타냅니다. 광채널 스위치는 SAN에서 데이터를 빠르게 전송하고, 멀리 떨어진 서버들도 연결하며, 다양한 프로토콜을 지원하는 역할을 합니다. 또한, ""각기 다른 운영체제를 가진 여러 기종들이 네트워크상에서 동일 저장장치의 데이터를 공유하게 함으로써, 여러 개의 저장장치나 백업 장비를 단일화시킨 시스템""이라는 설명은 SAN이 여러 서버의 저장장치를 통합 관리하여 효율성을 높이는 기능을 강조하고 있습니다.  즉, SAN은 여러 서버가 공통으로 사용하는 고성능 저장장치 네트워크를 구축하여 데이터 저장 및 관리의 효율성을 높이는 기술입니다.  다른 보기들은 네트워크와 관련된 용어이지만, 문제에서 설명하는 시스템의 특징과는 부합하지 않습니다. MBR(Master Boot Record)은 하드디스크의 부팅 정보를 담고 있는 영역이고, NAC(Network Access Control)는 네트워크 접근 제어 시스템이며, NIC(Network Interface Card)는 네트워크 인터페이스 카드입니다.",57,151
482,5,82,SSH(Secure Shell)에 대한 설명으로 틀린 것은?,,SSH의 기본 네트워크 포트는 220번을 사용한다,전송되는 데이터는 암호화 된다.,키를 통한 인증은 클라이언트의 공개키를 서버에 등록해야 한다.,서로 연결되어 있는 컴퓨터 간 원격 명령실행이나 셀 서비스 등을 수행한다.,1,"SSH(Secure Shell)는 원격 컴퓨터에 안전하게 접속하여 명령을 실행하거나 파일을 전송하는 데 사용되는 프로토콜입니다.  1번 보기는 SSH의 기본 포트 번호가 22번이라는 것을 잘못 기술하고 있습니다.  SSH는 22번 포트를 기본적으로 사용하며, 다른 포트를 사용하도록 설정할 수 있지만, 일반적으로 22번 포트를 사용합니다. 2번 보기는 SSH가 데이터를 암호화하여 전송하기 때문에 안전하게 통신할 수 있다는 것을 설명하고 있으며, 이는 사실입니다. 3번 보기는 키 기반 인증을 설명하고 있는데, 키 기반 인증을 사용하려면 클라이언트의 공개키를 서버에 등록해야 합니다. 이 또한 사실입니다. 4번 보기는 SSH의 주요 기능인 원격 명령 실행 및 파일 전송 등을 설명하고 있으며, 이 역시 사실입니다. 따라서 1번 보기만 틀린 설명입니다.",68,145
483,5,83,CBD(Component Based Development) SW개발 표준 산출물 중 분석 단계에 해당하는 것은?,,클래스 설계서,통합시험 결과서,프로그램 코드,사용자 요구사항 정의서,4,"CBD(Component Based Development)는 구성요소 기반 개발 방식으로, 미리 만들어 놓은 소프트웨어 구성요소들을 조립하여 새로운 시스템을 만드는 개발 방법입니다.  문제에서 묻고 있는 것은 분석 단계에 해당하는 산출물입니다. 분석 단계는 시스템 개발의 초기 단계로, 사용자의 요구사항을 파악하고 시스템의 기능과 성능을 정의하는 단계입니다.  따라서 분석 단계의 산출물은 사용자의 요구사항을 명확하게 기술한 문서가 되어야 합니다.  제시된 선택지 중 '사용자 요구사항 정의서'는 사용자의 요구를 문서화한 산출물이므로 분석 단계에 해당하는 산출물입니다.  반면, 클래스 설계서, 프로그램 코드, 통합시험 결과서는 설계, 구현, 테스트 단계의 산출물입니다.",61,102
484,5,84,다음 내용이 설명하는 접근 제어 모델은?,https://www.cbtbank.kr/images/iz/iz20210515/iz20210515m84.gif,Clark-Wilson Integrity Model,PDCA Model,Bell-Lapadula Model,Chinese Wall Model,3,"문제에서 설명하는 접근 제어 모델은 Bell-Lapadula 모델입니다.  Bell-Lapadula 모델은 군사 시스템의 보안을 위해 개발된 모델로, 정보의 기밀성을 중시합니다.  마치 군대의 보안 등급처럼 정보에 보안 레벨을 부여하고,  사용자에게도 특정 보안 레벨을 할당합니다.  핵심 원칙은 ""읽기 접근 제어""와 ""쓰기 접근 제어""로 구성됩니다.  ""읽기 접근 제어""는 자신의 보안 레벨보다 높은 레벨의 정보에는 접근할 수 없다는 것을 의미하고, ""쓰기 접근 제어""는 자신의 보안 레벨보다 낮은 레벨의 정보에는 쓸 수 없다는 것을 의미합니다. 문제에서 언급된 ""자신의 권한보다 낮은 보안 레벨 권한을 가진 경우에는 높은 보안 레벨의 문서를 읽을 수 없고 자신의 권한보다 낮은 수준의 문서만 읽을 수 있다""는 내용은 읽기 접근 제어를, ""자신의 권한보다 높은 보안 레벨의 문서에는 쓰기가 가능하지만 보안레벨이 낮은 문서의 쓰기 권한은 제한한다""는 내용은 쓰기 접근 제어를 설명합니다.  즉,  높은 보안 레벨의 정보를 가진 사용자는 낮은 레벨의 정보에도 접근할 수 있지만, 낮은 레벨의 사용자는 높은 레벨의 정보에 접근할 수 없도록 제한하는 계층적인 접근 제어 방식입니다.  이러한 특징은 문제에서 설명하는 내용과 정확히 일치합니다.",58,153
485,5,85,하둡(Hadoop)과 관계형 데이터베이스간에 데이터를 전송할 수 있도록 설계된 도구는?,,Apnic,Topology,Sqoop,SDB.,3,"Hadoop은 대량의 데이터를 분산 처리하는 오픈소스 프레임워크이고, 관계형 데이터베이스(RDBMS)는 MySQL, Oracle과 같이 데이터를 테이블 형태로 체계적으로 관리하는 데이터베이스 시스템입니다.  Hadoop과 RDBMS는 데이터를 저장하고 관리하는 방식이 다르기 때문에 서로 데이터를 주고받으려면 특별한 도구가 필요합니다.  Sqoop은 바로 이러한 역할을 하는 도구로, Hadoop과 관계형 데이터베이스 간의 데이터를 효율적으로 가져오고 내보낼 수 있도록 설계되었습니다.  쉽게 말해, Sqoop을 이용하면 Hadoop에 저장된 방대한 데이터를 RDBMS로 옮기거나, RDBMS에 있는 데이터를 Hadoop으로 옮길 수 있습니다.  문제에서 제시된 다른 선택지는 Hadoop과 관계형 데이터베이스 간의 데이터 전송과는 직접적인 관련이 없습니다.",73,135
486,5,86,라우팅 프로토콜인 OSPF(Open Shortest Path First)에 대한 설명으로 옳지 않은 것은?,,네트워크 변화에 신속하게 대처할 수 있다.,거리 벡터 라우팅 프로토콜이라고 한다.,멀티캐스팅을 지원한다.,최단 경로 탐색에 Dijkstra 알고리즘을 사용한다.,2,"OSPF는 링크 상태 라우팅 프로토콜입니다.  링크 상태 라우팅은 네트워크의 전체적인 토폴로지(구조)를 파악하여 최단 경로를 계산하는 방식입니다.  반면, 거리 벡터 라우팅은 각 라우터가 이웃 라우터에게 자신의 거리 정보만을 알려주고, 이 정보를 바탕으로 각 라우터가 최단 경로를 계산합니다.  문제에서 2번 보기는 OSPF를 거리 벡터 라우팅 프로토콜이라고 잘못 설명하고 있습니다. OSPF는 네트워크의 전체적인 토폴로지를 파악하기 때문에 네트워크 변화에 신속하게 대처할 수 있으며, Dijkstra 알고리즘을 사용하여 최단 경로를 계산합니다. 또한, 멀티캐스팅을 지원하여 효율적인 통신을 가능하게 합니다. 따라서 정답은 2번입니다.",49,149
487,5,87,소프트웨어 비용 추정 모형(estimation models)이 아닌 것은?,,COCOMO,Putnam,Function-Point,PERT,4,"이 문제는 소프트웨어 개발 비용을 추정하는 다양한 모델 중에서 어떤 것이 **아닌지** 묻고 있습니다.  COCOMO, Putnam, Function-Point는 모두 소프트웨어 개발 비용을 추정하는 데 사용되는 대표적인 모델입니다.  COCOMO는 코드의 크기와 개발자의 경험 등을 고려하여 비용을 추정하고, Putnam은 개발 기간과 인력을 예측하여 비용을 산정하며, Function-Point는 소프트웨어의 기능 점수를 기반으로 비용을 추정합니다.  반면 PERT(Program Evaluation and Review Technique)는 프로젝트의 일정 관리 및 위험 관리에 사용되는 기법으로, 소프트웨어 비용 추정 모델이 아닙니다.  PERT는 각 작업의 완료 시간을 확률적으로 예측하고, 전체 프로젝트의 완료 시간과 비용을 추정하는 데 사용되지만, 소프트웨어의 기능이나 코드 크기와 직접적으로 연관되어 비용을 추정하는 모델은 아닙니다. 따라서 정답은 4번 PERT입니다.",67,147
488,5,88,"코드의 기입 과정에서 원래 '12536‘으로 기입되어야 하는데 ’12936‘으로 표기되었을 경우, 어떤 코드 오류에 해당하는가?",,Addition Error,Omission Error,Sequence Error,Transcription Error,4,"문제에서 '12536'이라는 코드가 '12936'으로 잘못 기입되었다는 것은, 숫자 '5'가 '9'로 잘못 기록되었다는 것을 의미합니다.  이는 원래 코드의 내용을 정확하게 복사하지 못하고, 다른 숫자로 바꿔서 기록한 오류입니다.  즉, 코드의 내용 자체가 잘못 기록된 '전사 오류(Transcription Error)'에 해당합니다.  Addition Error는 덧셈 오류, Omission Error는 누락 오류, Sequence Error는 순서 오류를 의미하는데, 이 문제의 경우에는 숫자 자체가 잘못 기록되었으므로 전사 오류가 가장 적절한 설명입니다. 정보처리기사 시험에서는 이러한 코드 오류의 종류를 정확하게 이해하고 있어야 합니다.",57,154
489,5,89,ISO 12207 표준의 기본 생명주기의 주요 프로세스에 해당하지 않는 것은?,,획득 프로세스,개발 프로세스,성능평가 프로세스,유지보수 프로세스,3,"ISO 12207은 소프트웨어 생명주기 프로세스에 대한 국제 표준입니다.  소프트웨어를 개발하고 유지보수하는 전 과정을 표준화하여 효율성과 품질을 높이기 위한 목적으로 만들어졌습니다.  문제에서 제시된 1번 획득 프로세스, 2번 개발 프로세스, 4번 유지보수 프로세스는 모두 소프트웨어의 생명주기에서 중요한 단계입니다.  획득 프로세스는 소프트웨어를 구매하거나 개발 의뢰하는 과정을, 개발 프로세스는 소프트웨어를 설계하고 구현하는 과정을, 유지보수 프로세스는 개발된 소프트웨어를 유지하고 개선하는 과정을 의미합니다.  반면 3번 성능평가 프로세스는 소프트웨어의 생명주기 *전반에 걸쳐* 수행될 수 있는 활동이지, 생명주기의 *독립적인 주요 프로세스*로 분류되지는 않습니다.  성능 평가는 개발 단계에서도, 유지보수 단계에서도, 심지어 획득 단계에서도 필요한 활동이기 때문에 ISO 12207의 기본 생명주기의 주요 프로세스로 분류되지 않습니다. 따라서 정답은 3번입니다.",34,147
490,5,90,"소프트웨어 비용 산정 기법 중 개발 유형으로 organic, semi-detached, embedded로 구분되는 것은?",,PUTNAM,COCOMO,FP,SLIM,2,"소프트웨어 비용 산정 기법 중 COCOMO(Constructive Cost Model) 모델은 소프트웨어 개발 규모와 복잡도에 따라 비용을 산정하는 방법입니다.  COCOMO는 개발 유형을 크게 Organic(소규모, 잘 정의된 프로젝트), Semi-detached(중간 규모, 일부 요구사항이 불확실한 프로젝트), Embedded(대규모, 실시간 시스템 등 복잡한 프로젝트) 세 가지로 나누어 각 유형에 맞는 비용 산정 공식을 적용합니다.  문제에서 언급된 Organic, Semi-detached, Embedded는 바로 COCOMO 모델에서 사용하는 개발 유형 분류 방식입니다.  따라서 정답은 2번 COCOMO입니다.  다른 선택지들은 소프트웨어 비용 산정 기법이지만,  Organic, Semi-detached, Embedded라는 개발 유형 분류를 사용하지 않습니다.",83,147
491,5,91,SPICE 모델의 프로세스 수행능력 수준의 단계별 설명이 틀린 것은?,,수준 7 - 미완성 단계,수준 5 - 최적화 단계,수준 4 - 예측 단계,수준 3 - 확립 단계,1,"SPICE(Software Process Improvement and Capability dEtermination) 모델은 소프트웨어 개발 프로세스의 성숙도를 평가하는 국제 표준 모델입니다.  문제에서 제시된 프로세스 수행능력 수준은 소프트웨어 개발 조직의 프로세스가 얼마나 잘 정의되고, 관리되고, 실행되는지를 나타내는 단계를 의미합니다.  각 수준은 특정한 능력을 보여야 합니다.  수준 7이 ""미완성 단계""라는 것은 잘못된 설명입니다. SPICE 모델은 일반적으로 1~5레벨까지를 사용하며, 7레벨은 존재하지 않습니다.  수준 1부터 5까지는 각각 초기, 관리, 정의, 정량화, 최적화 단계를 나타내며, 수준이 높아질수록 프로세스의 성숙도가 높아짐을 의미합니다. 따라서 1번 선택지가 틀린 설명입니다. 다른 선택지는 SPICE 모델의 일반적인 수준 설명과 일치합니다.",71,147
492,5,92,"PC, TV, 휴대폰에서 원하는 콘텐츠를 끊김없이 자유롭게 이용할 수 있는 서비스는?",,Memristor,MEMS,SNMP,N-Screen,4,"PC, TV, 휴대폰 등 다양한 기기에서 원하는 콘텐츠를 시간과 장소에 구애받지 않고 끊김 없이 이용할 수 있는 서비스를 N-Screen 서비스라고 합니다.  N은 여러 개를 의미하는데,  여러 종류의 기기(N개의 화면)에서 동일한 콘텐츠를 이용할 수 있다는 의미입니다. 예를 들어, 집에서는 TV로 영화를 보다가, 출퇴근길에는 휴대폰으로 같은 영화를 이어서 볼 수 있는 것이 N-Screen 서비스의 대표적인 예시입니다.  따라서, 문제에서 제시된 상황은 N-Screen 서비스를 가장 잘 설명하고 있습니다.  Memristor, MEMS, SNMP는 각각 메모리 소자, 초소형 기계 시스템, 네트워크 관리 프로토콜을 의미하며, 문제의 상황과는 직접적인 관련이 없습니다.",71,149
493,5,93,해쉬(Hash) 기법에 대한 설명으로 틀린 것은?,,임의의 길이의 입력 데이터를 받아 고정된 길이의 해쉬 값으로 변환한다.,주로 공개키 암호화 방식에서 키 생성을 위해 사용한다.,"대표적인 해쉬 알고리즘으로 HAVAL, SHA-1 등이 있다.",해쉬 함수는 일방향 함수(One-way function)이다.,2,"해쉬(Hash) 기법은 임의의 길이를 가진 데이터를 고정된 길이의 해쉬 값으로 변환하는 일방향 함수입니다.  쉽게 말해, 아무리 긴 문서라도 해쉬 함수에 넣으면 특정 길이의 암호 같은 값(해쉬 값)이 나오는 것이죠.  그리고 중요한 점은 이 과정이 일방향이라는 것입니다.  해쉬 값을 알고 있다고 해서 원래 데이터를 알아낼 수 없습니다.  마치 계란을 깨뜨리는 것은 쉽지만, 깨진 계란을 다시 원래대로 조립하는 것은 불가능한 것과 같습니다.  문제의 2번 선택지가 틀린 이유는 해쉬 기법은 주로 데이터 무결성 검증이나 디지털 서명 등에 사용되며, 공개키 암호화 방식의 키 생성에는 사용되지 않습니다. 공개키 암호화 방식의 키 생성에는 다른 알고리즘이 사용됩니다.  따라서 해쉬 기법은 데이터의 무결성을 확인하거나, 데이터의 크기가 큰 경우 데이터베이스에서 빠르게 검색하는 데 유용하게 사용됩니다.",50,121
494,5,94,IPSec(IP Security)에 대한 설명으로 틀린 것은?,,암호화 수행시 일방향 암호화만 지원한다.,"ESP는 발신지 인증, 데이터 무결성, 기밀성 모두를 보장한다.",운영 모드는 Tunnel 모드와 Transport 모드로 분류된다.,"AH는 발신지 호스트를 인증하고, IP 패킷의 무결성을 보장한다.",1,"IPSec(IP Security)는 IP 패킷을 암호화하고 인증하여 네트워크 통신의 보안을 강화하는 프로토콜입니다.  문제에서 틀린 것은 1번입니다. IPSec은 암호화를 수행할 때,  일방향 암호화(해시 함수처럼 복호화가 불가능한 암호화)만 사용하는 것이 아니라,  양방향 암호화(암호화된 데이터를 다시 원래대로 복호화할 수 있는 암호화)도 지원합니다.  대칭키 암호화나 비대칭키 암호화를 모두 사용할 수 있습니다.  나머지 보기들은 모두 IPSec의 특징을 정확하게 설명하고 있습니다. ESP(Encapsulating Security Payload)는 데이터의 기밀성, 무결성, 발신지 인증을 모두 제공하며, AH(Authentication Header)는 발신지 인증과 데이터 무결성을 보장합니다.  Tunnel 모드와 Transport 모드는 IPSec의 두 가지 운영 모드입니다. 따라서 1번이 틀린 설명입니다.",68,155
495,5,95,메모리상에서 프로그램의 복귀 주소와 변수 사이에 특정 값을 저장해 두었다가 그 값이 변경되었을 경우 오버플로우 상태로 가정하여 프로그램 실행을 중단하는 기술은?,,Stack Guard,Bridge,ASLR,FIN,1,"프로그램이 실행될 때,  메모리에는 프로그램의 실행 순서를 기록하는 스택이라는 영역이 존재합니다.  함수를 호출하면 복귀 주소(함수가 끝난 후 돌아갈 위치)가 스택에 저장되고, 함수 내에서 사용하는 변수들도 스택에 저장됩니다.  Stack Guard는 이 스택 영역에 복귀 주소와 변수 사이에 특정 값(canary 값)을 미리 저장해두는 기술입니다.  만약 프로그램에 버퍼 오버플로우와 같은 보안 취약점이 존재하여 변수 영역에 저장된 데이터가 스택 영역을 넘어 복귀 주소를 덮어쓰게 되면,  canary 값이 변경됩니다.  Stack Guard는 프로그램 실행 중에 이 canary 값을 주기적으로 검사하여 값이 변경되었는지 확인하고, 변경되었다면(즉, 오버플로우가 발생했다면) 프로그램 실행을 중단시켜 보안 위협을 방지합니다.  마치 성문 앞에 경비병을 세워두고 침입자를 감지하는 것과 같은 원리입니다.",79,144
496,5,96,침입차단 시스템(방화벽) 중 다음과 같은 형태의 구축 유형은?,https://www.cbtbank.kr/images/iz/iz20210515/iz20210515m96.gif,Block Host,Tree Host,Screened Subnet,Ring Homed,3,"침입차단 시스템(방화벽) 구축 유형 중 'Screened Subnet'은 내부 네트워크를 외부 네트워크로부터 보호하기 위해 하나 이상의 방화벽을 사용하는 구조입니다.  외부 네트워크와 직접 연결되지 않은, 하나 이상의 방화벽으로 보호되는 중간 영역(Subnet)을 두어 내부 네트워크의 보안을 강화하는 방식입니다.  마치 성의 해자와 같은 역할을 하는 것이죠.  외부에서 내부 네트워크로 접근하려면 두 개 이상의 방화벽을 통과해야 하므로 보안성이 높아집니다.  반면, Block Host는 단일 호스트를 방화벽으로 보호하는 단순한 구조이고, Tree Host는 여러 호스트를 계층적으로 보호하는 구조, Ring Homed는 특정한 토폴로지(네트워크 구조)를 의미하는 용어로, 문제에서 제시된 그림과는 일치하지 않습니다. 따라서 문제의 그림은 Screened Subnet 방식의 방화벽 구축 유형을 나타냅니다.",50,155
497,5,97,Secure OS의 보안 기능으로 거리가 먼 것은?,,식별 및 인증,임의적 접근 통제,고가용성 지원,강제적 접근 통제,3,"Secure OS(보안 운영체제)는 시스템의 보안을 강화하기 위해 다양한 기능을 제공합니다.  문제에서 제시된 1번 식별 및 인증, 2번 임의적 접근 통제, 4번 강제적 접근 통제는 모두 Secure OS의 핵심적인 보안 기능입니다.  식별 및 인증은 시스템에 접근하려는 사용자의 신원을 확인하는 과정이고, 임의적 접근 통제와 강제적 접근 통제는  자원에 대한 접근 권한을 제어하는 기능입니다.  하지만 3번 고가용성 지원은 시스템의 안정적인 운영을 보장하는 기능이지, 직접적으로 시스템의 보안을 강화하는 기능은 아닙니다. 고가용성은 시스템이 장애 없이 지속적으로 작동하도록 하는 데 초점을 맞추며,  보안 기능은 시스템에 대한 무단 접근이나 데이터 유출을 방지하는 데 초점을 맞춥니다. 따라서 Secure OS의 보안 기능과는 거리가 먼 것은 고가용성 지원입니다.",75,151
498,5,98,서버에 열린 포트 정보를 스캐닝해서 보안취약점을 찾는데 사용하는 도구는?,,type,mkdir,ftp,nmap,4,"서버의 보안 취약점을 찾는 과정에서 열려있는 포트를 확인하는 것은 매우 중요합니다.  열려있는 포트는 공격자가 시스템에 침입할 수 있는 경로를 제공하기 때문입니다.  nmap은 네트워크 스캐닝 도구로,  특정 서버의 열려있는 포트들을 확인하고,  그 포트들이 어떤 서비스를 제공하는지 파악하는 데 사용됩니다.  따라서 nmap을 이용하여 열려있는 포트를 확인하고,  알려진 보안 취약점이 있는 포트가 열려있는지 확인하면 서버의 보안 취약점을 찾을 수 있습니다.  반면,  type, mkdir, ftp는 파일이나 디렉토리를 다루는 명령어이거나 파일 전송 프로토콜이므로 서버의 열린 포트를 스캐닝하는 데 사용되지 않습니다.",68,156
499,5,99,서로 다른 네트워크 대역에 있는 호스트들 상호간에 통신할 수 있도록 해주는 네트워크 장비는?,,L2 스위치,HIPO,라우터,RAD.,3,"서로 다른 네트워크 대역에 있는 호스트는 서로 다른 네트워크 주소를 가지고 있습니다.  예를 들어, 회사 내부 네트워크와 인터넷은 서로 다른 대역에 속합니다.  이처럼 서로 다른 네트워크 대역에 있는 호스트들이 통신하려면,  네트워크 주소를 해석하고 경로를 찾아 데이터를 전달해주는 장비가 필요합니다.  이 역할을 하는 것이 바로 라우터입니다.  라우터는 각 네트워크의 주소 체계를 이해하고,  데이터 패킷을 목적지 네트워크로 전달하는 경로를 결정하여 통신을 가능하게 합니다.  반면 L2 스위치는 같은 네트워크 내의 통신을 담당하며,  HIPO는 하드웨어와 소프트웨어의 상호작용을 나타내는 도구이고, RAD는 신속한 애플리케이션 개발 방법론입니다. 따라서 서로 다른 네트워크 대역 간의 통신을 가능하게 하는 장비는 라우터입니다.",79,149
500,5,100,암호화 키와 복호화 키가 동일한 암호화 알고리즘은?,,RSA,AES,DSA,ECC,2,"암호화는 정보를 다른 사람이 이해할 수 없도록 변환하는 과정이고, 복호화는 암호화된 정보를 다시 원래대로 돌리는 과정입니다.  암호화 키와 복호화 키가 동일한 암호화 알고리즘을 대칭키 암호화 알고리즘이라고 합니다.  반대로, 키가 다른 것을 비대칭키 암호화 알고리즘이라고 합니다.  문제에서 제시된 옵션 중 AES(Advanced Encryption Standard)는 대표적인 대칭키 암호화 알고리즘입니다.  AES는 하나의 키를 사용하여 데이터를 암호화하고 복호화하기 때문에 암호화 키와 복호화 키가 동일합니다.  반면 RSA, DSA, ECC는 비대칭키 암호화 알고리즘으로, 서로 다른 키(공개키와 개인키)를 사용합니다. 따라서 정답은 AES(2번)입니다.",57,154
501,6,1,요구사항 검증(Requirements Validation)과 관련한 설명으로 틀린 것은?,,요구사항이 고객이 정말 원하는 시스템을 제대로 정의하고 있는지 점검하는 과정이다.,개발완료 이후에 문제점이 발견될 경우 막대한 재작업 비용이 들 수 있기 때문에 요구사항 검증은 매우 중요하다.,"요구사항이 실제 요구를 반영하는지, 문서상의 요구사항은 서로 상충되지 않는지 등을 점검한다.",요구사항 검증 과정을 통해 모든 요구사항 문제를 발견할 수 있다.,4,"요구사항 검증은 개발에 들어가기 전에 고객의 요구사항이 정확하게 이해되었는지, 그리고 그 요구사항들이 서로 모순되지 않는지 확인하는 매우 중요한 과정입니다.  1번과 3번은 요구사항 검증의 목표와 활동을 정확하게 설명하고 있으며, 2번은 요구사항 검증의 중요성을 강조하고 있습니다. 하지만 4번은 잘못된 설명입니다.  아무리 철저하게 검증 과정을 거치더라도 모든 문제를 찾아낼 수 있다는 보장은 없습니다.  요구사항 검증은 가능한 한 많은 문제를 사전에 발견하여 개발 후 발생할 수 있는 큰 비용과 시간 낭비를 줄이기 위한 노력이지, 모든 문제를 완벽하게 해결하는 것은 아니기 때문입니다.  따라서 4번이 틀린 설명입니다.",92,102
502,6,2,"UML 모델에서 한 사물의 명세가 바뀌면 다른사물에 영향을 주며, 일반적으로 한 클래스가다른 클래스를 오퍼레이션의 매개변수로 사용하는 경우에 나타나는 관계는?",,Association,Dependency,Realization,Generalization,2,"문제에서 설명하는 상황은 한 사물(클래스)의 변경이 다른 사물(클래스)에 영향을 미치는 경우입니다.  A 클래스가 B 클래스의 오퍼레이션(메서드)의 매개변수로 사용된다는 것은 A 클래스의 명세가 바뀌면, A 클래스를 매개변수로 사용하는 B 클래스의 오퍼레이션도 영향을 받아 수정이 필요하다는 것을 의미합니다. 이러한 관계를 UML에서 Dependency(의존성)라고 합니다.  Association(연관)은 두 클래스 간의 구조적인 관계를 나타내는 반면, Dependency는 한 클래스가 다른 클래스에 대해 일시적으로 의존하는 관계를 나타냅니다. Realization(실현)은 인터페이스와 클래스 간의 관계이고, Generalization(일반화)은 상속 관계를 나타냅니다. 따라서, 한 클래스가 다른 클래스의 오퍼레이션 매개변수로 사용되는 경우는 의존성(Dependency) 관계가 가장 적절합니다. 정보처리기사 공식 교재에서는 UML 다이어그램의 각 관계(연관, 의존, 일반화, 실현)에 대한 설명과 예시를 통해 이러한 차이점을 자세히 설명하고 있을 것입니다.",65,102
503,6,3,익스트림 프로그래밍 (XP)에 대한 설명으로 틀린 것은?,,빠른 개발을 위해 테스트를 수행하지 않는다.,사용자의 요구사항은 언제든지 변할 수있다.,고객과 직접 대면하며 요구사항을 이야기하기 위해 사용자 스토리(User Story)를 활용할 수 있다.,기존의 방법론에 비해 실용성(Pragmatism)을 강조한 것이라고 볼 수있다.,1,"익스트림 프로그래밍(XP)은 빠르고 유연한 소프트웨어 개발을 위해 고안된 애자일 방법론입니다.  문제에서 틀린 것은 1번입니다. XP는 빠른 개발을 위해 테스트를 *생략하지 않고* 오히려 매우 중요하게 여깁니다.  XP에서는 테스트 주도 개발(TDD)을 강조하여, 코드를 작성하기 전에 먼저 테스트 코드를 작성하고, 그 테스트를 통과하는 코드를 작성하는 방식을 사용합니다. 이를 통해 버그를 조기에 발견하고, 코드의 품질을 높이며, 개발 속도를 향상시키는 것을 목표로 합니다.  2번, 3번, 4번은 모두 XP의 특징을 잘 나타내는 설명입니다. 사용자 요구사항의 변화에 유연하게 대처하고, 고객과의 긴밀한 소통을 중시하며, 기존의 무거운 개발 방법론과 달리 실용성을 강조하는 것이 XP의 핵심 철학입니다. 따라서 1번이 틀린 설명입니다.",91,102
504,6,4,소프트웨어 설계에서 사용되는 대표적인 추상화(Abstraction) 기법이 아닌 것은?,,자료 추상화,제어 추상화,과정 추상화,강도 추상화,4,"소프트웨어 설계에서 추상화는 복잡한 시스템을 단순화하여 이해하고 관리하기 위한 중요한 기법입니다. 자료 추상화는 데이터의 구체적인 표현 방식을 숨기고, 필요한 기능만을 노출시켜 사용하는 방법입니다. 예를 들어, 리스트 자료구조를 사용할 때 내부적으로 어떻게 데이터가 저장되는지 알 필요 없이, 리스트에 데이터를 추가하고 삭제하는 기능만 사용할 수 있습니다. 제어 추상화는 복잡한 제어 흐름을 단순화하여 표현하는 방법입니다.  프로그래밍에서 함수나 서브루틴을 사용하는 것이 제어 추상화의 좋은 예입니다. 과정 추상화는 복잡한 과정을 단순화하여 표현하는 방법입니다.  예를 들어,  자동차를 운전하는 과정을  ""시동을 걸고, 가속 페달을 밟고, 브레이크를 밟아 정지한다"" 와 같이 단순화하여 설명할 수 있습니다.  반면, ""강도 추상화""라는 용어는 소프트웨어 설계에서 일반적으로 사용되지 않는 용어입니다.  따라서 소프트웨어 설계에서 사용되는 대표적인 추상화 기법이 아닌 것은 ""강도 추상화""입니다.",81,107
505,6,5,객체지향 설계에서 정보 은닉(Information Hiding)과 관련한 설명으로 틀린 것은?,,필요하지 않은 정보는 접근할 수 없도록 하여 한 모듈 또는 하부시스템이 다른 모듈의 구현에 영향을 받지 않게 설계되는것을 의미한다.,모듈들 사이의 독립성을 유지시키는 데 도움이 된다.,"설계에서 은닉되어야 할 기본 정보로는 IP주소와 같은 물리적 코드, 상세 데이터 구조 등이 있다.",모듈 내부의 자료 구조와 접근 동작들에만 수정을 국한하기 때문에 요구사항 등변화에 따른 수정이 불가능하다.,4,"정보 은닉(Information Hiding)은 객체지향 설계의 핵심 개념 중 하나입니다.  외부에서 접근할 필요가 없는 내부 데이터나 구현 세부 사항을 감추어,  외부 변경으로부터 내부 모듈을 보호하고 모듈 간의 의존성을 줄이는 것을 의미합니다.  1번과 2번은 정보 은닉의 목적과 효과를 정확하게 설명하고 있습니다. 3번 또한 IP 주소나 상세 데이터 구조와 같은 정보가 은닉되어야 할 대상이라는 점을 잘 나타냅니다. 하지만 4번은 잘못된 설명입니다. 정보 은닉은 오히려 요구사항 변경에 따른 수정을 용이하게 합니다.  모듈 내부의 자료 구조와 접근 동작만 수정하면 되기 때문에, 다른 모듈에 영향을 미치지 않고 변경 작업을 수행할 수 있습니다.  즉,  변경에 대한 영향을 최소화하여 유지보수를 쉽게 만드는 것이 정보 은닉의 중요한 장점입니다. 따라서 4번 문항은 정보 은닉의 특징을 잘못 이해한 것입니다.",84,107
506,6,6,소프트웨어 공학에서 모델링 (Modeling)과 관련한 설명으로 틀린 것은?,,개발팀이 응용문제를 이해하는 데 도움을 줄 수 있다.,유지보수 단계에서만 모델링 기법을 활용한다.,개발될 시스템에 대하여 여러 분야의 엔지니어들이 공통된 개념을 공유하는 데 도움을 준다.,절차적인 프로그램을 위한 자료흐름도는 프로세스 위주의 모델링 방법이다.,2,"소프트웨어 공학에서 모델링은 시스템을 개발하기 전에 시스템의 구조, 동작, 데이터 흐름 등을 시각적으로 표현하는 과정입니다.  1번의 경우, 모델링을 통해 개발팀은 복잡한 시스템을 그림이나 다이어그램으로 이해하기 쉽게 만들어 응용 문제를 파악하는 데 도움을 받을 수 있습니다. 3번 또한 모델링이 여러 분야의 엔지니어들이 시스템에 대한 공통된 이해를 갖도록 돕는다는 점에서 맞는 설명입니다. 4번은 자료흐름도가 시스템의 프로세스(처리 과정)를 중심으로 모델링하는 방법이라는 점에서 옳은 설명입니다. 하지만 2번은 모델링이 유지보수 단계에서만 사용된다는 주장은 잘못되었습니다. 모델링은 시스템 개발 전 단계(요구사항 분석, 설계 등)와 유지보수 단계 모두에서 활용되는 중요한 기법입니다.  따라서 2번이 틀린 설명입니다.",89,103
507,6,7,요구 분석(Requirement Analysis)에 대한 설명으로 틀린 것은?,,요구 분석은 소프트웨어 개발의 실제적인 첫 단계로 사용자의 요구에 대해 이해하는 단계라 할 수 있다.,요구 추출(Requirement Elicitation)은 프로젝트 계획 단계에 정의한 문제의 범위 안에 있는 사용자의 요구를 찾는 단계이다.,도메인 분석(Domain Analysis)은 요구에 대한 정보를 수집하고 배경을 분석하여 이를 토대로 모델링을 하게 된다.,"기능적(Functional) 요구에서 시스템 구축에대한 성능, 보안, 품질, 안정 등에 대한 요구사항을 도출한다.",4,"4번 문항은 기능적 요구사항과 비기능적 요구사항을 혼동하고 있습니다. 기능적 요구사항은 시스템이 무엇을 해야 하는지에 대한 요구사항(예: 사용자 로그인 기능, 상품 검색 기능 등)을 의미하며, 비기능적 요구사항은 시스템이 어떻게 동작해야 하는지에 대한 요구사항(예: 시스템 성능, 보안, 품질, 안정성 등)을 의미합니다.  따라서 시스템 구축에 대한 성능, 보안, 품질, 안정 등에 대한 요구사항은 비기능적 요구사항에 속하며, 기능적 요구사항에서 도출되는 것이 아닙니다.  쉽게 말해, 기능은 '무엇을 할까?'이고, 비기능은 '어떻게 할까?'에 대한 질문에 대한 답변이라고 생각하면 됩니다.  4번 문항은 이러한 두 가지 요구사항의 차이를 명확하게 구분하지 못하고 있습니다.",55,102
508,6,8,클래스 다이어그램의 요소로 다음 설명에 해당하는 용어는?,https://www.cbtbank.kr/images/iz/iz20210814/iz20210814m8.gif,Instance,Operation,Item,Hiding,2,"문제에서 설명하는 용어는 클래스 다이어그램의 'Operation'입니다. 클래스 다이어그램은 객체지향 설계에서 클래스들의 관계와 구조를 시각적으로 표현하는 도구인데요,  'Operation'은 클래스가 수행할 수 있는 동작, 즉 메서드를 의미합니다.  쉽게 말해, 클래스가 가지고 있는 기능(무엇을 할 수 있는지)을 나타내는 것이죠. 예를 들어, '강아지'라는 클래스가 있다면 '짖다', '뛰다', '먹다' 등이 Operation이 될 수 있습니다.  문제에서 설명하는 ""클래스의 동작을 의미한다"", ""클래스에 속하는 객체에 대하여 적용될 메서드를 정의한 것이다"", ""UML에서는 동작에 대한 인터페이스를 지정한다고 볼 수 있다""는 모두 Operation의 특징을 정확하게 설명하고 있습니다.  Instance는 객체를, Item은 특정 항목을, Hiding은 정보 은닉을 의미하므로 문제의 설명과는 맞지 않습니다.",69,107
509,6,9,분산 시스템을 위한 마스터-슬레이브(Master-Slave) 아키텍처에 대한 설명으로 틀린 것은?,,일반적으로 실시간 시스템에서 사용된다.,"마스터 프로세스는 일반적으로 연산, 통신, 조정을 책임진다.",슬레이브 프로세스는 데이터 수집 기능을 수행할 수 없다.,마스터 프로세스는 슬레이브 프로세스들을 제어할 수 있다.,3,"마스터-슬레이브 아키텍처는 하나의 마스터 프로세스가 여러 개의 슬레이브 프로세스를 관리하는 분산 시스템 구조입니다. 마스터는 전체 시스템을 감독하고, 슬레이브들은 마스터의 지시에 따라 작업을 수행합니다.  문제에서 틀린 것은 3번입니다. 슬레이브 프로세스는 마스터의 지시에 따라 데이터 수집 등 다양한 작업을 수행할 수 있습니다.  데이터 수집은 슬레이브 프로세스가 담당하는 전형적인 작업 중 하나입니다.  따라서 슬레이브 프로세스는 데이터 수집 기능을 수행할 수 없다는 3번의 설명은 틀렸습니다.  1번은 실시간 시스템에서 마스터-슬레이브 아키텍처가 자주 사용되는 것을 나타내므로 맞는 설명입니다. 2번은 마스터 프로세스의 역할을 정확하게 설명하고 있으며, 4번은 마스터 프로세스가 슬레이브 프로세스를 제어하는 기본적인 기능을 나타내므로 역시 맞는 설명입니다.",80,106
510,6,10,요구 사항 정의 및 분석·설계의 결과물을 표현하기 위한 모델링 과정에서 사용되는 다이어그램(Diagram)이 아닌 것은?,,Data Flow Diagram,UML Diagram,E-R Diagram,AVL Diagram,4,"이 문제는 요구사항 정의 및 분석·설계 단계에서 사용되는 다이어그램을 묻고 있습니다.  Data Flow Diagram(DFD), UML Diagram, E-R Diagram은 모두 시스템 분석 및 설계 과정에서 널리 사용되는 모델링 도구입니다. DFD는 데이터의 흐름을 시각적으로 표현하고, UML은 객체지향 시스템의 설계에 사용되며, E-R Diagram은 데이터베이스 설계에 사용됩니다.  반면 AVL Diagram은 이진 탐색 트리의 한 종류인 AVL 트리를 나타내는 다이어그램으로, 시스템 분석 및 설계 과정에서 직접적으로 사용되는 다이어그램은 아닙니다.  AVL 트리는 자료구조의 개념에 속하며, 효율적인 데이터 검색 및 관리를 위한 알고리즘 설계에 활용되지만, 시스템의 전체적인 흐름이나 데이터 모델을 표현하는 데는 사용되지 않습니다. 따라서 시스템 분석 및 설계의 결과물을 표현하는 다이어그램이 아닌 것은 AVL Diagram입니다.",73,103
511,6,11,객체지향의 주요 개념에 대한 설명으로 틀린 것은?,,캡슐화는 상위클래스에서 속성이나 연산을 전달받아 새로운 형태의 클래스로 확장하여 사용하는 것을 의미한다.,객체는 실세계에 존재하거나 생각할 수 있는 것을 말한다.,클래스는 하나 이상의 유사한 객체들을 묶어 공통된 특성을 표현한 것이다.,다형성은 상속받은 여러 개의 하위 객체들이 다른 형태의 특성을 갖는 객체로 이용될 수 있는 성질이다.,1,"객체지향 프로그래밍(OOP)의 핵심 개념 중 하나인 캡슐화는 데이터(속성)와 데이터를 처리하는 함수(메서드)를 하나로 묶어 외부로부터 데이터를 보호하고, 데이터 접근을 제어하는 것을 의미합니다.  1번 보기는 캡슐화의 개념을 상속(inheritance)의 개념과 혼동하고 있습니다. 상속은 기존 클래스의 속성과 메서드를 재사용하여 새로운 클래스를 만드는 것이지, 캡슐화 자체가 상위 클래스의 속성이나 연산을 확장하는 것을 의미하는 것은 아닙니다.  캡슐화는 정보 은닉(information hiding)을 통해 데이터 무결성을 유지하고, 코드의 재사용성과 유지보수성을 높이는 데 기여합니다.  나머지 보기들은 객체지향 프로그래밍의 개념을 정확하게 설명하고 있습니다. 객체는 실세계의 개념을 프로그램으로 표현한 것이고, 클래스는 객체의 설계도와 같으며, 다형성은 하나의 인터페이스로 여러 가지의 구현을 제공하는 것을 의미합니다. 따라서 1번 보기만 틀린 설명입니다.",79,107
512,6,12,사용자 인터페이스(User Interface)에 대한 설명으로 틀린 것은?,,사용자와 시스템이 정보를 주고받는 상호작용이 잘 이루어지도록 하는 장치나 소프트웨어를 의미한다.,편리한 유지보수를 위해 개발자 중심으로 설계되어야 한다.,배우기가 용이하고 쉽게 사용할 수 있도록 만들어져야 한다.,사용자 요구사항이 UI에 반영될 수 있도록 구성해야 한다.,2,"사용자 인터페이스(UI)는 사용자와 시스템 사이의 소통을 원활하게 해주는 매개체입니다.  쉽게 말해, 사용자가 컴퓨터나 스마트폰 등의 시스템을 이용할 때 보이는 화면, 버튼, 메뉴 등을 모두 포함하는 개념입니다.  문제에서 틀린 것은 2번입니다.  UI는 개발자의 편의성보다 사용자의 편의성을 최우선으로 고려하여 설계되어야 합니다.  개발자가 유지보수하기 쉽게 만든다고 해서 사용자가 사용하기 쉬운 UI가 되는 것은 아니기 때문입니다.  좋은 UI는 사용자가 직관적으로 이해하고 쉽게 사용할 수 있도록 만들어져야 하며, 사용자의 요구사항을 충분히 반영해야 합니다.  따라서 사용자 중심의 설계가 중요하며, 개발자 중심의 설계는 오히려 UI의 효율성을 떨어뜨릴 수 있습니다.",92,104
513,6,13,GoF(Gang of Four) 디자인 패턴과 관련한 설명으로 틀린 것은?,,"디자인 패턴을 목적(Purpose)으로 분류할 때 생성, 구조, 행위로 분류할 수 있다.",Strategy 패턴은 대표적인 구조 패턴으로 인스턴스를 복제하여 사용하는 구조를 말한다.,행위 패턴은 클래스나 객체들이 상호작용하는 방법과 책임을 분산하는 방법을 정의한다.,"Singleton 패턴은 특정 클래스의 인스턴스가 오직 하나임을 보장하고, 이 인스턴스에 대한 접근 방법을 제공한다.",2,"GoF 디자인 패턴은 소프트웨어 설계에서 자주 발생하는 문제에 대한 재사용 가능한 해결책을 제공하는 일종의 템플릿입니다.  문제에서 제시된 2번 선택지가 틀린 이유는 Strategy 패턴이 구조 패턴이 아니기 때문입니다. Strategy 패턴은 행위 패턴에 속하며, 알고리즘을 캡슐화하여 상호 교환 가능하게 만드는 패턴입니다.  인스턴스를 복제하는 것은 Prototype 패턴의 특징입니다.  나머지 선택지들은 GoF 디자인 패턴에 대한 정확한 설명입니다. 1번은 디자인 패턴의 세 가지 주요 분류(생성, 구조, 행위)를 제시하고 있으며, 3번은 행위 패턴의 목적을 정확하게 설명하고 있습니다. 4번은 Singleton 패턴의 특징을 잘 나타내고 있습니다. 따라서 2번 선택지가 GoF 디자인 패턴에 대한 잘못된 설명입니다.",67,107
514,6,14,애자일 개발 방법론과 관련한 설명으로 틀린 것은?,,빠른 릴리즈를 통해 문제점을 빠르게 파악할 수 있다.,정확한 결과 도출을 위해 계획 수립과 문서화에 중점을 둔다.,고객과의 의사소통을 중요하게 생각한다.,진화하는 요구사항을 수용하는데 적합하다.,2,"애자일 개발 방법론은 빠르게 변화하는 요구사항에 유연하게 대처하고, 고객과의 긴밀한 소통을 통해 개발 과정 전반에 걸쳐 피드백을 반영하여 최적의 결과물을 만들어내는 것을 목표로 합니다.  따라서 빠른 릴리즈를 통해 문제점을 신속하게 파악하고, 고객의 요구 변화에 맞춰 개발 방향을 조정하는 것은 애자일의 핵심 전략입니다.  하지만 애자일은 계획 수립과 문서화에 과도하게 집중하기보다는,  실제 개발 과정에서의 유연성과 효율성을 중시합니다.  정확한 결과 도출을 위해 엄격하고 자세한 계획과 문서화에 치중하는 것은 애자일의 원칙과는 상반됩니다.  애자일은  반복적인 개발 주기(Iteration)와 지속적인 통합(Continuous Integration)을 통해  변화에 적응하고, 고객 만족도를 높이는 데 초점을 맞춥니다.",88,102
515,6,15,럼바우(Rumbaugh)의 객체지향 분석 기법 중 자료 흐름도(DFD)를 주로 이용하는 것은?,,기능 모델링,동적 모델링,객체 모델링,정적 모델링,1,"럼바우의 객체지향 분석 기법은 시스템을 객체들의 상호작용으로 모델링하는 기법입니다.  여기서 자료 흐름도(DFD)는 시스템의 기능적 측면, 즉 어떤 데이터가 어떤 기능을 통해 어떻게 변환되는지를 시각적으로 표현하는 도구입니다.  럼바우 기법은 객체 모델링(정적인 측면)과 동적 모델링(동적인 측면)을 모두 고려하지만, DFD는 시스템의 기능(무엇을 하는가)을 중심으로 데이터의 흐름을 보여주는 것이므로 기능 모델링에 해당합니다.  쉽게 말해, DFD는 시스템이 어떤 일을 하는지, 어떤 데이터를 사용하는지를 나타내는 '기능'에 초점을 맞춘 도구이기 때문에 기능 모델링에 주로 사용됩니다.  객체 모델링은 객체의 속성과 관계를 중심으로 시스템을 표현하는 것이고, 동적 모델링은 시스템의 시간에 따른 변화를 나타내는 것이므로 DFD와는 목적이 다릅니다. 정적 모델링은 시스템의 구조를 나타내는 것이므로 DFD와는 직접적인 관련이 적습니다. 따라서 정답은 기능 모델링입니다.",51,102
516,6,16,순차 다이어그램(Sequence Diagram)과 관련한 설명으로 틀린 것은?,,객체들의 상호 작용을 나타내기 위해 사용한다.,시간의 흐름에 따라 객체들이 주고 받는 메시지의 전달 과정을 강조한다.,동적 다이어그램보다는 정적 다이어그램에 가깝다.,교류 다이어그램(Interaction Diagram)의 한 종류로 볼 수 있다.,3,"순차 다이어그램은 객체들의 상호작용을 시간 순서대로 보여주는 다이어그램입니다.  객체들이 메시지를 주고받는 과정을 시각적으로 나타내어 시스템의 동작을 이해하기 쉽게 만들어줍니다.  1번과 2번은 순차 다이어그램의 주요 특징을 잘 나타내고 있으며, 4번 또한 순차 다이어그램이 상호작용 다이어그램의 한 종류라는 점을 정확히 설명하고 있습니다. 하지만 3번은 잘못된 설명입니다. 순차 다이어그램은 시간의 흐름을 강조하는 동적 다이어그램이며, 정적 다이어그램(예: 클래스 다이어그램)과는 다릅니다. 정적 다이어그램은 시스템의 구조를 나타내는 반면, 순차 다이어그램은 시스템의 동작을 나타냅니다. 따라서 시간의 흐름을 보여주는 동적 다이어그램에 더 가깝습니다.",77,102
517,6,17,객체지향 분석 기법과 관련한 설명으로 틀린것은?,,동적 모델링 기법이 사용될 수 있다.,기능 중심으로 시스템을 파악하며 순차적인처리가 중요시되는 하향식(Top-down)방식으로 볼 수 있다.,데이터와 행위를 하나로 묶어 객체를 정의내리고 추상화시키는 작업이라 할 수 있다.,코드 재사용에 의한 프로그램 생산성 향상 및 요구에 따른 시스템의 쉬운 변경이 가능하다.,2,"객체지향 분석 기법은 시스템을 객체라는 개념으로 분석하는 방법입니다.  객체는 데이터(속성)와 행위(메소드)를 하나로 묶어 표현하는데, 이를 통해 시스템을 구성하는 요소들을 모듈화하고 재사용성을 높일 수 있습니다.  문제에서 틀린 것은 2번입니다.  객체지향 분석은 기능 중심의 하향식 접근 방식이 아니라, 객체 중심의 상향식(Bottom-up) 또는 혼합 방식으로 시스템을 모델링합니다.  순차적인 처리보다는 객체 간의 상호작용과 데이터 흐름에 초점을 맞춥니다.  동적 모델링 기법을 사용하여 객체 간의 상호작용을 시각화하고 분석할 수 있으며,  데이터와 행위를 하나로 묶는 객체 정의와 추상화는 객체지향 분석의 핵심입니다.  코드 재사용성 향상과 시스템 변경의 용이성 또한 객체지향 분석의 주요 장점입니다. 따라서 1, 3, 4번은 객체지향 분석 기법에 대한 올바른 설명입니다.",71,107
518,6,18,"대표적으로 DOS 및 Unix 등의 운영체제에서조작을 위해 사용하던 것으로, 정해진 명령문자열을 입력하여 시스템을 조작하는 사용자인터페이스(User Interface)는?",,GUI(Graphical User Interface),CLI(Command Line Interface),CUI(Cell User Interface),MUI(Mobile User Interface),2,"문제에서 묻고 있는 것은 사용자가 명령어를 입력하여 컴퓨터를 제어하는 방식의 사용자 인터페이스입니다.  GUI(Graphical User Interface)는 마우스나 터치를 이용하여 아이콘이나 메뉴를 선택하는 방식인 반면, CLI(Command Line Interface)는 텍스트 기반의 명령어를 입력하여 시스템을 조작하는 방식입니다. DOS(Disk Operating System)나 Unix와 같은 운영체제는 초기에는 GUI가 아닌 CLI를 사용하여 명령어를 입력하는 방식으로 작동했습니다.  따라서 정답은 CLI(Command Line Interface)입니다. CUI(Cell User Interface)와 MUI(Mobile User Interface)는 문제와 관련이 없습니다.",84,144
519,6,19,분산 시스템에서의 미들웨어 (Middleware)와 관련한 설명으로 틀린 것은?,,분산 시스템에서 다양한 부분을 관리하고 통신하며 데이터를 교환하게 해주는소프트웨어로 볼 수 있다.,위치 투명성(Location Transparency)을 제공한다.,분산 시스템의 여러 컴포넌트가 요구하는 재사용가능한 서비스의 구현을 제공한다.,애플리케이션과 사용자 사이에서만 분산서비스를 제공한다.,4,"문제에서 제시된 4번 선택지는 ""애플리케이션과 사용자 사이에서만 분산 서비스를 제공한다"" 입니다.  미들웨어는 분산 시스템 내의 다양한 구성 요소(애플리케이션, 데이터베이스, 운영체제 등) 간의 상호 작용을 중개하고 관리하는 소프트웨어입니다.  따라서 애플리케이션과 사용자 사이의 상호 작용만을 담당하는 것이 아니라, 분산 시스템 내의 여러 구성 요소들 사이의 통신과 데이터 교환을 원활하게 해주는 역할을 합니다.  쉽게 말해, 미들웨어는 분산 시스템 내의 여러 부품들이 서로 잘 소통하고 협력할 수 있도록 돕는 '중간 관리자'와 같은 역할을 수행합니다.  따라서 4번 선택지는 미들웨어의 기능을 제대로 반영하지 못하고 있습니다.  나머지 선택지들은 미들웨어의 주요 기능들을 잘 설명하고 있습니다.  위치 투명성(Location Transparency)은 애플리케이션이 데이터나 서비스의 실제 위치를 알 필요 없이 접근할 수 있도록 해주는 기능을 의미하고, 재사용 가능한 서비스 구현은 여러 애플리케이션에서 공통적으로 사용할 수 있는 기능들을 미들웨어가 제공함을 의미합니다.",86,110
520,6,20,소프트웨어 아키텍처와 관련한 설명으로 틀린것은?,,"파이프 필터 아키텍처에서 데이터는 파이프를 통해 양방향으로 흐르며, 필터 이동 시 오버헤드가 발생하지 않는다.",외부에서 인식할 수 있는 특성이 담긴 소프트웨어의 골격이 되는 기본 구조로 볼수 있다.,데이터 중심 아키텍처는 공유 데이터저장소를 통해 접근자 간의 통신이 이루어지므로 각 접근자의 수정과 확장이 용이하다.,이해 관계자들의 품질 요구사항을 반영하여 품질 속성을 결정한다.,1,"문제에서 제시된 네 가지 설명 중 틀린 것은 1번입니다. 파이프 필터 아키텍처는 데이터가 한 방향으로만 흐르는 구조입니다.  데이터는 파이프를 따라 한 필터에서 다음 필터로 순차적으로 처리되며, 양방향으로 흐르지 않습니다. 또한, 필터의 이동은 일반적으로 발생하지 않으므로 오버헤드가 발생한다는 설명 또한 틀렸습니다.  2번은 소프트웨어 아키텍처의 일반적인 정의를 잘 나타내고 있으며, 3번은 데이터 중심 아키텍처의 장점을, 4번은 아키텍처 설계 과정에서 중요한 요소를 설명하고 있습니다. 따라서 1번이 틀린 설명입니다.  쉽게 말해, 파이프 필터 아키텍처는 조립 라인과 같습니다.  자동차 부품이 한 단계씩 조립되는 것처럼 데이터가 필터를 거쳐 처리됩니다.  데이터가 거꾸로 흐르거나 필터가 이동하는 것은 아닙니다.",79,106
521,6,21,"테스트를 목적에 따라 분류했을 때,강도(Stress) 테스트에 대한 설명으로 옳은것은?",,시스템에 고의로 실패를 유도하고 시스템이정상적으로 복귀하는지 테스트한다.,시스템에 과다 정보량을 부과하여 과부하 시에도 시스템이 정상적으로 작동되는지를 테스트한다.,"사용자의 이벤트에 시스템이 응답하는 시간,특정 시간 내에 처리하는 업무량, 사용자 요구에 시스템이 반응하는 속도 등을 테스트한다.",부당하고 불법적인 침입을 시도하여 보안시스템이 불법적인 침투를 잘 막아내는지 테스트한다.,2,"강도(Stress) 테스트는 시스템의 성능 한계를 확인하기 위한 테스트입니다.  마치 운동선수가 자신의 최대 능력을 시험하듯, 시스템에 과도한 부하를 가하여 어느 정도의 부하까지 견딜 수 있는지, 그리고 과부하 상황에서도 시스템이 안정적으로 작동하는지 확인하는 것이죠.  예를 들어, 동시에 많은 사용자가 접속하거나, 엄청난 양의 데이터를 처리하는 상황을 만들어 시스템의 반응을 살펴보는 것입니다.  문제의 1번은 시스템의 실패를 유도하는 '고장(Failure) 테스트'에 가깝고, 3번은 시스템의 응답 속도를 측정하는 '성능(Performance) 테스트', 4번은 시스템의 보안 취약성을 확인하는 '보안(Security) 테스트'와 관련이 있습니다. 따라서 시스템에 과다한 정보량을 부과하여 과부하 상황에서의 시스템 작동 여부를 확인하는 2번이 강도 테스트의 정확한 설명입니다.",79,119
522,6,22,다음 자료를 버블 정렬을 이용하여오름차순으로 정렬할 경우 PASS 3의 결과는?,https://www.cbtbank.kr/images/iz/iz20210814/iz20210814m22.gif,"6, 3, 5, 7, 9","3, 5, 6, 7, 9","6, 7, 3, 5, 9","3, 5, 9, 6, 7",2,"버블 정렬은 인접한 두 원소를 비교하여 크기 순서대로 자리를 바꾸는 정렬 알고리즘입니다.  주어진 자료 9, 6, 7, 3, 5를 오름차순으로 정렬하는 과정을 PASS 단위로 살펴보겠습니다.",68,111
523,6,23,다음 그래프에서 정점 A를 선택하여 깊이우선탐색(DFS)으로 운행한 결과는?,https://www.cbtbank.kr/images/iz/iz20210814/iz20210814m23.gif,ABECDFG,ABECFDG,ABCDEFG,ABEFGCD,4,"이 문제는 그래프 탐색 알고리즘 중 하나인 깊이 우선 탐색(Depth-First Search, DFS)을 이해하고 있는지 묻는 문제입니다.  DFS는 그래프의 정점을 탐색하는 방법으로, 하나의 정점을 시작하여 가능한 한 깊이 탐색한 후, 더 이상 갈 곳이 없으면 이전 정점으로 돌아와 다른 가지를 탐색하는 방식입니다.  문제에서 주어진 그래프와 A를 시작 정점으로 DFS를 수행하는 과정을 살펴보겠습니다.",78,111
524,6,24,다음 설명에 부합하는 용어로 옳은 것은?,https://www.cbtbank.kr/images/iz/iz20210814/iz20210814m24.gif,통합 프로그램,저장소,모듈,데이터,3,"문제에서 설명하는 용어는 소프트웨어를 구성하는 기본 단위를 의미합니다.  소프트웨어는 매우 복잡한 시스템이기 때문에, 이를 작고 관리하기 쉬운 여러 조각으로 나누어 개발하는 것이 효율적입니다. 이러한 각 조각이 독립적인 기능을 가지고 있으며, 다른 조각들과 결합하여 전체 시스템을 이루는 것을 ""모듈""이라고 합니다.  마치 레고 블록처럼, 각 블록(모듈)은 특정 기능을 수행하고, 여러 블록을 조합하여 원하는 모양(프로그램)을 만들 수 있는 것과 같습니다.  ""통합 프로그램""은 이미 완성된 프로그램을 의미하고, ""저장소""는 데이터를 저장하는 공간, ""데이터""는 정보 자체를 의미하므로 문제의 설명과는 맞지 않습니다. 따라서 정답은 모듈(3번)입니다.",86,106
525,6,25,테스트 드라이버(Test Driver)에 대한 설명으로 틀린 것은?,,시험대상 모듈을 호출하는 간이 소프트웨어이다.,필요에 따라 매개 변수를 전달하고 모듈을 수행한 후의 결과를 보여줄 수 있다.,상향식 통합 테스트에서 사용된다.,테스트 대상 모듈이 호출하는 하위 모듈의 역할을 한다.,4,"테스트 드라이버는 시험 대상 모듈(테스트할 코드 부분)을 호출하여 테스트하는 간단한 프로그램입니다.  마치 시험 대상 모듈에게 필요한 입력값(매개변수)을 주고, 그 결과를 확인하는 역할을 합니다.  상향식 통합 테스트에서는 아래쪽(하위) 모듈부터 테스트를 진행하는데, 이때 위쪽(상위) 모듈의 역할을 대신하는 것이 테스트 드라이버입니다.  하지만 테스트 드라이버는 시험 대상 모듈이 호출하는 하위 모듈의 역할을 하지는 않습니다.  오히려 시험 대상 모듈을 *호출*하는 쪽이기 때문입니다.  4번 선택지는 테스트 드라이버의 역할과 반대되는 설명입니다.",61,120
526,6,26,다음 중 선형 구조로만 묶인 것은?,,"스택, 트리","큐, 데크","큐, 그래프","리스트, 그래프",2,"이 문제는 자료구조의 기본 개념을 묻는 문제입니다.  선형 구조란 데이터가 순차적으로 연결되어 있는 구조를 말합니다.  리스트는 데이터들이 순서대로 나열된 선형 구조이고, 큐는 FIFO(First-In, First-Out) 방식으로 데이터를 처리하는 선형 구조, 데크는 양쪽 끝에서 데이터를 삽입하거나 삭제할 수 있는 선형 구조입니다. 반면, 트리는 계층적인 구조를 가지고 있으며, 그래프는 여러 노드들이 연결된 비선형 구조입니다. 따라서 큐와 데크는 모두 선형 구조이지만, 나머지 선택지에는 비선형 구조인 트리 또는 그래프가 포함되어 있습니다.  따라서 정답은 2번, 큐와 데크입니다.",80,111
527,6,27,"다음은 스택의 자료 삭제 알고리즘이다. ⓐ에 들어 갈 내용으로 옳은 것은? (단, Top: 스택포인터, S: 스택의 이름)",https://www.cbtbank.kr/images/iz/iz20210814/iz20210814m27.gif,Overflow,Top = Top + 1,Underflow,Top = Top,3,"이 코드는 스택이라는 자료구조에서 데이터를 삭제하는 알고리즘을 나타냅니다. 스택은 쌓아 올린 접시처럼, 데이터를 넣고(push) 뺄(pop) 때 가장 나중에 들어온 데이터부터 먼저 나가는 후입선출(LIFO, Last-In-First-Out) 방식의 자료구조입니다.  `Top`은 스택의 맨 위를 가리키는 포인터입니다.  `Top`이 0이라는 것은 스택이 비어있다는 것을 의미합니다.  스택이 비어있는 상태에서 데이터를 삭제하려고 하면 에러가 발생하는데, 이를 Underflow라고 합니다. 따라서 `Top`이 0일 때는 Underflow 에러를 처리해야 합니다.  반대로, 스택에 데이터가 있고(`Top`이 0보다 클 때),  `S(Top)`에서 데이터를 삭제하고 `Top`을 1 감소시켜 스택 포인터를 갱신합니다.  따라서 ⓐ에는 스택이 비어있을 때 발생하는 에러 상황인 Underflow를 처리하는 코드가 와야 합니다.",69,111
528,6,28,제품 소프트웨어의 사용자 매뉴얼 작성절차로 (가)~(다)와 [보기]의 기호를 바르게 연결한 것은?,https://www.cbtbank.kr/images/iz/iz20210814/iz20210814m28.gif,"(가)-㉠, (나)-㉡, (다)-㉢","(가)-㉢, (나)-㉡, (다)-㉠","(가)-㉠, (나)-㉢, (다)-㉡","(가)-㉢, (나)-㉠, (다)-㉡",2,"제품 소프트웨어의 사용자 매뉴얼 작성 절차는 크게 세 단계로 나눌 수 있습니다.  먼저, 사용 설명서에 들어갈 구성 요소들을 정의하는 단계(③ 사용 설명서 구성 요소 정의)가 필요합니다.  이후, 각 구성 요소에 대한 내용을 작성하는 단계(② 구성 요소별 내용 작성)를 거칩니다.  마지막으로, 완성된 사용 설명서를 검토하고 수정하는 단계(① 사용 설명서 검토)를 통해 최종 사용 설명서를 완성하게 됩니다. 문제에서 제시된 순서 (가)→(나)→(다)→사용 설명서에 맞춰 각 단계를 연결하면, (가)는 사용 설명서 구성 요소를 정의하는 단계(㉢), (나)는 구성 요소별 내용을 작성하는 단계(㉡), (다)는 사용 설명서를 검토하는 단계(㉠)가 됩니다. 따라서 정답은 2번 (가)-㉢, (나)-㉡, (다)-㉠ 입니다.  컴포넌트 명세서와 컴포넌트 구현 설계서는 사용 설명서 작성에 필요한 정보를 제공하는 자료로,  매뉴얼 작성 절차의 전 단계에 위치한다고 볼 수 있습니다.",82,117
529,6,29,"순서가 A, B, C, D로 정해진 입력 자료를 스택에 입력한 후 출력한 결과로 불가능한 것은?",,"D, C, B, A","B, C, D, A","C, B, A, D","D, B, C, A",4,"스택은 후입선출(LIFO, Last-In-First-Out) 자료구조입니다.  마지막에 들어온 데이터가 먼저 나가는 구조이죠. 문제에서 A, B, C, D 순서대로 스택에 입력한다면, 스택의 맨 아래에는 A가, 맨 위에는 D가 위치하게 됩니다.  스택에서 데이터를 출력할 때는 맨 위의 데이터부터 출력되므로, D가 먼저 나오고, 그 다음 C, B, A 순서로 나옵니다. 따라서 1번 (D, C, B, A)은 가능한 출력 결과입니다.  마찬가지로 2번 (B, C, D, A)과 3번 (C, B, A, D)도 스택의 후입선출 특성을 고려하면 불가능한 출력 순서가 아닙니다. 하지만 4번 (D, B, C, A)의 경우, B가 C보다 먼저 나오는 것은 스택의 특성과 맞지 않습니다.  B는 C보다 나중에 스택에 들어왔으므로, C가 먼저 나와야 합니다.  따라서 4번은 불가능한 출력 결과입니다.",74,111
530,6,30,소프트웨어 테스트에서 검증(Verification)과 확인 (Validation)에 대한 설명으로 틀린 것은?,,소프트웨어 테스트에서 검증과 확인을 구별하면 찾고자 하는 결함 유형을 명확하게 하는 데 도움이 된다.,"검증은 소프트웨어 개발 과정을 테스트하는 것이고, 확인은 소프트웨어 결과를 테스트 하는 것이다.","검증은 작업 제품이 요구 명세의 기능, 비기능 요구사항을 얼마나 잘 준수하는지 측정하는 작업이다.","검증은 작업 제품이 사용자의 요구에 적합한지 측정하며, 확인은 작업 제품이 개발자의 기대를 충족시키는지를 측정한다.",4,"문제에서 검증(Verification)과 확인(Validation)은 소프트웨어 테스트의 중요한 개념입니다.  쉽게 말해, 검증은 ""제대로 만들었는가?""를 확인하는 것이고, 확인은 ""맞는 것을 만들었는가?""를 확인하는 것입니다.  4번 보기는 검증을 사용자 요구에 맞는지 확인하는 것으로, 확인을 개발자의 기대를 충족하는지 확인하는 것으로 설명하고 있습니다. 하지만 이는 잘못된 설명입니다. 검증은 개발 과정에서의 요구사항 충족 여부를 확인하는 것이고, 확인은 최종 결과물이 사용자의 요구사항을 충족하는지 확인하는 것입니다.  즉, 검증은 개발 과정 내부의 정확성을, 확인은 최종 결과물의 적합성을 평가하는 것입니다.  따라서 4번 보기는 검증과 확인의 개념을 뒤바꿔 설명하고 있으므로 틀린 것입니다.  1번 보기는 검증과 확인을 구분하면 결함 유형을 명확히 하는 데 도움이 된다는 점을 지적하고 있으며, 2번 보기는 검증이 개발 과정, 확인이 결과물을 테스트하는 것이라는 점을 설명하고 있습니다. 3번 보기는 검증이 요구 명세 준수 여부를 측정하는 것이라고 설명하고 있습니다. 이 세 가지 보기는 모두 검증과 확인의 개념을 올바르게 설명하고 있습니다.",66,119
531,6,31,"개별 모듈을 시험하는 것으로 모듈이 정확하게 구현되었는지, 예정한 기능이 제대로 수행되는지를 점검하는 것이 주요 목적인 테스트는?",,통합 테스트(Integration Test),단위 테스트(Unit Test),시스템 테스트(System Test),인수 테스트(Acceptance Test),2,"단위 테스트는 소프트웨어 개발 과정에서 가장 기본적인 테스트 단계입니다.  마치 레고 블록 하나하나를 조립하고 제대로 작동하는지 확인하는 것과 같습니다.  개별적인 작은 모듈(함수, 클래스, 프로시저 등)을 독립적으로 테스트하여 각 모듈이 정상적으로 작동하는지, 예상대로 결과를 출력하는지 확인하는 것을 목표로 합니다.  통합 테스트는 여러 모듈을 결합하여 테스트하는 것이고, 시스템 테스트는 전체 시스템을 테스트하는 것이며, 인수 테스트는 사용자가 실제로 사용하면서 테스트하는 단계이므로, 개별 모듈의 정확성을 검증하는 목적에는 단위 테스트가 가장 적합합니다. 정보처리기사 공식 교재에서는 단위 테스트를 통해 각 모듈의 기능을 검증하고 오류를 조기에 발견하여 수정함으로써 전체 시스템의 안정성과 품질을 높이는 중요한 단계로 설명하고 있습니다.",76,114
532,6,32,형상 관리의 개념과 절차에 대한 설명으로 틀린 것은?,,형상 식별은 형상 관리 계획을 근거로 형상관리의 대상이 무엇인지 식별하는 과정이다.,형상 관리를 통해 가시성과 추적성을 보장함으로써 소프트웨어의 생산성과 품질을 높일 수 있다.,형상 통제 과정에서는 형상 목록의 변경 요구를 즉시 수용 및 반영해야 한다.,"형상 감사는 형상 관리 계획대로 형상관리가 진행되고 있는지, 형상 항목의 변경이 요구 사항에 맞도록 제대로 이뤄졌는지 등을 살펴보는 활동이다.",3,"형상 관리란 소프트웨어 개발 과정에서 생성되는 모든 산출물(설계 문서, 코드, 테스트 결과 등)을 체계적으로 관리하는 것을 말합니다.  문제에서 틀린 것은 3번입니다. 형상 통제 과정에서는 형상 목록의 변경 요구를 즉시 수용하고 반영하는 것이 아니라, 변경 요청에 대한 검토 및 승인 절차를 거쳐야 합니다.  즉시 반영한다면 변경 관리의 체계가 무너지고, 오류 발생 가능성이 높아지며, 버전 관리에도 혼란이 초래될 수 있기 때문입니다.  형상 관리의 목적은 소프트웨어의 품질을 높이고, 개발 과정의 투명성을 확보하며, 변경 사항을 추적 가능하게 하는 데 있습니다. 따라서 변경 사항은 신중하게 검토하고 승인된 후에만 반영되어야 합니다.  1번은 형상 식별의 정의를 잘 나타내고 있으며, 2번은 형상 관리의 이점을 잘 설명하고 있습니다. 4번은 형상 감사의 목적을 정확하게 설명하고 있습니다.",81,115
533,6,33,소스코드 정적 분석(Static Analysis)에 대한 설명으로 틀린 것은?,,소스 코드를 실행시키지 않고 분석한다.,코드에 있는 오류나 잠재적인 오류를 찾아내기 위한 활동이다.,하드웨어적인 방법으로만 코드 분석이 가능하다.,자료 흐름이나 논리 흐름을 분석하여 비정상적인 패턴을 찾을 수 있다.,3,"소스코드 정적 분석은 프로그램을 실행하지 않고 소스 코드 자체를 분석하는 기법입니다.  마치 숙제를 풀기 전에 답안지를 미리 검토하여 오류를 찾는 것과 같습니다.  코드를 직접 실행하지 않고 분석하기 때문에, 실행 중 발생하는 오류뿐 아니라 실행 전에 발견할 수 있는 오류나 잠재적인 문제점(예: 변수 초기화 누락, 메모리 누수 가능성 등)을 미리 찾아낼 수 있습니다.  자료 흐름이나 논리 흐름을 분석하여 비정상적인 패턴을 감지하는 것도 가능합니다.  하지만, 정적 분석은 소스 코드만을 분석하기 때문에 하드웨어적인 방법과는 무관합니다.  따라서 3번 선택지 ""하드웨어적인 방법으로만 코드 분석이 가능하다""는 잘못된 설명입니다.",76,121
534,6,34,"소프트웨어 개발 활동을 수행함에 있어서 시스템이 고장(Failure)을 일으키게 하며, 오류(Error)가 있는 경우 발생하는 것은?",,Fault,Testcase,Mistake,Inspection,1,"소프트웨어 개발 과정에서 시스템 고장(Failure)은 시스템이 의도한 대로 동작하지 않는 현상을 말합니다.  이 고장의 근본 원인을 'Fault'라고 합니다.  Fault는 소스코드의 결함, 설계의 잘못, 요구사항의 오류 등 다양한 원인으로 발생할 수 있습니다.  오류(Error)는 시스템이 Fault로 인해 잘못된 결과를 생성하거나 예상치 못한 동작을 하는 것을 의미합니다.  따라서 시스템 고장(Failure)과 오류(Error)가 발생하는 근본적인 원인은 Fault입니다.  Testcase는 시스템을 테스트하기 위한 입력값과 기대 결과를 정의한 것이고, Mistake는 개발자의 실수를 의미하며, Inspection은 코드 검토를 의미하므로, 시스템 고장의 근본 원인과는 직접적인 관련이 없습니다.",79,153
535,6,35,코드의 간결성을 유지하기 위해 사용되는 지침으로 틀린 것은?,,공백을 이용하여 실행문 그룹과 주석을 명확히 구분한다.,복잡한 논리식과 산술식은 괄호와 들여쓰기(Indentation)를 통해 명확히 표현한다.,빈 줄을 사용하여 선언부와 구현부를 구별한다.,한 줄에 최대한 많은 문장을 코딩한다.,4,"코드의 간결성을 유지하기 위해서는 불필요한 요소를 제거하고 가독성을 높이는 것이 중요합니다.  1번은 공백을 이용하여 코드의 구조를 명확하게 하는 좋은 방법이고, 2번은 복잡한 식을 괄호와 들여쓰기를 통해 이해하기 쉽게 만드는 것을 의미합니다. 3번 또한 빈 줄을 사용하여 코드의 섹션을 구분함으로써 가독성을 높이는 데 도움이 됩니다. 하지만 4번은 한 줄에 최대한 많은 문장을 코딩하는 것은 오히려 코드를 복잡하고 이해하기 어렵게 만들기 때문에 코드의 간결성을 해치는 행위입니다.  간결한 코드는 한눈에 알아보기 쉽고, 유지보수가 용이하며, 오류를 줄이는 데 도움이 됩니다. 따라서 한 줄에 많은 문장을 작성하는 것은 권장되지 않습니다.",89,121
536,6,36,소프트웨어 품질 목표 중 하나 이상의 하드웨어 환경에서 운용되기 위해 쉽게 수정될 수 있는 시스템 능력을 의미하는 것은?,,Portability,Efficiency,Usability,Correctness,1,"문제에서 묻고 있는 것은 소프트웨어의 품질 목표 중 하나로, 여러 다른 하드웨어 환경에서도 쉽게 작동하도록 수정이 가능한 시스템의 능력을 의미하는 용어입니다.  'Portability(이식성)'는 바로 이러한 의미를 담고 있습니다.  다른 하드웨어(예: 다른 운영체제를 사용하는 컴퓨터, 서로 다른 CPU 아키텍처를 가진 기기 등)에서도 최소한의 수정만으로 소프트웨어를 실행할 수 있도록 하는 능력을 말합니다.  반면, 'Efficiency(효율성)'는 소프트웨어가 얼마나 빠르고 자원을 적게 사용하는지를 나타내고, 'Usability(사용성)'는 사용자가 얼마나 쉽게 소프트웨어를 사용할 수 있는지를, 'Correctness(정확성)'는 소프트웨어가 얼마나 정확하게 요구사항을 충족하는지를 나타냅니다. 따라서, 여러 하드웨어 환경에서의 쉬운 수정 가능성을 나타내는 것은 'Portability'가 가장 적절합니다.",57,117
537,6,37,다음 중 최악의 경우 검색 효율이 가장 나쁜트리 구조는?,,이진 탐색트리,AVL 트리,2-3 트리,레드-블랙 트리,1,"이 문제는 트리 구조의 검색 효율을 비교하는 문제입니다.  이진 탐색 트리는 데이터를 이진 트리 형태로 저장하고, 검색 시 중앙값을 기준으로 왼쪽 또는 오른쪽 서브트리로 탐색을 반복하는 방식입니다.  최악의 경우, 트리가 한쪽으로 치우쳐서(예를 들어, 모든 노드가 오른쪽 자식만 가지는 경우)  일반적인 선형 리스트와 같이 모든 노드를 순차적으로 검색해야 하므로 검색 효율이 O(n)으로 매우 나빠집니다.  반면에 AVL 트리, 2-3 트리, 레드-블랙 트리는 균형 트리(balanced tree) 구조를 유지하도록 설계되어 있어, 최악의 경우에도 검색 효율이 O(log n)을 보장합니다. 따라서 최악의 경우 검색 효율이 가장 나쁜 트리 구조는 이진 탐색 트리입니다.  정보처리기사 시험에서는 자료구조의 효율성을 이해하는 것이 중요하며, 특히 균형 트리의 개념과 이진 탐색 트리의 최악의 경우를 구분할 수 있어야 합니다.",65,111
538,6,38,다음 트리에 대한 중위 순회 운행 결과는?,https://www.cbtbank.kr/images/iz/iz20210814/iz20210814m38.gif,ABDCEF,ABCDEF,DBECFA,DBAECF,4,"이 문제는 트리 자료구조의 중위 순회(Inorder Traversal) 알고리즘을 이해하고 있는지를 묻는 문제입니다.  중위 순회는 왼쪽 서브트리 → 루트 노드 → 오른쪽 서브트리 순서로 노드를 방문하는 방법입니다.  주어진 트리를 살펴보면 루트 노드는 A이고, A의 왼쪽 자식은 B, 오른쪽 자식은 C입니다.  B의 왼쪽 자식은 D이고, C의 왼쪽 자식은 E, 오른쪽 자식은 F입니다. 따라서 중위 순회를 적용하면 다음과 같은 순서로 노드를 방문하게 됩니다.",68,111
539,6,39,테스트 케이스 자동 생성 도구를 이용하여 테스트 데이터를 찾아내는 방법이 아닌 것은?,,스터브(Stub)와 드라이버(Driver),입력 도메인 분석,랜덤(Random) 테스트,자료 흐름도,1,"테스트 케이스 자동 생성 도구를 이용하여 테스트 데이터를 찾는 방법에 대한 문제입니다.  스터브와 드라이버는 모듈 단위 테스트를 위한 기술로, 테스트 대상 모듈의 일부 기능을 대체하거나 테스트 대상 모듈을 호출하는 역할을 합니다.  즉, 테스트 데이터를 *찾아내는* 방법이 아니라, 모듈 테스트를 *수행하는* 방법입니다. 입력 도메인 분석, 랜덤 테스트, 자료 흐름도는 모두 테스트 데이터를 생성하거나 찾아내는 데 사용될 수 있는 방법입니다. 입력 도메인 분석은 가능한 입력값의 범위를 분석하여 테스트 데이터를 도출하고, 랜덤 테스트는 무작위로 테스트 데이터를 생성하며, 자료 흐름도는 프로그램의 데이터 흐름을 분석하여 테스트 데이터를 설계하는 데 도움을 줍니다. 따라서 스터브와 드라이버만 테스트 데이터를 찾아내는 방법이 아닙니다.",47,119
540,6,40,저작권 관리 구성 요소 중 패키저(Packager)의 주요 역할로 옳은 것은?,,콘텐츠를 제공하는 저작권자를 의미한다.,콘텐츠를 메타 데이터와 함께 배포 가능한 단위로 묶는다.,라이선스를 발급하고 관리한다.,배포된 콘텐츠의 이용 권한을 통제한다.,2,"저작권 관리 구성 요소 중 패키저(Packager)는 콘텐츠를 배포 가능한 형태로 만들어주는 역할을 합니다.  마치 선물 포장을 하는 것과 같다고 생각하면 이해하기 쉽습니다.  선물(콘텐츠)을 예쁘게 포장하고(메타데이터 추가), 리본(라이선스 정보)을 묶어서 배송(배포)하기 좋게 만드는 것이죠.  1번은 저작권을 가진 사람이고, 3번과 4번은 라이선스 관리 및 접근 권한 통제와 관련된 역할입니다. 따라서 패키저의 주요 역할은 콘텐츠를 메타데이터와 함께 배포 가능한 단위로 묶는 2번이 정답입니다.  메타데이터는 콘텐츠에 대한 부가적인 정보(예: 제목, 저자, 설명 등)를 의미합니다.  패키저는 이러한 메타데이터를 콘텐츠와 함께 묶어서 사용자가 쉽게 콘텐츠를 이해하고 이용할 수 있도록 합니다.",78,116
541,6,41,데이터베이스의 무결성 규정(Integrity Rule)과 관련한 설명으로 틀린 것은?,,"무결성 규정에는 데이터가 만족해야 될 제약 조건, 규정을 참조할 때 사용하는 식별자 등의 요소가 포함될 수 있다.","무결성 규정의 대상으로는 도메인, 키, 종속성 등이 있다.",정식으로 허가 받은 사용자가 아닌 불법적인 사용자에 의한 갱신으로부터 데이터베이스를 보호하기 위한 규정이다.,릴레이션 무결성 규정(Relation Integrity Rules)은 릴레이 션을 조작하는 과정에서의 의미적 관계(Semantic Relationship)을 명세한 것이다.,3,"문제에서 제시된 4가지 설명 중 틀린 것은 3번입니다.  데이터베이스의 무결성 규정은 데이터의 정확성과 일관성을 유지하기 위한 규칙들을 의미합니다.  데이터의 값이 특정 범위 안에 들어가야 한다거나, 서로 다른 테이블 간의 데이터가 일관성을 유지해야 한다는 등의 제약 조건을 포함합니다.  1번과 2번은 무결성 규정의 일반적인 내용을 잘 설명하고 있으며, 4번은 릴레이션 무결성 규정이 데이터 간의 의미적 관계를 명세한다는 점을 정확히 지적하고 있습니다.  반면 3번은 무결성 규정의 목적을 잘못 설명하고 있습니다. 무결성 규정은 불법적인 사용자로부터 데이터베이스를 보호하는 것이 아니라,  **허가된 사용자라 할지라도** 잘못된 데이터 입력이나 수정으로 인해 데이터베이스의 정확성과 일관성이 깨지는 것을 방지하기 위한 것입니다.  즉, 무결성 규정은 데이터의 신뢰성을 확보하는 데 초점을 맞추고 있으며,  보안 측면(불법적인 사용자 접근 방지)은 접근 제어와 같은 다른 보안 메커니즘을 통해 다루어야 합니다.",60,133
542,6,42,데이터베이스에서 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 할 일련의 연산들을 의미하는 것은?,,트랜잭션,뷰,튜플,카디널리티,1,"데이터베이스에서 트랜잭션은 하나의 논리적 작업 단위를 의미합니다.  예를 들어, 은행 계좌에서 돈을 이체하는 작업을 생각해 보세요.  이 작업은 '출금'과 '입금'이라는 두 개의 작은 작업으로 나눌 수 있습니다.  트랜잭션은 이 두 작업을 하나의 단위로 묶어서,  두 작업이 모두 성공적으로 완료되거나, 모두 실패하여 원래 상태로 되돌아가도록 보장하는 역할을 합니다.  만약 '출금'은 성공했지만 '입금'이 실패한다면,  계좌 잔액에 불일치가 생기겠죠? 트랜잭션은 이러한 문제를 방지하여 데이터의 일관성을 유지하는 데 중요한 역할을 합니다.  즉, 데이터베이스의 상태를 일관성 있게 유지하기 위해 한꺼번에 처리해야 하는 일련의 연산들을 하나의 단위로 묶은 것을 트랜잭션이라고 합니다.  문제에서 제시된 다른 선택지들은 데이터베이스의 다른 개념들을 나타냅니다. 뷰는 데이터의 특정 부분을 보여주는 가상 테이블이고, 튜플은 테이블의 한 행을, 카디널리티는 테이블의 행의 개수를 의미합니다.",81,127
543,6,43,다음 두 릴레이션 Rl과 R2의 카티션 프로덕트(cartesian product) 수행 결과는?,https://www.cbtbank.kr/images/iz/iz20210814/iz20210814m43.gif,https://www.cbtbank.kr/images/iz/iz20210814/iz20210814m43b1.gif,https://www.cbtbank.kr/images/iz/iz20210814/iz20210814m43b2.gif,https://www.cbtbank.kr/images/iz/iz20210814/iz20210814m43b3.gif,https://www.cbtbank.kr/images/iz/iz20210814/iz20210814m43b4.gif,4,"이 문제는 관계형 데이터베이스에서의 카티션 프로덕트(Cartesian Product) 연산을 이해하고 있는지 묻는 문제입니다. 카티션 프로덕트는 두 개 이상의 릴레이션(관계)을 결합하여 새로운 릴레이션을 생성하는 연산인데,  간단히 말해 첫 번째 릴레이션의 모든 튜플(행)과 두 번째 릴레이션의 모든 튜플을 조합하여 새로운 릴레이션을 만드는 것입니다.",78,129
544,6,44,물리적 데이터베이스 설계에 대한 설명으로 거리가 먼 것은?,,물리적 설계의 목적은 효율적인 방법으로 데이터를 저장하는 것이다.,"트랜잭션 처리량과 응답시간, 디스크 용량 등을 고려해야 한다.","저장 레코드의 형식, 순서, 접근 경로와 같은 정보를 사용하여 설계한다.","트랜잭션의 인터페이스를 설계하며, 데이터 타입 및 데이터 타입들 간의 관계로 표현한다.",4,"물리적 데이터베이스 설계는 데이터를 실제로 저장하고 관리하는 방법에 대한 설계입니다.  효율적인 저장 방법을 찾는 것이 목표이며,  트랜잭션 처리 속도, 응답 시간, 필요한 저장 공간 등을 고려하여  레코드의 형식, 저장 순서, 데이터 접근 방식 등을 결정합니다.  4번 선택지는 트랜잭션 인터페이스 설계에 대한 내용으로,  데이터의 물리적인 저장 방식보다는 데이터베이스와 애플리케이션 간의 상호작용에 초점을 맞추고 있습니다.  따라서 물리적 데이터베이스 설계와는 거리가 멉니다.  쉽게 말해, 4번은 데이터가 어떻게 *보이는지*에 대한 설계이고, 나머지는 데이터가 어떻게 *저장되는지*에 대한 설계입니다.",67,133
545,6,45,"다음 중 기본키는 NULL 값을 가져서는 안되며, 릴레이션 내에 오직 하나의 값만 존재해야 한다는 조건을 무엇이라 하는가?",,개체 무결성 제약조건,참조 무결성 제약조건,도메인 무결성 제약조건,속성 무결성 제약조건,1,"데이터베이스에서 기본키(Primary Key)는 테이블의 각 행을 유일하게 식별하는 데 사용되는 속성 또는 속성들의 집합입니다.  문제에서 언급된 ""NULL 값을 가져서는 안되며, 릴레이션 내에 오직 하나의 값만 존재해야 한다""는 조건은 기본키의 가장 중요한 특징을 나타냅니다.  NULL 값을 허용하면 유일성이 보장되지 않고, 여러 값이 존재하면 유일한 식별자가 될 수 없기 때문입니다. 이러한 기본키의 무결성을 유지하는 것을  ""개체 무결성 제약조건""이라고 합니다.  개체 무결성은 데이터베이스 내의 각 행이 유일하게 식별될 수 있도록 보장하는 중요한 무결성 제약 조건입니다.  다른 선택지들은 기본키와 직접적인 관련이 없거나, 다른 종류의 무결성 제약 조건을 설명합니다.  예를 들어, 참조 무결성은 외래키 제약 조건과 관련이 있으며, 도메인 무결성은 데이터 타입과 값의 범위를 제한하는 것과 관련이 있습니다. 속성 무결성은 데이터 타입이나 NULL 허용 여부 등 개별 속성에 대한 제약 조건을 의미합니다. 따라서 정답은 1번 개체 무결성 제약조건입니다.",80,133
546,6,46,SQL문에서 HAVING을 사용할 수 있는 절은?,,LIKE 절,WHERE 절,GROUP BY 절,ORDER BY 절,3,"SQL에서 HAVING 절은 GROUP BY 절과 함께 사용하여 그룹화된 결과에 대한 조건을 설정하는 데 사용됩니다.  WHERE 절은 개별 행에 대한 조건을 걸지만, HAVING 절은 GROUP BY 절을 통해 생성된 그룹에 대한 조건을 걸어줍니다.  즉,  GROUP BY 절로 그룹을 만든 후, 그 그룹들 중 특정 조건을 만족하는 그룹만을 선택하고 싶을 때 HAVING 절을 사용합니다.  예를 들어, 특정 지역에서 판매액이 100만원 이상인 지역만을 출력하고 싶다면, GROUP BY 절로 지역별 판매액을 그룹화한 후, HAVING 절을 이용하여 판매액이 100만원 이상인 그룹만 필터링할 수 있습니다.  따라서 HAVING 절은 GROUP BY 절과 함께 사용되어야 의미를 갖습니다.  LIKE 절과 ORDER BY 절은 각각 패턴 매칭과 정렬을 위한 절이므로 HAVING 절과는 관련이 없습니다.",77,126
547,6,47,관계 데이터베이스에 있어서 관계 대수 연산이 아닌 것은?,,디비전(Division),프로젝트(Project),조인(Join),포크(Fork),4,"관계 대수는 관계형 데이터베이스를 조작하기 위한 연산들의 집합입니다.  프로젝트(Project)는 특정 속성만 선택하는 연산이고, 조인(Join)은 두 개의 관계를 특정 조건에 따라 결합하는 연산이며, 디비전(Division)은 한 관계를 다른 관계로 나누는 연산입니다.  이들은 모두 관계형 데이터베이스에서 흔히 사용되는 표준적인 관계 대수 연산입니다.  반면, '포크(Fork)'는 관계 대수 연산으로 정의되어 있지 않습니다.  데이터베이스 연산에서 '포크'라는 용어는 일반적으로 다른 맥락(예: 프로세스 포크)에서 사용되며, 관계형 데이터베이스의 데이터 조작과는 직접적인 관련이 없습니다. 따라서 관계 데이터베이스의 관계 대수 연산이 아닌 것은 '포크(Fork)'입니다.",77,129
548,6,48,"학적 테이블에서 전화번호가 Null값이 아닌 학생명을 모두 검색할 때, SQL 구문으로 옳은 것은?",,SELECT FROM 07 WHERE 전화번호 DON'T NULL;,SELECT FROM WHERE 전화번호 != NOT NULL;,SELECT 학생명 FROM 학적 WHERE 전화번호 IS NOT NULL;,SELECT FROM WHERE 전화번호 IS NULL;,3,"이 문제는 SQL을 이용하여 데이터베이스에서 특정 조건을 만족하는 데이터를 검색하는 방법을 묻고 있습니다.  문제에서 학적 테이블의 전화번호가 Null 값이 아닌 학생들의 이름(학생명)을 검색해야 합니다.  SQL에서 Null 값을 비교하는 방법은 일반적인 비교 연산자( =, !=, <, > 등)를 사용할 수 없습니다. Null 값은 '값이 없다'는 의미이기 때문에 특별한 연산자인 `IS NULL` 과 `IS NOT NULL`을 사용해야 합니다.",84,126
549,6,49,관계형 데이터베이스에서 다음 설명에 해당하는 키(Key)는?,https://www.cbtbank.kr/images/iz/iz20210814/iz20210814m49.gif,후보키,대체키,슈퍼키,외래키,3,"관계형 데이터베이스에서 키(Key)는 데이터베이스 내의 레코드(튜플)들을 유일하게 식별하는 데 사용되는 속성 또는 속성들의 집합입니다.  문제에서 설명하는 키는 ""릴레이션을 구성하는 모든 튜플에 대한 유일성은 만족시키지만 최소성은 만족시키지 못한다""고 합니다.  유일성이란 키 값이 중복되지 않고 각 튜플을 유일하게 식별한다는 의미이고, 최소성이란 키를 구성하는 속성 중 어떤 속성도 제거하면 유일성이 보장되지 않는다는 의미입니다.  슈퍼키는 유일성을 만족하지만 최소성을 만족하지 않는 키를 의미합니다.  즉, 슈퍼키는 유일하게 튜플을 식별할 수 있지만, 불필요한 속성을 포함하고 있을 수 있습니다.  예를 들어, 학생 테이블에서 학번과 이름을 합쳐서 키로 사용한다면, 학번만으로도 유일하게 학생을 식별할 수 있으므로 학번과 이름을 합친 키는 슈퍼키가 됩니다.  반면 후보키는 유일성과 최소성을 모두 만족하는 키이고, 대체키는 후보키 중에서 주키(primary key)로 선택되지 않은 키이며, 외래키는 다른 테이블의 주키를 참조하는 키입니다. 따라서 문제의 설명에 해당하는 키는 슈퍼키입니다.",73,129
550,6,50,데이터베이스에서 인덱스(Index)와 관련한 설명으로 틀린 것은?,,인덱스의 기본 목적은 검색 성능을 최적화하는 것으로 볼 수 있다.,B-트리 인덱스는 분기를 목적으로 하는 Branch Block을 가지고 있다.,BETWEEN 등 범위(Range) 검색에 활용될 수 있다.,시스템이 자동으로 생성하여 사용자가 변경할 수 없다.,4,"인덱스는 책의 목차와 같다고 생각하면 이해하기 쉽습니다. 책에서 특정 내용을 찾을 때 목차를 이용하면 훨씬 빠르게 찾을 수 있듯이, 데이터베이스에서도 인덱스는 특정 데이터를 빠르게 찾기 위해 사용됩니다.  1번은 인덱스의 주요 목적을 정확하게 설명하고 있습니다. 2번은 B-트리 인덱스의 특징을 잘 나타내고 있습니다. B-트리는 계층적인 구조를 가지고 있으며, Branch Block은 다음 레벨의 데이터 블록을 가리키는 역할을 합니다. 3번 또한 인덱스를 이용하여 BETWEEN과 같은 범위 검색을 효율적으로 수행할 수 있습니다. 하지만 4번은 틀렸습니다.  대부분의 데이터베이스 시스템에서는 사용자가 인덱스를 직접 생성하거나 삭제할 수 있습니다. 시스템이 자동으로 생성하는 인덱스도 있지만, 사용자가 관리할 수 없는 것은 아닙니다. 따라서 4번이 틀린 설명입니다.",80,128
551,6,51,로킹 단위(Locking Granularity)에 대한 설명으로 옳은 것은?,,로킹 단위가 크면 병행성 수준이 낮아진다.,로킹 단위가 크면 병행 제어 기법이 복잡해진다.,로킹 단위가 작으면 로크(lock)의 수가 적어진다.,"로킹은 파일 단위로 이루어지며, 레코드와 필드는 로킹 단위가 될 수 없다.",1,"로킹 단위(Locking Granularity)란 데이터베이스에서 동시에 여러 사용자가 데이터를 접근하고 변경하는 것을 제어하기 위해 데이터를 잠그는 단위를 의미합니다.  로킹 단위가 크다는 것은 한 번에 더 많은 데이터를 잠근다는 것을 의미하며, 예를 들어 파일 전체를 잠그는 경우 파일 단위 로킹이라고 합니다. 반대로 로킹 단위가 작다는 것은 한 번에 더 적은 데이터(예: 레코드, 필드)를 잠근다는 것을 의미합니다.  문제에서 1번이 정답인 이유는 로킹 단위가 클수록 동시에 접근 가능한 데이터의 양이 줄어들기 때문에 병행성 수준이 낮아지기 때문입니다.  파일 전체를 잠그면 여러 사용자가 동시에 파일을 수정할 수 없으므로 병행성이 떨어집니다.  반면 로킹 단위가 작으면(예: 레코드 단위) 여러 사용자가 서로 다른 레코드를 동시에 수정할 수 있으므로 병행성이 높아집니다.  2번은 로킹 단위가 크다고 해서 항상 병행 제어 기법이 복잡해지는 것은 아닙니다.  3번은 로킹 단위가 작으면 오히려 로크의 수가 증가합니다.  4번은 잘못된 설명입니다.  레코드나 필드도 로킹 단위가 될 수 있습니다.",65,131
552,6,52,관계 대수에 대한 설명으로 틀린 것은?,,원하는 릴레이션을 정의하는 방법을 제공하며 비절차적 언어이다.,릴레이션 조작을 위한 연산의 집합으로 피연산자와 결과가 모두 릴레이션이다.,일반 집합 연산과 순수 관계 연산으로 구분된다.,질의에 대한 해를 구하기 위해 수행해야 할 연산의 순서를 명시한다.,1,"관계 대수는 데이터베이스의 자료를 조작하는 방법 중 하나입니다.  문제에서 틀린 것은 1번입니다. 관계 대수는 원하는 릴레이션(관계, 즉 테이블)을 얻기 위한 연산들을 정의하는 방법을 제공하지만, *어떤 순서로* 연산을 수행해야 하는지는 명시하지 않습니다.  즉, 비절차적(declarative) 언어라는 점이 핵심입니다.  프로그래밍처럼 단계별 명령어를 나열하는 것이 아니라, ""어떤 결과를 얻고 싶다""는 것을 선언하는 방식입니다.  데이터베이스 시스템이 최적의 실행 계획을 스스로 세워서 원하는 결과를 효율적으로 가져옵니다.  따라서 4번은 관계 대수의 특징이 아닌, 데이터베이스 시스템의 최적화 과정에 대한 설명입니다.  2번과 3번은 관계 대수의 정확한 설명입니다.  2번은 관계 대수 연산의 입력과 출력이 모두 릴레이션이라는 점을, 3번은 일반 집합 연산(합집합, 교집합 등)과 관계 연산(선택, 투영, 조인 등)으로 구분된다는 점을 보여줍니다.",65,129
553,6,53,데이터의 중복으로 인하여 관계연산을 처리할 때 예기치 못한 곤란한 현상이 발생하는 것을 무엇이라 하는가?,,이상(Anomaly),제한 (Restriction),종속성(Dependency),변환(Translation),1,"관계형 데이터베이스에서 관계 연산을 수행할 때, 데이터 중복으로 인해 예상치 못한 결과가 발생하는 현상을 이상(Anomaly)이라고 합니다.  예를 들어, 같은 사람의 정보가 여러 행에 중복되어 저장되어 있다면,  데이터를 수정하거나 삭제할 때 일관성을 유지하기 어렵고, 잘못된 결과를 초래할 수 있습니다. 이러한 데이터 중복으로 인한 문제는 데이터베이스의 무결성을 깨뜨리고, 데이터 관리의 어려움을 야기합니다.  따라서 데이터 중복을 최소화하기 위해 데이터베이스 설계 단계에서 정규화 과정을 거치는 것이 중요합니다. 정규화는 데이터 중복을 줄이고 데이터 무결성을 높이는 데이터베이스 설계 기법입니다.  이상 현상은 데이터베이스의 정규화가 제대로 이루어지지 않았을 때 발생하는 대표적인 문제 중 하나입니다.",84,129
554,6,54,다음 중 SQL에서의 DDL 문이 아닌 것은?,,CREATE,DELETE,ALTER,DROP,2,"SQL(Structured Query Language)은 데이터베이스를 관리하고 조작하는 데 사용되는 표준 언어입니다.  SQL 문은 크게 데이터 정의어(DDL: Data Definition Language), 데이터 조작어(DML: Data Manipulation Language), 데이터 제어어(DCL: Data Control Language)로 나뉩니다.",76,127
555,6,55,정규화에 대한 설명으로 적절하지 않은 것은?,,데이터베이스의 개념적 설계 단계 이전에 수행한다.,데이터 구조의 안정성을 최대화한다.,"중복을 배제하여 삽입, 삭제, 갱신 이상의 발생을 방지한다.",데이터 삽입 시 릴레이션을 재구성할 필요성을 줄인다.,1,"정규화는 데이터베이스 설계에서 데이터 중복을 최소화하고 데이터 무결성을 유지하기 위한 중요한 과정입니다.  데이터 중복이 많으면 데이터 삽입, 삭제, 수정 시 여러 곳을 일일이 변경해야 하는 문제(삽입, 삭제, 갱신 이상)가 발생하고, 데이터 불일치로 인한 오류가 생길 가능성이 높아집니다. 정규화는 이러한 문제를 해결하기 위해 데이터를 여러 개의 테이블로 분해하고, 각 테이블에 필요한 데이터만 저장하도록 설계하는 방법입니다.  따라서 2번, 3번, 4번은 정규화의 목적과 효과를 잘 나타내고 있습니다.  하지만 1번은 잘못된 설명입니다. 정규화는 데이터베이스의 개념적 설계 단계 *이후*에 수행됩니다. 개념적 설계 단계에서는 데이터베이스의 전반적인 구조와 엔티티, 관계 등을 정의하고, 그 이후에 정규화를 통해 논리적 설계를 구체화하고 데이터 중복을 제거하는 것입니다.  즉, 정규화는 개념적 설계를 바탕으로 데이터베이스의 논리적 구조를 최적화하는 과정입니다.",74,130
556,6,56,트랜잭션의 주요 특성 중 하나로 둘 이상의 트랜잭션이 동시에 병행 실행되는 경우 어느 하나의 트랜잭션 실행 중에 다른 트랜잭션의 연산이 끼어들 수 없음을 의미하는 것은?,,Log,Consistency,Isolation,Durability,3,"여러 개의 트랜잭션이 동시에 데이터베이스를 접근하여 작업을 수행할 때,  각 트랜잭션은 마치 자신만 데이터베이스를 독점하여 사용하는 것처럼 동작해야 데이터의 일관성을 유지할 수 있습니다.  'Isolation'(격리) 특성은 바로 이러한 상황을 보장합니다.  즉, 둘 이상의 트랜잭션이 동시에 실행되더라도, 어떤 트랜잭션의 연산이 다른 트랜잭션의 연산에 영향을 주거나 끼어들지 않도록 격리하여 실행하는 것을 의미합니다.  마치 여러 사람이 동시에 은행 업무를 처리하더라도, 각 사람의 거래가 서로 섞이거나 영향을 받지 않고 독립적으로 처리되는 것과 같습니다.  만약 Isolation 특성이 없다면, 한 트랜잭션이 데이터를 읽는 도중 다른 트랜잭션이 그 데이터를 변경하는 등의 문제가 발생하여 데이터의 일관성이 깨질 수 있습니다.",73,127
557,6,57,SQL의 논리 연산자가 아닌 것은?,,AND,OTHER,OR,NOT,2,"SQL은 데이터베이스를 관리하고 조작하는 데 사용되는 언어입니다.  WHERE 절 등에서 조건을 설정할 때 사용하는 논리 연산자는 데이터를 검색하거나 필터링하는 데 중요한 역할을 합니다.  AND, OR, NOT은 모두 SQL에서 사용되는 대표적인 논리 연산자입니다. AND는 두 조건 모두 참일 때만 참이 되고, OR은 두 조건 중 하나라도 참이면 참이 되며, NOT은 조건의 참/거짓을 반대로 바꿉니다.  문제에서 제시된 'OTHER'는 표준 SQL에서 정의된 논리 연산자가 아니므로 정답이 아닙니다.  즉,  'OTHER'는 SQL에서 특정 논리 연산을 나타내는 키워드가 아니라는 의미입니다.",85,126
558,6,58,동시성 제어를 위한 직렬화 기법으로 트랜잭션 간의 처리 순서를 미리 정하는 방법은?,,로킹 기법,타임스탬프 기법,검증 기법,배타 로크 기법,2,"여러 개의 트랜잭션이 동시에 데이터베이스를 접근할 때 발생하는 문제를 해결하기 위해 동시성 제어 기법이 사용됩니다.  문제에서처럼 트랜잭션 간의 처리 순서를 미리 정하는 방법은 바로 타임스탬프 기법입니다.  타임스탬프 기법은 각 트랜잭션에 고유한 시간 값(타임스탬프)을 부여하고, 이 타임스탬프를 기준으로 트랜잭션의 실행 순서를 결정합니다.  시간이 빠른 트랜잭션이 먼저 실행되도록 함으로써 데이터베이스의 일관성을 유지하는 것이죠.  마치 번호표를 뽑아 순서대로 처리하는 것과 같은 원리입니다.  반면 로킹 기법은 특정 데이터에 대한 접근 권한을 제어하는 방식이고, 검증 기법은 트랜잭션이 완료될 때 데이터의 일관성을 검증하는 방식입니다. 배타 로크 기법은 로킹 기법의 한 종류로, 한 트랜잭션이 데이터를 독점적으로 사용하도록 하는 기법입니다. 따라서 트랜잭션 처리 순서를 미리 정하는 기법은 타임스탬프 기법이 가장 적절합니다.",74,127
559,6,59,이전 단계의 정규형을 만족하면서 후보키를 통하지 않는 조인 종속(JD : Join Dependency) 제거해야 만족하는 정규형은?,,제3정규형,제4정규형,제5정규형,제6정규형,3,"데이터베이스 정규화는 데이터 중복을 최소화하고 데이터 무결성을 높이기 위한 과정입니다.  정규형은 이러한 정규화의 단계를 나타내는 것으로, 낮은 정규형은 데이터 중복이 많고 무결성이 낮으며, 높은 정규형은 데이터 중복이 적고 무결성이 높습니다.  문제에서 언급된 '조인 종속(JD)'은 여러 테이블을 조인했을 때, 특정 속성들의 조합이 다른 속성들을 결정하는 종속성을 의미합니다.  이러한 조인 종속이 존재하면 데이터 중복이 발생할 가능성이 높습니다.  제3정규형까지는 함수적 종속성(한 속성이 다른 속성을 결정하는 종속성)을 제거하는 데 초점을 맞추지만, 제4정규형부터는 조인 종속성까지 고려합니다.  따라서 이전 단계의 정규형을 만족하면서 후보키를 통하지 않는 조인 종속을 제거해야 하는 정규형은 제5정규형입니다.  제5정규형은 모든 조인 종속성을 제거하여 데이터 중복을 최소화하고 데이터 무결성을 최대한 높인 상태를 의미합니다.  문제의 정답이 3번(제5정규형)인 이유는 바로 이 때문입니다.",65,130
560,6,60,어떤 릴레이션 R에서 X와 Y를 각각 R의 애트리뷰트 집합의 부분 집합이라고 할 경우 애트리뷰트 X의 값 각각에 대해 시간에 관계없이 항상 애트리뷰트 Y의 값이 오직 하나만 연관되어 있을 때 Y는 X에 함수 종속이라고 한다. 이 함수 종속의 표기로 옳은 것은?,,Y → X,Y ⊂ X,X → Y,X ⊂ Y,3,"함수 종속은 데이터베이스에서 매우 중요한 개념입니다.  쉽게 설명하자면, 어떤 속성(X)의 값이 정해지면 다른 속성(Y)의 값이 단 하나로 결정되는 관계를 말합니다.  예를 들어, '주민등록번호(X)'가 주어지면 '이름(Y)'은 단 하나로 정해집니다.  하지만 '이름(Y)'이 주어졌다고 해서 '주민등록번호(X)'가 단 하나로 정해지는 것은 아닙니다(동명이인이 있을 수 있으므로).  문제에서 X의 값 하나에 대해 Y의 값이 오직 하나만 연관되어 있다고 했으므로, X가 Y를 결정한다는 의미이며, 이를 표기하는 방법은 X → Y 입니다. 따라서 정답은 3번입니다.  1번은 Y가 X를 결정한다는 의미이고, 2번과 4번은 집합 포함 관계를 나타내는 표기이므로 함수 종속과는 관련이 없습니다.",54,129
561,6,61,모듈 내 구성 요소들이 서로 다른 기능을 같은 시간대에 함께 실행하는 경우의 응집도(Cohesion)는?,,Temporal Cohesion,Logical Cohesion,Coincidental Cohesion,Sequential Cohesion,1,"모듈 내 구성 요소들이 서로 다른 기능을 같은 시간대에 함께 실행하는 경우, 이러한 요소들은 시간적으로 연관되어 있습니다.  즉, 특정 시간에만 함께 동작하는 특징을 가지고 있죠.  이러한 응집도를 시간적 응집도(Temporal Cohesion)라고 합니다.  예를 들어, 시스템의 초기화 과정에서 여러 구성 요소가 동시에 실행되는 경우가 이에 해당합니다.  다른 응집도 유형들은 시간적 연관성보다는 기능적 연관성이나 우연적인 연관성에 초점을 맞추고 있습니다. 따라서, 서로 다른 기능을 동시에 실행하는 경우에는 시간적 응집도가 가장 적절한 설명이 됩니다.",59,106
562,6,62,오류 제어에 사용되는 자동반복 요청방식(ARQ)이 아닌 것은?,,Stop-and-wait ARQ,Go-back-N ARQ,Selective-Repeat ARQ,Non-Acknowledge ARQ,4,"자동반복 요청(ARQ) 방식은 데이터 전송 과정에서 오류가 발생했을 때, 오류를 감지하고 재전송을 요청하는 방식입니다.  Stop-and-wait ARQ는 한 번에 하나의 패킷만 전송하고, 확인 응답(ACK)을 받아야 다음 패킷을 전송하는 방식입니다. Go-back-N ARQ는 여러 개의 패킷을 연속적으로 전송하고, 순서대로 ACK를 받지 못하면 그 이후의 모든 패킷을 재전송하는 방식입니다. Selective-Repeat ARQ는 여러 개의 패킷을 전송하고, ACK를 받지 못한 패킷만 재전송하는 방식입니다.  반면 Non-Acknowledge ARQ는 확인 응답(ACK)을 전혀 사용하지 않는 방식입니다.  오류 발생 시 재전송 여부를 판단하는 메커니즘이 없으므로, 오류 제어에 사용될 수 없습니다. 따라서 오류 제어에 사용되는 ARQ 방식이 아닌 것은 Non-Acknowledge ARQ입니다.",64,145
563,6,63,다음 파이썬(Python) 프로그램이 실행되었을 때의 결과는?,https://www.cbtbank.kr/images/iz/iz20210814/iz20210814m63.gif,45,55,66,78,3,"이 파이썬 코드는 `cs`라는 함수를 정의하고 있습니다.  `cs` 함수는 입력값 `n`을 받아 0부터 `n`까지의 정수를 모두 더한 값을 반환합니다.  `range(n+1)`은 0부터 n까지의 숫자를 생성하는 함수입니다.  `for` 문을 통해 0부터 n까지의 각 숫자를 `s` 변수에 더하고, 최종적으로 `s`의 값(합계)을 반환합니다.  `print(cs(11))`은 `cs` 함수에 11을 입력값으로 주고, 그 결과를 출력하는 명령어입니다. 따라서 0부터 11까지의 합 (0 + 1 + 2 + ... + 10 + 11)을 계산하는데, 이 값은 66입니다.  수학적으로는 n(n+1)/2 공식을 이용하여 11(11+1)/2 = 66으로 계산할 수도 있습니다.",66,141
564,6,64,다음 C언어 프로그램이 실행되었을 때의 결과는?,https://www.cbtbank.kr/images/iz/iz20210814/iz20210814m64.gif,nation,nationalter,alter,alternation,2,"이 C언어 프로그램은 문자열을 다루는 함수 `strcat`의 사용을 보여줍니다.  `strcat` 함수는 첫 번째 인자로 주어진 문자열의 끝에 두 번째 인자로 주어진 문자열을 붙이는 역할을 합니다.  `str` 배열에는 ""nation""이라는 문자열이 저장되어 있고, `p2` 포인터는 ""alter""라는 문자열을 가리키고 있습니다.  `strcat(str, p2);` 라인은 ""nation""의 끝에 ""alter""를 붙여 ""nationalter""를 만듭니다.  따라서 `printf(""%s"", str);`는 ""nationalter""를 출력합니다.  `str` 배열의 크기가 50이므로 충분한 공간이 있고, 메모리 범위를 벗어나는 문제는 발생하지 않습니다.",75,141
565,6,65,JAVA에서 힙(Heap)에 남아있으나 변수가 가지고 있던 참조값을 잃거나 변수 자체가 없어짐으로써 더 이상 사용되지 않는 객체를 제거해주는 역할을 하는 모듈은?,,Heap Collector,Garbage Collector,Memory Collector,Variable Collector,2,"JAVA에서 객체는 메모리의 힙(Heap) 영역에 저장됩니다.  프로그램이 객체를 생성하면 힙에 객체가 생성되고, 변수는 이 객체의 주소(참조값)를 저장하여 객체에 접근합니다.  그런데 프로그램 실행 중에 더 이상 사용하지 않는 객체가 힙에 남아있을 수 있습니다.  예를 들어, 변수가 다른 객체를 참조하도록 변경되거나, 변수 자체가 프로그램의 범위를 벗어나 소멸되면 해당 객체는 더 이상 참조되지 않게 됩니다.  이렇게 참조되지 않는 객체는 메모리 공간만 차지할 뿐 프로그램 실행에 필요하지 않으므로 제거해야 합니다.  이 역할을 하는 것이 바로 Garbage Collector(가비지 컬렉터)입니다.  Garbage Collector는 주기적으로 힙을 검사하여 참조되지 않는 객체를 자동으로 찾아내어 메모리에서 제거함으로써 메모리 누수를 방지하고 시스템 성능을 향상시키는 역할을 합니다.  Heap Collector, Memory Collector, Variable Collector는 모두 가비지 컬렉터의 다른 이름으로 사용될 수 있지만, 일반적으로 Garbage Collector라는 용어가 가장 널리 사용됩니다. 따라서 정답은 2번 Garbage Collector입니다.",80,107
566,6,66,다음 C언어 프로그램이 실행되었을 때의 결과는?,https://www.cbtbank.kr/images/iz/iz20210814/iz20210814m66.gif,0,1,2,3,3,"이 C언어 프로그램은 논리 연산자(&&, ||, !)와 비교 연산자(>, <, ==, <=)를 사용하여 변수들의 값을 비교하고, 그 결과를 바탕으로 r1, r2, r3 변수에 정수 값(1 또는 0)을 저장합니다.  `||`는 논리합(OR), `&&`는 논리곱(AND), `!`는 논리 부정(NOT) 연산자입니다.  각 연산의 결과는 참이면 1, 거짓이면 0으로 표현됩니다.",67,141
567,6,67,다음 중 JAVA에서 우선순위가 가장 낮은 연산자는?,,--,%,&,=,4,"JAVA에서 연산자의 우선순위는 연산이 수행되는 순서를 결정합니다.  우선순위가 높은 연산자는 먼저 계산되고, 우선순위가 낮은 연산자는 나중에 계산됩니다.  문제에서 제시된 연산자 중 `=`는 대입 연산자입니다.  대입 연산자는 오른쪽 피연산자의 값을 왼쪽 피연산자에 할당하는 역할을 합니다.  다른 연산자들(`--`, `%`, `&`)은 각각 감소 연산자, 나머지 연산자, 비트 AND 연산자로, 대입 연산자보다 우선순위가 높습니다. 따라서 JAVA에서 우선순위가 가장 낮은 연산자는 `=`(대입 연산자)입니다.  쉽게 말해,  `=`는 다른 계산이 모두 끝난 후에야 값을 할당하는 역할을 합니다.",70,141
568,6,68,"사용자가 요청한 디스크 입·출력 내용이 다음과 같은 순서로 큐에 들어 있을 때 SSTF 스케쥴링을 사용한 경우의 처리 순서는? (단, 현재 헤드 위치는 53 이고, 제일 안쪽이 1번, 바깥쪽이 200번 트랙이다.)",https://www.cbtbank.kr/images/iz/iz20210814/iz20210814m68.gif,53-65-67-37-14-98-122-124-183,53-98-183-37-122-14-124-65-67,53-37-14-65-67-98-122-124-183,53-67-65-124-14-122-37-183-98,1,"이 문제는 디스크 스케줄링 알고리즘 중 하나인 SSTF(Shortest Seek Time First) 알고리즘을 이해하고 적용하는 문제입니다. SSTF 알고리즘은 현재 헤드 위치에서 가장 가까운 트랙의 요청을 먼저 처리하는 방식입니다.  문제에서 현재 헤드 위치는 53이고, 큐에는 98, 183, 37, 122, 14, 124, 65, 67 순으로 요청이 들어와 있습니다.  따라서, 53에서 가장 가까운 트랙은 65 또는 67입니다.  65를 먼저 처리하고, 그 다음 67을 처리하는 식으로,  현재 위치에서 가장 가까운 트랙 순서대로 처리해 나가면 됩니다.  이 과정을 반복하여 모든 요청을 처리하는 순서를 찾으면 됩니다.  1번 답변인 53-65-67-37-14-98-122-124-183이 바로 이러한 SSTF 알고리즘을 적용한 결과입니다. 다른 답변들은 헤드의 이동 거리를 최소화하는 SSTF 알고리즘의 원칙을 따르지 않았습니다.",57,111
569,6,69,192.168.1.0/24 네트워크를 FLSM 방식을 이용하여 4개의 Subnet으로 나누고 IP Subnet-zero를 적용했다. 이 때 Subnetting 된 네트워크 중 4번째 네트워크의 4번째 사용가능한 IP는 무엇인가?,,192.168.1.192,192.168.1.195,192.168.1.196,192.168.1.198,3,"192.168.1.0/24 네트워크는 총 256개(2<sup>8</sup>)의 IP 주소를 가지고 있습니다.  /24는 네트워크 마스크가 255.255.255.0임을 의미하며, 호스트 부분은 8비트(256개)입니다. 이 네트워크를 FLSM(Flexible Length Subnet Masking) 방식으로 4개의 서브넷으로 나누려면 호스트 부분의 2비트를 차용해야 합니다(2<sup>2</sup> = 4). 따라서 각 서브넷은 64개(2<sup>6</sup>)의 IP 주소를 가지게 되고, 그 중 2개는 네트워크 주소와 브로드캐스트 주소로 사용되므로 실제 사용 가능한 IP 주소는 62개입니다.",53,145
570,6,70,C Class에 속하는 IP address는?,,200.168.30.1,10.3.2.1 4,225.2.4.1,172.16.98.3,1,"IP 주소는 네트워크 상에서 컴퓨터를 식별하는 고유한 주소입니다.  IP 주소는 네트워크 클래스에 따라 구분되는데, 클래스 A, B, C 등으로 나뉩니다.  클래스 C IP 주소는 첫 번째 옥텟(8비트)이 192~223으로 시작합니다. 문제에서 제시된 IP 주소들을 살펴보면, 1번 200.168.30.1은 첫 번째 옥텟이 200이므로 클래스 C에 속합니다.  2번 10.3.2.1은 클래스 A, 3번 225.2.4.1은 클래스 C를 넘어선 특수 주소 영역, 4번 172.16.98.3은 클래스 B에 속합니다. 따라서 클래스 C에 속하는 IP 주소는 1번 200.168.30.1 입니다.  (참고로, 클래스 A는 1~126, 클래스 B는 128~191로 시작합니다.  현재는 클래스 없는 도메인 라우팅(CIDR) 방식이 주로 사용되지만, 기본적인 IP 주소 클래스 구분은 여전히 중요한 개념입니다.)",58,145
571,6,71,다음 C언어 프로그램이 실행되었을 때의 결과는?,https://www.cbtbank.kr/images/iz/iz20210814/iz20210814m71.gif,0,4,8,12,3,"이 문제는 C언어의 포인터와 메모리 주소 연산에 대한 이해를 묻는 문제입니다.  `int n = 4;`는 정수형 변수 n을 선언하고 4를 저장합니다. `int* pt = NULL;`는 정수형 포인터 변수 pt를 선언하고 NULL(0)을 저장합니다. `pt = &n;`는 pt에 n의 메모리 주소를 저장합니다.  `printf(""%d"", &n + *pt - &pt + n);` 에서  `&n`은 n의 주소, `*pt`는 pt가 가리키는 값(n의 값, 즉 4), `&pt`는 pt의 주소입니다.  이들을 계산하면 다음과 같습니다.",60,141
572,6,72,"귀도 반 로섬(Guido van Rossum)이 발표한 언어로 인터프리터 방식이자 객체지향적이며, 배우기 쉽고 이식성이 좋은 것이 특징인 스크립트 언어는?",,C++,JAVA,C#,Python,4,"문제에서 제시된 특징들을 살펴보면, 귀도 반 로섬이 개발한 언어, 인터프리터 방식, 객체지향적, 배우기 쉽고 이식성이 좋다는 점 등이 Python 언어의 주요 특징들입니다.  C++, JAVA, C#은 모두 컴파일 방식의 언어이며, Python에 비해 배우는 데 상대적으로 높은 진입장벽을 가지고 있습니다. 따라서, 문제의 조건에 가장 부합하는 언어는 Python입니다.  Python은 다양한 분야에서 활용되며, 그 간결하고 직관적인 문법 덕분에 초보자도 쉽게 접근할 수 있다는 장점이 있습니다.",77,142
573,6,73,다음 JAVA 프로그램이 실행되었을 때의 결과를 쓰시오.,https://www.cbtbank.kr/images/iz/iz20210814/iz20210814m73.gif,13,21,34,55,3,"이 JAVA 프로그램은 피보나치 수열을 계산하는 코드입니다. 피보나치 수열은 첫 번째 항이 0, 두 번째 항이 1이고, 그 이후의 항은 바로 앞의 두 항의 합으로 이루어지는 수열입니다.  `arr` 배열에 피보나치 수열의 값들을 저장합니다. `while` 루프는 8번 반복되며, 각 반복마다 다음 피보나치 수를 계산하여 `arr` 배열에 저장합니다.  `arr[0] = 0`, `arr[1] = 1`로 초기화되고, 루프를 통해 `arr[2]`부터 `arr[9]`까지 피보나치 수열의 값들이 채워집니다.  마지막으로 `arr[9]`의 값(8번째 피보나치 수)을 출력합니다.  실제로 계산해보면 다음과 같습니다.",60,111
574,6,74,프로세스와 관련한 설명으로 틀린 것은?,,프로세스가 준비 상태에서 프로세서가 배당되어 실행 상태로 변화하는 것을 디스패치(Dispatch)라고 한다.,"프로세스 제어 블록(PCB, Process Control Block)은 프로세스 식별자, 프로세스 상태 등의 정보로 구성된다.",이전 프로세스의 상태 레지스터 내용을 보관하고 다른 프로세스의 레지스터를 적재하는 과정을 문맥 교환(Context Switching)이라고 한다.,"프로세스는 스레드(Thread) 내에서 실행되는 흐름의 단위이며, 스레드와 달리 주소 공간에 실행 스택(Stack)이 없다.",4,"4번 문항은 프로세스와 스레드의 차이점에 대한 설명입니다.  프로세스는 독립적인 메모리 공간(주소 공간)을 가지고 실행되는 프로그램의 인스턴스입니다.  반면 스레드는 하나의 프로세스 내에서 실행되는 실행 흐름의 단위로, 같은 프로세스 내의 다른 스레드와 메모리 공간을 공유합니다.  따라서 스레드는 프로세스 내에 존재하며,  자신만의 독립적인 실행 스택을 가지고 있지 않다는 것은 틀린 설명입니다.  스레드는 프로세스의 자원(메모리 공간 등)을 공유하지만, 각 스레드는 자신만의 스택을 가지고 있어서 지역 변수나 함수 호출 정보를 저장합니다.  따라서 4번 문항의 설명은 프로세스와 스레드의 관계 및 스레드의 특징에 대한 오류를 포함하고 있습니다.  1, 2, 3번 문항은 프로세스의 상태 변화, 프로세스 제어 블록, 문맥 교환에 대한 정확한 설명입니다.",69,144
575,6,75,모듈의 독립성을 높이기 위한 결합도(Coupling)와 관련한 설명으로 틀린 것은?,,오류가 발생했을 때 전파되어 다른 오류의 원인이 되는 파문 효과(Ripple Effect)를 최소화해야 한다.,인터페이스가 정확히 설정되어 있지 않을 경우 불필요한 인터페이스가 나타나 모듈 사이의 의존도는 높아지고 결합도가 증가한다.,모듈들이 변수를 공유하여 사용하게 하거나 제어 정보를 교류하게 함으로써 결합도를 낮추어야 한다.,다른 모듈과 데이터 교류가 필요한 경우 전역변수(Global Variable)보다는 매개변수(Parameter)를 사용하는 것이 결합도를 낮추는 데 도움이 된다.,3,"이 문제는 모듈 간의 결합도(Coupling)를 낮추는 방법에 대한 이해도를 묻는 문제입니다.  결합도란 모듈 간의 상호 의존성 정도를 나타내는 척도로, 결합도가 높으면 모듈 간의 의존성이 높아 하나의 모듈에 오류가 발생하면 다른 모듈에도 영향을 미치는 파급 효과(Ripple Effect)가 커지게 됩니다. 따라서 좋은 소프트웨어 설계를 위해서는 결합도를 낮추는 것이 중요합니다.",60,106
576,6,76,TCP헤더와 관련한 설명으로 틀린 것은?,,순서번호(Sequence Number)는 전달하는 바이트마다 번호가 부여된다.,수신번호확인(Acknowledgement Number)은 상대편 호스트에서 받으려는 바이트의 번호를 정의한다.,체크섬(Checksum)은 데이터를 포함한 세그먼트의 오류를 검사한다.,윈도우 크기는 송수신 측의 버퍼 크기로 최대크기는 32767bit 이다.,4,문제에서 제시된 TCP 헤더의 구성 요소들을 살펴보고 틀린 부분을 찾아봅시다.,69,145
577,6,77,모듈화(Modularity)와 관련한 설명으로 틀린 것은?,,"소프트웨어의 모듈은 프로그래밍 언어에서 Subroutine, Function 등으로 표현될 수 있다.","모듈의 수가 증가하면 상대적으로 각 모듈의 크기가 커지며, 모듈 사이의 상호교류가 감소하여 과부하(Overload) 현상이 나타난다.","모듈화는 시스템을 지능적으로 관리할 수 있도록 해주며, 복잡도 문제를 해결하는 데 도움을 준다.",모듈화는 시스템의 유지보수와 수정을 용이하게 한다.,2,"모듈화는 소프트웨어를 여러 개의 독립적인 모듈로 나누는 것을 의미합니다.  각 모듈은 특정 기능을 수행하며, 다른 모듈과는 최소한의 인터페이스만을 통해 상호작용합니다.  문제에서 틀린 것은 2번입니다. 모듈의 수가 증가한다고 해서 각 모듈의 크기가 반드시 커지는 것은 아닙니다. 오히려 모듈화를 통해 각 모듈의 크기는 작고, 기능은 명확해집니다.  모듈의 수가 증가하면 모듈 간의 상호작용이 복잡해질 수는 있지만,  잘 설계된 모듈화는 이러한 상호작용을 최소화하고, 과부하 현상을 방지하는 데 도움이 됩니다.  즉, 모듈의 수 증가는 과부하의 원인이 될 수도 있지만,  항상 그런 것은 아니며,  오히려 잘 설계된 모듈화는 과부하를 줄이는 데 기여합니다.  나머지 1, 3, 4번은 모두 모듈화의 장점을 잘 나타내고 있습니다.  1번은 모듈이 어떻게 표현되는지, 3번은 모듈화의 목적, 4번은 모듈화의 이점을 설명하고 있습니다.",79,106
578,6,78,다음 중 페이지 교체(Page Replacement)알고리즘이 아닌 것은?,,FIFO(First-In-First-Out),LUF(Least Used First),Optimal,LRU(Least Recently Used),2,"페이지 교체 알고리즘은 메모리에 모든 페이지를 적재할 수 없을 때, 어떤 페이지를 메모리에서 꺼내고 새로운 페이지를 적재할지를 결정하는 알고리즘입니다.  FIFO(First-In-First-Out)는 가장 먼저 들어온 페이지를 먼저 꺼내는 방식이고, LRU(Least Recently Used)는 가장 최근에 사용되지 않은 페이지를 먼저 꺼내는 방식이며, Optimal 알고리즘은 미래에 가장 늦게 사용될 페이지를 꺼내는 방식입니다.  문제에서 제시된 LUF(Least Used First)는  가장 적게 사용된 페이지를 먼저 교체하는 알고리즘으로,  일반적인 페이지 교체 알고리즘으로 분류되지 않습니다.  정보처리기사 공식 교재에서는 FIFO, LRU, Optimal 알고리즘을 주로 다루며, LUF는 다루지 않거나, 다른 맥락에서 설명될 가능성이 높습니다. 따라서 정답은 2번 LUF입니다.",46,121
579,6,79,C언어에서의 변수 선언으로 틀린 것은?,,int else;,int Test2;,int pc;,int True;,1,"C언어에서 변수를 선언할 때는 변수 이름으로 사용할 수 없는 키워드를 사용하면 안 됩니다.  문제에서 제시된 1번 선택지 `int else;`는 `else`가 C언어의 조건문에서 사용되는 키워드이기 때문에 변수 이름으로 사용할 수 없습니다.  `else`는 조건문의 특정 블록을 실행할지 말지를 결정하는 역할을 하므로, 변수 이름으로 사용하면 컴파일러가 변수인지 키워드인지 구분하지 못해 오류가 발생합니다.  나머지 선택지들은 모두 허용되는 변수 이름입니다.  `Test2`, `pc`, `True`는 C언어의 키워드가 아니므로 변수 이름으로 사용 가능합니다.  따라서 틀린 것은 1번입니다.  변수 이름을 지을 때는 키워드를 피하고, 의미를 명확하게 나타내는 이름을 사용하는 것이 좋습니다.  예를 들어, `count`, `sum`, `average` 등과 같이 변수의 용도를 쉽게 알 수 있는 이름을 사용하는 것이 코드의 가독성을 높이는 데 도움이 됩니다.",71,141
580,6,80,파일 디스크립터(File Descriptor)에 대한 설명으로 틀린 것은?,,파일 관리를 위해 시스템이 필요로 하는 정보를 가지고 있다.,보조기억장치에 저장되어 있다가 파일이 개방(open)되면 주기억장치로 이동된다.,사용자가 파일 디스크립터를 직접 참조할 수 있다.,파일 제어 블록(File Control Block)이라고도 한다.,3,"파일 디스크립터는 운영체제가 파일을 관리하기 위해 사용하는 일종의 번호표라고 생각하면 됩니다.  우리가 파일을 열면(open), 운영체제는 그 파일에 대한 정보(파일의 위치, 크기, 접근 권한 등)를 가지고 있는 파일 제어 블록(File Control Block, FCB)을 찾아서, 그 FCB에 해당하는 고유한 번호(파일 디스크립터)를 프로그램에 할당해줍니다.  프로그램은 이 번호를 이용해서 파일을 읽고 쓰는 등의 작업을 합니다.  따라서 파일 디스크립터는 시스템이 파일 관리에 필요한 정보를 가지고 있고(1번), 파일이 열릴 때 주기억장치에서 관리됩니다(2번).  하지만, 프로그램은 파일 디스크립터 자체를 직접적으로 보거나 조작하지 않습니다.  운영체제가 내부적으로 관리하는 것이기 때문입니다.  파일 제어 블록(FCB)은 파일 디스크립터와 관련된 정보를 담고 있지만, 파일 디스크립터와 완전히 동일한 것은 아닙니다(4번).  결론적으로, 사용자가 파일 디스크립터를 직접 참조할 수 있다는 3번이 틀린 설명입니다.",72,144
581,6,81,침입탐지 시스템(IDS : Intrusion Detection System)과 관련한 설명으로 틀린 것은?,,이상 탐지 기법(Anomaly Detection)은 Signature Base나 Knowledge Base라고도 불리며 이미 발견되고 정립된 공격 패턴을 입력해두었다가 탐지 및 차단한다.,HIDS(Host-Based Intrusion Detection)는 운영체제에 설정된 사용자 계정에 따라 어떤 사용자가 어떤 접근을 시도하고 어떤 작업을 했는지에 대한 기록을 남기고 추적한다.,NIDS(Network-Based Intrusion Detection System)로는 대표적으로 Snort가 있다.,외부 인터넷에 서비스를 제공하는 서버가 위치하는 네트워크인 DMZ(Demilitarized Zone)에는 IDS가 설치될 수 있다.,1,"침입탐지 시스템(IDS)의 종류와 동작 방식에 대한 문제입니다. 1번 보기는 이상 탐지 기법(Anomaly Detection)에 대한 설명이 잘못되었습니다.  이상 탐지 기법은 기존에 알려진 공격 패턴(시그니처)을 이용하는 시그니처 기반 탐지(Signature-based Detection)와는 다릅니다.  이상 탐지 기법은 정상적인 시스템 동작 패턴을 학습하여 이와 다른 비정상적인 활동을 탐지하는 방식입니다.  따라서 ""Signature Base나 Knowledge Base라고도 불리며 이미 발견되고 정립된 공격 패턴을 입력해두었다가 탐지 및 차단한다""는 설명은 시그니처 기반 탐지에 대한 설명이며, 이상 탐지 기법과는 다릅니다.  나머지 보기들은 모두 침입탐지 시스템에 대한 정확한 설명입니다. HIDS는 호스트 시스템 내부의 활동을 모니터링하고, NIDS는 네트워크 트래픽을 모니터링하며, DMZ에 IDS를 설치하는 것은 일반적인 보안 관행입니다.  따라서 1번 보기가 틀린 설명입니다.",43,155
582,6,82,정보 시스템 내에서 어떤 주체가 특정 개체에 접근하려 할 때 양쪽의 보안 레이블(Security Label)에 기초하여 높은 보안 수준을 요구하는 정보(객체)가 낮은 보안 수준의 주체에게 노출되지 않도록 하는 접근 제어 방법은?,,Mandatory Access Control,User Access Control,Discretionary Access Control,Data-Label Access Control,1,"정보 시스템에서 중요한 정보를 보호하기 위해 접근 제어 방법이 사용됩니다.  여러 접근 제어 방법 중 Mandatory Access Control(MAC)은 보안 레이블을 기반으로 접근을 제어하는 강력한 방법입니다.  쉽게 말해, 정보(객체)마다 보안 등급(예: 비밀, 기밀, 공개)이 설정되어 있고, 사용자(주체)도 각자의 보안 등급을 가지게 됩니다.  MAC에서는 높은 보안 등급의 정보는 낮은 보안 등급의 사용자가 접근할 수 없도록 엄격하게 제어합니다.  예를 들어, '비밀' 등급의 정보는 '기밀' 등급의 사용자는 접근할 수 없지만, '비밀' 등급의 사용자는 접근할 수 있습니다.  이는 시스템의 보안 수준을 높이고, 중요 정보의 유출을 방지하는 데 매우 효과적입니다.  반면, 다른 접근 제어 방법들은 사용자의 재량에 따라 접근 권한을 부여하는 등 유연성이 높지만, 보안 수준이 MAC보다 낮을 수 있습니다.  따라서, 높은 보안 수준을 요구하는 정보를 보호하기 위해서는 MAC이 가장 적합한 방법입니다.  문제에서 언급된 '높은 보안 수준을 요구하는 정보(객체)가 낮은 보안 수준의 주체에게 노출되지 않도록 하는 접근 제어 방법'은 바로 이 MAC의 개념을 정확하게 설명하고 있습니다.",45,153
583,6,83,구글의 구글 브레인 팀이 제작하여 공개한 기계 학습(Machine Leaming)을 위한 오픈소스 소프트웨어 라이브러리는?,,타조(Tajo),원 세그(One Seg),포스퀘어(Foursquare),텐서플로(TensorFlow),4,"이 문제는 기계 학습(Machine Learning) 분야에서 널리 사용되는 오픈소스 소프트웨어 라이브러리를 묻고 있습니다.  제시된 보기 중 텐서플로(TensorFlow)는 구글의 구글 브레인 팀이 개발하여 공개한 대표적인 기계 학습 라이브러리입니다.  텐서플로는 다양한 기계 학습 모델을 구축하고 학습시키는 데 사용되며,  신경망(Neural Network)을 포함한 다양한 알고리즘을 지원합니다.  나머지 보기들은 기계 학습과 직접적인 관련이 없습니다. 타조(Tajo)는 분산 데이터베이스 시스템이고, 원 세그(One Seg)는 방송 관련 기술, 포스퀘어(Foursquare)는 위치 기반 서비스 플랫폼입니다. 따라서 정답은 텐서플로(TensorFlow)입니다.",71,143
584,6,84,"국내 IT 서비스 경쟁력 강화를 목표로 개발되었으며 인프라 제어 및 관리 환경, 실행 환경, 개발 환경, 서비스 환경, 운영환경으로 구성되어 있는 개방형 클라우드 컴퓨팅 플랫폼은?",,N20S,PaaS-TA,KAWS,Metaverse,2,"문제에서 제시된 플랫폼은 국내 IT 서비스 경쟁력 강화를 목표로 개발되었고, 인프라 제어 및 관리 환경, 실행 환경, 개발 환경, 서비스 환경, 운영 환경으로 구성된 개방형 클라우드 컴퓨팅 플랫폼입니다.  선택지 중 PaaS-TA(Platform as a Service - Trusted Architecture)는 이러한 조건에 부합하는 플랫폼입니다. PaaS-TA는  국내에서 개발된 클라우드 플랫폼으로, 다양한 서비스 환경을 제공하며, 개발, 운영, 관리 등 전반적인 IT 인프라를 지원하는 특징을 가지고 있습니다. 다른 선택지들은 클라우드 플랫폼과 직접적인 관련이 없거나, 국내 IT 서비스 경쟁력 강화라는 목표와 부합하지 않습니다. 따라서 정답은 2번 PaaS-TA입니다.",60,138
585,6,85,정보 보안을 위한 접근 제어(Access Control)과 관련한 설명으로 틀린 것은?,,적절한 권한을 가진 인가자만 특정 시스템이나 정보에 접근할 수 있도록 통제하는 것이다.,시스템 및 네트워크에 대한 접근 제어의 가장 기본적인 수단은 IP와 서비스 포트로 볼 수 있다.,DBMS에 보안 정책을 적용하는 도구인 XDMCP를 통해 데이터베이스에 대한 접근제어를 수행할 수 있다.,네트워크 장비에서 수행하는 IP에 대한 접근 제어로는 관리 인터페이스의 접근제어와 ACL(Access Control List) 등 있다.,3,"문제에서 제시된 내용들을 하나씩 살펴보겠습니다. 1번은 접근 제어의 기본적인 정의를 잘 설명하고 있습니다.  2번은 IP 주소와 포트 번호를 이용하여 특정 시스템이나 서비스에 대한 접근을 제어하는 것이 네트워크 접근 제어의 기본적인 방법이라는 점에서 맞는 설명입니다.  4번은 네트워크 장비(예: 라우터, 방화벽)에서 IP 주소를 기반으로 접근을 제어하는 방법으로 ACL(Access Control List)을 사용하는 것을 설명하고 있으며, 이 또한 사실입니다.  하지만 3번은 잘못된 설명입니다. XDMCP(X Display Manager Control Protocol)는 X Window System에서 원격으로 디스플레이를 관리하는 프로토콜입니다. 데이터베이스 접근 제어와는 관련이 없습니다. 데이터베이스 접근 제어는 DBMS(Database Management System) 자체의 기능이나, 별도의 보안 도구(예: 접근 제어 목록, 역할 기반 접근 제어)를 통해 수행됩니다. 따라서 3번이 틀린 선택지입니다.",58,131
586,6,86,소프트웨어 개발 프레임워크와 관련한 설명으로 틀린 것은?,,반제품 상태의 제품을 토대로 도메인별로 필요한 서비스 컴포넌트를 사용하여 재사용성 확대와 성능을 보장 받을 수 있게하는 개발 소프트웨어이다.,개발해야 할 애플리케이션의 일부분이 이미구현되어 있어 동일한 로직 반복을 줄일 수있다.,라이브러리와 달리 사용자 코드가 직접호출하여 사용하기 때문에 소프트웨어 개발프레임워크가 직접 코드의 흐름을 제어할수 없다.,생산성 향상과 유지보수성 향상 등의장점이 있다.,3,"소프트웨어 개발 프레임워크는 미리 만들어진 뼈대나 틀을 제공하여 개발자가 애플리케이션을 더 쉽고 빠르게 만들 수 있도록 돕는 도구입니다.  1번은 프레임워크의 재사용성과 성능 향상에 대한 장점을 잘 나타내고 있으며, 2번 또한 프레임워크가 기존에 구현된 부분을 제공하여 개발 시간을 단축하는 것을 설명합니다. 4번 역시 생산성과 유지보수성 향상이라는 프레임워크의 주요 장점을 언급하고 있습니다.  하지만 3번은 잘못된 설명입니다. 프레임워크는 라이브러리와 달리,  개발자가 사용하는 코드의 흐름을 제어하는 역할을 합니다.  즉, 사용자 코드가 프레임워크에 의해 호출되고, 프레임워크가 전체적인 애플리케이션의 흐름을 관리하는 구조입니다.  따라서 사용자 코드가 프레임워크를 직접 호출하여 사용한다고 해서 프레임워크가 코드의 흐름을 제어할 수 없는 것은 아닙니다.  프레임워크는 개발자가 작성한 코드를 특정 시점에 호출하고 실행하는 역할을 수행하며, 이를 통해 애플리케이션의 전체적인 구조와 흐름을 제어합니다.",82,148
587,6,87,물리적 배치와 상관없이 논리적으로 LAN을구성하여 Broadcast Domain을 구분할 수있게 해주는 기술로 접속된 장비들의 성능향상 및 보안성 증대 효과가 있는 것은?,,VLAN,STP,L2AN,ARP,1,"이 문제는 물리적인 위치와 상관없이 논리적으로 네트워크를 분할하여 방송 도메인(Broadcast Domain)을 나눌 수 있는 기술을 묻고 있습니다.  방송 도메인이란, 네트워크 상에서 브로드캐스트(Broadcast) 패킷이 전달되는 영역을 말합니다.  브로드캐스트 패킷은 네트워크 상의 모든 장비에 전달되는 패킷이므로, 네트워크가 커질수록 브로드캐스트 패킷으로 인한 네트워크 트래픽 증가와 보안 취약성이 증가하게 됩니다.  VLAN(Virtual LAN) 기술은 물리적인 위치와 상관없이 논리적으로 네트워크를 여러 개의 가상 LAN으로 분할하여 각 VLAN에 속한 장비들만 브로드캐스트 패킷을 주고받도록 합니다.  따라서 VLAN을 사용하면 브로드캐스트 도메인을 효과적으로 분할하여 네트워크 트래픽을 줄이고 보안성을 높일 수 있습니다.  STP(Spanning Tree Protocol)는 네트워크 루프를 방지하는 기술이고, L2AN(Layer 2 Access Network)은 2계층 접근 네트워크를 의미하며, ARP(Address Resolution Protocol)는 IP 주소를 MAC 주소로 변환하는 프로토콜이므로 문제의 조건과 부합하지 않습니다.  따라서 정답은 VLAN입니다.",68,149
588,6,88,SQL Injection 공격과 관련한 설명으로 틀린것은?,,SQL Injection은 임의로 작성한 SQL 구문을 애플리케이션에 삽입하는 공격방식이다.,SQL Injection 취약점이 발생하는 곳은 주로웹 애플리케이션과 데이터베이스가 연동되는 부분이다.,DBMS의 종류와 관계없이 SQL Injection공격 기법은 모두 동일하다.,로그인과 같이 웹에서 사용자의 입력 값을 받아 데이터베이스 SQL문으로 데이터를요청하는 경우 SQL Injection을 수행할 수 있다.,3,"SQL Injection은 악의적인 사용자가 웹 애플리케이션에 악성 SQL 코드를 입력하여 데이터베이스를 조작하는 공격 기법입니다.  1번과 4번은 SQL Injection의 기본적인 원리를 정확하게 설명하고 있습니다.  2번 또한 웹 애플리케이션과 데이터베이스 연동 부분이 SQL Injection 공격의 주요 표적임을 올바르게 지적하고 있습니다. 하지만 3번은 잘못된 설명입니다.  SQL Injection 공격 기법은 사용하는 DBMS(데이터베이스 관리 시스템)의 종류에 따라 다를 수 있습니다. 각 DBMS는 SQL 문법과 보안 기능에 차이가 있기 때문에, 동일한 공격 기법이 모든 DBMS에서 동일하게 작동한다고 단정 지을 수 없습니다. 예를 들어, MySQL과 Oracle은 SQL 문법 자체에 약간의 차이가 있으며, 각 DBMS가 제공하는 보안 기능 또한 상이하여 공격 성공 여부 및 방법이 달라질 수 있습니다. 따라서, 모든 DBMS에서 동일한 공격 기법이 적용된다는 주장은 사실과 다릅니다.",80,153
589,6,89,비대칭 암호화 방식으로 소수를 활용한암호화 알고리즘은?,,DES,AES,SMT,RSA,4,"RSA 알고리즘은 비대칭 암호화 방식으로, 공개키와 개인키 두 개의 키를 사용합니다.  공개키는 누구에게나 공개해도 되지만, 개인키는 소유자만 알고 있어야 합니다.  RSA는 매우 큰 두 개의 소수(prime number)를 곱하여 얻은 값을 기반으로 키를 생성합니다.  이 소수의 곱은 공개키로 사용되고, 소수 자체는 개인키를 생성하는 데 사용됩니다.  이러한 소수의 특성 때문에, 공개키로 암호화된 메시지는 개인키 없이는 복호화가 매우 어렵습니다.  따라서, RSA는 데이터의 기밀성을 보장하는 데 효과적입니다.  DES와 AES는 대칭키 암호화 방식이며, SMT는 문제와 관련이 없습니다.",67,154
590,6,90,다음에서 설명하는 IT 스토리지 기술은?,https://www.cbtbank.kr/images/iz/iz20210814/iz20210814m90.gif,Software Defined Storage,Distribution Oriented Storage,Network Architected Storage,Systematic Network Storage,1,"문제에서 설명하는 IT 스토리지 기술은 Software Defined Storage(SDS)입니다.  SDS는 소프트웨어를 통해 스토리지 자원을 관리하고 제어하는 기술입니다.  기존의 하드웨어 중심 스토리지와 달리, 소프트웨어로 스토리지 시스템을 가상화하여 필요한 만큼의 용량을 유연하게 할당하고 관리할 수 있습니다.  마치 서버 가상화(VMware, Hyper-V 등)에서 여러 가상 머신을 하나의 물리 서버에서 운영하는 것과 유사하게, SDS는 여러 물리 스토리지를 하나의 논리적인 스토리지 풀로 통합 관리하여 효율성을 높입니다.  따라서 문제에서 제시된 ""가상화를 적용하며 필요한 공간만큼 나눠 사용할 수 있도록 하여 서버 가상화와 유사함"", ""컴퓨팅 소프트웨어로 구성하는 데이터 스토리지 체계이며, 일정 조직 내 여러 스토리지를 하나처럼 관리하고 운용하는 컴퓨터 이용 환경"", ""스토리지 자원을 효율적으로 나누어 쓰는 방법으로 이해할 수 있음"" 등의 설명은 모두 SDS의 특징을 정확하게 나타내고 있습니다. 다른 선택지는 스토리지 기술의 일반적인 구조나 특징을 설명하는 용어이지만, 문제에서 제시된 설명과 정확하게 일치하지 않습니다.",47,151
591,6,91,"Cocomo model 중 기관 내부에서 개발된 중소규모의 소프트웨어로 일괄 자료 처리나 과학기술계산용, 비즈니스 자료 처리용으로 5만 라인이하의 소프트웨어를 개발하는 유형은?",,Embeded,Organic,Semi-detached,Semi-embeded,2,"COCOMO(Constructive Cost Model) 모델은 소프트웨어 개발에 필요한 노력, 비용, 기간을 예측하는 모델입니다.  여러 유형으로 나뉘는데, 문제에서 제시된 조건(기관 내부 개발, 중소규모, 5만 라인 이하, 일괄 자료 처리나 과학기술계산, 비즈니스 자료 처리)에 가장 적합한 유형은 Organic 모형입니다.  Organic 모형은 소규모 팀이 잘 정의된 요구사항을 가지고 개발하는 프로젝트에 적용되며, 개발팀의 경험과 숙련도가 높고, 개발 환경이 안정적인 경우에 사용됩니다. 문제에서 제시된 조건들이 모두 Organic 모형의 특징과 일치하기 때문에 정답은 2번 Organic입니다.  Embedded, Semi-detached, Semi-embedded 모형은 각각 임베디드 시스템, 부분적으로 외부 요소가 포함된 시스템, 임베디드 시스템의 특징을 일부 가지는 시스템 개발에 적용되는 유형으로, 문제의 조건과는 맞지 않습니다.",69,147
592,6,92,다음 내용이 설명하는 것은?,https://www.cbtbank.kr/images/iz/iz20210814/iz20210814m92.gif,Format String,Ransomware,Buffer overflow,Adware,2,"문제에서 설명하는 것은 랜섬웨어(Ransomware)입니다.  랜섬웨어는 사용자의 컴퓨터 시스템이나 네트워크에 침입하여 중요한 파일을 암호화하거나 시스템을 잠근 후, 이를 해제하는 대가로 금전을 요구하는 악성 프로그램입니다.  Snake나 Darkside와 같은 유명한 랜섬웨어는 기업과 개인 모두에게 심각한 피해를 입히는 사이버 범죄의 주요 원인 중 하나입니다.  문제에서 제시된 설명은 랜섬웨어의 작동 방식과 그로 인한 피해를 명확하게 보여줍니다.  Format String, Buffer overflow, Adware는 다른 종류의 악성 프로그램이나 보안 취약점을 나타내는 용어입니다.",86,156
593,6,93,"생명주기 모형 중 가장 오래된 모형으로 많은적용 사례가 있지만 요구사항의 변경이어렵고 각 단계의 결과가 확인 되어야 다음단계로 넘어갈 수 있는 선형 순차적, 고전적생명 주기 모형이라고도 하는 것은?",,Waterfall Model,Prototype Model,Cocomo Model,Spiral Model,1,"문제에서 설명하는 생명주기 모형은 '폭포수 모형(Waterfall Model)'입니다.  폭포수 모형은 소프트웨어 개발 과정을 여러 단계로 나누어 순차적으로 진행하는 방식입니다.  마치 폭포수가 위에서 아래로 떨어지듯이, 각 단계가 완료되어야만 다음 단계로 넘어갈 수 있습니다.  가장 큰 특징은 선형적이고 순차적인 구조이며, 이전 단계로 돌아가는 것이 어렵다는 점입니다.  따라서 요구사항 변경에 유연하게 대처하기 어렵다는 단점이 있습니다.  하지만,  단계별 결과물이 명확하고 관리가 용이하여,  오래전부터 많은 프로젝트에서 사용되어 왔습니다.  문제에서 언급된 '고전적 생명주기 모형'이라는 표현 또한 폭포수 모형을 지칭하는 것입니다.  Prototype Model, Cocomo Model, Spiral Model은 각각 프로토타입 기반 개발, 소프트웨어 비용 추정 모델, 반복적 개발 모델로 폭포수 모형과는 다른 특징을 가지고 있습니다.",82,147
594,6,94,소프트웨어 생명주기 모형 중 Spiral Model에 대한 설명으로 틀린 것은?,,비교적 대규모 시스템에 적합하다.,"개발 순서는 계획 및 정의, 위험 분석, 공학적 개발, 고객 평가 순으로 진행된다.",소프트웨어를 개발하면서 발생할 수 있는 위험을 관리하고 최소화하는 것을 목적으로 한다.,"계획, 설계, 개발, 평가의 개발 주기가 한번만 수행된다.",4,"Spiral Model은 소프트웨어 개발 과정을 나선형으로 반복하는 모델입니다.  각 반복 단계마다 계획, 위험 분석, 개발, 평가를 거치며, 위험을 최소화하고 고객의 요구사항을 반영하여 점진적으로 소프트웨어를 완성해 나가는 방식입니다. 문제에서 틀린 것은 4번입니다.  Spiral Model은 한 번의 개발 주기만 수행하는 것이 아니라, 위험을 관리하고 고객 피드백을 반영하기 위해 여러 번의 반복(iteration)을 거치는 것이 특징입니다.  따라서 계획, 설계, 개발, 평가 단계가 여러 번 반복되며, 각 반복마다 더욱 완성도 높은 소프트웨어를 만들어 나가는 것입니다. 대규모 시스템에 적합한 이유는 바로 이러한 반복적인 개발 과정을 통해 위험을 조기에 발견하고 관리할 수 있기 때문입니다.  작은 단위의 개발을 반복하며 점진적으로 완성도를 높여가는 방식이므로, 대규모 시스템의 복잡성을 효과적으로 관리할 수 있습니다.",79,147
595,6,95,"특정 사이트에 매우 많은 ICMP Echo를 보내면, 이에 대한 응답(Respond)을 하기 위해 시스템 자원을 모두 사용해버려 시스템이 정상적으로 동작하지 못하도록 하는 공격방법은?",,Role-Based Access Control,Ping Flood,Brute-Force,Trojan Horses,2,"Ping Flood 공격은 매우 많은 ICMP Echo 요청(ping)을 특정 시스템에 지속적으로 보내는 분산 서비스 거부(DoS, Denial of Service) 공격의 한 종류입니다.  ICMP Echo 요청은 네트워크의 연결 상태를 확인하는 데 사용되는 프로토콜이지만,  엄청난 양의 요청이 동시에 들어오면 시스템은 각 요청에 대해 응답(ICMP Echo Reply)을 생성해야 합니다. 이 과정에서 시스템의 네트워크 인터페이스 카드(NIC), CPU, 메모리 등의 자원이 모두 소모되어 정상적인 서비스 제공이 불가능해집니다. 마치 전화 교환기에 끊임없이 전화가 몰려와서 아무도 전화를 걸거나 받을 수 없는 상황과 유사합니다.  결과적으로 시스템은 과부하에 걸려 응답하지 않거나 매우 느리게 응답하게 되어 서비스가 마비됩니다.  따라서 정상적인 사용자는 시스템에 접근할 수 없게 되는 것입니다.",77,155
596,6,96,TCP/IP 기반 네트워크에서 동작하는 발행-구독 기반의 메시징 프로토콜로 최근 IoT 환경에서 자주 사용되고 있는 프로토콜은?,,MLFQ,MQTT,Zigbee,MTSP,2,"문제에서 제시된 프로토콜은 TCP/IP 기반 네트워크에서 동작하며, 발행-구독 방식으로 메시지를 전달하는 특징을 가지고 있습니다.  발행-구독 방식이란, 메시지를 발행하는 쪽(Publisher)과 메시지를 구독하는 쪽(Subscriber)이 서로 직접 연결되어 있지 않고, 중개자를 통해 메시지가 전달되는 방식입니다.  IoT 환경에서는 많은 장치들이 서로 정보를 주고받아야 하므로, 효율적인 메시지 전달 방식이 중요한데, MQTT 프로토콜은 이러한 요구사항에 적합합니다.  MQTT는 경량화된 프로토콜로,  데이터 전송량이 적고, 배터리 전력 소모가 적은 장점이 있어,  배터리로 작동하는 IoT 기기들에 적합합니다.  반면, 다른 선택지들은 MQTT와 같은 발행-구독 방식의 메시징 프로토콜이 아니거나, IoT 환경에 적합하지 않은 특징을 가지고 있습니다. 따라서,  TCP/IP 기반 네트워크에서 동작하는 발행-구독 기반의 메시징 프로토콜로 최근 IoT 환경에서 자주 사용되는 프로토콜은 MQTT입니다.",62,145
597,6,97,시스템이 몇 대가 되어도 하나의 시스템에서 인증에 성공하면 다른 시스템에 대한 접근권한도 얻는 시스템을 의미하는 것은?,,SOS,SBO,SSO,SOA,3,"여러 개의 시스템을 사용하더라도, 한 시스템에서 로그인(인증)을 한 번만 하면 다른 시스템에도 접근할 수 있도록 해주는 시스템을 SSO(Single Sign-On)라고 합니다.  예를 들어, 회사 내부 시스템에 접속할 때,  A 시스템에 로그인하면 B, C 시스템에도 별도의 로그인 절차 없이 자동으로 접근할 수 있는 것이죠.  이렇게 하면 사용자는 여러 시스템에 각각 로그인할 필요가 없어 편리하고,  보안 관리 측면에서도 효율적입니다.  문제에서 제시된 다른 선택지들은 SSO와 관련이 없습니다. SOS, SBO, SOA는 각각 다른 기술이나 아키텍처를 의미합니다. 따라서 정답은 SSO(Single Sign-On)입니다.",67,155
598,6,98,시스템에 저장되는 패스워드들은 Hash 또는 암호화 알고리즘의 결과 값으로 저장된다. 이때 암호공격을 막기 위해 똑같은 패스워드들이 다른 암호 값으로 저장되도록 추가되는 값을 의미하는 것은?,,Pass flag,Bucket,Opcode,Salt,4,"시스템에 저장되는 패스워드는 보안상 중요하기 때문에,  원래 패스워드를 그대로 저장하지 않고 해시(Hash) 또는 암호화 알고리즘을 이용하여 변환된 값으로 저장합니다.  만약 같은 패스워드를 사용하는 사용자가 여러 명이라면, 모두 같은 해시 값으로 저장될 것입니다.  이 경우, 해커가 해시 값을 획득하여 패스워드를 추측하는 공격(예: 레인보우 테이블 공격)에 취약해집니다.  이러한 공격을 막기 위해,  각 패스워드마다 고유한 값(Salt)을 추가하여 해시 연산을 수행합니다.  같은 패스워드라도 Salt 값이 다르면 다른 해시 값이 생성되므로, 해커의 공격을 효과적으로 방지할 수 있습니다.  Salt는 패스워드와 함께 저장되지만,  패스워드 자체를 복호화하는 데에는 사용되지 않습니다.  즉, Salt는  같은 패스워드를 다른 암호 값으로 저장되도록 하는 추가적인 값입니다.",55,154
599,6,99,"S/W 각 기능의 원시 코드 라인수의 비관치, 낙관치, 기대치를 측정하여 예측치를 구하고 이를 이용하여 비용을 산정하는 기법은?",,Effort Per Task기법,전문가 감정 기법,델파이기법,LOC기법,4,"소프트웨어 개발 비용을 산정하는 방법 중 하나인 LOC(Lines of Code) 기법은 소프트웨어의 기능별 원시 코드 라인 수를 기준으로 비용을 예측하는 기법입니다.  각 기능에 대한 원시 코드 라인 수를 낙관치(가장 적게 소요될 라인 수), 기대치(평균적으로 소요될 라인 수), 비관치(가장 많이 소요될 라인 수)로 추정하여 이 세 가지 값을 이용해 예측치를 계산합니다.  예측치를 바탕으로 라인 수당 단가를 곱하여 전체 소프트웨어 개발 비용을 산정합니다.  즉, 코드 라인 수가 많을수록 개발 비용이 많이 들 것이라는 간단한 원리를 이용한 방법입니다.  이 문제는  원시 코드 라인 수를 이용하여 비용을 산정하는 기법을 묻고 있으므로 LOC 기법이 정답입니다.",66,147
600,6,100,"오픈소스 웹 애플리케이션 보안 프로젝트로서 주로 웹을 통한 정보 유출, 악성 파일 및 스크립트, 보안 취약점 등을 연구하는 곳은?",,WWW,OWASP,WBSEC,ITU,2,"OWASP(Open Web Application Security Project)는 오픈소스 웹 애플리케이션의 보안을 향상시키기 위해 설립된 비영리 재단입니다.  웹을 통한 정보 유출, 악성 파일 및 스크립트, 그리고 다양한 보안 취약점들을 연구하고, 그에 대한 대응 방안을 제시하는 프로젝트들을 진행합니다.  WWW는 월드 와이드 웹 자체를 의미하며, WBSEC는 특정 기관을 지칭하는 것으로 보이지만, 문제의 맥락과는 맞지 않습니다. ITU는 국제전기통신연합으로, 웹 애플리케이션 보안에 특화된 기관은 아닙니다. 따라서, 웹 애플리케이션 보안에 중점을 두고 연구하는 곳은 OWASP가 가장 적절합니다.",64,153
601,7,1,User Interface 설계 시 오류 메시지나 경고에 관한 지침으로 가장 거리가 먼 것은?,,메시지는 이해하기 쉬워야 한다.,오류로부터 회복을 위한 구체적인 설명이 제공되어야 한다.,오류로 인해 발생 될 수 있는 부정적인 내용을 적극적으로 사용자들에게 알려야 한다.,소리나 색의 사용을 줄이고 텍스트로만 전달하도록 한다.,4,"User Interface(UI) 설계 시 오류 메시지나 경고는 사용자에게 중요한 정보를 전달하는 역할을 합니다. 따라서 사용자가 쉽게 이해하고 오류를 해결할 수 있도록 명확하고 친절하게 작성되어야 합니다.  1번 지침인 '메시지는 이해하기 쉬워야 한다'는 사용자의 이해도를 높이는 필수적인 요소이고, 2번 지침인 '오류로부터 회복을 위한 구체적인 설명이 제공되어야 한다'는 사용자가 오류를 해결하는 데 도움을 주는 중요한 지침입니다. 3번 지침인 '오류로 인해 발생될 수 있는 부정적인 내용을 적극적으로 사용자들에게 알려야 한다'는 사용자에게 위험을 인지시켜 예방 조치를 취하도록 유도하는 데 도움이 됩니다.  반면 4번 지침인 '소리나 색의 사용을 줄이고 텍스트로만 전달하도록 한다'는  UI 디자인의 다양한 표현 방식을 제한하는 지침으로,  오류 메시지 전달의 효과성을 떨어뜨릴 수 있습니다.  오류 메시지는 시각적 요소(색상, 아이콘)를 적절히 활용하여 사용자의 주의를 끌고 빠르게 이해하도록 유도하는 것이 더 효과적일 수 있기 때문입니다. 따라서 4번이 가장 거리가 먼 지침입니다.  정보처리기사 시험에서는 사용자 중심의 UI 설계를 강조하며, 사용자의 편의성과 이해도를 높이는 방향으로 오류 메시지를 설계하는 것이 중요합니다.",87,104
602,7,2,다음 중 애자일(Agile) 소프트웨어 개발에 대한 설명으로 틀린 것은?,,공정과 도구보다 개인과의 상호작용을 더 가치 있게 여긴다.,동작하는 소프트웨어보다는 포괄적인 문서를 가치 있게 여긴다.,계약 협상보다는 고객과의 협력을 가치 있게 여긴다.,계획을 따르기보다 변화에 대응하기를 가치 있게 여긴다.,2,"애자일(Agile) 소프트웨어 개발 방법론은 빠르게 변화하는 요구사항에 유연하게 대처하고, 고객과의 긴밀한 협력을 통해 소프트웨어를 개발하는 것을 중시합니다.  문제에서 틀린 것은 2번입니다. 애자일은 '동작하는 소프트웨어'를 중시하며, 포괄적인 문서보다 실제 작동하는 소프트웨어를 우선시합니다.  문서가 중요하지 않다는 것은 아니지만,  실제 작동하는 소프트웨어가 먼저 만들어지고, 그 과정에서 필요한 문서가 만들어지는 방식입니다.  나머지 보기들은 모두 애자일의 핵심 가치를 잘 나타내고 있습니다.  개인과의 상호작용, 고객과의 협력, 변화에 대한 대응 모두 애자일 개발의 중요한 요소입니다.",87,102
603,7,3,소프트웨어 설계에서 요구사항 분석에 대한 설명으로 틀린 것은?,,소프트웨어가 무엇을 해야하는가를 추적하여 요구사항 명세를 작성하는 작업이다.,사용자의 요구를 추출하여 목표를 정하고 어떤 방식으로 해결할 것인지 결정하는 단계이다.,소프트웨어 시스템이 사용되는 동안 발견되는 오류를 정리하는 단계이다.,소프트웨어 개발의 출발점이면서 실질적인 첫 번째 단계이다.,3,"이 문제는 소프트웨어 요구사항 분석의 의미를 묻고 있습니다.  소프트웨어 요구사항 분석은 사용자가 원하는 소프트웨어의 기능과 성능을 정확하게 파악하는 과정입니다. 1번과 2번은 요구사항 분석의 핵심적인 내용을 잘 나타내고 있습니다.  4번 또한 소프트웨어 개발의 시작점이라는 점에서 맞는 설명입니다. 하지만 3번은 소프트웨어가 이미 개발된 후에 발생하는 오류를 다루는 단계로, 요구사항 분석 단계와는 관련이 없습니다. 요구사항 분석은 소프트웨어 개발 *전*에 사용자의 요구를 파악하고 명세화하는 단계이기 때문입니다. 따라서 3번이 틀린 설명입니다.  쉽게 말해, 요구사항 분석은 ""무엇을 만들 것인가""를 정하는 단계이고, 3번은 ""만든 것을 고치는"" 단계인 것이죠.",84,102
604,7,4,객체지향 기법에서 상위 클래스의 메소드와 속성을 하위 클래스가 물려받는 것을 의미하는 것은?,,Abstraction,Polymorphism,Encapsulation,Inheritance,4,"객체지향 기법은 현실 세계의 개념을 컴퓨터 프로그램으로 모델링하는 방법입니다.  상위 클래스는 여러 하위 클래스의 공통적인 특징을 담고 있는 클래스이고, 하위 클래스는 상위 클래스의 특징을 물려받아 더욱 특수화된 기능을 가집니다.  예를 들어, ""동물""이라는 상위 클래스가 있고, ""강아지""와 ""고양이""라는 하위 클래스가 있다면, ""동물"" 클래스는 ""먹는다"", ""잔다"" 와 같은 공통적인 속성과 기능을 가지고 있고, ""강아지""와 ""고양이"" 클래스는 ""동물"" 클래스의 속성과 기능을 물려받으면서 각각 ""짖는다"", ""야옹거린다"" 와 같은 자신만의 특징을 추가할 수 있습니다. 이처럼 상위 클래스의 속성과 메소드를 하위 클래스가 물려받는 것을 상속(Inheritance)이라고 합니다. 따라서 문제의 정답은 4번, Inheritance(상속)입니다.",78,107
605,7,5,설계 기법 중 하향식 설계 방법과 상향식 설계 방법에 대한 비교 설명으로 가장 옳지 않은 것은?,,하향식 설계에서는 통합 검사 시 인터페이스가 이미 정의되어 있어 통합이 간단하다.,하향식 설계에서 레벨이 낮은 데이터 구조의 세부 사항은 설계초기 단계에서 필요하다.,상향식 설계는 최하위 수준에서 각각의 모듈들을 설계하고 이러한 모듈이 완성되면 이들을 결합하여 검사한다.,상향식 설계에서는 인터페이스가 이미 성립되어 있지 않더라도 기능 추가가 쉽다.,4,"이 문제는 소프트웨어 설계 기법 중 하향식 설계와 상향식 설계의 차이점을 이해하고 있는지 묻는 문제입니다.  하향식 설계는 전체 시스템을 큰 모듈로 나누고, 각 모듈을 다시 작은 모듈로 나누는 방식으로, 마치 나무의 가지가 뻗어나가는 것처럼 설계가 진행됩니다. 반면 상향식 설계는 작은 모듈부터 설계하여 이들을 조합하여 큰 시스템을 만드는 방식입니다.",55,106
606,7,6,자료흐름도(DFD)의 각 요소별 표기 형태의 연결이 옳지 않은 것은?,,Process : 원,Data Flow : 화살표,Data Store : 삼각형,Terminator : 사각형,3,"자료흐름도(DFD)는 시스템의 자료 흐름을 그림으로 나타내는 기법입니다.  문제에서 제시된 각 요소는 자료흐름도를 구성하는 기본적인 요소들입니다.  Process(처리 과정)는 원으로, Data Flow(자료 흐름)는 화살표로, Terminator(시작/종료 지점 또는 외부 개체)는 사각형으로 표현됩니다.  하지만 Data Store(자료 저장소)는 삼각형이 아닌 두 개의 평행한 수직선으로 표현됩니다. 따라서 3번이 옳지 않은 연결입니다.  쉽게 말해, 자료를 저장하는 곳(Data Store)은 삼각형이 아니라,  두 개의 평행한 수직선으로 표시하는 것이 자료흐름도의 표준 표기법입니다.",80,103
607,7,7,소프트웨어 개발에 이용되는 모델(Model)에 대한 설명 중 거리가 먼 것은?,,모델은 개발 대상을 추상화하고 기호나 그림 등으로 시각적으로 표현한다.,모델을 통해 소프트웨어에 대한 이해도를 향상시킬 수 있다.,모델을 통해 이해 당사자 간의 의사소통이 향상된다.,모델을 통해 향후 개발될 시스템의 유추는 불가능하다.,4,"소프트웨어 개발 과정에서 모델(Model)은 개발 대상을 단순화하고 이해하기 쉽게 표현하는 중요한 도구입니다.  1번부터 3번까지의 설명은 모두 모델의 목적과 효과를 정확하게 나타냅니다. 모델은 복잡한 시스템을 그림이나 기호 등으로 시각화하여 이해도를 높이고, 개발팀과 이해관계자 간의 원활한 소통을 가능하게 합니다. 하지만 4번의 경우, 모델은 미래 시스템의 정확한 모습을 완벽하게 예측하는 것은 불가능합니다. 모델은 추상화된 표현이기 때문에, 실제 구현 과정에서 예상치 못한 문제나 변경 사항이 발생할 수 있으며,  모델을 통해 시스템의 모든 측면을 완벽하게 유추할 수는 없다는 점을 명심해야 합니다. 따라서 모델은 미래 시스템을 '유추'하는 데 도움을 주는 도구이지,  '완벽하게 예측'하는 도구는 아닙니다.",88,102
608,7,8,다음의 설명에 해당하는 언어는?,https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m8.gif,JAVA,C,UML,Python,3,"문제에서 설명하는 언어는 객체지향 시스템 개발 시 산출물을 명세화, 시각화, 문서화하는 데 사용되는 표준화된 모델링 언어입니다.  JAVA, C, Python은 프로그래밍 언어이고,  UML(Unified Modeling Language)은 시스템 설계 및 분석을 위한 표준 모델링 언어입니다. 문제의 설명은 UML이 객체지향 시스템 개발 과정에서 시스템을 이해하기 쉽게 표현하고, 개발자, 의뢰인 등 이해관계자 간 효율적인 의사소통을 돕는 역할을 강조하고 있으므로 정답은 UML입니다.  UML은 다양한 다이어그램(클래스 다이어그램, 시퀀스 다이어그램 등)을 통해 시스템의 구조와 동작을 시각적으로 표현하여 개발 과정 전반에 걸쳐 사용됩니다.",79,102
609,7,9,다음 내용이 설명하는 UI설계 도구는?,https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m9.gif,스토리보드(Storyboard),목업(Mockup),프로토타입(Prototype),유스케이스(Usecase),2,"문제에서 설명하는 UI 설계 도구는 목업(Mockup)입니다.  목업은 실제 프로그램을 구현하지 않고, 디자인, 사용 방법 설명, 평가 등을 위해 실제 화면과 유사하게 만든 정적인 모형을 의미합니다.  마치 종이에 그린 디자인 시안과 같이 시각적으로 구성 요소를 배치하는 데 초점을 맞추며, 실제 기능은 구현되지 않습니다.  스토리보드는 사용자 인터페이스의 흐름을 시각적으로 보여주는 데 중점을 두고, 프로토타입은 실제 기능을 일부 구현하여 테스트하는 데 사용됩니다. 유스케이스는 시스템의 기능적 요구사항을 사용자의 관점에서 기술하는 방법론입니다. 따라서 문제에서 제시된 설명과 가장 잘 맞는 것은 실제 기능 구현 없이 시각적인 디자인에 집중하는 목업입니다.",67,105
610,7,10,애자일(Agile) 기법 중 스크럼(Scrum)과 관련된 용어에 대한 설명이 틀린 것은?,,"스크럼 마스터(Scrum Master)는 스크럼 프로세스를 따르고, 팀이 스크럼을 효과적으로 활용할 수 있도록 보장하는 역할 등을 맡는다.","제품 백로그(Product Backlog)는 스크럼 팀이 해결해야 하는 목록으로 소프트웨어 요구사항, 아키텍처 정의 등이 포함될 수 있다.",스프린트(Sprint)는 하나의 완성된 최종 결과물을 만들기 위한 주기로 3달 이상의 장기간으로 결정된다.,속도(Velocity)는 한 번의 스프린트에서 한 팀이 어느 정도의 제품 백로그를 감당할 수 있는지에 대한 추정치로 볼 수 있다.,3,"문제에서 제시된 4가지 스크럼 용어에 대한 설명 중 틀린 것을 찾는 문제입니다.  1번 스크럼 마스터의 역할 설명은 정확합니다. 스크럼 마스터는 스크럼 프로세스를 원활하게 진행하고 팀이 스크럼을 잘 활용하도록 돕는 역할을 합니다. 2번 제품 백로그에 대한 설명도 맞습니다. 제품 백로그는 개발팀이 처리해야 할 작업 목록으로, 소프트웨어 요구사항, 기능, 버그 수정 등 다양한 내용이 포함될 수 있습니다. 4번 속도(Velocity)에 대한 설명 또한 정확합니다. 속도는 과거 스프린트에서 완료한 작업량을 기반으로, 다음 스프린트에서 처리 가능한 작업량을 예측하는 데 사용됩니다.  하지만 3번 스프린트에 대한 설명은 잘못되었습니다. 스프린트는 일반적으로 1~4주 정도의 짧은 기간으로 설정되며, 하나의 완성된 결과물(Increment)을 만들어내는 것을 목표로 합니다. 3달 이상의 장기간으로 스프린트를 설정하는 것은 스크럼의 원칙에 어긋납니다.  스크럼은 반복적인 개발과 빠른 피드백을 중시하는 애자일 방법론이기 때문에 짧은 주기의 스프린트를 통해 유연성과 적응력을 확보하는 것이 중요합니다. 따라서 3번이 틀린 설명입니다.",79,102
611,7,11,UML 다이어그램 중 정적 다이어그램이 아닌 것은?,,컴포넌트 다이어그램,배치 다이어그램,순차 다이어그램,패키지 다이어그램,3,"UML 다이어그램은 시스템을 시각적으로 표현하는 도구입니다.  정적 다이어그램은 시스템의 구조나 구성 요소 간의 관계를 시간에 무관하게 나타내는 반면, 동적 다이어그램은 시스템의 동작이나 시간에 따른 변화를 보여줍니다. 문제에서 제시된 1번 컴포넌트 다이어그램, 2번 배치 다이어그램, 4번 패키지 다이어그램은 모두 시스템의 구성 요소와 그 관계를 나타내는 정적 다이어그램입니다.  반면 3번 순차 다이어그램은 시간의 흐름에 따라 객체 간의 상호 작용을 보여주는 동적 다이어그램입니다. 따라서 정적 다이어그램이 아닌 것은 순차 다이어그램입니다.  정보처리기사 공식 교재에서는 UML 다이어그램의 종류와 각 다이어그램의 특징을 자세히 설명하고 있으며, 정적 다이어그램과 동적 다이어그램을 구분하는 기준을 명확히 제시하고 있습니다.",66,102
612,7,12,"LOC기법에 의하여 예측된 총 라인수가 36000라인, 개발에 참여할 프로그래머가 6명, 프로그래머들의 평균 생산성이 월간 300라인일 때 개발에 소요되는 기간을 계산한 결과로 가장 옳은 것은?",,5개월,10개월,15개월,20개월,4,"문제에서 주어진 정보는 LOC(Lines of Code, 라인 수) 기법을 이용하여 소프트웨어 개발 기간을 예측하는 문제입니다. LOC 기법은 소프트웨어의 크기를 코드 라인 수로 측정하여 개발 기간을 추정하는 방법입니다.  총 라인 수가 36,000라인이고, 프로그래머 6명이 월 300라인씩 개발한다면, 한 달에 개발 가능한 총 라인 수는 6명 * 300라인/명 = 1800라인 입니다. 따라서 36,000라인을 개발하는 데 필요한 기간은 36,000라인 / 1,800라인/월 = 20개월이 됩니다.  따라서 정답은 4번, 20개월입니다.",87,147
613,7,13,클래스 설계원칙에 대한 바른 설명은?,,단일 책임원칙 : 하나의 클래스만 변경 가능 해야한다.,개방-폐쇄의 원칙 : 클래스는 확장에 대해 열려 있어야 하며 변경에 대해 닫혀 있어야 한다.,리스코프 교체의 원칙 : 여러 개의 책임을 가진 클래스는 하나의 책임을 가진 클래스로 대체되어야 한다.,의존관계 역전의 원칙 : 클라이언트는 자신이 사용하는 메소드와 의존관계를 갖지 않도록 해야 한다.,2,"클래스 설계 원칙 중 개방-폐쇄의 원칙(Open/Closed Principle)은 소프트웨어의 유연성과 유지보수성을 높이기 위한 중요한 원칙입니다.  이 원칙은 ""클래스는 확장에 대해 열려 있어야 하며, 변경에 대해 닫혀 있어야 한다""라고 설명합니다.  쉽게 말해, 기존 클래스의 코드를 수정하지 않고도 새로운 기능을 추가할 수 있도록 설계해야 한다는 의미입니다.  예를 들어,  새로운 종류의 도형을 그리는 기능을 추가해야 한다면, 기존의 도형 클래스를 수정하는 대신 새로운 도형 클래스를 만들어서 기존 시스템에 통합하는 방식으로 구현해야 합니다. 이렇게 하면 기존 코드의 안정성을 유지하면서 새로운 기능을 추가할 수 있고,  향후 유지보수 및 확장이 용이해집니다.  1번은 단일 책임 원칙의 잘못된 설명이고, 3번은 리스코프 치환 원칙의 잘못된 설명이며, 4번은 의존 역전 원칙의 설명입니다. 따라서 정답은 2번입니다.",58,107
614,7,14,GoF(Gangs of Four) 디자인 패턴에서 생성(Creational) 패턴에 해당하는 것은?,,컴퍼지트(Composite),어댑터(Adapter),추상 팩토리(Abstract Factory),옵서버(Observer),3,"GoF 디자인 패턴은 소프트웨어 설계에서 자주 발생하는 문제에 대한 해결책을 미리 정의해 놓은 디자인 템플릿입니다.  생성(Creational) 패턴은 객체 생성 과정을 제어하는 패턴들을 말하는데,  추상 팩토리(Abstract Factory) 패턴은 서로 관련된 객체들의 집합을 생성하는 인터페이스를 제공하지만, 생성될 구체적인 객체 클래스는 지정하지 않습니다.  즉, 어떤 종류의 객체들을 만들어야 하는지는 알지만, 정확히 어떤 클래스의 객체를 만들지는 생성 시점에 결정하는 것이죠.  다른 선택지들은 생성 패턴이 아닙니다. 컴퍼지트(Composite)는 부분-전체 계층 구조를 표현하는 패턴이고, 어댑터(Adapter)는 호환되지 않는 인터페이스를 연결하는 패턴이며, 옵서버(Observer)는 객체 간의 일대다 의존성을 정의하는 패턴입니다. 따라서 정답은 추상 팩토리(Abstract Factory)입니다.",65,107
615,7,15,아키텍처 설계과정이 올바른 순서로 나열된 것은?,https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m15.gif,㉮ → ㉯ → ㉰ → ㉱ → ㉲,㉲ → ㉮ → ㉯ → ㉱ → ㉰,㉮ → ㉲ → ㉯ → ㉱ → ㉰,㉮ → ㉯ → ㉰ → ㉲ → ㉱,1,"아키텍처 설계는 건물을 짓는 것과 비슷합니다.  먼저 무엇을 지을지 목표(㉠ 설계 목표 설정)를 정하고, 어떤 종류의 건물일지(㉡ 시스템 타입 결정) 결정해야 합니다.  그 다음 건물의 스타일(㉢ 스타일 적용 및 커스터마이즈)을 정하고, 각 방의 기능과 연결(㉣ 서브시스템의 기능, 인터페이스 동작 작성)을 설계합니다.  마지막으로 설계에 문제가 없는지 검토(㉤ 아키텍처 설계 검토)하는 과정을 거칩니다. 따라서 올바른 순서는 ㉠ → ㉡ → ㉢ → ㉣ → ㉤ 이며, 이는 1번 선택지와 일치합니다.",62,106
616,7,16,사용자 인터페이스를 설계할 경우 고려해야 할 가이드라인과 가장 거리가 먼 것은?,,심미성을 사용성보다 우선하여 설계해야 한다.,효율성을 높이게 설계해야 한다.,발생하는 오류를 쉽게 수정할 수 있어야 한다.,사용자에게 피드백을 제공해야 한다.,1,"사용자 인터페이스(UI)를 설계할 때는 사용자의 편의성과 효율성을 최우선으로 고려해야 합니다.  문제에서 제시된 보기들을 살펴보면, 2번 '효율성을 높이게 설계해야 한다'와 4번 '사용자에게 피드백을 제공해야 한다'는 사용자 중심 설계의 중요한 원칙입니다.  3번 '발생하는 오류를 쉽게 수정할 수 있어야 한다'는 개발자의 편의성과 유지보수 측면에서 중요하지만, 사용자 경험에 직접적으로 영향을 미치는 요소는 아닙니다.  하지만 1번 '심미성을 사용성보다 우선하여 설계해야 한다'는 사용자 인터페이스 설계의 기본 원칙에 어긋납니다. 아무리 보기가 좋더라도 사용하기 어렵다면 좋은 UI라고 할 수 없습니다.  사용성(Usability)이 확보되지 않은 심미성(Aesthetics)은 오히려 사용자에게 불편함을 야기할 수 있습니다. 따라서 사용자 인터페이스 설계에서는 사용성을 우선시하고, 그 위에 심미성을 더하는 것이 바람직합니다.  결론적으로, 사용성을 희생하면서까지 심미성을 추구하는 것은 바람직하지 않으므로 1번이 가장 거리가 먼 보기입니다.",85,104
617,7,17,소프트웨어 설계에서 자주 발생하는 문제에 대한 일반적이고 반복적인 해결 방법을 무엇이라고 하는가?,,모듈 분해,디자인 패턴,연관 관계,클래스 도출,2,"소프트웨어를 설계할 때, 자주 발생하는 문제들을 해결하기 위해 일반적이고 반복적으로 사용되는 해결책들을 미리 만들어 놓은 것을 디자인 패턴이라고 합니다.  마치 건축에서 건물을 지을 때 반복적으로 사용되는 설계 도면과 같은 개념입니다.  예를 들어, 특정 상황에서 자주 발생하는 문제(예: 데이터를 효율적으로 관리해야 하는 상황)에 대해 이미 검증된 해결책(예: 특정 디자인 패턴을 사용)을 활용하면,  새로운 소프트웨어를 설계할 때 시간과 노력을 절약하고, 안정적이고 효율적인 시스템을 구축할 수 있습니다.  따라서 소프트웨어 설계에서 자주 발생하는 문제에 대한 일반적이고 반복적인 해결 방법은 디자인 패턴입니다.  모듈 분해, 연관 관계, 클래스 도출은 소프트웨어 설계의 구성 요소이거나 기법이지만, 반복적으로 발생하는 문제에 대한 일반적인 해결책을 제공하는 것은 아닙니다.",68,107
618,7,18,"객체지향 분석기법의 하나로 객체 모형, 동적 모형, 기능 모형의 3개 모형을 생성하는 방법은?",,Wirfs-Block Method,Rumbaugh Method,Booch Method,Jacobson Method,2,"객체지향 분석 기법은 소프트웨어를 객체라는 개념을 중심으로 분석하고 설계하는 방법입니다.  여러 가지 객체지향 분석 기법 중 Rumbaugh 방법(OMT: Object-Oriented Modeling Technique)은 객체 모형, 동적 모형, 기능 모형의 세 가지 모형을 사용하여 시스템을 분석하는 대표적인 방법입니다.  객체 모형은 시스템을 구성하는 객체와 객체 간의 관계를 나타내고, 동적 모형은 객체 간의 상호 작용과 시간에 따른 변화를 표현하며, 기능 모형은 시스템의 기능과 데이터 흐름을 보여줍니다.  이 세 가지 모형을 통합적으로 사용하여 시스템의 전체적인 구조와 동작을 이해하고 설계하는 것이 Rumbaugh 방법의 핵심입니다.  문제에서 제시된 다른 방법들(Wirfs-Brock, Booch, Jacobson)도 객체지향 분석 기법이지만, 세 가지 모형(객체, 동적, 기능)을 모두 사용하는 방식은 Rumbaugh 방법이 가장 잘 부합합니다.  따라서 정답은 2번입니다.",80,107
619,7,19,입력되는 데이터를 컴퓨터의 프로세서가 처리하기 전에 미리 처리하여 프로세서가 처리하는 시간을 줄여주는 프로그램이나 하드웨어를 말하는 것은?,,EAI,FEP,GPL,Duplexing,2,"컴퓨터의 프로세서(CPU)는 입력된 데이터를 처리하는 역할을 합니다.  프로세서가 데이터를 처리하는 속도는 컴퓨터 성능에 직접적인 영향을 미치는데, 입력 데이터의 양이 많거나 복잡할 경우 처리 시간이 오래 걸릴 수 있습니다.  FEP(Front-End Processor)는 이러한 문제를 해결하기 위해 프로세서가 처리하기 전에 데이터를 미리 가공하고 정리하는 역할을 하는 프로그램이나 하드웨어입니다.  데이터를 미리 정리하고 필터링함으로써 프로세서의 부담을 줄이고 처리 속도를 높이는 것이죠.  마치 요리사가 요리하기 전에 재료를 손질하고 다듬는 것과 같은 원리입니다.  따라서 입력되는 데이터를 컴퓨터의 프로세서가 처리하기 전에 미리 처리하여 프로세서가 처리하는 시간을 줄여주는 프로그램이나 하드웨어는 FEP입니다.  다른 선택지는 EAI(Enterprise Application Integration), GPL(General Public License), Duplexing으로, 각각 기업 애플리케이션 통합, 오픈소스 소프트웨어 라이선스, 이중화 기술을 의미하며 문제의 맥락과는 관련이 없습니다.",45,121
620,7,20,객체 지향 개념 중 하나 이상의 유사한 객체들을 묶어 공통된 특성을 표현한 데이터 추상화를 의미하는 것은?,,Method,Class,Field,Message,2,"객체 지향 프로그래밍(OOP)에서 '클래스(Class)'는 여러 개의 비슷한 객체(Object)들을 묶어서 표현하는 개념입니다.  마치 도장처럼, 클래스는 객체를 만드는 설계도 역할을 합니다.  클래스는 객체들이 공통적으로 가지는 특징(속성, 즉 Field)과 행동(메소드, 즉 Method)을 정의합니다.  예를 들어 '강아지'라는 클래스를 생각해보면,  '털 색깔', '크기' 등의 속성과 '짖기', '뛰어놀기' 등의 행동을 정의할 수 있습니다.  그리고 이 클래스를 바탕으로 '흰둥이', '검둥이'와 같은 개별 강아지 객체들을 만들 수 있습니다.  문제에서 말하는 '유사한 객체들을 묶어 공통된 특성을 표현한 데이터 추상화'는 바로 이 클래스가 하는 역할을 정확히 설명하고 있습니다.  따라서 정답은 2번, Class입니다.",82,107
621,7,21,클린 코드(Clean Code)를 작성하기 위한 원칙으로 틀린 것은?,,"추상화 : 하위 클래스/메소드/함수를 통해 애플리케이션의 특성을 간략하게 나타내고, 상세 내용은 상위 클래스/메소드/함수에서 구현한다.",의존성 : 다른 모듈에 미치는 영향을 최소화하도록 작성한다.,가독성 : 누구든지 읽기 쉽게 코드를 작성한다.,중복성 : 중복을 최소화 할 수 있는 코드를 작성한다.,1,"1번 선택지가 틀린 이유는 추상화의 개념을 잘못 이해하고 있기 때문입니다. 추상화는 복잡한 시스템을 단순화하여 이해하기 쉽게 만드는 기법입니다.  상위 클래스나 메서드가 하위 클래스나 메서드의 상세한 구현 내용을 포함하는 것이 아니라, 오히려 *하위 클래스/메서드/함수가 상위 클래스/메서드/함수의 추상적인 기능을 구체적으로 구현*하는 것입니다.  즉, 상위는 일반적인 기능을 정의하고, 하위는 그 기능을 특정 상황에 맞게 구현하는 방식입니다.  1번 선택지는 이러한 추상화의 개념을 반대로 설명하고 있습니다.  나머지 2, 3, 4번은 클린 코드를 작성하기 위한 중요한 원칙들입니다.  의존성을 최소화하고, 가독성을 높이며, 중복을 줄이는 것은 코드의 유지보수성과 확장성을 높이는 데 필수적입니다.",73,107
622,7,22,"단위 테스트에서 테스트의 대상이 되는 하위 모듈을 호출하고, 파라미터를 전달하는 가상의 모듈로 상향식 테스트에 필요한 것은?",,테스트 스텁(Test Stub),테스트 드라이버(Test Driver),테스트 슈트(Test Suites),테스트 케이스(Test Case),2,"상향식 테스트는 하위 모듈부터 테스트하여 상위 모듈로 통합해나가는 방식입니다.  문제에서 단위 테스트의 대상이 되는 하위 모듈을 호출하고 파라미터를 전달하는 가상의 모듈을 찾는다고 했는데, 이는 상위 모듈의 관점에서 하위 모듈을 시뮬레이션하는 역할을 합니다.  하위 모듈이 아직 완성되지 않았거나, 테스트 환경을 위해 하위 모듈을 대체해야 할 때 사용하는 것이 바로 테스트 드라이버(Test Driver)입니다.  테스트 드라이버는 상위 모듈을 테스트하기 위해 하위 모듈의 기능을 모방하여 상위 모듈과의 인터페이스를 검증하는 역할을 수행합니다.  반대로 테스트 스텁(Test Stub)은 하위 모듈이 아직 구현되지 않았을 때 상위 모듈의 테스트를 위해 상위 모듈에서 호출하는 하위 모듈을 대신하는 가상의 모듈입니다.  즉, 테스트 드라이버는 상위 모듈에서 하위 모듈을 호출하는 역할을 하고, 테스트 스텁은 하위 모듈에서 상위 모듈을 호출하는 역할을 한다는 차이가 있습니다.  이 문제에서는 상위 모듈이 하위 모듈을 호출하는 상황이므로 테스트 드라이버가 정답입니다.",61,114
623,7,23,스택(Stack)에 대한 옳은 내용으로만 나열된 것은?,https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m23.gif,"㉠, ㉡","㉡, ㉢",㉣,"㉠, ㉡, ㉢, ㉣",3,"스택(Stack)은 데이터를 쌓아 올리는 방식으로, 가장 나중에 쌓은 데이터를 가장 먼저 꺼내는 LIFO(Last-In, First-Out) 방식의 자료구조입니다.  ①번은 FIFO(First-In, First-Out) 방식으로, 큐(Queue)의 특징이므로 틀렸습니다. ②번은 스택의 삽입과 삭제 방식을 잘못 설명하고 있습니다. 스택은 한쪽 끝에서만 삽입(push)과 삭제(pop) 연산이 이루어집니다.  ③번은 큐와 같은 양방향 삽입/삭제가 가능한 자료구조에 대한 설명으로 스택의 특징이 아닙니다. ④번은 스택의 대표적인 응용 분야로, 함수 호출 시 지역변수 저장이나 인터럽트 처리 등에서 스택이 사용됩니다. 따라서 스택에 대한 옳은 내용은 ④번 뿐입니다.  따라서 정답은 3번입니다.",67,111
624,7,24,소프트웨어 모듈화의 장점이 아닌 것은?,,오류의 파급 효과를 최소화한다.,기능의 분리가 가능하여 인터페이스가 복잡하다.,모듈의 재사용 가능으로 개발과 유지보수가 용이하다.,프로그램의 효율적인 관리가 가능하다.,2,"소프트웨어 모듈화란 큰 프로그램을 작고 독립적인 여러 개의 모듈로 나누는 것을 말합니다.  각 모듈은 특정 기능을 담당하며, 다른 모듈과는 인터페이스(연결점)를 통해 상호 작용합니다.  문제에서 제시된 보기들을 살펴보면, 1번, 3번, 4번은 모두 모듈화의 장점을 잘 나타냅니다. 오류가 발생해도 특정 모듈에 국한될 가능성이 높아 파급 효과를 최소화하고(1), 재사용성이 높아 개발 및 유지보수가 용이하며(3), 프로그램 관리도 효율적입니다(4).  하지만 2번은 모듈화의 장점이 아닙니다.  모듈화는 기능을 분리하여 각 모듈의 역할을 명확하게 함으로써 오히려 인터페이스의 복잡성을 *줄이는* 효과를 가져옵니다.  잘 설계된 모듈화는 각 모듈 간의 인터페이스를 단순하고 명확하게 만들어 전체 시스템의 복잡성을 관리하기 쉽게 합니다. 따라서 인터페이스가 복잡해지는 것은 모듈화가 잘못 적용되었거나, 모듈 간의 인터페이스 설계가 부적절했음을 시사합니다.",85,106
625,7,25,소프트웨어 프로젝트 관리에 대한 설명으로 가장 옳은 것은?,,개발에 따른 산출물 관리,소요인력은 최대화하되 정책 결정은 신속하게 처리,주어진 기간은 연장하되 최소의 비용으로 시스템을 개발,주어진 기간 내에 최소의 비용으로 사용자를 만족시키는 시스템을 개발,4,"소프트웨어 프로젝트 관리는 제한된 자원(시간, 비용) 내에서 사용자의 요구를 충족하는 시스템을 개발하는 것을 목표로 합니다.  1번은 산출물 관리만 강조하고, 2번은 인력 최대화를 목표로 하여 비용 효율성을 고려하지 않고, 3번은 기간 연장을 허용하여 프로젝트 관리의 중요한 목표인 기한 준수를 무시합니다. 따라서 4번이 가장 적절한데, 주어진 기간과 비용 안에서 사용자 만족도를 최대화하는 것이 소프트웨어 프로젝트 관리의 핵심 목표이기 때문입니다.  즉, 효율적인 자원 관리와 사용자 요구 충족이라는 두 가지 중요한 요소를 모두 고려하고 있죠.",73,147
626,7,26,정형 기술 검토(FTR)의 지침으로 틀린 것은?,,의제를 제한한다.,논쟁과 반박을 제한한다.,문제 영역을 명확히 표현한다.,참가자의 수를 제한하지 않는다.,4,"정형 기술 검토(Formal Technical Review, FTR)는 소프트웨어 개발 과정에서 제품의 품질을 높이기 위해 수행하는 검토 과정입니다.  FTR은 특정 목표를 달성하기 위해 참가자들이 체계적으로 문서를 검토하는 활동으로, 효과적인 검토를 위해 몇 가지 지침을 따릅니다.  문제에서 제시된 1번, 2번, 3번 지침은 모두 FTR의 효율성을 높이기 위한 필수적인 요소입니다.  의제를 제한하고(1), 논쟁과 반박을 최소화하며(2), 검토 대상을 명확히 하는 것(3)은 검토의 집중도를 높이고 불필요한 시간 낭비를 줄이는 데 중요합니다.  하지만 4번 지침인 '참가자의 수를 제한하지 않는다'는 잘못된 지침입니다.  FTR은 효과적인 검토를 위해 참가자의 수를 적절히 제한하여 검토의 집중도를 유지해야 합니다.  참가자가 너무 많으면 검토 시간이 길어지고 의사소통의 어려움이 발생하여 검토의 효율성이 떨어질 수 있습니다. 따라서 정답은 4번입니다.",65,147
627,7,27,소프트웨어 재공학의 주요 활동 중 기존 소프트웨어 시스템을 새로운 기술 또는 하드웨어 환경에서 사용할 수 있도록 변환하는 작업을 의미하는 것은?,,Analysis,Migration,Restructuring,Reverse Engineering,2,"소프트웨어 재공학은 기존 소프트웨어를 개선하거나 현대화하는 작업입니다.  문제에서 제시된 네 가지 선택지 중 'Migration'은 기존 소프트웨어 시스템을 새로운 기술 환경이나 하드웨어 환경으로 옮기는 것을 의미합니다. 예를 들어, 오래된 시스템을 최신 운영체제나 데이터베이스로 이전하는 작업이 바로 Migration에 해당합니다.  Analysis는 분석, Restructuring은 재구조화, Reverse Engineering은 역공학을 의미하는데, 이들은 모두 소프트웨어 재공학의 일부이지만, 문제에서 묻고 있는 '새로운 기술 또는 하드웨어 환경에서 사용할 수 있도록 변환하는 작업'과 가장 직접적으로 관련된 것은 Migration입니다. 다른 선택지는 소프트웨어의 특정 부분을 변경하거나 이해하는 데 초점을 맞추는 반면, Migration은 전체 시스템의 환경 변경에 초점을 맞춥니다.",48,100
628,7,28,정보시스템 개발 단계에서 프로그래밍 언어 선택 시 고려할 사항으로 가장 거리가 먼 것은?,,개발 정보시스템의 특성,사용자의 요구사항,컴파일러의 가용성,컴파일러의 독창성,4,"정보시스템 개발 시 프로그래밍 언어를 선택하는 것은 매우 중요한 과정입니다.  프로그래밍 언어는 시스템의 성능, 개발 기간, 유지보수 용이성 등에 큰 영향을 미치기 때문입니다.  따라서 개발하려는 정보시스템의 특성(예: 웹 기반 시스템인지, 모바일 앱인지, 데이터 처리량이 큰 시스템인지 등)과 사용자의 요구사항(예: 특정 기능 구현, 특정 플랫폼 지원 등)을 고려하여 적절한 언어를 선택해야 합니다.  컴파일러의 가용성 또한 중요한 고려 사항입니다.  선택한 언어에 대한 컴파일러가 존재하고, 개발 환경에서 잘 작동하는지 확인해야 합니다.  하지만 컴파일러의 '독창성'은 프로그래밍 언어 선택 기준으로 적절하지 않습니다.  컴파일러는 프로그래밍 언어를 기계어로 변환하는 도구일 뿐이며, 그 자체의 독창성이 시스템 개발에 직접적인 영향을 미치지는 않습니다.  즉, 컴파일러의 성능이나 기능은 중요하지만,  '독창성'이라는 추상적인 개념은 프로그래밍 언어 선택의 기준이 될 수 없습니다.",78,147
629,7,29,소프트웨어 패키징에 대한 설명으로 틀린 것은?,,패키징은 개발자 중심으로 진행한다.,"신규 및 변경 개발소스를 식별하고, 이를 모듈화하여 상용제품으로 패키징한다.",고객의 편의성을 위해 매뉴얼 및 버전관리를 지속적으로 한다.,범용 환경에서 사용이 가능하도록 일반적인 배포 형태로 패키징이 진행된다.,1,"소프트웨어 패키징은 개발된 소프트웨어를 고객에게 배포하기 위한 최종 단계입니다.  1번 보기 ""패키징은 개발자 중심으로 진행한다""는 잘못된 설명입니다.  패키징은 개발자의 작업이 끝난 후, 고객이 쉽고 편리하게 소프트웨어를 사용할 수 있도록 하는 과정이므로, 고객의 편의성을 최우선으로 고려해야 합니다.  따라서 사용자 매뉴얼 작성, 버전 관리, 범용 환경에서의 실행 가능성 확보 등 고객 중심으로 진행되어야 합니다.  2번, 3번, 4번 보기는 모두 고객 중심의 패키징 과정을 잘 설명하고 있습니다.  따라서 정답은 1번입니다.",82,116
630,7,30,자료 구조의 분류 중 선형 구조가 아닌 것은?,,트리,리스트,스택,데크,1,"자료구조는 데이터를 효율적으로 저장하고 관리하는 방법을 연구하는 컴퓨터 과학의 한 분야입니다.  선형 구조는 데이터가 순차적으로 연결되어 있는 구조를 말합니다.  리스트, 스택, 큐, 데크 등이 대표적인 선형 구조입니다.  반면 트리는 계층적인 구조로, 하나의 루트 노드에서 여러 개의 자식 노드로 가지를 뻗어나가는 형태입니다.  트리 구조는 데이터 간의 계층적 관계를 표현하는 데 적합하지만, 데이터가 순차적으로 연결되어 있지 않으므로 선형 구조라고 할 수 없습니다. 따라서 문제에서 제시된 자료구조 중 선형 구조가 아닌 것은 트리입니다.  쉽게 말해, 선형 구조는 기차처럼 데이터가 일렬로 연결된 것이고, 트리 구조는 나무처럼 가지가 뻗어나가는 형태라고 생각하면 이해하기 쉬울 것입니다.",73,111
631,7,31,아주 오래되거나 참고문서 또는 개발자가 없어 유지보수 작업이 아주 어려운 프로그램을 의미하는 것은?,,Title Code,Source Code,Object Code,Alien Code,4,"오래되어서 코드를 이해하기 어렵고, 개발자가 없거나 연락이 닿지 않아 유지보수가 거의 불가능한 프로그램을 ""Alien Code(외계 코드)""라고 합니다.  마치 외계인이 만든 코드처럼 이해할 수 없다는 의미에서 붙여진 이름입니다.  Title Code, Source Code, Object Code는 프로그램의 일부분을 나타내는 용어이지만, 유지보수의 어려움을 직접적으로 나타내는 용어는 아닙니다.  Alien Code는  오래된 시스템의 기술 부채(Technical Debt)를 상징적으로 보여주는 표현이라고 할 수 있습니다.  즉, 과거에 기술적인 빚을 지고(쉽게 개발하기 위해 품질을 낮춘 코드를 작성하고) 그 빚을 갚지 못해(유지보수가 어려워짐) 현재 심각한 문제를 야기하는 상황을 나타냅니다.",84,117
632,7,32,소프트웨어를 재사용함으로써 얻을 수 있는 이점으로 가장 거리가 먼 것은?,,생산성 증가,프로젝트 문서 공유,소프트웨어 품질 향상,새로운 개발 방법론 도입 용이,4,"소프트웨어 재사용이란 이미 만들어진 소프트웨어 구성요소(모듈, 라이브러리 등)를 다시 사용하는 것을 의미합니다.  이를 통해 개발 시간과 비용을 절감하고, 이미 검증된 코드를 사용하므로 소프트웨어 품질을 향상시키는 효과를 얻을 수 있습니다.  생산성 또한 자연스럽게 증가하게 됩니다.  하지만 프로젝트 문서 공유는 소프트웨어 재사용의 직접적인 이점이라기보다는 소프트웨어 개발 전반에 걸쳐 필요한 활동입니다.  마찬가지로 새로운 개발 방법론 도입은 소프트웨어 재사용과는 별개의 문제입니다.  소프트웨어 재사용은 어떤 개발 방법론을 사용하든지 적용할 수 있는 기법이기 때문입니다. 따라서 소프트웨어 재사용과 가장 거리가 먼 것은 새로운 개발 방법론 도입 용이성입니다.",72,106
633,7,33,인터페이스 간의 통신을 위해 이용되는 데이터 포맷이 아닌 것은?,,AJTML,JSON,XML,YAML,1,"이 문제는 인터페이스 간 통신에 사용되는 데이터 포맷을 묻고 있습니다.  JSON(JavaScript Object Notation), XML(Extensible Markup Language), YAML(YAML Ain't Markup Language)은 모두 인터페이스 간 데이터 교환을 위해 널리 사용되는 표준화된 데이터 포맷입니다.  JSON은 웹 애플리케이션에서 가볍고 빠른 데이터 교환을 위해 많이 사용되고, XML은 다양한 시스템 간의 데이터 교환에 유연성을 제공하며, YAML은 JSON보다 사람이 읽기 쉬운 형태로 데이터를 표현합니다.  반면 AJTML은 표준 데이터 포맷으로 알려진 바가 없습니다. 따라서 인터페이스 간 통신에 사용되는 데이터 포맷이 아닌 것은 AJTML입니다.  정보처리기사 시험에서는 표준적인 데이터 포맷에 대한 이해를 묻는 문제가 자주 출제되므로, JSON, XML, YAML 등의 특징과 용도를 숙지하는 것이 중요합니다.",43,108
634,7,34,프로그램 설계도의 하나인 NS Chart에 대한 설명으로 가장 거리가 먼 것은?,,논리의 기술에 중점을 두고 도형을 이용한 표현 방법이다.,이해하기 쉽고 코드 변환이 용이하다.,화살표나 GOTO를 사용하여 이해하기 쉽다.,"연속, 선택, 반복 등의 제어 논리 구조를 표현한다.",3,"NS 차트(Nassi-Shneiderman Chart)는 프로그램의 논리적 흐름을 표현하는 설계 도구입니다.  도형을 이용하여 순차, 선택, 반복 등의 제어 구조를 명확하게 나타내므로, 프로그램의 논리를 시각적으로 이해하기 쉽게 만들어줍니다.  코드로의 변환도 비교적 용이하다는 장점이 있습니다.  하지만 3번 보기처럼 화살표나 GOTO문과 같은 비구조적 제어 방식을 사용하지 않습니다. NS 차트는 구조적 프로그래밍의 원칙을 따르기 때문에, GOTO문과 같은 비구조적인 점프 명령어는 사용하지 않고, 순차, 선택, 반복의 세 가지 기본 제어 구조만을 사용하여 프로그램의 흐름을 표현합니다. 따라서 3번은 NS 차트의 특징과 거리가 멉니다.",55,106
635,7,35,"순서가 A, B, C, D로 정해진 입력자료를 push, push, pop, push, push, pop, pop, pop 순서로 스택연산을 수행하는 경우 출력 결과는?",,B D C A,A B C D,B A C D,A B D C,1,"이 문제는 스택 자료구조의 동작 원리를 이해하고 있는지 묻는 문제입니다. 스택은 후입선출(LIFO, Last-In-First-Out) 방식으로 데이터를 저장하고 접근하는 자료구조입니다.  마치 접시를 쌓아 올리는 것과 같이, 가장 나중에 쌓은 접시를 가장 먼저 꺼낼 수 있습니다.  문제에서 주어진 연산 순서대로 스택에 데이터를 넣고 빼는 과정을 살펴보겠습니다.",68,111
636,7,36,분할 정복(Divide and Conquer)에 기반한 알고리즘으로 피벗(pivot)을 사용하며 최악의 경우 회의 비교를 수행해야 하는 정렬(Sort)은?,https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m36m1.gif,Selection Sort,Bubble Sort,Insert Sort,Quick Sort,4,"문제에서 제시된 n(n-1)/2는 정렬 알고리즘에서 최악의 경우 비교 횟수를 나타냅니다.  퀵 정렬(Quick Sort)은 분할 정복(Divide and Conquer) 전략을 사용하는 정렬 알고리즘으로, 피벗(pivot)을 기준으로 데이터를 작은 값과 큰 값으로 나누는 방식으로 동작합니다.  최악의 경우, 피벗 선택이 항상 가장 작거나 가장 큰 값일 때 발생하며, 이 경우 데이터가 이미 정렬되어 있거나 거의 정렬되어 있는 상황과 같습니다.  이때,  퀵 정렬은  n(n-1)/2 회의 비교를 수행하게 되어 시간 복잡도가 O(n²)이 됩니다.  선택 정렬(Selection Sort), 버블 정렬(Bubble Sort), 삽입 정렬(Insertion Sort)은 최악의 경우에도 O(n²)의 시간 복잡도를 가지지만, 퀵 정렬과 달리 분할 정복 전략을 사용하지 않고 피벗을 사용하지도 않습니다. 따라서, 분할 정복과 피벗을 사용하며 최악의 경우 n(n-1)/2 회의 비교를 수행하는 정렬 알고리즘은 퀵 정렬입니다.",53,121
637,7,37,화이트 박스 검사 기법에 해당하는 것으로만 짝지어진 것은?,https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m37.gif,"㉠, ㉡","㉠, ㉣","㉡, ㉤","㉢, ㉥",1,"화이트 박스 검사는 소프트웨어의 내부 구조와 동작을 알고 테스트하는 기법입니다.  소스 코드를 직접 확인하며 테스트를 설계하고 실행하므로, 프로그램의 논리적 흐름, 루프, 데이터 흐름 등을 자세히 검사할 수 있습니다. 문제에서 제시된 선택지 중 데이터 흐름 검사와 루프 검사는 모두 프로그램의 내부 구조를 직접적으로 분석하는 화이트 박스 검사 기법에 해당합니다. 반면, 동등 분할 검사, 경계값 분석, 원인 결과 그래프 기법, 오류 예측 기법은 프로그램의 내부 구조를 직접적으로 고려하지 않고, 입력값이나 예상되는 결과를 바탕으로 테스트를 설계하는 블랙 박스 검사 기법입니다. 따라서, 화이트 박스 검사 기법에 해당하는 것으로만 짝지어진 것은 데이터 흐름 검사와 루프 검사인 1번이 정답입니다.",67,119
638,7,38,소프트웨어 품질 관련 국제 표준인 ISO/IEC 25000에 관한 설명으로 옳지 않은 것은?,,소프트웨어 품질 평가를 위한 소프트웨어 품질평가 통합모델 표준이다.,System and Software Quality Requirements and Evaluation으로 줄여서 SQuaRE라고도 한다.,"ISO/IEC 2501n에서는 소프트웨어의 내부 측정, 외부측정, 사용품질 측정, 품질 측정 요소 등을 다룬다.",기존 소프트웨어 품질 평가 모델과 소프트웨어 평가 절차 모델인 ISO/IEC 9126과 ISO/IEC 14598을 통합하였다.,3,"ISO/IEC 25000은 소프트웨어 품질을 평가하기 위한 국제 표준으로, SQuaRE(System and Software Quality Requirements and Evaluation)라고도 불립니다.  기존의 소프트웨어 품질 평가 모델인 ISO/IEC 9126(소프트웨어 품질 모델)과 ISO/IEC 14598(소프트웨어 품질 평가 절차)을 통합하여 하나의 통합 모델을 제시합니다.  따라서 1번과 4번은 맞는 설명입니다.  문제에서 틀린 것은 3번입니다.  ISO/IEC 25010(ISO/IEC 25000 시리즈의 일부)은 소프트웨어 품질 특성과 하위 특성을 정의하고 있지만,  '내부 측정, 외부 측정, 사용품질 측정, 품질 측정 요소' 등의 구체적인 측정 방법이나 요소들을 직접적으로 다루지는 않습니다.  각각의 측정은 ISO/IEC 25000 시리즈의 다른 부분에서 다루어집니다.  즉, 3번은 ISO/IEC 25010의 내용을 잘못 이해하고 있는 설명입니다.",47,117
639,7,39,코드 인스펙션과 관련한 설명으로 틀린 것은?,,프로그램을 수행시켜보는 것 대신에 읽어보고 눈으로 확인하는 방법으로 볼 수 있다.,코드 품질 향상 기법 중 하나이다.,동적 테스트 시에만 활용하는 기법이다.,"결함과 함께 코딩 표준 준수 여부, 효율성 등의 다른 품질 이슈를 검사하기도 한다.",3,"코드 인스펙션은 프로그램을 직접 실행하지 않고 코드를 읽어서 오류나 문제점을 찾는 방법입니다.  마치 책을 읽듯이 코드를 검토하여 논리적 오류, 코딩 표준 위반, 비효율적인 코드 등을 발견하는 것이죠.  따라서 1번과 4번은 코드 인스펙션의 특징을 잘 나타내고 있습니다.  코드 인스펙션은 코드의 품질을 높이기 위한 활동이므로 2번도 맞는 설명입니다.  하지만 3번은 잘못된 설명입니다. 코드 인스펙션은 프로그램을 실행하지 않고 코드 자체를 검토하는 정적 테스트 기법이지, 프로그램을 실행하는 동적 테스트 기법이 아닙니다. 동적 테스트는 프로그램을 실제로 실행하여 오류를 찾는 방법입니다.  결론적으로, 코드 인스펙션은 코드를 읽고 검토하는 정적 분석 기법이며, 동적 테스트와는 구분됩니다.",69,113
640,7,40,"프로젝트에 내재된 위험 요소를 인식하고 그 영향을 분석하여 이를 관리하는 활동으로서, 프로젝트를 성공시키기 위하여 위험 요소를 사전에 예측, 대비하는 모든 기술과 활동을 포함하는 것은?",,Critical Path Method,Risk Analysis,Work Breakdown Structure,Waterfall Model,2,"프로젝트를 진행하다 보면 예상치 못한 문제들이 발생할 수 있습니다. 예를 들어, 개발에 필요한 장비가 고장나거나, 핵심 개발자가 갑자기 퇴사하거나, 예산이 부족해지는 등의 상황이 발생할 수 있죠.  이러한 예상치 못한 문제들을 '위험 요소'라고 부릅니다.  Risk Analysis는 이러한 위험 요소들을 미리 파악하고, 각 위험 요소가 프로젝트에 미칠 영향을 분석하여,  발생 가능성과 그 영향을 줄이기 위한 대책을 세우는 활동입니다.  즉, 프로젝트 성공을 위해 위험을 사전에 예측하고 대비하는 모든 기술과 활동을 포함하는 것이 Risk Analysis입니다.  Critical Path Method는 프로젝트 일정 관리 기법이고, Work Breakdown Structure는 프로젝트 작업을 분해하는 기법이며, Waterfall Model은 소프트웨어 개발 방법론입니다. 따라서 문제에서 요구하는 '프로젝트 위험 관리'와 가장 직접적으로 관련된 것은 Risk Analysis입니다.",78,147
641,7,41,데이터베이스 설계 단계 중 물리적 설계 시 고려 사항으로 적절하지 않은 것은?,,스키마의 평가 및 정제,응답 시간,저장 공간의 효율화,트랜잭션 처리량,1,"데이터베이스 물리적 설계는 논리적 설계를 바탕으로 실제 데이터베이스 시스템에 구현하기 위한 구체적인 계획을 세우는 단계입니다.  응답 시간, 저장 공간 효율화, 트랜잭션 처리량은 모두 물리적 설계 단계에서 중요하게 고려해야 할 요소들입니다.  빠른 응답 속도를 위해 어떤 인덱스를 사용할지, 저장 공간을 효율적으로 사용하기 위해 어떤 데이터 타입을 선택할지, 많은 트랜잭션을 처리하기 위해 어떤 하드웨어 구성을 선택할지 등을 결정하는 것이 물리적 설계의 핵심입니다.  반면, ""스키마의 평가 및 정제""는 논리적 설계 단계에서 수행되어야 할 작업입니다.  논리적 설계 단계에서는 데이터베이스의 구조와 관계를 정의하고, 정규화를 통해 데이터 중복을 제거하고 데이터 무결성을 확보하는 등의 작업을 합니다.  스키마의 평가 및 정제가 완료된 후에야 물리적 설계 단계로 넘어가 실제 구현에 필요한 세부적인 사항들을 결정하는 것이 올바른 순서입니다. 따라서 물리적 설계 단계에서 고려 사항으로 적절하지 않은 것은 스키마의 평가 및 정제입니다.",69,134
642,7,42,DELETE 명령에 대한 설명으로 틀린 것은?,,테이블의 행을 삭제할 때 사용한다.,WHERE 조건절이 없는 DELETE 명령을 수행하면 DROP TABLE 명령을 수행했을 때와 동일한 효과를 얻을 수 있다.,SQL을 사용 용도에 따라 분류할 경우 DML에 해당한다.,기본 사용 형식은 “DELETE FROM 테이블 [WHERE 조건];” 이다.,2,"DELETE 명령은 데이터베이스에서 테이블의 행(레코드)을 삭제하는 데 사용하는 SQL 명령어입니다.  1번은 DELETE 명령의 기본적인 기능을 정확하게 설명하고 있습니다. 3번 또한 DELETE 명령이 데이터 조작 언어(DML: Data Manipulation Language)에 속한다는 점을 올바르게 지적하고 있습니다. 4번은 DELETE 명령의 기본적인 문법 형식을 제시하고 있으며, WHERE 조건절을 사용하여 특정 조건에 맞는 행만 삭제할 수 있다는 것을 보여줍니다.  하지만 2번은 잘못된 설명입니다. WHERE 조건절 없이 DELETE FROM 테이블; 명령을 실행하면 테이블의 모든 행이 삭제되지만, 테이블 자체는 남아있습니다. 반면 DROP TABLE 명령은 테이블 자체를 완전히 삭제합니다. 따라서 두 명령어의 효과는 동일하지 않습니다.  따라서 틀린 것은 2번입니다.",70,126
643,7,43,"어떤 릴레이션 R의 모든 조인 종속성의 만족이 R의 후보 키를 통해서만 만족될 때, 이 릴레이션 R이 해당하는 정규형은?",,제5정규형,제4정규형,제3정규형,제1정규형,1,"릴레이션 R의 모든 조인 종속성이 후보 키를 통해서만 만족된다는 것은,  데이터 중복이 최대한 제거되었다는 것을 의미합니다.  좀 더 자세히 설명하면,  조인 종속성이란 여러 개의 속성이 다른 속성을 결정하는 종속성을 말하는데, 이 종속성이 후보 키(테이블의 모든 튜플을 유일하게 식별하는 최소한의 속성 집합)를 통해서만 만족된다는 것은  비키(후보키가 아닌 속성)를 통해서는 데이터 중복이 발생하지 않는다는 뜻입니다. 이러한 상태는 데이터베이스의 정규화 과정에서 가장 높은 수준의 정규화인 제5정규형(5NF)에 해당합니다.  제5정규형은 조인 종속성을 제거하여 데이터 중복을 최소화하고 데이터 무결성을 보장하는 최고 수준의 정규화 단계입니다.  제3정규형이나 제4정규형은 제5정규형보다 낮은 수준의 정규화로, 여전히 데이터 중복이 존재할 가능성이 있습니다.  따라서 정답은 제5정규형입니다.",61,130
644,7,44,E-R 모델에서 다중값 속성의 표기법은?,,https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m44b1.gif,https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m44b2.gif,https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m44b3.gif,https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m44b4.gif,3,"E-R 모델에서 다중값 속성이란, 하나의 개체가 여러 개의 값을 가질 수 있는 속성을 의미합니다. 예를 들어, '학생'이라는 개체가 여러 개의 '전화번호'를 가질 수 있는 경우 '전화번호'는 다중값 속성입니다.  일반적인 E-R 다이어그램에서는 다중값 속성을 별도의 개체로 표현하여 관계를 맺는 방식으로 표기합니다.  즉,  '학생' 개체와 '전화번호' 개체 사이에 관계를 설정하고,  '학생' 개체는 여러 개의 '전화번호' 개체와 연결될 수 있도록 표현하는 것입니다.  따라서 다중값 속성은 하나의 속성으로 표현하지 않고, 새로운 개체와 관계를 통해 표현하는 것이 E-R 모델의 표기법입니다.  정보처리기사 공식 교재에서는 이러한 다중값 속성의 처리 방법을 자세히 설명하고 있으며,  별도의 개체를 생성하여 관계를 설정하는 방법이 가장 일반적인 표기법으로 제시됩니다.",78,130
645,7,45,다른 릴레이션의 기본키를 참조하는 키를 의미하는 것은?,,필드키,슈퍼키,외래키,후보키,3,"다른 테이블의 기본키를 참조하는 키를 외래키라고 합니다.  데이터베이스에서 여러 개의 테이블이 서로 연관되어 있을 때,  하나의 테이블의 기본키(Primary Key)를 다른 테이블에서 참조하는 키를 외래키(Foreign Key)라고 부릅니다.  예를 들어, '고객' 테이블과 '주문' 테이블이 있다고 가정해 봅시다. '고객' 테이블의 기본키는 고객 ID이고, '주문' 테이블에는 고객 ID를 참조하는 외래키가 있습니다. 이를 통해 '주문' 테이블은 어떤 고객이 해당 주문을 했는지 알 수 있습니다.  즉, 외래키는 테이블 간의 관계를 설정하고 데이터의 무결성을 유지하는 데 중요한 역할을 합니다.  문제에서 제시된 다른 옵션들은 모두 데이터베이스 키의 종류이지만, 다른 테이블의 기본키를 참조하는 특징을 가진 것은 외래키뿐입니다.",74,129
646,7,46,관계해석에서 '모든 것에 대하여'의 의미를 나타내는 논리 기호는?,,∃,∈,∀,⊂,3,"모든 것에 대하여'라는 표현은 수학이나 논리학에서 모든 원소 또는 모든 경우를 다룬다는 의미를 나타냅니다.  정보처리기사 시험에서 다루는 관계해석(Relational Calculus)은 데이터베이스의 데이터를 조작하는 방법 중 하나인데,  여기서 '모든 것에 대하여'를 표현하는 기호는 '∀' (for all) 입니다.  '∀' 기호는 집합의 모든 원소에 대해 조건이 성립함을 나타내는 전칭 기호(universal quantifier)입니다.  예를 들어, ""모든 학생은 수업에 참석한다"" 라는 명제를 논리 기호로 표현한다면, 학생을 나타내는 집합을 U라고 하고, 수업에 참석한다는 조건을 P(x)라고 하면  ∀x∈U, P(x) 와 같이 표현할 수 있습니다.  따라서 문제에서 제시된 답 중 '∀'가 '모든 것에 대하여'를 의미하는 올바른 논리 기호입니다.  다른 답변들은 각각 존재 기호, 원소 포함 기호, 부분집합 기호를 나타내므로 문제의 의미와 맞지 않습니다.",67,129
647,7,47,다음 릴레이션의 Degree와 Cardinality는?,https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m47.gif,"Degree : 4, Cardinality : 3","Degree : 3, Cardinality : 4","Degree : 3, Cardinality : 12","Degree : 12, Cardinality : 3",1,이 문제는 관계형 데이터베이스(Relational Database)에서 사용하는 용어인 Degree와 Cardinality를 묻고 있습니다.  표에서 보이는 데이터를 관계형 데이터베이스의 테이블로 생각해보세요.,64,129
648,7,48,뷰(View)에 대한 설명으로 틀린 것은?,,뷰 위에 또 다른 뷰를 정의할 수 있다.,DBA는 보안성 측면에서 뷰를 활용할 수 있다.,사용자가 필요한 정보를 요구에 맞게 가공하여 뷰로 만들 수 있다.,"SQL을 사용하면 뷰에 대한 삽입, 갱신, 삭제 연산 시 제약 사항이 없다.",4,"뷰(View)는 데이터베이스의 테이블이나 다른 뷰를 기반으로 만들어진 가상의 테이블입니다.  쉽게 말해, 원본 테이블의 일부분만 보여주거나, 여러 테이블의 데이터를 합쳐서 특정 형태로 보여주는 창문과 같은 역할을 합니다.  문제에서 틀린 것은 4번입니다.  SQL을 사용하여 뷰에 데이터를 삽입하거나, 갱신, 삭제하는 작업을 할 때는 제약사항이 있을 수 있습니다.  예를 들어, 뷰가 여러 테이블의 데이터를 결합하여 만들어진 경우, 뷰를 통해 데이터를 수정하면 원본 테이블에 영향을 미치는지,  어떤 제약조건이 있는지 등을 고려해야 합니다.  따라서 뷰에 대한 삽입, 갱신, 삭제 연산에는 제약사항이 없다는 것은 잘못된 설명입니다. 1번은 뷰 위에 또 다른 뷰를 만들 수 있습니다. 2번은 DBA가 보안을 위해 특정 데이터만 보여주는 뷰를 만들어 접근 제어를 할 수 있습니다. 3번은 사용자가 원하는 데이터만 추출하여 뷰를 만들 수 있습니다.",77,128
649,7,49,관계 대수식을 SQL 질의로 옳게 표현한 것은?,https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m49.gif,SELECT 학생 FROM 이름 WHERE 학과='교육';,SELECT 이름 FROM 학생 WHERE 학과='교육';,SELECT 교육 FROM 학과 WHERE 이름='학생';,SELECT 학과 FROM 학생 WHERE 이름='교육';,2,"문제에서 제시된 관계 대수식 \(\Pi_{\text{이름}}(\sigma_{\text{학과} = \text{'교육'}}(\text{학생}))\)는 학생 테이블에서 학과가 '교육'인 레코드만 선택한 후(σ 연산자), 그 레코드들 중 '이름' 속성만 추출하는(Π 연산자) 것을 의미합니다.  쉽게 말해, 학생 테이블에서 학과가 '교육'인 학생들의 이름만을 조회하는 것입니다.  선택지 1, 3, 4는 조건이나 선택하는 속성이 관계 대수식과 일치하지 않습니다.  선택지 2인 ""SELECT 이름 FROM 학생 WHERE 학과='교육';""는  SQL 문법을 사용하여 학생 테이블에서 학과가 '교육'인 학생들의 이름만을 선택하는 명령어로, 관계 대수식과 정확하게 일치합니다. 따라서 정답은 2번입니다.",67,128
650,7,50,정규화 과정에서 함수 종속이 A→B 이고 B→C 일 때 A→C인 관계를 제거하는 단계는?,,1NF → 2NF,2NF → 3NF,3NF → BCNF,BCNF → 4NF,2,"함수 종속이란, 어떤 속성(A)의 값이 결정되면 다른 속성(B)의 값도 결정되는 관계를 말합니다.  A → B 라는 표기는 A가 B를 함수적으로 결정한다는 의미입니다.  문제에서 A → B 이고 B → C 라면, A의 값이 결정되면 B의 값이 결정되고, B의 값이 결정되면 C의 값도 결정됩니다.  결국 A의 값만 알면 C의 값도 알 수 있으므로 A → C 라는 함수 종속이 성립합니다.  이러한 중복적인 함수 종속을 제거하는 과정은 데이터베이스 정규화의 핵심 단계 중 하나입니다.  2NF(Second Normal Form, 제2정규형)는 부분 함수 종속을 제거하는 단계이고, 이 문제에서 설명하는 A → C 와 같은 전이 종속(transitive dependency)을 제거하는 단계는 3NF(Third Normal Form, 제3정규형)입니다.  하지만, 문제에서는 2NF → 3NF 단계에서 이러한 중복적인 함수 종속을 제거한다고 명시하고 있으므로 정답은 2번입니다.  정규화 과정은 1NF에서 시작하여 BCNF까지 진행되며, 각 단계에서 특정 종류의 데이터 중복을 제거하여 데이터베이스의 무결성과 효율성을 높입니다.  2NF에서 3NF로 넘어가는 과정에서 전이 종속성을 제거하는 것이 핵심입니다.",58,130
651,7,51,CREATE TABLE문에 포함되지 않는 기능은?,,속성 타입 변경,속성의 NOT NULL 여부 지정,기본키를 구성하는 속성 지정,CHECK 제약조건의 정의,1,"CREATE TABLE 문은 데이터베이스에 새로운 테이블을 생성하는 SQL 명령어입니다.  테이블의 이름, 속성(컬럼)의 이름과 데이터 타입, 그리고 각 속성에 대한 제약 조건(예: NOT NULL, PRIMARY KEY, CHECK 등)을 정의하는 데 사용됩니다.  문제에서 제시된 옵션들을 살펴보면,  NOT NULL 제약 조건 지정, 기본키 지정, CHECK 제약 조건 정의는 모두 CREATE TABLE 문에서 가능합니다. 하지만 속성(컬럼)의 타입을 *변경*하는 것은 CREATE TABLE 문의 목적이 아니며,  기존 테이블의 구조를 변경하는 ALTER TABLE 문을 사용해야 합니다.  CREATE TABLE은 새로운 테이블을 만드는 것이지, 이미 존재하는 테이블을 수정하는 것이 아니기 때문입니다. 따라서 CREATE TABLE 문에 포함되지 않는 기능은 속성 타입 변경입니다.",57,127
652,7,52,SQL과 관련한 설명으로 틀린 것은?,,REVOKE 키워드를 사용하여 열 이름을 다시 부여할 수 있다.,"데이터 정의어는 기본 테이블, 뷰 테이블, 또는 인덱스 등을 생성, 변경, 제거하는데 사용되는 명령어이다.",DISTINCT를 활용하여 중복 값을 제거할 수 있다.,JOIN을 통해 여러 테이블의 레코드를 조합하여 표현할 수 있다.,1,"문제에서 제시된 SQL 관련 설명 중 틀린 것을 찾는 문제입니다.  1번 선택지 ""REVOKE 키워드를 사용하여 열 이름을 다시 부여할 수 있다""가 틀렸습니다. REVOKE 키워드는 사용자나 역할에게 부여된 권한을 취소하는 데 사용되는 명령어입니다. 열 이름을 변경하려면 ALTER TABLE 명령어를 사용해야 합니다.  2번 선택지는 데이터 정의어(DDL: Data Definition Language)의 역할을 정확하게 설명하고 있습니다.  3번 선택지는 DISTINCT 키워드를 사용하여 중복된 값을 제거할 수 있다는 것을 올바르게 설명하고 있습니다. 4번 선택지는 JOIN 키워드를 사용하여 여러 테이블의 레코드를 조합할 수 있다는 것을 정확하게 설명하고 있습니다. 따라서 1번 선택지가 유일하게 틀린 설명입니다.",67,127
653,7,53,다음 SQL문의 실행결과로 생성되는 튜플 수는?,https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m53.gif,1,3,4,5,4,"문제에서 제시된 SQL 문 `SELECT 급여 FROM 사원;`은 `사원` 테이블에서 `급여` 컬럼의 모든 값을 선택하라는 명령입니다.  `사원` 테이블의 데이터를 살펴보면,  총 5명의 사원에 대한 정보가 있고 각 사원마다 급여 정보가 존재합니다. 따라서, 이 SQL 문을 실행하면 각 사원의 급여가 하나의 튜플(row)로 결과에 나타나게 됩니다.  결과적으로 5명의 사원이 있으므로 5개의 튜플이 생성되지만, 문제에서 중복된 급여(35000, 40000)가 있으므로, 튜플의 수는 중복을 포함하여 5개가 됩니다.  하지만 문제의 질문 의도가 중복을 제외한 급여의 종류를 묻는 것이 아니라, 급여 정보를 가지고 있는 튜플의 개수를 묻는 것이므로 정답은 5개입니다.  문제에 제시된 정답 4는 잘못된 답변입니다.  문제의 오류를 지적하고, 정답은 5개임을 명확히 합니다.",75,126
654,7,54,다음 SQL문에서 사용된 BETWEEN 연산의 의미와 동일한 것은?,https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m54.gif,점수 ＞= 90 AND 점수 ＜= 95,점수 ＞ 90 AND 점수 ＜ 95,점수 ＞ 90 AND 점수 ＜= 95,점수 ＞= 90 AND 점수 ＜ 95,1,"SQL문에서 `BETWEEN` 연산자는 지정된 범위 내의 값을 선택하는 데 사용됩니다.  문제의 SQL문 `WHERE (점수 BETWEEN 90 AND 95)`는 '점수'가 90 이상이고 95 이하인 레코드만 선택하라는 의미입니다.  즉, 90과 95를 포함한 90부터 95까지의 점수를 가진 데이터를 선택합니다. 따라서,  `점수 >= 90 AND 점수 <= 95` 와 동일한 의미를 가집니다. 다른 보기들은 90 또는 95를 포함하지 않거나, 범위를 잘못 표현하고 있습니다. 예를 들어, 2번 보기는 90과 95를 제외한 90보다 크고 95보다 작은 값만 선택합니다.",73,126
655,7,55,트랜잭션의 상태 중 트랜잭션의 수행이 실패하여 Rollback 연산을 실행한 상태는?,,철회(Aborted),부분 완료(Partially Committed),완료(Commit),실패(Fail),1,"트랜잭션은 데이터베이스의 여러 작업을 하나의 논리적 단위로 묶어서 처리하는 것을 말합니다.  예를 들어, 계좌 이체를 한다고 생각해보세요.  출금 계좌에서 돈을 빼고, 입금 계좌에 돈을 넣는 두 가지 작업이 모두 성공해야만 이체가 완료된다고 할 수 있습니다.  만약 출금은 성공했는데 입금이 실패한다면 데이터베이스의 일관성이 깨지게 되겠죠.  이러한 문제를 해결하기 위해 트랜잭션이라는 개념이 사용됩니다.  트랜잭션은 '모두 성공하거나, 모두 실패하거나' 하는 특징(원자성)을 가지고 있습니다.  문제에서 Rollback 연산은 트랜잭션 수행 중에 오류가 발생했을 때, 이미 수행된 작업을 취소하고 데이터베이스를 이전 상태로 되돌리는 것을 의미합니다.  Rollback이 실행되었다는 것은 트랜잭션의 수행이 실패했음을 의미하며, 이 상태를 '철회(Aborted)'라고 합니다.  따라서 정답은 1번 철회(Aborted)입니다.",69,127
656,7,56,데이터 제어어(DCL)에 대한 설명으로 옳은 것은?,,ROLLBACK : 데이터의 보안과 무결성을 정의한다.,COMMIT : 데이터베이스 사용자의 사용 권한을 취소한다.,GRANT : 데이터베이스 사용자의 사용 권한을 부여한다.,REVOKE : 데이터베이스 조작 작업이 비정상적으로 종료되었을 때 원래 상태로 복구한다.,3,"데이터 제어어(DCL: Data Control Language)는 데이터베이스 시스템에서 사용자의 접근 권한을 관리하는 데 사용되는 명령어 집합입니다.  쉽게 말해, 누가 데이터베이스에 접근해서 어떤 작업을 할 수 있는지,  어떤 작업을 할 수 없는지를 정의하는 역할을 합니다.  문제에서 제시된 보기들을 살펴보면, 1번 ROLLBACK은 트랜잭션(데이터베이스 작업 단위)을 취소하는 명령어이고, 2번 COMMIT은 트랜잭션을 완료하는 명령어이며, 4번 REVOKE는 사용자의 권한을 취소하는 명령어입니다.  반면 3번 GRANT는 사용자에게 특정 권한을 부여하는 명령어이므로, 데이터베이스 사용자의 사용 권한을 관리하는 DCL의 기능에 정확하게 부합합니다. 따라서 정답은 3번입니다.",76,126
657,7,57,"테이블 R과 S에 대한 SQL에 대한 SQL문이 실행되었을 때, 실행결과로 옳은 것은?",https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m57.gif,https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m57b1.gif,https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m57b2.gif,https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m57b3.gif,https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m57b4.gif,4,"이 문제는 SQL의 집합 연산자 중 `UNION ALL`의 동작을 이해하고 있는지 묻는 문제입니다.  `UNION ALL` 연산자는 두 개 이상의 SELECT 문의 결과를 하나로 합쳐줍니다.  중복되는 행도 모두 포함하는 것이 특징입니다.  문제에서 `SELECT A FROM R`은 테이블 R의 A열 값인 1과 3을 가져오고, `SELECT A FROM S`는 테이블 S의 A열 값인 1과 2를 가져옵니다.  `UNION ALL`을 사용했으므로, 중복된 값 1도 포함되어 최종 결과는 1, 3, 1, 2가 됩니다. 따라서 정답은 4번입니다.  쉽게 말해, 두 테이블의 A열을 붙여서 보여주는 것이고, 중복된 값도 그대로 나타납니다.",73,128
658,7,58,분산 데이터베이스 시스템(Distributed Database System)에 대한 설명으로 틀린 것은?,,분산 데이터베이스는 논리적으로는 하나의 시스템에 속하지만 물리적으로는 여러 개의 컴퓨터 사이트에 분산되어 있다.,"위치 투명성, 중복 투명성, 병행 투명성, 장애 투명성을 목표로 한다.","데이터베이스의 설계가 비교적 어렵고, 개발 비용과 처리 비용이 증가한다는 단점이 있다.","분산 데이터베이스 시스템의 주요 구성 요소는 분산 처리기, P2P 시스템, 단일 데이터베이스 등이 있다.",4,"4번이 틀린 이유는 분산 데이터베이스 시스템의 주요 구성 요소에 대한 설명이 부정확하기 때문입니다.  분산 데이터베이스 시스템은 여러 개의 독립적인 데이터베이스 사이트로 구성되며, 이들 사이트는 네트워크를 통해 서로 연결되어 하나의 논리적인 데이터베이스처럼 동작합니다.  문제의 4번에서 언급된 '분산 처리기', 'P2P 시스템', '단일 데이터베이스'는 분산 데이터베이스 시스템을 구성하는 요소가 될 수는 있지만,  주요 구성 요소라고 단정 지을 수 없습니다.  분산 데이터베이스 시스템의 핵심은 여러 사이트에 분산된 데이터를 통합적으로 관리하고 접근하는 데 있으며, 이를 위해서는 분산 트랜잭션 관리, 데이터 복제 및 일관성 유지, 분산 쿼리 처리 등의 기능이 필수적입니다.  P2P 시스템은 분산 시스템의 한 유형이지만, 모든 분산 데이터베이스 시스템이 P2P 방식을 사용하는 것은 아닙니다.  단일 데이터베이스는 분산 데이터베이스의 개념과 정반대입니다. 따라서 4번은 분산 데이터베이스 시스템의 구성 요소를 잘못 이해하고 있는 설명입니다.  1, 2, 3번은 분산 데이터베이스 시스템의 특징과 장단점을 잘 나타내고 있습니다.",49,131
659,7,59,"테이블 두 개를 조인하여 뷰 V_1을 정의하고, V_1을 이용하여 뷰 V_2를 정의하였다. 다음 명령 수행 후 결과로 옳은 것은?",https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m59.gif,V_1만 삭제된다.,V_2만 삭제된다.,V_1과 V_2 모두 삭제된다.,V_1과 V_2 모두 삭제되지 않는다.,3,"DROP VIEW 명령어는 뷰를 삭제하는 명령어입니다.  문제에서 `CASCADE` 옵션이 함께 사용되었는데, 이 옵션은 해당 뷰에 의존하는 다른 객체들도 함께 삭제한다는 의미입니다.  V_1이라는 뷰를 삭제하는데 CASCADE 옵션이 있으므로, V_1을 기반으로 만들어진 V_2 뷰도 자동으로 삭제됩니다.  따라서 V_1과 V_2 모두 삭제되는 것이 정답입니다.  쉽게 말해, V_1이라는 레고 블록을 쌓아 V_2라는 더 큰 레고 블록을 만들었다면, V_1을 없애면 V_2도 자동으로 없어지는 것과 같습니다.",73,128
660,7,60,데이터베이스에서 병행제어의 목적으로 틀린 것은?,,시스템 활용도 최대화,사용자에 대한 응답시간 최소화,데이터베이스 공유 최소화,데이터베이스 일관성 유지,3,"데이터베이스 병행 제어는 여러 사용자가 동시에 데이터베이스를 접근하고 수정하는 상황에서 데이터의 일관성을 유지하기 위한 기술입니다.  1번과 2번은 병행 제어의 목표와 일치합니다. 시스템 활용도를 높이고 응답 시간을 줄이는 것은 병행 제어를 통해 여러 사용자의 요청을 효율적으로 처리함으로써 달성할 수 있는 목표이기 때문입니다.  4번 역시 데이터베이스의 일관성 유지는 병행 제어의 가장 중요한 목표입니다.  하지만 3번, 데이터베이스 공유 최소화는 병행 제어의 목표가 아닙니다.  오히려 병행 제어는 여러 사용자가 데이터베이스를 *공유*하면서도 일관성을 유지하는 방법을 제공합니다. 데이터베이스 공유를 최소화하면 병행 제어의 필요성 자체가 줄어들게 됩니다. 따라서 데이터베이스 공유 최소화는 병행 제어의 목적과는 반대되는 개념입니다.",70,127
661,7,61,IP 주소체계와 관련한 설명으로 틀린 것은?,,IPv6의 패킷 헤더는 32 octet의 고정된 길이를 가진다.,IPv6는 주소 자동설정(Auto Configuration) 기능을 통해 손쉽게 이용자의 단말을 네트워크에 접속시킬 수 있다.,IPv4는 호스트 주소를 자동으로 설정하며 유니캐스트(Unicast)를 지원한다.,IPv4는 클래스별로 네트워크와 호스트 주소의 길이가 다르다.,1,"문제에서 제시된 네 가지 설명 중 틀린 것을 찾는 문제입니다.  IPv6 패킷 헤더의 크기는 40 octet(옥텟)으로 고정되어 있습니다.  문제 1번에서는 32 octet이라고 잘못 기술되어 있으므로 틀린 설명입니다.  나머지 설명들은 모두 IPv4와 IPv6의 특징을 정확하게 반영하고 있습니다. IPv6는 주소 자동 설정 기능을 제공하며, IPv4는 클래스별로 네트워크와 호스트 주소의 길이가 다릅니다. IPv4는 유니캐스트를 지원하고 호스트 주소를 자동으로 설정하는 기능은 DHCP(Dynamic Host Configuration Protocol)와 같은 프로토콜을 통해 이루어집니다. 따라서 정답은 1번입니다.",57,145
662,7,62,"다음 C언어 프로그램이 실행되었을 때, 실행 결과는?",https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m62.gif,"7, 5","8, 5","8, 9","7, 9",3,"이 문제는 C언어의 포인터와 2차원 배열을 이용한 메모리 접근 방식을 이해하고 있는지를 묻는 문제입니다.  `arr`은 2행 3열의 2차원 배열이고, `p`는 `arr`을 가리키는 포인터 변수입니다.  `p[0]`은 `arr`의 첫 번째 행을 가리키고, `p[1]`은 두 번째 행을 가리킵니다.  `*(p[0] + 1)`은 `arr[0][1]` 즉, 2를 의미하고, `*(p[1] + 2)`는 `arr[1][2]` 즉, 6을 의미합니다. 따라서 `*(*(p[0] + 1) + *(*(p[1] + 2)))`는 2 + 6 = 8이 됩니다.  다음으로 `*(*(p + 1) + 0)`은 `arr[1][0]` 즉, 4를 의미하고, `*(*(p + 1) + 1)`은 `arr[1][1]` 즉, 5를 의미합니다. 따라서 `*(*(p + 1) + 0) + *(*(p + 1) + 1)`은 4 + 5 = 9가 됩니다.  결과적으로 프로그램은 ""8, 9""를 출력합니다.  포인터 연산의 이해가 중요하며, 배열의 메모리상의 연속적인 저장 방식을 고려하여 포인터 연산 결과를 예측해야 합니다.",42,111
663,7,63,OSI 7계층 중 데이터링크 계층에 해당되는 프로토콜이 아닌 것은?,,HTTP,HDLC,PPP,LLC,1,"이 문제는 OSI 7계층 모델 중 데이터링크 계층에서 사용되는 프로토콜을 묻고 있습니다. OSI 7계층은 네트워크 통신을 7개의 계층으로 나누어 각 계층이 특정 기능을 담당하도록 설계된 모델입니다.  데이터링크 계층은 물리적으로 연결된 장비들 사이에서 데이터를 신뢰성 있게 전송하는 역할을 합니다.  HDLC, PPP, LLC는 모두 데이터링크 계층에서 동작하는 프로토콜입니다. HDLC(High-Level Data Link Control)는 비동기식 및 동기식 통신 모두를 지원하는 표준 데이터링크 계층 프로토콜이고, PPP(Point-to-Point Protocol)는 두 지점 간의 직접 연결을 위한 프로토콜이며, LLC(Logical Link Control)는 데이터링크 계층의 하위 계층으로 MAC 주소를 사용하여 데이터를 전송하는 역할을 합니다. 반면 HTTP(Hypertext Transfer Protocol)는 애플리케이션 계층 프로토콜로 웹 브라우저와 웹 서버 간의 통신에 사용되며, 데이터링크 계층과는 관련이 없습니다. 따라서 데이터링크 계층에 해당되지 않는 프로토콜은 HTTP입니다.",62,145
664,7,64,"C언어에서 두 개의 논리 값 중 하나라도 참이면 1을, 모두 거짓이면 0을 반환하는 연산자는?",,||,&&,**,!=,1,"C언어에서 논리 연산자는 참(true)과 거짓(false) 값을 다루는 연산자입니다.  || 연산자는 논리합(OR) 연산자로, 두 개의 논리 값 중 하나라도 참이면 전체 결과는 참(1)이 됩니다.  모두 거짓일 경우에만 거짓(0)이 됩니다.  예를 들어,  (true || false)는 true(1)이고, (false || false)는 false(0)입니다.  반면 && 연산자는 논리곱(AND) 연산자로, 두 값 모두 참일 때만 참(1)을 반환하고, 하나라도 거짓이면 거짓(0)을 반환합니다.  != 연산자는 같지 않다는 의미의 비교 연산자이며, ** 연산자는 C언어에서 사용되지 않는 연산자입니다. 따라서 두 개의 논리 값 중 하나라도 참이면 1을, 모두 거짓이면 0을 반환하는 연산자는 || 입니다.",73,141
665,7,65,IPv6에 대한 특성으로 틀린 것은?,,표시방법은 8비트씩 4부분의 10진수로 표시한다.,2128개의 주소를 표현할 수 있다.,"등급별, 서비스별로 패킷을 구분할 수 있어 품질보장이 용이하다.",확장기능을 통해 보안기능을 제공한다.,1,"IPv6 주소는 128비트(16바이트)로 구성되어 있으며, 16진수로 표기할 때 콜론(:)으로 구분된 8개의 16진수 블록으로 표현됩니다.  각 16진수 블록은 16비트(2바이트)를 나타내므로, 8비트씩 4부분으로 나누어 10진수로 표시한다는 1번 설명은 잘못되었습니다.  2번은 IPv6이 2<sup>128</sup>개의 주소를 지원한다는 사실을 정확히 나타내고 있으며, 3번은 IPv6의 QoS(Quality of Service) 기능을, 4번은 IPv6의 확장 헤더를 통해 다양한 보안 기능을 제공할 수 있다는 점을 각각 올바르게 설명하고 있습니다. 따라서 틀린 것은 1번입니다.",69,145
666,7,66,JAVA의 예외(exception)와 관련한 설명으로 틀린 것은?,,문법 오류로 인해 발생한 것,오동작이나 결과에 악영향을 미칠 수 있는 실행 시간 동안에 발생한 오류,배열의 인덱스가 그 범위를 넘어서는 경우 발생하는 오류,존재하지 않는 파일을 읽으려고 하는 경우에 발생하는 오류,1,"JAVA에서 예외(exception)란 프로그램 실행 중 발생하는 오류를 말합니다.  문법 오류는 프로그램을 컴파일하는 단계에서 발생하는 것이지, 실행 중 발생하는 오류가 아니므로 1번이 틀린 설명입니다.  2, 3, 4번은 모두 실행 중 발생할 수 있는 예외의 예시입니다.  2번은 일반적인 오류, 3번은 배열 범위를 벗어나는 오류(ArrayIndexOutOfBoundsException), 4번은 파일을 찾을 수 없는 오류(FileNotFoundException)를 나타냅니다.  따라서 JAVA 예외는 실행시간에 발생하는 오류이며, 프로그램의 정상적인 동작을 방해할 수 있는 다양한 상황에서 발생합니다.  문법 오류는 컴파일 단계에서 잡히는 것이므로 예외(exception)와는 구분됩니다.",55,143
667,7,67,TCP/IP 계층 구조에서 IP의 동작 과정에서의 전송 오류가 발생하는 경우에 대비해 오류 정보를 전송하는 목적으로 사용하는 프로토콜은?,,ECP(Error Checking Protocol),ARP(Address Resolution Protocol),ICMP(Internet Control Message Protocol),PPP(Point-to-Point Protocol),3,"TCP/IP 계층 구조에서 IP는 데이터를 목적지까지 전달하는 역할을 합니다.  하지만 네트워크 환경은 예측 불가능한 요소들이 많아 데이터 전송 중 오류가 발생할 수 있습니다.  이때, 오류 발생 정보를 보내는 역할을 하는 프로토콜이 바로 ICMP(Internet Control Message Protocol)입니다.  ICMP는 IP 패킷 전송 과정에서 발생하는 다양한 오류(예: 목적지에 도달할 수 없음, 패킷 손실 등)에 대한 정보를 보내주어 오류를 진단하고 해결하는 데 도움을 줍니다.  다른 선택지들은 각각 다른 목적으로 사용되는 프로토콜입니다. ARP는 IP 주소를 MAC 주소로 변환하는 역할을 하고, PPP는 점대점 연결을 위한 프로토콜이며, ECP는 표준 프로토콜이 아닙니다. 따라서 IP의 동작 과정에서 발생하는 전송 오류 정보를 전달하는 목적으로 사용되는 프로토콜은 ICMP가 가장 적합합니다.",42,145
668,7,68,좋은 소프트웨어 설계를 위한 소프트웨어의 모듈간의 결합도(Coupling)와 모듈 내 요소 간 응집도(Cohesion)에 대한 설명으로 옳은 것은?,,응집도는 낮게 결합도는 높게 설계한다.,응집도는 높게 결합도는 낮게 설계한다.,양쪽 모두 낮게 설계한다.,양쪽 모두 높게 설계한다.,2,"좋은 소프트웨어는 마치 잘 만들어진 레고 같습니다.  각각의 레고 블록(모듈)은 특정 기능을 담당하고, 이 블록들이 서로 연결되어(결합도) 전체 작품을 완성합니다.  각 블록 내부의 구성 요소들(응집도)도 잘 정돈되어 있어야 블록이 제 기능을 제대로 수행할 수 있습니다.",71,106
669,7,69,다음과 같은 형태로 임계 구역의 접근을 제어하는 상호배제 기법은?,https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m69.gif,Dekker Algorithm,Lamport Algorithm,Peterson Algorithm,Semaphore,4,"문제에서 제시된 코드 `P(S) : while S <= 0 do skip; S := S - 1;` 와 `V(S) : S := S + 1;` 는 세마포어(Semaphore)의 동작을 나타냅니다.  세마포어는 임계 구역(Critical Section)에 대한 접근을 제어하는데 사용되는 동기화 기법입니다.  `S`는 세마포어 변수이고, `P(S)`는 세마포어 값을 1 감소시키는 연산(wait 또는 down 연산이라고도 함), `V(S)`는 세마포어 값을 1 증가시키는 연산(signal 또는 up 연산이라고도 함)입니다.  `P(S)` 연산에서 `while S <= 0 do skip;` 부분은 세마포어 값이 0보다 작거나 같으면(즉, 임계 구역이 사용 중이면)  프로세스가 대기하도록 합니다.  세마포어 값이 양수가 되면(임계 구역이 사용 가능해지면)  `S := S - 1;` 연산을 통해 세마포어 값을 감소시키고 임계 구역에 진입합니다.  임계 구역을 빠져나온 후에는 `V(S)` 연산을 통해 세마포어 값을 증가시켜 다른 프로세스가 임계 구역에 접근할 수 있도록 합니다.  따라서 문제에서 제시된 코드는 세마포어를 이용한 상호 배제 기법을 설명하고 있습니다. Dekker 알고리즘, Lamport 알고리즘, Peterson 알고리즘은 세마포어를 사용하지 않는 다른 상호 배제 기법들입니다.",47,111
670,7,70,소프트웨어 개발에서 모듈(Module)이 되기 위한 주요 특징에 해당하지 않는 것은?,,다른 것들과 구별될 수 있는 독립적인 기능을 가진 단위(Unit)이다.,독립적인 컴파일이 가능하다.,유일한 이름을 가져야 한다.,다른 모듈에서의 접근이 불가능해야 한다.,4,"소프트웨어 개발에서 모듈은 독립적으로 개발하고 관리할 수 있는 코드의 단위입니다.  마치 레고 블록처럼, 각각의 모듈은 특정 기능을 수행하며 다른 모듈과 결합하여 큰 시스템을 만듭니다.  문제에서 1번은 모듈이 독립적인 기능을 가져야 함을, 2번은 독립적인 컴파일을 통해 개발 효율성을 높일 수 있음을, 3번은 모듈을 구분하기 위한 고유한 이름이 필요함을 나타냅니다.  하지만 4번은 잘못되었습니다.  모듈은 다른 모듈과 상호작용하고 데이터를 주고받기 위해 접근 가능해야 합니다.  만약 다른 모듈에서 접근이 불가능하다면, 모듈 간의 협력이 불가능해지고 시스템 전체 기능 구현에 어려움이 생깁니다.  따라서 모듈은 독립적이지만, 완전히 고립되어서는 안 됩니다.  다른 모듈과의 적절한 상호작용을 통해 시스템의 목표를 달성해야 합니다.",73,106
671,7,71,"빈 기억공간의 크기가 20KB, 16KB, 8KB, 40KB 일 때 기억장치 배치 전략으로 “Best Fit""을 사용하여 17KB의 프로그램을 적재할 경우 내부단편화의 크기는 얼마인가?",,3KB,23KB,64KB,67KB,1,"Best Fit 기억장치 배치 전략은 빈 기억공간 중에서 요청한 크기와 가장 가까운(가장 잘 맞는) 크기의 공간에 프로그램을 적재하는 방법입니다.  문제에서 17KB의 프로그램을 적재해야 하고, 빈 기억공간의 크기가 20KB, 16KB, 8KB, 40KB로 주어졌습니다. Best Fit 전략에 따라 가장 적합한 공간은 20KB입니다. 20KB 공간에 17KB 프로그램을 적재하면 남는 공간은 20KB - 17KB = 3KB가 됩니다. 이 남는 3KB 공간이 내부 단편화입니다. 내부 단편화란 할당된 기억공간 내에서 사용되지 않는 공간을 의미합니다. 따라서 17KB 프로그램 적재 후 발생하는 내부 단편화의 크기는 3KB입니다.",73,111
672,7,72,"다음 C언어프로그램이 실행되었을 때, 실행 결과는?",https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m72.gif,i = 0,i = 1,i = 3,i = 4,4,"이 C언어 프로그램은 `while(1)` 루프를 사용하여 무한 루프를 만듭니다.  루프 안에서는 `i`의 값이 4가 될 때까지 `i`를 1씩 증가시키고, `i`가 4가 되면 `break`문을 통해 루프를 빠져나옵니다. 따라서 루프가 종료될 때 `i`의 값은 4가 됩니다.  `printf` 함수는 `i`의 값(4)을 출력합니다.  결론적으로 프로그램의 실행 결과는 ""i = 4"" 입니다.  `i`는 0에서 시작하여 1씩 증가하며, `i`가 4가 되는 순간 `break`문에 의해 `while`문을 벗어나기 때문에 `i`의 최종 값은 4가 되는 것입니다.",68,141
673,7,73,"다음 JAVA 프로그램이 실행되었을 때, 실행 결과는?",https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m73.gif,BCDABCA,BCDABCC,CDDACCC,CDDACCA,2,"문제에서 제시된 JAVA 프로그램의 실행 결과를 예측하는 문제입니다.  프로그램 코드는 제시되지 않았지만,  정답이 2번 'BCDABCC' 라는 것을 알고 있습니다. 이는 프로그램 내부적으로 문자열 ""BCDABC"" 가 어떤 처리 과정을 거쳐 ""BCDABCC"" 로 변환되었음을 의미합니다.  추가적인 정보가 없어 정확한 코드를 알 수는 없지만,  가장 가능성 높은 시나리오는 다음과 같습니다.  프로그램이 ""BCDABC"" 라는 문자열을 처리하는 과정에서 마지막 문자 'C'를 한 번 더 추가하는 연산을 수행했을 것입니다.  예를 들어, 반복문을 사용하여 문자열을 처리하고, 마지막에 'C'를 추가하는 코드가 있었을 가능성이 높습니다.  문제의 핵심은 JAVA의 문자열 처리 방식과 반복문, 조건문 등의 제어문을 이해하는 데 있습니다.  비전공자라도 문자열 처리에 대한 기본적인 이해만 있다면 정답을 유추할 수 있습니다.  정답이 2번이라는 정보를 바탕으로,  문자열 ""BCDABC""에 'C'가 추가되는 과정을 생각해보면 쉽게 이해할 수 있습니다.",54,142
674,7,74,개발 환경 구성을 위한 빌드(Build) 도구에 해당하지 않는 것은?,,Ant,Kerberos,Maven,Gradle,2,"이 문제는 개발 환경을 구축하고 소프트웨어를 빌드하는 데 사용되는 도구들을 묻고 있습니다.  Ant, Maven, Gradle은 모두 자바 기반의 빌드 자동화 도구로, 프로젝트의 소스 코드를 컴파일하고, 테스트하고, 패키징하는 등의 작업을 자동화하여 개발 과정을 효율적으로 관리하는 데 사용됩니다.  반면 Kerberos는 네트워크 보안 프로토콜로, 사용자 인증과 권한 부여를 위한 기술입니다.  따라서 개발 환경 구성을 위한 빌드 도구와는 관련이 없습니다.  빌드 도구는 소프트웨어 개발 과정에서 코드를 컴파일하고 실행 파일을 만드는 데 사용되는 반면, Kerberos는 시스템의 보안을 담당하는 별개의 영역입니다.",63,118
675,7,75,"3개의 페이지 프레임을 갖는 시스템에서 페이지 참조 순서가 1, 2, 1, 0, 4, 1, 3 일 경우 FIFO 알고리즘에 의한 페이지 교체의 경우 프레임의 최종 상태는?",,"1, 2, 0","2, 4, 3","1, 4, 2","4, 1, 3",4,"이 문제는 페이지 교체 알고리즘 중 FIFO(First-In, First-Out) 알고리즘을 이해하고 있는지 묻는 문제입니다. FIFO 알고리즘은 가장 먼저 들어온 페이지를 가장 먼저 교체하는 방식입니다.  3개의 페이지 프레임이 있고, 페이지 참조 순서가 1, 2, 1, 0, 4, 1, 3이라고 할 때, 각 페이지 참조 시 프레임의 상태 변화를 살펴보겠습니다.",66,144
676,7,76,"다음 C언어 프로그램이 실행되었을 때, 실행 결과는?",https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m76.gif,E,V,R,O,3,"이 C언어 프로그램은 문자열을 조작하는 과정을 보여줍니다.  먼저 `str1`에는 ""KOREA"", `str2`에는 ""LOVE""가 저장됩니다.  `p1`과 `p2`는 각각 `str1`과 `str2`를 가리키는 포인터 변수입니다.  `str1[1] = p2[2];`는 `str1`의 두 번째 문자('O')를 `str2`의 세 번째 문자('V')로 바꿉니다.  `str2[3] = p1[4];`는 `str2`의 네 번째 문자('E')를 `str1`의 다섯 번째 문자('A')로 바꿉니다.  `strcat(str1, str2);`는 `str2`를 `str1`에 이어 붙입니다. 따라서 `str1`은 ""KOVRA LOVEA""가 됩니다. 마지막으로 `printf(""%c"", *(p1+2));`는 `str1`의 세 번째 문자를 출력하는데, 이는 'R'입니다.  따라서 정답은 3번 'R'입니다.",47,141
677,7,77,"다음 Python 프로그램이 실행되었을 때, 실행 결과는?",https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m77.gif,https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m77b1.gif,https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m77b2.gif,https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m77b3.gif,https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m77b4.gif,1,"이 Python 프로그램은 리스트와 딕셔너리라는 두 가지 자료구조를 사용합니다.  `list_data`는 문자열 'a', 'b', 'c'를 원소로 가지는 리스트이고, `dict_data`는 키가 문자열이고 값이 숫자인 딕셔너리입니다.  `print(list_data[0])`는 리스트 `list_data`의 첫 번째 원소(인덱스 0)를 출력하는 명령어이며,  `print(dict_data['a'])`는 딕셔너리 `dict_data`에서 키 'a'에 해당하는 값을 출력하는 명령어입니다. 따라서 프로그램 실행 결과는 리스트의 첫 번째 원소인 'a'와 딕셔너리에서 키 'a'에 해당하는 값 90이 순서대로 출력됩니다.  변수 a에 100이라는 값이 할당되어 있지만, 프로그램에서는 이 변수를 사용하지 않으므로 결과에 영향을 미치지 않습니다.",74,111
678,7,78,"C언어에서 정수 변수 a, b에 각각 1, 2가 저장되어 있을 때 다음 식의 연산 결과로 옳은 것은?",https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m78.gif,0,1,3,5,2,"문제에서 주어진 식 `a < b + 2 && a << 1 <= b` 를 차례대로 풀어보겠습니다.  `a`는 1이고, `b`는 2입니다.",53,141
679,7,79,"다음 Python 프로그램이 실행되었을 때, 실행 결과는?",https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m79.gif,https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m79b1.gif,https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m79b2.gif,https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m79b3.gif,https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m79b4.gif,2,"이 Python 코드는 리스트 `a`에 저장된 문자열들을 순차적으로 출력하는 간단한 반복문 예제입니다.  `for i in a:` 문은 리스트 `a`의 각 요소를 `i` 변수에 할당하며, `print(i)` 문은 `i` 변수에 저장된 문자열을 화면에 출력합니다. 따라서 리스트 `a`에 ""대"", ""한"", ""민"", ""국"" 이라는 문자열이 순서대로 저장되어 있으므로, 실행 결과는 각 문자열이 한 줄씩 출력되는 것입니다.  즉, ""대"", ""한"", ""민"", ""국"" 이 각각 한 줄씩 출력됩니다.  문제에서 제시된 이미지 정보가 없어도 코드 자체만으로 실행 결과를 예측할 수 있습니다.",62,141
680,7,80,UNIX 시스템의 쉘(shell)의 주요 기능에 대한 설명이 아닌 것은?,,사용자 명령을 해석하고 커널로 전달하는 기능을 제공한다.,반복적인 명령 프로그램을 만드는 프로그래밍 기능을 제공한다.,쉘 프로그램 실행을 위해 프로세스와 메모리를 관리한다.,초기화 파일을 이용해 사용자 환경을 설정하는 기능을 제공한다.,3,"이 문제는 UNIX 시스템의 쉘(shell)이 어떤 기능을 하는지 묻고 있습니다.  쉘은 사용자가 명령어를 입력하면 그 명령어를 해석하여 운영체제의 커널(kernel)에 전달하는 역할을 합니다.  1번은 이러한 쉘의 기본적인 기능을 정확하게 설명하고 있습니다. 2번은 쉘이 반복적인 작업을 자동화하기 위해 스크립트(shell script)를 작성할 수 있도록 프로그래밍 기능을 제공한다는 점을 보여줍니다. 4번은 쉘이 사용자 환경 설정 파일(예: .bashrc, .profile)을 통해 사용자의 환경(예: 경로 설정, 별칭 설정 등)을 맞춤화할 수 있도록 지원한다는 것을 나타냅니다. 하지만 3번은 쉘의 기능이 아닙니다. 프로세스와 메모리 관리는 운영체제 커널의 역할이며, 쉘은 커널에 명령을 전달하는 중개자 역할만 수행합니다.  쉘은 프로세스와 메모리를 직접 관리하지 않습니다. 따라서 3번이 정답입니다.",42,144
681,7,81,소프트웨어 생명주기 모델 중 나선형 모델(Spiral Model)과 관련한 설명으로 틀린 것은??,,소프트웨어 개발 프로세스를 위험 관리(Risk Management) 측면에서 본 모델이다.,위험 분석(Risk Analysis)은 반복적인 개발 진행 후 주기의 마지막 단계에서 최종적으로 한 번 수행해야 한다.,시스템을 여러 부분으로 나누어 여러 번의 개발 주기를 거치면서 시스템이 완성된다.,요구사항이나 아키텍처를 이해하기 어렵다거나 중심이 되는 기술에 문제가 있는 경우 적합한 모델이다.,2,"나선형 모델은 소프트웨어 개발 과정을 여러 단계로 나누어 반복적으로 개발하는 모델입니다. 각 단계마다 위험 분석을 수행하고, 그 결과에 따라 다음 단계를 진행합니다.  문제의 2번 선택지는 ""위험 분석(Risk Analysis)은 반복적인 개발 진행 후 주기의 마지막 단계에서 최종적으로 한 번 수행해야 한다""라고 되어 있는데, 이는 나선형 모델의 특징과 맞지 않습니다. 나선형 모델에서는 각 반복 주기마다 위험 분석을 수행하여 위험을 조기에 발견하고 대응해야 합니다.  따라서 위험 분석은 주기의 마지막 단계에서만 한 번 수행하는 것이 아니라, 각 주기마다 반복적으로 수행되어야 합니다.  나머지 선택지들은 나선형 모델의 특징을 잘 나타내고 있습니다. 1번은 위험 관리를 중시하는 점, 3번은 반복적인 개발 주기를 통해 시스템을 완성하는 점, 4번은 불확실성이 높은 프로젝트에 적합한 점을 보여줍니다.",68,147
682,7,82,정보시스템과 관련한 다음 설명에 해당하는 것은?,https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m82.gif,고가용성 솔루션(HACMP),점대점 연결 방식(Point-to-Point Mode),스턱스넷(Stuxnet),루팅(Rooting),1,"문제에서 설명하는 시스템은 여러 대의 서버가 공유 디스크를 통해 연결되어 하나의 시스템처럼 동작하는 구조입니다.  이를 통해 하나의 서버에 장애가 발생하더라도 다른 서버가 업무를 이어받아 서비스 중단 없이 계속 운영될 수 있도록 합니다.  기업의 중요한 업무 시스템의 안정성을 확보하는 데 사용되며,  특히 두 대의 서버를 연결하여 각각 업무를 처리하는 방식이 흔히 사용됩니다. 이러한 특징들은 고가용성 솔루션(High Availability Cluster Multi-Processing, HACMP)의 핵심적인 기능과 정확히 일치합니다.  HACMP는 서버 장애 발생 시 자동으로 다른 서버로 업무를 전환하여 시스템의 가동 시간을 극대화하는 기술입니다.  반면, 점대점 연결 방식은 두 시스템 간의 직접적인 연결을 의미하며, 스턱스넷은 악성 코드, 루팅은 시스템 권한을 획득하는 행위를 의미하므로 문제의 설명과는 관련이 없습니다. 따라서 정답은 1번 고가용성 솔루션(HACMP)입니다.",47,151
683,7,83,"위조된 매체 접근 제어(MAC) 주소를 지속적으로 네트워크로 흘려보내, 스위치 MAC 주소 테이블의 저장 기능을 혼란시켜 더미 허브(Dummy Hub)처럼 작동하게 하는 공격은?",,Parsing,LAN Tapping,Switch Jamming,FTP Flooding,3,"스위치는 네트워크 상의 각 장비의 MAC 주소를 기억하여 효율적으로 데이터를 전달합니다.  MAC 주소는 네트워크 장비의 고유한 주소인데, 이 공격은 위조된 MAC 주소를 끊임없이 스위치에 보내 스위치의 MAC 주소 테이블을 잘못된 정보로 가득 채웁니다.  결과적으로 스위치는 어떤 장비에 데이터를 보내야 할지 제대로 판단하지 못하고 모든 포트로 데이터를 무작위로 브로드캐스팅하게 됩니다. 이는 허브와 같이 모든 장비에게 데이터를 전송하는 방식과 같아지므로 네트워크 성능이 심각하게 저하되고, 보안에도 취약해집니다.  마치 스위치가 허브처럼 동작하는 것처럼 보이기 때문에 ""더미 허브(Dummy Hub)""처럼 작동한다고 표현하는 것입니다.  Switch Jamming은 이러한 스위치의 MAC 주소 테이블을 혼란시키는 공격을 정확하게 설명하는 용어입니다.",54,155
684,7,84,다음 내용이 설명하는 스토리지 시스템은?,https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m84.gif,DAS,NAS,BSA,NFC,1,"문제에서 설명하는 스토리지 시스템은 직접 연결 스토리지(Direct Attached Storage, DAS)입니다.  DAS는 하드디스크와 같은 저장 장치를 호스트 컴퓨터(서버)에 직접 연결하는 방식으로, 저장 장치와 호스트 기기 사이에 네트워크 장비(스위치, 라우터 등)가 개입하지 않습니다.  쉽게 말해, 컴퓨터 본체에 직접 하드디스크를 연결하는 것과 같은 방식입니다.  NAS(Network Attached Storage)는 네트워크를 통해 여러 대의 컴퓨터에서 공유하여 사용하는 저장 장치이고, SAN(Storage Area Network)은 전용 네트워크를 통해 저장 장치를 연결하는 방식입니다.  NFC(Near Field Communication)는 근거리 무선 통신 기술이므로 저장 장치 시스템과는 관련이 없습니다. 따라서 문제의 설명에 가장 적합한 답은 DAS입니다.",63,151
685,7,85,취약점 관리를 위해 일반적으로 수행하는 작업이 아닌 것은?,,무결성 검사,응용 프로그램의 보안 설정 및 패치(Patch) 적용,중단 프로세스 및 닫힌 포트 위주로 확인,불필요한 서비스 및 악성 프로그램의 확인과 제거,3,"취약점 관리란 시스템의 보안을 위협하는 취약점을 찾아내고 해결하는 과정입니다.  1번의 무결성 검사는 시스템의 데이터가 변경되지 않았는지 확인하는 작업이고, 2번의 응용 프로그램의 보안 설정 및 패치 적용은 소프트웨어의 취약점을 메우는 작업이며, 4번의 불필요한 서비스 및 악성 프로그램의 확인과 제거는 시스템에 불필요하거나 악의적인 요소를 제거하는 작업입니다. 이 모든 작업은 시스템의 보안을 강화하기 위한 일반적인 취약점 관리 작업입니다.  반면 3번의 중단 프로세스 및 닫힌 포트 위주로 확인은  취약점을 찾는 데 초점을 맞추기보다는 시스템의 작동 상태를 확인하는 데 초점을 맞춘 작업입니다.  닫힌 포트는 외부 접근이 차단되어 있으므로,  취약점이 존재하더라도 외부 공격에 직접 노출될 가능성이 낮습니다. 따라서 중단된 프로세스와 닫힌 포트만 확인하는 것은  취약점 관리의 전반적인 측면을 고려하지 않은 불완전한 접근 방식입니다.  취약점 관리는  활성화된 서비스, 열려있는 포트, 실행중인 프로세스 등 시스템의 모든 측면을 포괄적으로 검토해야 효과적입니다.",74,156
686,7,86,소프트웨어 생명주기 모델 중 V 모델과 관련한 설명으로 틀린 것은?,,요구 분석 및 설계단계를 거치지 않으며 항상 통합 테스트를 중심으로 V 형태를 이룬다.,Perry에 의해 제안되었으며 세부적인 테스트 과정으로 구성되어 신뢰도 높은 시스템을 개발하는데 효과적이다.,개발 작업과 검증 작업 사이의 관계를 명확히 들어내 놓은 폭포수 모델의 변형이라고 볼 수 있다.,폭포수 모델이 산출물 중심이라면 V 모델은 작업과 결과의 검증에 초점을 둔다.,1,"V 모델은 소프트웨어 개발 단계와 테스트 단계를 V자 형태로 연결하여 각 개발 단계에 해당하는 테스트 단계를 명확하게 매칭시킨 모델입니다.  1번 보기는 ""요구 분석 및 설계 단계를 거치지 않는다""라고 했는데, 이는 잘못된 설명입니다. V 모델은 요구 분석과 설계 단계를 거치고, 각 단계에 대응하는 테스트 단계(단위 테스트, 통합 테스트, 시스템 테스트 등)를 수행합니다.  V 모델은 통합 테스트를 중심으로 한다는 것도 사실과 다릅니다. 통합 테스트는 V 모델에서 중요한 부분이지만, 다른 테스트 단계들도 모두 중요하게 수행됩니다.  따라서 1번 보기는 V 모델의 특징을 잘못 이해한 설명입니다.  2번, 3번, 4번 보기는 V 모델의 특징을 잘 설명하고 있습니다. 2번은 V 모델의 제안자와 효과적인 측면을, 3번은 폭포수 모델과의 관계를, 4번은 V 모델의 초점을 정확하게 설명하고 있습니다.",54,147
687,7,87,블루투스(Bluetooth) 공격과 해당 공격에 대한 설명이 올바르게 연결된 것은?,,블루버그(BlueBug) - 블루투스의 취약점을 활용하여 장비의 파일에 접근하는 공격으로 OPP를 사용하여 정보를 열람,블루스나프(BlueSnarf) - 블루투스를 이용해 스팸처럼 명함을 익명으로 퍼뜨리는 것,블루프린팅(BluePrinting) - 블루투스 공격 장치의 검색 활동을 의미,블루재킹(BlueJacking) - 블루투스 장비사이의 취약한 연결 관리를 악용한 공격,3,"문제에서 제시된 블루투스 공격 유형들을 살펴보면, 각 용어의 의미와 공격 방식이 서로 혼동될 수 있습니다.  블루버그는 블루투스의 취약점을 이용해 파일 접근을 시도하는 공격이고, 블루스나프는 무단으로 블루투스 기기를 페어링하여 정보를 빼내는 공격입니다. 블루프린팅은 블루투스 기기 검색 활동을 의미하며, 블루재킹은 블루투스 기기의 연결을 악용하여 무단으로 메시지를 전송하는 공격입니다. 따라서, 블루투스 공격 장치의 검색 활동을 의미하는 것은 블루프린팅(BluePrinting)이 정답입니다.  다른 선택지는 블루투스 공격의 종류를 설명하고 있지만, 문제에서 묻고 있는 것은 '검색 활동'이라는 점을 명확히 구분해야 합니다. 정보처리기사 시험에서는 용어의 정확한 의미를 이해하는 것이 중요합니다.",44,155
688,7,88,DoS(Denial of Service) 공격과 관련한 내용으로 틀린 것은?,,Ping of Death 공격은 정상 크기보다 큰 ICMP 패킷을 작은 조각(Fragment)으로 쪼개어 공격 대상이 조각화 된 패킷을 처리하게 만드는 공격 방법이다.,Smurf 공격은 멀티캐스트(Multicast)를 활용하여 공격 대상이 네트워크의 임의의 시스템에 패킷을 보내게 만드는 공격이다.,SYN Flooding은 존재하지 않는 클라이언트가 서버별로 한정된 접속 가능 공간에 접속한 것처럼 속여 다른 사용자가 서비스를 이용하지 못하게 하는 것이다.,Land 공격은 패킷 전송 시 출발지 IP주소와 목적지 IP주소 값을 똑같이 만들어서 공격 대상에게 보내는 공격 방법이다.,2,"문제에서 제시된 네 가지 DoS(Denial of Service, 서비스 거부 공격) 유형에 대한 설명 중 틀린 것을 찾는 문제입니다.  각 공격 방식을 살펴보면 다음과 같습니다.",38,155
689,7,89,다음 설명에 해당하는 시스템은?,https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m89.gif,Apache,Hadoop,Honeypot,MapReduce,3,"Honeypot은 침입자를 유인하기 위해 의도적으로 설치된 시스템입니다. 마치 미끼와 같은 역할을 하죠.  실제 시스템처럼 보이지만, 실제로는 중요한 데이터나 기능이 없거나, 가짜 데이터만 가지고 있습니다.  침입자가 Honeypot에 접근하여 공격을 시도하면, 그 행위를 모두 감시하고 기록하여 침입자의 공격 기법을 분석하고 추적하는 데 사용됩니다.  쉽게 공격받을 수 있도록 취약하게 보이도록 설계되어 침입자를 유인하는 것이 핵심입니다.  문제에서 언급된 David Clock은 Honeypot 개념을 처음 제안한 사람으로 알려져 있습니다.  따라서 문제의 설명에 가장 잘 맞는 시스템은 Honeypot입니다. Apache, Hadoop, MapReduce는 모두 Honeypot과는 다른 목적으로 사용되는 시스템입니다. Apache는 웹 서버, Hadoop은 분산 처리 프레임워크, MapReduce는 Hadoop에서 사용되는 분산 처리 모델입니다.",64,156
690,7,90,다음이 설명하는 IT 기술은?,https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m90.gif,StackGuard,Docker,Cipher Container,Scytale,2,"문제에서 설명하는 IT 기술은 Docker입니다. Docker는 응용 프로그램을 작은 독립적인 단위인 컨테이너로 패키징하여 배포하는 오픈소스 플랫폼입니다.  마치 배송용 컨테이너처럼, 응용 프로그램과 그 실행에 필요한 모든 것을 하나의 컨테이너에 담아서 운영체제나 하드웨어 환경에 상관없이 어디서든 동일하게 실행할 수 있도록 해줍니다.  이를 통해 개발, 테스트, 배포 과정을 자동화하고 효율적으로 관리할 수 있습니다.  쉽게 말해, 프로그램을 깔끔하게 포장해서 어디든 옮겨서 실행할 수 있게 해주는 기술이라고 생각하면 됩니다.  다른 선택지들은 보안 관련 기술이나 암호화 기술 등 Docker와는 관련이 없는 기술들입니다.",53,116
691,7,91,간트 차트(Gantt Chart)에 대한 설명으로 틀린 것은?,,프로젝트를 이루는 소작업 별로 언제 시작되고 언제 끝나야 하는지를 한 눈에 볼 수 있도록 도와준다.,자원 배치 계획에 유용하게 사용된다.,CPM 네트워크로부터 만드는 것이 가능하다.,수평 막대의 길이는 각 작업(Task)에 필요한 인원수를 나타낸다.,4,"간트 차트는 프로젝트의 일정을 시각적으로 표현하는 도구입니다.  각 작업(Task)을 수평 막대로 나타내고, 막대의 시작과 끝 지점으로 작업의 시작일과 종료일을 표시합니다.  따라서 1번과 3번 설명은 간트 차트의 특징을 잘 나타내고 있습니다.  2번의 경우, 간트 차트는 작업의 시작과 종료 시점뿐 아니라, 작업에 필요한 자원(인력, 장비 등)을 고려하여 자원 배치 계획을 세우는 데에도 유용하게 활용될 수 있습니다. 하지만 4번은 잘못된 설명입니다. 간트 차트에서 수평 막대의 길이는 작업(Task)의 *기간*을 나타내는 것이지, 작업에 필요한 인원수를 나타내는 것이 아닙니다. 인원수는 별도로 표시하거나, 다른 차트와 함께 사용하여 관리해야 합니다.  즉, 막대의 길이는 작업 소요 시간을 나타내는 것이지 인원수를 나타내는 것이 아니라는 점을 기억해야 합니다.",64,147
692,7,92,Python 기반의 웹 크롤링(Web Crawling) 프레임워크로 옳은 것은?,,Li-fi,Scrapy,CrawlCat,SBAS,2,"이 문제는 Python 기반의 웹 크롤링 프레임워크를 묻고 있습니다. 웹 크롤링이란 웹사이트에서 데이터를 자동으로 수집하는 기술입니다.  Scrapy는 Python으로 작성된 강력하고 유연한 웹 크롤링 프레임워크로,  웹 페이지를 효율적으로 파싱하고 데이터를 추출하는 데 필요한 다양한 기능을 제공합니다.  반면 Li-fi는 무선 통신 기술, CrawlCat과 SBAS는 웹 크롤링과 관련이 없는 용어입니다. 따라서 정답은 Scrapy(2번)입니다.  정보처리기사 시험에서는  웹 크롤링과 같은  자동화 기술과 관련된 프로그래밍 언어 및 프레임워크에 대한 이해를 묻는 문제가 출제될 수 있습니다.  Python은 웹 크롤링에 많이 사용되는 언어이며, Scrapy는 그 중 대표적인 프레임워크이기 때문에  이 문제가 출제된 것입니다.",47,138
693,7,93,Secure 코딩에서 입력 데이터의 보안 약점과 관련한 설명으로 틀린 것은?,,SQL 삽입 : 사용자의 입력 값 등 외부 입력 값이 SQL 쿼리에 삽입되어 공격,크로스사이트 스크립트 : 검증되지 않은 외부 입력 값에 의해 브라우저에서 악의적인 코드가 실행,운영체제 명령어 삽입 : 운영체제 명령어 파라미터 입력 값이 적절한 사전검증을 거치지 않고 사용되어 공격자가 운영체제 명령어를 조작,자원 삽입 : 사용자가 내부 입력 값을 통해 시스템 내에 사용이 불가능한 자원을 지속적으로 입력함으로써 시스템에 과부하 발생,4,"문제에서 제시된 4가지 항목은 모두 Secure 코딩에서 중요하게 다루는 입력 데이터 관련 보안 약점입니다.  1번 SQL 삽입, 2번 크로스사이트 스크립팅(XSS), 3번 운영체제 명령어 삽입은 모두 악의적인 사용자가 입력 데이터를 조작하여 시스템에 해를 가하는 공격 기법입니다.  하지만 4번 자원 삽입은 다릅니다.  자원 삽입은 사용자가 시스템에 과부하를 일으키는 목적으로 *내부* 입력 값을 통해 자원을 지속적으로 입력하는 것을 의미합니다.  이는 외부 공격자가 시스템에 접근하여 악의적인 코드를 실행하는 것과는 다른 양상입니다.  따라서 외부 입력 값의 검증 부족으로 인한 보안 취약점을 설명하는 다른 세 가지 항목과는 성격이 다르며, 문제에서 묻고자 하는 '입력 데이터의 보안 약점'과는 정확히 일치하지 않습니다.  4번은 시스템 자원 고갈 공격(Denial of Service, DoS)의 한 유형으로 볼 수 있지만,  주로 내부 사용자의 잘못된 행위나 시스템 오류로 인해 발생하는 경우가 많아, 외부 입력 데이터의 보안 약점으로 분류하기에는 적절하지 않습니다.  따라서 4번이 틀린 설명입니다.",43,153
694,7,94,Windows 파일 시스템인 FAT와 비교했을 때의 NTFS의 특징이 아닌 것은?,,보안에 취약,대용량 볼륨에 효율적,자동 압축 및 안정성,저용량 볼륨에서의 속도 저하,1,"NTFS(NT File System)와 FAT(File Allocation Table)는 Windows 운영체제에서 사용되는 파일 시스템입니다.  FAT는 오래된 파일 시스템으로 용량이 작은 저장장치에 적합하며, 구조가 간단하여 속도가 빠르다는 장점이 있습니다. 하지만 보안 기능이 부족하고, 대용량 저장장치에는 효율적이지 않습니다.  반면 NTFS는 FAT보다 훨씬 발전된 파일 시스템으로, 대용량 저장장치를 효율적으로 관리하고, 파일 시스템 자체의 안정성도 높습니다.  또한, 접근 권한 제어 등의 보안 기능도 강화되어 있습니다.  문제에서 제시된 보기 중 '보안에 취약'은 NTFS의 특징이 아니며, 오히려 FAT의 특징입니다. NTFS는 파일의 압축 기능을 제공하지 않으므로 '자동 압축 및 안정성'도 NTFS의 특징이라고 보기 어렵습니다.  저용량 볼륨에서 NTFS의 속도가 느려지는 현상은 발생할 수 있으나,  대용량 볼륨에서의 효율성을 고려하면 상대적인 비교일 뿐,  NTFS의 특징이 아닌 것은 아닙니다. 따라서 정답은 1번 '보안에 취약'입니다.",51,151
695,7,95,DES는 몇 비트의 암호화 알고리즘인가?,,8,24,64,132,3,"DES(Data Encryption Standard)는 데이터를 암호화하는 데 사용되는 대칭키 암호 알고리즘입니다.  대칭키 암호 알고리즘이란 암호화와 복호화에 같은 키를 사용하는 방식입니다. DES는 64비트의 데이터 블록을 입력으로 받아 64비트의 암호화된 데이터 블록을 출력합니다.  문제에서 묻고 있는 것은 DES 알고리즘이 한 번에 처리하는 데이터의 크기, 즉 블록 크기입니다. 따라서 DES는 64비트의 암호화 알고리즘입니다.  다른 보기들은 DES의 블록 크기가 아닌 다른 값들을 나타내고 있습니다.",66,154
696,7,96,리눅스에서 생성된 파일 권한이 644일 경우 umask 값은?,,22,666,777,755,1,"리눅스에서 파일 권한은 소유자, 그룹, 다른 사용자 각각에 대해 읽기(r), 쓰기(w), 실행(x) 권한을 부여하는 방식으로 표현됩니다. 각 권한은 숫자로 표현되는데, 읽기는 4, 쓰기는 2, 실행은 1입니다.  따라서 644는 소유자에게 읽기(4)와 쓰기(2) 권한을, 그룹과 다른 사용자에게는 읽기(4) 권한만 부여하는 것을 의미합니다.  umask는 파일 생성 시 기본적으로 부여되지 않는 권한을 나타내는 값입니다.  umask 값을 022라고 가정하면,  소유자는 777(모든 권한)에서 022를 뺀 755(읽기, 쓰기, 실행)의 권한을 갖게 되고, 그룹과 다른 사용자는 777에서 022를 뺀 755의 권한을 갖게 됩니다. 하지만 문제에서 소유자는 읽기와 쓰기 권한(6)을, 그룹과 다른 사용자는 읽기 권한(4)만 가지므로,  777에서 644를 뺀 값이 umask가 됩니다. 777 - 644 = 022 이므로 umask 값은 022가 됩니다.  즉, umask 022를 설정하면 파일 생성 시 소유자에게는 읽기와 쓰기 권한이, 그룹과 다른 사용자에게는 읽기 권한만 자동으로 부여됩니다.",49,144
697,7,97,다음 내용이 설명하는 로그 파일은?,https://www.cbtbank.kr/images/iz/iz20220305/iz20220305m97.gif,tapping,xtslog,linuxer,wtmp,4,"문제에서 제시된 설명은 리눅스 시스템에서 발생하는 사용자 로그인/로그아웃, 시스템 시작/종료와 같은 중요한 이벤트들을 기록하는 로그 파일의 특징을 나타냅니다.  wtmp 파일은 바로 이러한 시스템 이벤트 로그를 저장하는 리눅스 시스템의 표준 로그 파일 중 하나입니다.  사용자의 로그인/로그아웃 시간, 시스템 시작/종료 시간 등의 정보를 담고 있어 시스템 관리 및 보안 감사에 중요한 역할을 합니다.  따라서 정답은 wtmp가 됩니다.  다른 선택지들은 리눅스 시스템의 로그 파일과는 관련이 없습니다.",41,156
698,7,98,상향식 비용 산정 기법 중 LOC(원시 코드 라인 수) 기법에서 예측치를 구하기 위해 사용하는 항목이 아닌 것은?,,낙관치,기대치,비관치,모형치,4,"상향식 비용 산정 기법 중 LOC(원시 코드 라인 수) 기법은 소프트웨어 개발에 필요한 비용을 예측하는 방법 중 하나입니다.  프로그램의 크기를 원시 코드 라인 수(LOC)로 측정하고,  라인 수에 단위 라인당 비용을 곱하여 총 개발 비용을 추정합니다.  이때, 개발 비용의 불확실성을 고려하여 낙관치(가장 짧은 시간에 개발 완료될 경우), 기대치(평균적인 개발 시간), 비관치(가장 긴 시간이 걸릴 경우)를 사용하여  세 가지 추정치를 산출하고, 이를 바탕으로 개발 비용을 예측합니다.  문제에서 제시된 '모형치'는 LOC 기법에서 직접적으로 사용하는 항목이 아닙니다. 모형치는 다른 비용 산정 기법이나 통계적 모델에서 사용될 수 있지만, LOC 기법 자체에서는 낙관치, 기대치, 비관치 세 가지 추정치를 활용하여 예측치를 도출합니다. 따라서, LOC 기법에서 예측치를 구하기 위해 사용하는 항목이 아닌 것은 '모형치'입니다.",62,147
699,7,99,"OSI 7 Layer 전 계층의 프로토콜과 패킷 내부의 콘텐츠를 파악하여 침입 시도, 해킹 등을 탐지하고 트래픽을 조정하기 위한 패킷 분석 기술은?",,PLCP(Packet Level Control Processor),Traffic Distributor,Packet Tree,DPI(Deep Packet Inspection),4,"이 문제는 네트워크 트래픽을 분석하여 보안 위협을 탐지하는 기술을 묻고 있습니다.  OSI 7계층 각 계층의 프로토콜과 패킷의 내용을 자세히 분석하여 침입 시도나 해킹 등의 악의적인 활동을 감지하고, 필요에 따라 트래픽을 제어하는 기술이 바로 DPI(Deep Packet Inspection)입니다.  PLCP, Traffic Distributor, Packet Tree는 네트워크 관리에 관련된 용어이지만, 패킷의 내용까지 심층적으로 분석하여 보안 위협을 탐지하는 기능은 DPI가 가장 적합합니다. DPI는 패킷 헤더뿐만 아니라 패킷의 내용(페이로드)까지 분석하여, 악성코드, 스팸, 불법적인 활동 등을 식별할 수 있습니다.  예를 들어, 특정 악성코드의 시그니처가 포함된 패킷을 감지하거나, 허용되지 않은 포트를 통한 통신을 차단하는 등의 작업을 수행합니다.  따라서 OSI 7계층 전 계층의 프로토콜과 패킷 내부 콘텐츠를 파악하는 능력이 필요한 문제에서 정답은 DPI입니다.",46,145
700,7,100,소프트웨어 개발 방법론의 테일러링(Tailoring)과 관련한 설명으로 틀린 것은?,,프로젝트 수행 시 예상되는 변화를 배제하고 신속히 진행하여야 한다.,"프로젝트에 최적화된 개발 방법론을 적용하기 위해 절차, 산출물 등을 적절히 변경하는 활동이다.",관리 측면에서의 목적 중 하나는 최단기간에 안정적인 프로젝트 진행을 위한 사전 위험을 식별하고 제거하는 것이다.,기술적 측면에서의 목적 중 하나는 프로젝트에 최적화된 기술 요소를 도입하여 프로젝트 특성에 맞는 최적의 기법과 도구를 사용하는 것이다.,1,"소프트웨어 개발 방법론의 테일러링(Tailoring)은 특정 프로젝트의 상황과 요구사항에 맞춰 표준적인 개발 방법론을 조정하고 최적화하는 과정입니다.  1번 보기는 프로젝트 수행 중 발생할 수 있는 예상치 못한 변화를 무시하고 진행해야 한다고 주장하는데, 이는 테일러링의 개념과 정반대입니다.  테일러링은 오히려 예상되는 변화를 고려하여 유연하게 방법론을 적용하는 것을 목표로 합니다.  2, 3, 4번 보기는 모두 테일러링의 목적 또는 활동을 정확하게 설명하고 있습니다.  2번은 방법론의 절차와 산출물을 변경하는 활동을, 3번은 관리 측면에서의 위험 관리를, 4번은 기술적 측면에서 최적의 기술과 도구 사용을 강조하고 있기 때문입니다. 따라서 1번 보기만이 테일러링에 대한 잘못된 설명입니다.  쉽게 말해, 테일러링은 '옷을 맞춤형으로 제작하는 것'과 같습니다.  기성복(표준 방법론)을 그대로 입는 것이 아니라,  사람(프로젝트)의 체형(요구사항)에 맞게 수정하여 최적의 상태로 만들어 입는 것입니다.  변화를 무시하고 기성복을 강제로 입으려 한다면 불편하고 효율적이지 않겠죠?",55,147
701,8,1,검토회의 전에 요구사항 명세서를 미리 배포하여 사전 검토한 후 짧은 검토 회의를 통해 오류를 조기에 검출하는데 목적을 두는 요구 사항 검토 방법은?,,빌드 검증,동료 검토,워크 스루,개발자 검토,3,"문제에서 설명하는 요구사항 검토 방법은 요구사항 명세서를 미리 참석자들에게 배포하여 사전 검토를 진행하고, 검토 회의에서는 짧은 시간 동안 사전 검토에서 발견되지 않은 오류를 찾는 데 집중하는 방식입니다.  이러한 방식은 검토 회의 시간을 단축하고 효율성을 높이는 데 목적이 있습니다.  워크스루(Walkthrough)는 이러한 방식과 가장 잘 일치합니다. 워크스루는 개발자가 작성한 산출물(이 경우 요구사항 명세서)을 미리 배포하여 참석자들이 검토하고, 회의에서는 검토 결과를 공유하고 오류를 발견하는 과정을 거칩니다.  빌드 검증은 소프트웨어를 빌드한 후 검증하는 단계이고, 동료 검토는 코드를 중심으로 검토하는 방식이며, 개발자 검토는 개발자가 직접 검토하는 방식이므로 문제의 상황과는 맞지 않습니다. 따라서 정답은 워크스루인 3번입니다.",82,102
702,8,2,코드 설계에서 일정한 일련번호를 부여하는 방식의 코드는?,,연상 코드,블록 코드,순차 코드,표의 숫자 코드,3,"코드 설계에서 일정한 일련번호를 부여하는 방식은 순차 코드입니다.  예를 들어, 상품에 1, 2, 3…과 같이 순서대로 번호를 매기는 것이 순차 코드입니다.  연상 코드는 상품의 특징을 코드로 나타내는 방식이고, 블록 코드는 특정 범위를 나타내는 코드이며, 표의 숫자 코드는 표를 이용하여 코드를 부여하는 방식입니다. 문제에서 요구하는 일정한 일련번호를 부여하는 방식과 가장 잘 맞는 것은 순차 코드입니다.  쉽게 생각하면, 줄을 서서 번호표를 받는 것과 같은 원리라고 이해할 수 있습니다.",85,106
703,8,3,객체지향 프로그램에서 데이터를 추상화하는 단위는?,,메소드,클래스,상속성,메시지,2,"객체지향 프로그래밍(OOP)에서 데이터를 추상화하는 가장 기본적인 단위는 클래스입니다.  클래스는 객체의 설계도와 같다고 생각하면 됩니다.  자동차를 예로 들면, 자동차라는 클래스가 있고, 이 클래스는 바퀴, 엔진, 색깔 등 자동차의 속성(데이터)과  달리기, 멈추기 등 자동차가 할 수 있는 행위(메소드)를 정의합니다.  각각의 자동차는 클래스를 바탕으로 만들어진 객체(instance)가 되는 것이죠.  따라서 클래스는 데이터(속성)와 메소드(행위)를 묶어서 추상화하는 단위이며,  메소드는 클래스 내부의 특정 기능을 수행하는 부분일 뿐 데이터 자체를 추상화하는 것은 아닙니다. 상속성은 클래스 간의 관계를 나타내는 개념이고, 메시지는 객체 간의 상호작용 방식을 나타내는 개념이므로 데이터 추상화의 단위는 아닙니다.  결론적으로, 객체지향 프로그램에서 데이터를 추상화하는 단위는 클래스입니다.",83,107
704,8,4,데이터 흐름도(DFD)의 구성요소에 포함되지 않는 것은?,,process,data flow,data store,data dictionary,4,"데이터 흐름도(DFD)는 시스템의 데이터 흐름을 그림으로 표현하는 기법입니다.  주요 구성 요소는 데이터가 처리되는 과정(Process), 데이터가 이동하는 경로(Data Flow), 데이터가 저장되는 장소(Data Store)입니다.  데이터 딕셔너리(Data Dictionary)는 DFD의 구성 요소가 아니며, DFD에 사용되는 데이터 요소들에 대한 상세한 설명(데이터 이름, 데이터 타입, 데이터 길이 등)을 정의하는 별도의 문서입니다.  즉, DFD는 시스템의 데이터 흐름을 시각적으로 보여주는 그림이고, 데이터 딕셔너리는 그 그림에 사용된 데이터에 대한 자세한 설명을 담은 문서라고 생각하면 됩니다.  따라서 DFD의 구성요소에는 데이터 딕셔너리가 포함되지 않습니다.",83,103
705,8,5,소프트웨어 설계시 구축된 플랫폼의 성능특성 분석에 사용되는 측정 항목이 아닌 것은?,,응답시간(Response Time),가용성(Availability),사용률(Utilization),서버 튜닝(Server Tuning),4,"이 문제는 소프트웨어 설계 시 구축된 플랫폼의 성능 특성을 분석하는 데 사용되는 측정 항목을 묻고 있습니다.  응답시간, 가용성, 사용률은 모두 플랫폼의 성능을 평가하는 데 중요한 지표입니다. 응답시간은 사용자 요청에 대한 시스템의 반응 속도를 나타내고, 가용성은 시스템이 얼마나 안정적으로 작동하는지를 나타내며, 사용률은 시스템 자원의 활용도를 나타냅니다. 반면, 서버 튜닝은 시스템 성능을 향상시키기 위한 *활동*이지, 성능을 측정하는 *항목*이 아닙니다. 서버 튜닝은 응답시간, 가용성, 사용률 등을 개선하기 위해 수행하는 작업이므로, 성능 특성을 분석하는 측정 항목이라고 할 수 없습니다. 따라서 정답은 4번, 서버 튜닝입니다.",90,101
706,8,6,UML 확장 모델에서 스테레오 타입 객체를 표현할 때 사용하는 기호로 맞는 것은?,,《 》,(( )),{{ }},[[ ]],1,"UML(Unified Modeling Language)은 소프트웨어 시스템을 시각적으로 모델링하는 표준 언어입니다.  UML에서 확장 모델은 기본 UML 요소를 확장하여 특정 도메인이나 시스템에 맞는 표현을 추가할 수 있도록 합니다.  이때, 스테레오타입은 기존 UML 요소의 의미를 확장하는 데 사용되는데요,  예를 들어 클래스에 특정 역할이나 속성을 부여할 때 사용합니다.  문제에서 묻고 있는 것은 스테레오타입 객체를 표현하는 기호입니다.  UML에서 스테레오타입은 꺾쇠괄호(`《 》`)로 표현합니다.  따라서 정답은 1번 `《 》`입니다.  예를 들어,  `《인터페이스》` 와 같이 사용합니다. 다른 괄호들은 UML에서 다른 용도로 사용되거나 UML 표기법에 포함되지 않습니다.",82,102
707,8,7,GoF(Gang of Four)의 디자인 패턴에서 행위 패턴에 속하는 것은?,,Builder,Visitor,Prototype,Bridge,2,"GoF 디자인 패턴은 객체지향 설계에서 자주 발생하는 문제들을 해결하기 위한 디자인 템플릿입니다.  행위 패턴은 객체나 클래스 사이의 알고리즘이나 책임 분배를 다루는 패턴들을 말합니다.  문제에서 제시된 옵션들을 살펴보면, Visitor 패턴은 객체 구조를 순회하며 각 객체에 대해 특정 작업을 수행하는 행위 패턴입니다.  반면 Builder, Prototype, Bridge 패턴은 각각 생성, 객체 생성, 추상화와 구현을 분리하는 패턴으로, 행위 패턴이 아닌 생성 패턴, 생성 패턴, 구조 패턴에 속합니다. 따라서 Visitor 패턴만이 행위 패턴에 해당합니다.  쉽게 말해, Visitor는 여러 객체에 대해 같은 작업을 반복적으로 수행해야 할 때 효율적으로 코드를 작성할 수 있도록 도와주는 패턴입니다.",65,107
708,8,8,자료 사전에서 자료의 생략을 의미하는 기호는?,,{ },**,=,(　),4,"자료 사전에서 괄호 `(　)`는 자료의 생략을 의미하는 기호입니다.  데이터베이스나 프로그래밍에서 자료를 표현할 때,  모든 내용을 다 적지 않고 일부를 생략해야 할 경우 괄호 안에 생략된 내용이 있음을 표시합니다.  예를 들어,  (생략) 과 같이 사용하여 자료의 일부분이 생략되었음을 나타냅니다. 다른 기호들은 자료의 생략과는 직접적인 관련이 없습니다.  { }는 집합을 나타내고, **는 강조 표시, =는 등호로 사용됩니다. 따라서 자료 생략을 나타내는 기호는 괄호 `(　)`입니다.",79,111
709,8,9,트랜잭션이 올바르게 처리되고 있는지 데이터를 감시하고 제어하는 미들웨어는?,,RPC,ORB,TP monitor,HUB,3,"트랜잭션(Transaction)이란 데이터베이스에서 여러 작업을 하나의 논리적 단위로 묶어서 처리하는 것을 말합니다.  예를 들어, 계좌 이체를 생각해보면, 출금 계좌에서 돈을 빼고, 입금 계좌에 돈을 더하는 두 가지 작업이 하나의 트랜잭션으로 이루어집니다.  이때, 출금은 성공했는데 입금이 실패하는 등의 부분적인 실패가 발생하면 안 되겠죠?  트랜잭션 모니터(TP monitor)는 이러한 트랜잭션이 올바르게 처리되었는지, 즉 데이터의 일관성(Consistency)을 유지하며 완료되었는지 감시하고 제어하는 미들웨어입니다.  만약 문제가 발생하면, 이전 상태로 되돌리는(Rollback) 기능을 제공하여 데이터의 무결성을 보장합니다.  RPC, ORB, HUB는 각각 원격 프로시저 호출, 객체 요청 브로커, 네트워크 연결 장치로 트랜잭션의 성공적인 완료를 보장하는 기능은 제공하지 않습니다. 따라서 트랜잭션의 감시 및 제어라는 문제의 핵심 기능을 수행하는 것은 TP monitor입니다.",83,110
710,8,10,UI 설계 원칙에서 누구나 쉽게 이해하고 사용할 수 있어야 한다는 것은?,,유효성,직관성,무결성,유연성,2,"UI 설계의 핵심 원칙 중 하나는 누구든지 쉽게 이해하고 사용할 수 있도록 만드는 것입니다.  이는 사용자에게 직관적인 경험을 제공하는 것을 의미하며,  복잡한 절차나 어려운 용어 없이도 원하는 작업을 쉽게 수행할 수 있도록 설계해야 함을 나타냅니다.  따라서 정답은 직관성(2번)입니다. 유효성은 시스템이 제대로 작동하는지를, 무결성은 데이터의 정확성과 신뢰성을, 유연성은 시스템의 변화에 대한 적응력을 의미하는데, 문제에서 요구하는 '누구나 쉽게 이해하고 사용할 수 있어야 한다'는 사용자 인터페이스의 직관성과 가장 밀접하게 관련되어 있습니다. 정보처리기사 공식 교재에서는 UI 설계 원칙을 설명하면서 사용자 중심 설계의 중요성을 강조하고 있으며,  직관적인 인터페이스는 사용자 중심 설계의 핵심 요소로 다루고 있을 것입니다.",91,104
711,8,11,XP(eXtreme Programming)의 5가지 가치로 거리가 먼 것은?,,용기,의사소통,정형분석,피드백,3,"XP(eXtreme Programming)는 소프트웨어 개발 방법론 중 하나로,  변화에 빠르게 적응하고 고품질의 소프트웨어를 개발하는 데 중점을 둡니다.  XP의 핵심 가치는  '단순성', '의사소통', '피드백', '용기', '존중' 입니다.  문제에서 제시된 보기 중 '정형분석'은 XP의 가치와 거리가 멉니다. XP는  유연성과 빠른 적응을 강조하는 방법론이기 때문에,  정형적이고 엄격한 분석보다는  실험과 피드백을 통해  점진적으로 개발하는 것을 선호합니다.  정형분석은  요구사항을 미리 철저하게 분석하고 문서화하는  전통적인 접근 방식으로, XP의  민첩하고 반복적인 개발 방식과는 상반됩니다. 따라서 XP의 5가지 가치 중 '정형분석'은  가장 거리가 먼 선택지입니다.",81,102
712,8,12,UML 모델에서 사용하는 Structural Diagram 에 속하지 않은 것은?,,Class Diagram,Object Diagram,Component Diagram,Activity Diagram,4,"UML(Unified Modeling Language)은 소프트웨어 시스템을 시각적으로 표현하는 표준 모델링 언어입니다.  UML 다이어그램은 크게 구조 다이어그램(Structural Diagram)과 행위 다이어그램(Behavioral Diagram)으로 나뉘는데, 구조 다이어그램은 시스템의 정적인 구조를 보여주고, 행위 다이어그램은 시스템의 동적인 행위를 보여줍니다.  문제에서 제시된 Class Diagram, Object Diagram, Component Diagram은 모두 시스템의 구성 요소와 그 관계를 나타내는 정적인 구조를 표현하는 다이어그램이므로 구조 다이어그램에 속합니다. 반면 Activity Diagram은 시스템의 동적인 흐름과 활동을 보여주는 다이어그램으로 행위 다이어그램에 속합니다. 따라서, UML 모델에서 사용하는 Structural Diagram에 속하지 않는 것은 Activity Diagram입니다.  쉽게 말해, Class Diagram, Object Diagram, Component Diagram은 시스템의 '무엇'을 보여주는 그림이고, Activity Diagram은 시스템이 '어떻게' 동작하는지를 보여주는 그림입니다.",76,102
713,8,13,소프트웨어 개발 방법 중 요구사항 분석(requirements annalysis)과 거리가 먼 것은?,,비용과 일정에 대한 제약설정,타당성 조사,요구사항 정의 문서화,설계 명세서 작성,4,"소프트웨어 개발은 크게 요구사항 분석, 설계, 구현, 테스트 단계로 나눌 수 있습니다.  요구사항 분석 단계에서는 사용자의 요구를 파악하고 문서화하는 작업을 합니다.  1번의 비용과 일정 제약 설정은 프로젝트 관리의 일환으로 요구사항 분석에 영향을 미치지만, 분석 자체의 내용은 아닙니다. 2번의 타당성 조사는 프로젝트를 진행하기 전에 필요성과 가능성을 검토하는 단계로, 요구사항 분석의 전 단계입니다. 3번의 요구사항 정의 문서화는 분석 결과를 문서로 정리하는 작업으로 요구사항 분석의 핵심적인 부분입니다.  반면 4번의 설계 명세서 작성은 요구사항 분석이 끝난 후,  실제 시스템을 어떻게 구현할지 구체적으로 기술하는 단계입니다. 따라서 요구사항 분석과는 다른 단계이며,  요구사항 분석의 결과물을 바탕으로 진행됩니다.  문제에서 묻는 것은 요구사항 분석과 거리가 먼 것이므로, 요구사항 분석 이후의 단계인 설계 명세서 작성이 정답입니다.",65,106
714,8,14,럼바우(Rumbaugh)의 객체지향 분석 절차를 가장 바르게 나열한 것은?,,객체 모형→동적 모형→기능 모형,객체 모형→기능 모형→동적 모형,기능 모형→동적 모형→객체 모형,기능 모형→객체 모형→동적 모형,1,"럼바우의 객체지향 분석 절차는 시스템을 객체, 동작, 기능으로 모델링하는 과정을 나타냅니다.  먼저 시스템을 구성하는 객체들을 파악하고 그들의 속성과 관계를 정의하는 **객체 모형**을 만듭니다.  다음으로 객체들 간의 상호작용과 시간에 따른 변화를 나타내는 **동적 모형**을 생성합니다. 마지막으로 시스템의 기능을 정의하는 **기능 모형**을 만듭니다. 따라서 객체의 정의가 먼저 이루어져야 객체 간의 상호작용을 정의할 수 있고, 객체와 동작을 정의한 후에 시스템의 기능을 명확히 할 수 있습니다.  따라서 객체 모형 → 동적 모형 → 기능 모형 순서가 가장 논리적입니다. 다른 순서들은 객체에 대한 정보 없이 동작이나 기능을 정의하려는 시도이므로 비효율적이고 오류가 발생할 가능성이 높습니다.",86,107
715,8,15,공통 모듈에 대한 명세 기법 중 해당 기능에 대해 일관되게 이해하고 한 가지로 해석될 수 있도록 작성하는 원칙은?,,상호작용성,명확성,독립성,내용성,2,"공통 모듈이란 여러 프로그램에서 공통적으로 사용되는 기능을 모아놓은 부분입니다.  이러한 공통 모듈에 대한 명세를 작성할 때,  '명확성' 원칙은 해당 기능에 대한 설명이 모호하지 않고, 모든 개발자가 동일하게 이해하여 하나의 결과물로 해석될 수 있도록 작성해야 함을 의미합니다.  상호작용성, 독립성, 내용성도 중요하지만,  모듈의 기능을 명확하게 정의하는 것이 가장 기본적이고 중요한 원칙입니다.  다른 원칙들이 제대로 작동하기 위한 전제조건이 바로 명확성이기 때문입니다. 예를 들어, ""사용자 정보를 가져온다""라는 모호한 명세보다는 ""데이터베이스 테이블 'users'에서 사용자 ID가 '123'인 사용자의 이름, 이메일, 주소를 가져온다"" 와 같이 구체적으로 명시해야 합니다.  그래야 다른 개발자들이 오해 없이 동일한 기능을 구현할 수 있습니다.",86,106
716,8,16,객체지향 기법에서 클래스들 사이의 ‘부분-전체(part-whole)' 관계 또는 ’부분(is-a-part-of)'의 관계로 설명되는 연관성을 나타내는 용어는?,,일반화,추상화,캡슐화,집단화,4,"객체지향 기법에서 클래스는 객체를 만들기 위한 설계도와 같습니다.  여러 개의 클래스가 서로 관계를 맺을 수 있는데, 그 중 '부분-전체' 관계는 하나의 클래스가 다른 클래스의 일부분으로 구성되는 관계를 의미합니다. 예를 들어, 자동차라는 클래스가 있다면 엔진, 바퀴, 시트 등의 클래스는 자동차의 부분이 되겠죠. 이처럼 전체를 구성하는 부분들의 관계를 나타내는 용어가 바로 '집단화'입니다.  일반화는 상위 개념에서 하위 개념으로의 관계를, 추상화는 복잡한 내용을 간략하게 표현하는 것을, 캡슐화는 데이터와 함수를 하나로 묶는 것을 의미합니다. 따라서 자동차와 그 부품들의 관계를 가장 잘 나타내는 용어는 집단화입니다.",63,107
717,8,17,CASE가 갖고 있는 주요 기능이 아닌 것은?,,그래픽 지원,소프트웨어 생명주기 전 단계의 연결,언어번역,다양한 소프트웨어 개발 모형 지원,3,"CASE (Computer-Aided Software Engineering)는 소프트웨어 개발 과정을 지원하는 도구들의 총칭입니다.  그래픽 지원을 통해 소프트웨어 설계를 시각적으로 표현하고, 소프트웨어 생명주기(요구사항 분석부터 유지보수까지) 전 단계를 연결하여 효율적인 개발을 돕습니다. 또한, 다양한 소프트웨어 개발 방법론(예: 폭포수 모델, 애자일)을 지원하여 개발 프로젝트의 특성에 맞는 개발 방식을 선택할 수 있도록 합니다. 하지만 CASE는 언어 번역 기능을 제공하지 않습니다. 언어 번역은 컴파일러나 인터프리터와 같은 별도의 도구가 담당하는 영역입니다. 따라서 CASE의 주요 기능이 아닌 것은 언어 번역입니다.",84,147
718,8,18,DBMS 분석시 고려사항으로 거리가 먼 것은?,,가용성,성능,네트워크 구성도,상호 호환성,3,"DBMS(데이터베이스 관리 시스템) 분석 시 고려해야 할 사항은 데이터베이스의 성능, 안정성, 그리고 데이터의 호환성 등이 있습니다.  가용성은 데이터베이스가 얼마나 안정적으로 서비스를 제공하는지를 나타내는 중요한 지표이고, 성능은 데이터베이스의 처리 속도와 효율성을 의미하며, 상호 호환성은 다른 시스템과의 데이터 교환 가능성을 의미합니다.  하지만 네트워크 구성도는 DBMS 자체의 특성이나 성능을 직접적으로 평가하는 요소는 아닙니다.  DBMS는 네트워크 환경 *위에서* 동작하지만, 네트워크 구성 자체가 DBMS 분석의 직접적인 고려 대상은 아니기 때문에 정답은 3번입니다.  네트워크 구성은 DBMS가 작동하는 환경을 제공하는 것이지, DBMS의 내부적인 특성을 결정하는 요소는 아니라는 점을 이해하는 것이 중요합니다.",83,101
719,8,19,HIPO(Hierarchy Input Process Output)에 대한 설명으로 거리가 먼 것은?,,상향식 소프트웨어 개발을 위한 문서화 도구이다.,"HIPO 차트 종류에는 가시적 도표, 총체적 도표, 세부적 도표가 있다.",기능과 자료의 의존 관계를 동시에 표현할 수 있다.,보기 쉽고 이해하기 쉽다.,1,"HIPO(Hierarchy Input Process Output)는 소프트웨어 시스템의 기능을 계층적으로 표현하는 문서화 기법입니다.  계층적 구조를 통해 시스템의 전체적인 흐름을 한눈에 파악하고, 각 기능의 입력과 출력을 명확하게 보여줍니다.  쉽게 말해, 시스템이 어떤 입력을 받아 어떤 과정을 거쳐 어떤 출력을 내는지 계층적으로 나누어 그림으로 표현하는 방법입니다.  '가시적 도표', '총체적 도표', '세부적 도표' 등 여러 종류의 차트를 사용하여 시스템을 다양한 수준의 세부 정보로 설명할 수 있습니다.  따라서 기능과 자료의 의존 관계를 명확하게 보여주며, 보기 쉽고 이해하기 쉽다는 장점이 있습니다.  하지만 HIPO는 주로 *하향식* 소프트웨어 개발에 사용되며, 상향식 개발에는 적합하지 않습니다. 상향식 개발은 작은 모듈부터 시작하여 점차적으로 시스템을 구축하는 방식인데, HIPO는 전체 시스템을 먼저 설계하고 하위 기능으로 분해하는 하향식 접근 방식에 더 적합하기 때문입니다. 따라서 1번 선택지인 ""상향식 소프트웨어 개발을 위한 문서화 도구이다""는 HIPO의 특징과 거리가 멉니다.",78,106
720,8,20,"객체지향 분석 방법론 중 E-R 다이어그램을 사용하여 객체의 행위를 모델링하며, 객체식별, 구조 식별, 주체 정의, 속성 및 관계 정의, 서비스 정의 등의 과정으로 구성되는 것은?",,Coad와 Yourdon 방법,Booch 방법,Jacobson 방법,Wirfs-Brocks 방법,1,"이 문제는 객체지향 분석 방법론 중 E-R 다이어그램을 활용하는 방법을 묻고 있습니다.  E-R 다이어그램은 데이터베이스 설계에 주로 사용되는 도구이지만, 객체지향 분석에서도 객체 간의 관계를 시각적으로 표현하고 분석하는 데 유용하게 활용됩니다.  문제에서 제시된 '객체 식별, 구조 식별, 주체 정의, 속성 및 관계 정의, 서비스 정의' 와 같은 과정들은 객체지향 분석의 핵심적인 단계들을 나타냅니다.  Coad와 Yourdon 방법은 이러한 E-R 다이어그램을 이용하여 객체의 행위를 모델링하는 대표적인 객체지향 분석 방법론입니다.  다른 방법론들(Booch, Jacobson, Wirfs-Brock)도 객체지향 분석에 사용되지만, E-R 다이어그램을 객체의 행위 모델링에 중점적으로 사용하는 특징은 Coad와 Yourdon 방법이 가장 부합합니다. 따라서 정답은 1번 Coad와 Yourdon 방법입니다.",79,107
721,8,21,정렬된 N개의 데이터를 처리하는데 O(Nlog2N)의 시간이 소요되는 정렬 알고리즘은?,,선택정렬,삽입정렬,버블정렬,합병정렬,4,"정렬 알고리즘은 데이터를 특정 순서(예: 오름차순 또는 내림차순)로 정리하는 알고리즘입니다.  선택 정렬, 삽입 정렬, 버블 정렬은 시간 복잡도가 O(N²)인 알고리즘입니다.  이는 데이터의 개수(N)가 증가함에 따라 처리 시간이 N의 제곱에 비례하여 증가한다는 것을 의미합니다.  반면, 합병 정렬은 데이터를 반으로 나누어 정렬한 후 합치는 방식으로, 시간 복잡도가 O(N log₂N)입니다.  log₂N은 N의 이진 로그를 의미하며, N이 증가하더라도 N에 비해 훨씬 느리게 증가합니다. 따라서,  데이터의 개수가 많아질수록 합병 정렬이 선택 정렬, 삽입 정렬, 버블 정렬보다 훨씬 효율적입니다. 문제에서 O(N log₂N)의 시간 복잡도를 갖는 정렬 알고리즘을 묻고 있으므로 정답은 합병 정렬입니다.",69,121
722,8,22,White Box Testing 에 대한 설명으로 옳지 않은 것은?,,"Base Path Testing, Boundary Value Analysis가 대표적인 기법이다.",Source Code 의 모든 문장을 한번 이상 수행함으로서 진행된다.,모듈 안의 작동을 직접 관찰 할 수 있다.,"산출물의 각 기능별로 적절한 프로그램의 제어구조에 따라 선택, 반복 등의 부분들을 수행함으로써 논리적 경로를 점검한다.",1,"White Box Testing은 소스 코드를 직접 확인하면서 테스트하는 방법입니다.  마치 소프트웨어의 내부 구조를 투명하게 들여다보는 상자(White Box)와 같다고 생각하면 됩니다.  문제에서 옳지 않다고 하는 1번 선택지 ""Base Path Testing, Boundary Value Analysis가 대표적인 기법이다""는 잘못된 설명입니다. Base Path Testing과 Boundary Value Analysis는 블랙박스 테스트 기법에 속합니다. 블랙박스 테스트는 소스 코드를 보지 않고, 입력과 출력만을 가지고 테스트하는 방법입니다.  White Box Testing은 소스 코드의 모든 문장을 최소 한 번 이상 실행하여 테스트하는 것을 목표로 하며, 모듈 내부의 작동을 직접 관찰할 수 있습니다. 따라서 소스 코드의 논리적 경로를 따라 선택, 반복 등의 제어 구조를 점검하는 것도 White Box Testing의 특징입니다.  결론적으로, White Box Testing은 소스 코드를 직접 분석하여 테스트하는 방법이며,  블랙박스 테스트 기법을 포함하지 않습니다.",67,119
723,8,23,소프트웨어 품질 측정을 위해 개발자 관점에서 고려해야 할 항목으로 거리가 먼 것은?,,정확성,무결성,사용성,간결성,4,"소프트웨어 품질 측정은 개발된 소프트웨어가 얼마나 좋은지를 다양한 측면에서 평가하는 것을 말합니다.  정확성은 소프트웨어가 올바른 결과를 내는지, 무결성은 소프트웨어가 의도하지 않은 변경이나 손상으로부터 안전한지를, 사용성은 사용자가 얼마나 쉽고 편리하게 사용할 수 있는지를 나타냅니다.  반면 간결성은 소프트웨어의 코드가 얼마나 간결하고 효율적인지를 나타내는 것으로, 개발자 관점에서는 중요하지만,  **사용자 관점에서 소프트웨어 품질을 평가할 때는 직접적으로 고려되는 요소가 아닙니다.**  따라서 사용자 경험과 직결되는 정확성, 무결성, 사용성과 달리 간결성은 사용자에게는 크게 영향을 미치지 않으므로,  소프트웨어 품질 측정을 위해 개발자 관점에서 고려해야 할 항목으로는 거리가 멉니다.  간결성은 개발 효율성이나 유지보수 용이성과 관련된 내부적인 측면이지, 사용자에게 직접적으로 보이는 품질 요소는 아니기 때문입니다.",63,117
724,8,24,인터페이스 구현 검증도구 중 아래에서 설명하는 것은?,https://www.cbtbank.kr/images/iz/iz20200606/iz20200606m24.gif,xUnit,STAF,FitNesse,RubyNode,2,"문제에서 설명하는 검증 도구는 서비스 호출이나 컴포넌트 재사용 등 다양한 환경을 지원하는 테스트 프레임워크이며, 분산 환경에서 데몬을 사용하여 테스트를 자동화하는 기능을 가지고 있습니다.  제시된 선택지 중 이러한 특징을 가장 잘 나타내는 것은 STAF(Software Testing Automation Framework)입니다. STAF는 분산 환경에서 다양한 테스트를 자동화하기 위해 설계된 프레임워크로, 데몬을 이용하여 테스트 대상 프로그램을 제어하고 테스트 결과를 수집합니다.  xUnit은 단위 테스트 프레임워크, FitNesse는 피팅 테스트 프레임워크, RubyNode는 Ruby 언어 기반의 노드 관리 도구로 문제의 설명과 일치하지 않습니다. 따라서 정답은 STAF(2번)입니다.",64,124
725,8,25,EAI(Enterprise Application Integration)의 구축 유형으로 옳지 않은 것은?,,Point-to-Point,Hub&Spoke,Message Bus,Tree,4,"EAI(Enterprise Application Integration)는 여러 기업 애플리케이션들을 서로 연결하고 통합하여 데이터와 프로세스를 공유할 수 있도록 하는 기술입니다.  문제에서 제시된 구축 유형들은 EAI 시스템을 구축하는 방식들을 나타냅니다.  Point-to-Point는 각 애플리케이션을 개별적으로 연결하는 방식이고, Hub&Spoke는 중앙 허브를 통해 여러 애플리케이션을 연결하는 방식이며, Message Bus는 메시지를 전달하는 버스를 통해 애플리케이션 간 통신을 중개하는 방식입니다.  반면 Tree는 계층적인 구조를 가지는 방식으로, EAI 시스템의 일반적인 구축 유형으로는 잘 사용되지 않습니다.  EAI 시스템은 일반적으로 여러 애플리케이션 간의 효율적인 데이터 교환과 통합을 목표로 하기 때문에, 계층적인 Tree 구조는 적합하지 않고 유지보수 및 확장성 측면에서 비효율적일 수 있습니다. 따라서 4번 Tree가 옳지 않은 구축 유형입니다.",73,110
726,8,26,다음 트리를 전위 순회(preorder traversal)한 결과는?,https://www.cbtbank.kr/images/iz/iz20200606/iz20200606m26.gif,+*AB/*CDE,AB/C*D*E+,A/B*C*D+E,+**/ABCDE,4,"이 문제는 이진 트리의 전위 순회(preorder traversal)를 이해하고 있는지 묻는 문제입니다. 전위 순회란,  트리를 순회하는 방법 중 하나로,  먼저 루트 노드를 방문하고, 그 다음 왼쪽 서브트리를 순회한 후, 오른쪽 서브트리를 순회하는 방식입니다.  주어진 이진 트리를 살펴보면 루트 노드는 '+' 입니다.  그 다음 왼쪽 서브트리(* 노드)를 순회해야 하는데, 이때도 전위 순회 방식을 따라 * 노드를 먼저 방문하고, 그 다음 왼쪽 서브트리(/ 노드)를 순회합니다.  / 노드를 순회할 때도 마찬가지로 A 노드를 먼저 방문하고 B 노드를 방문합니다.  이런 식으로 트리를 왼쪽 서브트리부터 깊이 우선적으로 순회하면서 노드를 방문하는 순서대로 기록하면  '+ * / A B * C D E' 가 됩니다. 따라서 정답은 4번 '+ **/ABCDE' 가 됩니다.  문제에서 제시된 수식 (A / B) * C * D + E 는 이진 트리의 표현을 수식으로 나타낸 것일 뿐, 전위 순회 결과를 직접적으로 나타내는 것은 아닙니다. 전위 순회는 트리의 구조를 순회하는 순서를 나타내는 것이지, 수식의 계산 순서를 나타내는 것이 아닙니다.",79,111
727,8,27,인터페이스 보안을 위해 네트워크 영역에 적용될 수 있는 솔루션과 거리가 먼 것은?,,IPSec,SMTP,SSL,S-HTTP,2,"이 문제는 네트워크 영역에서 인터페이스 보안을 위해 사용되는 솔루션들을 묻고 있습니다.  IPSec, SSL, S-HTTP는 모두 네트워크 통신의 보안을 강화하는 프로토콜 또는 기술입니다. IPSec은 IP 패킷 자체를 암호화하여 네트워크 계층에서 보안을 제공하고, SSL(Secure Sockets Layer)과 S-HTTP(Secure Hypertext Transfer Protocol)는 응용 계층에서 데이터를 암호화하여 웹 통신 등의 보안을 확보합니다. 반면 SMTP(Simple Mail Transfer Protocol)는 이메일 전송 프로토콜로,  자체적으로는 데이터 암호화 기능을 제공하지 않습니다. 따라서 네트워크 영역의 인터페이스 보안을 위해 직접적으로 사용되는 솔루션과는 거리가 멉니다. SMTP를 통해 이메일을 안전하게 전송하려면 SSL/TLS와 같은 별도의 보안 프로토콜을 함께 사용해야 합니다.  따라서 정답은 SMTP입니다.",77,156
728,8,28,평가 점수에 따른 성적부여는 다음 표와 같다. 이를 구현한 소프트웨어를 경계값 분석 기법으로 테스트 하고자 할 때 다음 중 테스트 케이스의 입력 값으로 옳지 않은 것은?,https://www.cbtbank.kr/images/iz/iz20200606/iz20200606m28.gif,59,80,90,101,3,"이 문제는 소프트웨어 테스트 기법 중 하나인 경계값 분석을 이해하고 있는지 묻는 문제입니다. 경계값 분석은 입력값의 경계선에 해당하는 값들을 테스트 케이스로 사용하여 프로그램의 오류를 찾는 기법입니다.  문제에서 제시된 성적 평가 기준은 80점 이상 A, 60~79점 B, 59점 이하 C입니다.  각 구간의 경계값은 59, 60, 79, 80, 100입니다.  따라서 59, 80, 100은 경계값에 해당하지만 90은 경계값이 아닙니다. 90점은 이미 80점 이상 A등급에 포함되는 값이므로, 경계값 분석의 목적인 경계선을 확인하는 데 필요하지 않습니다. 101점은 주어진 범위(0~100)를 벗어난 값이므로, 경계값 분석에서 고려해야 할 값입니다. 하지만 문제에서 옳지 않은 것을 고르라고 했으므로 90점이 정답이 됩니다.  경계값 분석은 프로그램의 오류를 효율적으로 찾기 위해 경계선에 집중하는 테스트 기법이라는 점을 기억해야 합니다.",77,119
729,8,29,반정규화(Denormalization) 유형중 중복 테이블을 추가하는 방법에 해당하지 않는 것은?,,빌드 테이블의 추가,집계 테이블의 추가,진행 테이블의 추가,특정 부분만을 포함하는 테이블의 추가,1,"반정규화는 데이터베이스의 성능을 향상시키기 위해 정규화된 데이터베이스를 의도적으로 비정규화하는 기법입니다.  중복 데이터를 허용하여 데이터베이스 조회 속도를 높이는 것이 목표입니다.  문제에서 제시된 옵션들을 살펴보면, 집계 테이블(2)은 특정 데이터의 집계 값을 저장하여 쿼리 속도를 높이고, 진행 테이블(3)은 특정 작업의 진행 상황을 기록하여 조회 성능을 개선하며, 특정 부분만을 포함하는 테이블(4)은 자주 사용되는 데이터의 부분 집합을 별도로 저장하여 성능을 향상시키는 반정규화 기법의 예시입니다.  반면, 빌드 테이블(1)은 일반적으로 데이터베이스 설계 단계에서 사용되는 용어로, 실제 데이터를 저장하는 테이블이 아니고, 데이터베이스 구축 과정에서 임시적으로 사용되는 테이블을 의미합니다. 따라서 중복 테이블을 추가하는 반정규화 기법에 해당하지 않습니다.  즉, 빌드 테이블은 반정규화의 목적과는 무관하게 데이터베이스 생성 과정의 일부로 사용되는 것이지,  데이터베이스 성능 향상을 위한 중복 데이터 저장을 위한 테이블이 아니기 때문입니다.",47,133
730,8,30,ISO/IEC 9126의 소프트웨어 품질 특성 중 기능성(Functionlity)의 하위 특성으로 옳지 않은 것은?,,학습성,적합성,정확성,보안성,1,"ISO/IEC 9126는 소프트웨어의 품질을 평가하기 위한 국제 표준입니다.  기능성(Functionality)은 소프트웨어가 의도된 기능을 얼마나 잘 수행하는지를 나타내는 품질 특성입니다.  기능성의 하위 특성으로는 정확성(Accuracy), 적합성(Suitability), 상호운용성(Interoperability), 보안성(Security) 등이 있습니다.  문제에서 제시된 1번 '학습성'은 소프트웨어를 사용하는 사용자가 얼마나 쉽게 소프트웨어를 배우고 사용할 수 있는지를 나타내는 특성으로,  이는 ISO/IEC 9126에서 사용성(Usability)의 하위 특성에 속합니다. 따라서 기능성의 하위 특성이 아닌 사용성의 하위 특성인 '학습성'이 정답입니다.  쉽게 말해, 기능성은 소프트웨어가 제대로 작동하는지에 대한 것이고, 사용성은 소프트웨어를 사용하기 쉬운지에 대한 것입니다.  '학습성'은 소프트웨어를 배우는 데 얼마나 쉬운지를 나타내므로 사용성에 더 가깝습니다.",61,117
731,8,31,다음 트리의 차수(degree)와 단말 노드(terminal node)의 수는?,https://www.cbtbank.kr/images/iz/iz20200606/iz20200606m31.gif,"차수: 4, 단말 노드: 4","차수: 2, 단말 노드: 4","차수: 4, 단말 노드: 8","차수: 2, 단말 노드: 8",2,"문제에서 제시된 트리는 계층적인 구조를 나타냅니다.  트리에서 각 노드의 차수는 그 노드가 가지고 있는 자식 노드의 개수를 의미합니다.  문제의 트리를 살펴보면, 루트 노드 A는 2개의 자식 노드(B, C)를 가지고 있고, 노드 B는 1개(D), 노드 C는 2개(E, F), 노드 E는 2개(G, H)의 자식 노드를 가지고 있습니다.  따라서 트리의 차수는 각 노드의 자식 노드 개수 중 가장 큰 값을 의미하는 것이 아니라,  **각 노드의 자식 노드의 최대 개수**를 의미합니다.  이 트리에서 노드의 최대 자식 노드 개수는 2개이므로 트리의 차수는 2입니다.  단말 노드는 자식 노드가 없는 노드를 의미하며, 문제의 트리에서 단말 노드는 D, F, G, H의 4개입니다. 따라서 정답은 차수 2, 단말 노드 4개입니다.",72,111
732,8,32,디지털 저작권 관리(DRM)의 기술 요소가 아닌 것은?,,크랙 방지 기술,정책 관리 기술,암호화 기술,방화벽 기술,4,"디지털 저작권 관리(DRM)은 디지털 콘텐츠의 저작권을 보호하기 위한 기술입니다.  크랙 방지 기술은 불법 복제를 막기 위해 사용되고, 정책 관리 기술은 콘텐츠 접근 권한을 제어하며, 암호화 기술은 콘텐츠를 암호화하여 무단 접근을 방지하는 데 사용됩니다.  반면 방화벽 기술은 외부의 불법적인 접근을 차단하는 네트워크 보안 기술로, DRM의 핵심 기술 요소는 아닙니다. DRM은 콘텐츠 자체의 보호에 초점을 맞추는 반면, 방화벽은 네트워크 전체의 보안을 담당하는 것이죠. 따라서 DRM의 기술 요소가 아닌 것은 방화벽 기술입니다.",77,116
733,8,33,소프트 웨어 테스트에서 오류의 80%는 전체 모듈의 20% 내에서 발견된다는 법칙은?,,Brooks의 법칙,Boehm의 법칙,Pareto의 법칙,Jackson의 법칙,3,"소프트웨어 테스트를 진행하다 보면, 전체 오류의 대부분이 소수의 모듈에서 발생하는 현상을 경험하게 됩니다.  파레토 법칙(Pareto Principle)은 이러한 현상을 수치적으로 설명하는 법칙으로, 전체 오류의 80%가 전체 모듈의 20%에서 발견된다는 것을 의미합니다.  이는 소프트웨어 테스트의 효율성을 높이기 위해,  오류가 많이 발생할 가능성이 높은 핵심 모듈에 집중적으로 테스트를 수행해야 함을 시사합니다.  즉, 모든 모듈을 균일하게 테스트하는 것보다,  중요도가 높은 20%의 모듈에 집중하여 테스트하면 전체 오류의 80%를 발견할 수 있다는 의미입니다.  이는 자원을 효율적으로 사용하고 테스트 시간을 단축하는 데 도움이 됩니다.",75,119
734,8,34,소프트웨어 형상 관리의 의미로 적절한 것은?,,비용에 관한 사항을 효율적으로 관리하는 것,개발 과정의 변경 사항을 관리하는 것,테스트 과정에서 소프트웨어를 통합하는 것,개발 인력을 관리하는 것,2,"소프트웨어 형상 관리란 소프트웨어 개발 과정에서 발생하는 모든 변경 사항을 체계적으로 관리하는 것을 의미합니다.  소스 코드, 문서, 테스트 결과 등 소프트웨어 개발과 관련된 모든 산출물의 변경 이력을 추적하고 관리하여, 버전 관리, 변경 통제, 협업 등을 효율적으로 수행할 수 있도록 지원하는 활동입니다.  1번은 비용 관리, 3번은 소프트웨어 통합, 4번은 인력 관리에 대한 내용이므로 소프트웨어 형상 관리의 의미와는 부합하지 않습니다. 따라서 정답은 개발 과정의 변경 사항을 관리하는 2번입니다.  쉽게 말해, 소프트웨어 개발 과정에서 발생하는 모든 변화를 기록하고 관리하는 시스템이라고 생각하면 됩니다.  예를 들어, 소스 코드를 수정했을 때, 누가 언제 어떤 이유로 수정했는지, 수정 전후의 코드는 어떻게 다른지 등을 모두 기록하고 관리하는 것이죠.",69,115
735,8,35,알고리즘 시간복잡도 O(1)이 의미하는 것은?,,컴퓨터 처리가 불가,알고리즘 입력 데이터 수가 한 개,알고리즘 수행시간이 입력 데이터 수와 관계없이 일정,알고리즘 길이가 입력 데이터보다 작음,3,"O(1)은 알고리즘의 시간 복잡도를 나타내는 표기법입니다.  시간 복잡도는 알고리즘의 수행 시간이 입력 데이터의 크기에 따라 어떻게 변하는지를 나타내는 척도입니다. O(1)은 입력 데이터의 크기(n)에 관계없이 알고리즘의 수행 시간이 항상 일정하다는 것을 의미합니다.  예를 들어, 배열의 특정 인덱스에 접근하는 작업은 항상 같은 시간이 걸리므로 O(1)의 시간 복잡도를 가집니다.  입력 데이터가 1개이든 100만 개이든 상관없이,  특정 위치의 값을 가져오는 데 걸리는 시간은 동일하기 때문입니다.  반면에, 배열 전체를 순회하는 작업은 입력 데이터의 크기에 비례하여 시간이 증가하므로 O(n)의 시간 복잡도를 갖습니다.  따라서 정답은 3번, 알고리즘 수행시간이 입력 데이터 수와 관계없이 일정한 것입니다.",76,121
736,8,36,소스코드 품질분석 도구 중 정적분석 도구가 아닌 것은?,,pmd,cppcheck,valMeter,checkstyle,3,"소스코드 품질분석 도구는 개발된 소스코드의 품질을 분석하여 버그나 취약점을 찾아내는 도구입니다.  정적 분석 도구는 코드를 실행하지 않고 코드 자체를 분석하는 도구이고, 동적 분석 도구는 코드를 실행하면서 분석하는 도구입니다.  pmd, cppcheck, checkstyle은 모두 코드를 실행하지 않고 분석하는 정적 분석 도구입니다.  반면 valMeter는 코드 실행을 통해 성능이나 메모리 사용량 등을 측정하는 동적 분석 도구입니다. 따라서 정적 분석 도구가 아닌 것은 valMeter입니다.  쉽게 말해, 정적 분석 도구는 '코드를 읽어서' 문제점을 찾고, 동적 분석 도구는 '코드를 돌려보면서' 문제점을 찾는다고 생각하면 됩니다.",66,121
737,8,37,"검증 검사 기법 중 개발자의 장소에서 사용자가 개발자 앞에서 행하는 기법이며, 일반적으로 통제된 환경에서 사용자와 개발자가 함께 확인하면서 수행되는 검사는?",,동치 분할 검사,형상 검사,알파 검사,베타 검사,3,"문제에서 설명하는 검사 기법은 개발자가 만든 프로그램을 사용자가 직접 사용해보면서 오류를 찾는 검사입니다.  개발자의 장소에서 사용자가 직접 프로그램을 사용하고, 개발자는 옆에서 사용자의 행동을 관찰하며 문제점을 파악합니다. 이러한 검사는 일반적으로 통제된 환경에서 이루어지며, 사용자의 피드백을 바로 받아 수정할 수 있다는 장점이 있습니다.  선택지 중 알파 검사(3번)는 바로 이러한 상황을 나타냅니다. 알파 검사는 개발이 거의 완료된 시점에 내부 사용자(개발팀 내부 또는 제한된 사용자 그룹)가 제한된 환경에서 소프트웨어를 테스트하는 것을 의미합니다. 베타 검사는 알파 검사 이후 외부 사용자에게 배포하여 테스트하는 것이고, 동치 분할 검사는 테스트 케이스를 효율적으로 설계하는 기법이며, 형상 검사는 소프트웨어의 변경 사항을 관리하고 추적하는 기법입니다. 따라서 문제의 조건에 가장 부합하는 것은 알파 검사입니다.",79,119
738,8,38,하향식 통합에 있어서 모듈 간의 통합 시험을 위해 일시적으로 필요한 조건만을 가지고 임시로 제공되는 시험용 모듈을 무엇이라고 하는가?,,Stub,Driver,Procedure,Function,1,"하향식 통합 방식은 큰 모듈부터 통합하여 시스템을 구축하는 방식입니다.  이때, 아직 구현되지 않은 하위 모듈과의 인터페이스를 테스트하기 위해 임시로 기능을 제공하는 모듈이 필요합니다. 이러한 임시 모듈을 Stub(스터브)라고 합니다.  Stub은 실제 기능을 수행하는 대신, 하위 모듈이 호출했을 때 미리 정의된 값을 반환하거나 특정 동작을 시뮬레이션하여 상위 모듈의 테스트를 가능하게 합니다.  Driver는 상위 모듈을 테스트하기 위해 임시로 만드는 모듈이고, Procedure와 Function은 일반적인 프로그램 구성 요소이므로 이 문제와는 관련이 없습니다. 따라서 하향식 통합에서 모듈 간 통합 시험을 위해 일시적으로 필요한 조건만을 가지고 임시로 제공되는 시험용 모듈은 Stub입니다.",82,114
739,8,39,SW 패키징 도구 활용 시 고려 사항과 거리가 먼 것은?,,패키징 시 사용자에게 배포되는 SW이므로 보안을 고려한다.,사용자 편의성을 위한 복합성 및 비효율성 문제를 고려한다.,보안상 단일 기종에서만 사용할 수 있도록 해야 한다.,제품 SW 종류에 적합한 암호화 알고리즘을 적용한다.,3,"SW 패키징은 소프트웨어를 사용자에게 배포하기 위한 과정입니다.  이 과정에서 여러 가지 사항을 고려해야 하는데,  보안은 가장 중요한 요소 중 하나입니다.  사용자에게 배포되는 소프트웨어이기 때문에 악의적인 공격으로부터 안전하게 보호되어야 하며,  적절한 암호화 알고리즘을 사용하는 것도 중요합니다.  또한, 사용자들이 쉽고 편리하게 소프트웨어를 설치하고 사용할 수 있도록  패키징 과정을 설계해야 합니다.  하지만,  단일 기종에서만 사용하도록 제한하는 것은 사용자 편의성을 떨어뜨리고  소프트웨어의 활용도를 낮추는 결과를 초래합니다.  따라서,  다양한 기종에서 사용할 수 있도록  호환성을 고려하는 것이 중요합니다.  문제에서 3번은  소프트웨어의 활용성을 제한하는 요소이므로,  SW 패키징 도구 활용 시 고려 사항과 거리가 멉니다.",89,116
740,8,40,외계인코드(Alien Code)에 대한 설명으로 옳은 것은?,,프로그램의 로직이 복잡하여 이해하기 어려운 프로그램을 의미한다.,아주 오래되거나 참고문서 또는 개발자가 없어 유지보수 작업이 어려운 프로그램을 의미한다.,오류가 없어 디버깅 과정이 필요 없는 프로그램을 의미한다.,사용자가 직접 작성한 프로그램을 의미한다.,2,"외계인 코드(Alien Code)는 2번처럼 아주 오래되거나 관련 문서나 개발자가 없어서 유지보수가 어려운 프로그램을 의미합니다.  마치 외계인이 만든 것처럼 이해하기 어렵고 수정하기 힘든 코드를 비유적으로 표현한 것입니다.  1번의 경우 로직이 복잡한 프로그램은 많지만, 반드시 유지보수가 어려운 것은 아닙니다.  3번은 오류가 없는 프로그램을 의미하는데, 실제로 오류 없는 프로그램은 거의 없고,  4번은 사용자가 직접 작성한 프로그램은 외계인 코드와는 관련이 없습니다. 따라서, 오래되어 유지보수가 어려운 프로그램을 지칭하는 2번이 가장 적절한 설명입니다.",82,118
741,8,41,SQL 의 분류 중 DDL에 해당하지 않는 것은?,,UPDATE,ALTER,DROP,CREATE,1,"SQL은 데이터베이스를 관리하는 데 사용되는 언어입니다.  DDL(Data Definition Language)은 데이터베이스의 구조를 정의하는 데 사용되는 SQL의 한 종류입니다.  CREATE, ALTER, DROP 명령어는 테이블을 생성, 수정, 삭제하는 데 사용되므로 DDL에 속합니다. 반면 UPDATE 명령어는 이미 존재하는 테이블의 데이터를 수정하는 데 사용됩니다. 데이터의 *내용*을 변경하는 것은 DML(Data Manipulation Language)의 영역입니다. 따라서 UPDATE는 DDL에 해당하지 않습니다.  쉽게 말해, DDL은 데이터베이스의 '뼈대'를 만들고 바꾸는 것이고, DML은 그 '뼈대' 안에 '살'을 붙이고 수정하는 것입니다.  UPDATE는 데이터의 내용을 변경하는 것이므로 DML에 속하며, 따라서 DDL에 해당하지 않습니다.",74,127
742,8,42,다음 두 릴레이션에서 외래키로 사용된 것은? (단 밑줄 친 속성은 기본키이다.),https://www.cbtbank.kr/images/iz/iz20200606/iz20200606m42.gif,수강번호,과목번호,학번,과목명,2,"문제에서 주어진 두 릴레이션은 '과목'과 '수강'입니다.  '과목' 릴레이션은 과목번호와 과목명으로 구성되고, '수강' 릴레이션은 수강번호, 학번, 과목번호, 학기로 구성됩니다.  릴레이션 간의 관계를 이해하는 것이 중요한데,  '수강' 릴레이션에서 학생이 어떤 과목을 수강했는지 나타내는 정보가 '과목번호'에 담겨 있습니다.  '과목' 릴레이션의 '과목번호'는 기본키(밑줄)로, 각 과목을 유일하게 식별합니다.  '수강' 릴레이션의 '과목번호'는 '과목' 릴레이션의 '과목번호'를 참조하여, 어떤 과목을 수강했는지 연결하는 역할을 합니다. 이처럼 다른 릴레이션의 기본키를 참조하는 속성을 외래키라고 합니다. 따라서 '수강' 릴레이션의 '과목번호'는 '과목' 릴레이션을 참조하는 외래키입니다.  다른 선택지는 '수강번호', '학번', '과목명'인데, 이들은 다른 테이블의 기본키를 참조하지 않으므로 외래키가 아닙니다.",86,129
743,8,43,데이터 무결성 제약조건 중 “개체 무결성 제약”조건에 대한 설명으로 맞는 것은?,,릴레이션 내의 튜플들이 각 속성의 도메인에 지정된 값만을 가져야 한다.,기본키에 속해 있는 애트리뷰트는 널값이나 중복값을 가질 수 없다.,릴레이션은 참조할 수 없는 외래키 값을 가질 수 없다.,외래키 값은 참조 릴레이션의 기본키 값과 동일해야 한다.,2,"데이터 무결성 제약 조건은 데이터베이스의 데이터가 정확하고 일관성 있게 유지되도록 보장하는 규칙입니다.  개체 무결성 제약 조건은 그 중에서도 각 데이터 레코드(튜플)의 기본키(Primary Key)에 대한 무결성을 보장하는 규칙입니다. 기본키는 각 레코드를 유일하게 식별하는 속성(Attribute)이므로, 널값(NULL, 값이 없음을 의미)이나 중복값을 가질 수 없습니다.  따라서 2번이 정답입니다. 1번은 도메인 무결성 제약, 3번과 4번은 참조 무결성 제약에 대한 설명입니다.  쉽게 말해, 개체 무결성은 각각의 데이터 행이 유일하게 구분될 수 있도록 기본키를 관리하는 규칙이라고 생각하면 됩니다.  예를 들어, 학생들의 정보를 담은 데이터베이스에서 학번이 기본키라면, 어떤 학생도 같은 학번을 가질 수 없고, 학번이 비어있을 수도 없습니다.",76,133
744,8,44,뷰(view)에 대한 설명으로 옳지 않은 것은?,,뷰는 CREATE 문을 사용하여 정의한다.,뷰는 데이터의 논리적 독립성을 제공한다.,뷰를 제거할 때에는 DROP 문을 사용한다.,뷰는 저장장치 내에 물리적으로 존재한다.,4,"뷰(view)는 데이터베이스의 테이블들을 기반으로 만들어진 가상의 테이블입니다.  실제로 데이터를 저장하는 것이 아니라, 기존 테이블들의 데이터를 특정 조건에 따라 보여주는 역할을 합니다.  CREATE VIEW 문을 사용하여 뷰를 정의하고, DROP VIEW 문을 사용하여 뷰를 제거합니다.  뷰는 기존 테이블의 데이터를 참조하여 보여주기 때문에, 기존 테이블의 구조가 변경되어도 뷰 자체는 변경될 필요가 없어 데이터의 논리적 독립성을 제공합니다.  하지만 뷰는 실제 데이터를 저장하는 것이 아니고, 기존 테이블에 대한 질의(query) 결과를 보여주는 것이므로 저장장치에 물리적으로 존재하지 않습니다. 따라서 4번이 옳지 않은 설명입니다.  마치  사진을 여러 장 붙여서 만든 콜라주처럼 생각하면 이해하기 쉬울 것입니다. 콜라주 자체는 새로운 사진이지만, 실제로 새로운 사진을 찍어 만든 것이 아니라 기존 사진들을 조합한 것과 같습니다.",76,128
745,8,45,다음 SQL 문의 실행 결과는?,https://www.cbtbank.kr/images/iz/iz20200606/iz20200606m45.gif,"10,000","15,000","20,000","25,000",4,"이 SQL 문은 두 개의 테이블, `도서`와 `도서가격`을 사용합니다.  먼저 안쪽의 `SELECT` 문 (서브쿼리) 에서 `책명`이 '자료구조'인 책의 `책번호`를 찾습니다. `도서` 테이블을 보면 '자료구조' 책의 `책번호`는 222입니다.  이 222라는 `책번호`가 바깥쪽 `SELECT` 문의 `WHERE` 절에 전달되어, `책번호`가 222인 `도서가격`의 `가격`을 찾게 됩니다. `도서가격` 테이블에서 `책번호`가 222인 행의 `가격`은 25,000입니다. 따라서 최종적으로 SQL 문의 실행 결과는 25,000이 됩니다.  쉽게 말해, '자료구조' 책의 가격을 찾는 SQL 문입니다.",89,128
746,8,46,데이터베이스의 논리적 설계(logical design) 단계에서 수행하는 작업이 아닌 것은?,,레코드 집중의 분석 및 설계,논리적 데이터베이스 구조로 매핑(mapping),트랜잭션 인터페이스 설계,스키마의 평가 및 정제,1,"데이터베이스의 논리적 설계는 데이터베이스의 구조를 실제 데이터를 저장하는 방식과 무관하게, 사용자의 관점에서 데이터를 어떻게 조직하고 표현할지를 정의하는 단계입니다.  레코드 집중(Record Focusing)은 물리적 설계 단계에서 데이터의 효율적인 저장을 위해 레코드를 어떻게 배치하고 저장할지 결정하는 작업입니다.  따라서 레코드 집중의 분석 및 설계는 논리적 설계 단계에서 수행하는 작업이 아닙니다.  논리적 설계에서는 사용자의 요구사항을 충족하는 데이터 구조를 정의하는 데 집중하며, 실제 저장 방식은 물리적 설계 단계에서 고려됩니다.  나머지 선택지인 논리적 데이터베이스 구조로 매핑, 트랜잭션 인터페이스 설계, 스키마의 평가 및 정제는 모두 데이터베이스의 논리적 구조를 정의하고 개선하는 작업에 해당합니다.",45,130
747,8,47,이행적 함수 종속 관계를 의미하는 것은?,,"A→B이고 B→C 일 때, A→C를 만족하는 관계","A→B이고 B→C 일 때, C→A를 만족하는 관계","A→B이고 B→C 일 때, B→A를 만족하는 관계","A→B이고 B→C 일 때, C→B를 만족하는 관계",1,"이행적 함수 종속 관계는 데이터베이스 설계에서 매우 중요한 개념입니다.  간단히 말해, A라는 속성이 B라는 속성을 결정하고, B라는 속성이 C라는 속성을 결정하면, A라는 속성은 C라는 속성도 결정한다는 의미입니다.  마치 ""A가 B를 결정하고, B가 C를 결정하면, A는 C를 결정한다""는 논리적 추론과 같습니다.  문제에서 제시된 1번 선택지 ""A→B이고 B→C 일 때, A→C를 만족하는 관계""가 바로 이러한 이행적 함수 종속 관계를 정확하게 나타냅니다.  다른 선택지는 A, B, C 속성 간의 관계를 잘못 표현하고 있습니다. 예를 들어 2번 선택지는 A가 C에 의해 결정되는 관계를 나타내는데, 이는 문제의 조건과 일치하지 않습니다.",85,129
748,8,48,하나의 애트리뷰트가 가질 수 있는 원자값들의 집합을 의미하는 것은?,,도메인,튜플,엔티티,다형성,1,"하나의 애트리뷰트(Attribute)는 데이터베이스에서 테이블의 특정 속성을 나타냅니다.  예를 들어, ""고객"" 테이블에 ""나이""라는 애트리뷰트가 있다면, 이 애트리뷰트는 고객의 나이 정보를 저장하는 역할을 합니다.  이때, ""나이"" 애트리뷰트가 가질 수 있는 값들의 집합, 즉 0살부터 150살까지의 정수(실제로는 더 제한적일 수 있겠죠)와 같은 값들의 전체 집합을 도메인(Domain)이라고 합니다.  도메인은 애트리뷰트가 허용하는 값들의 범위를 정의하는 것이므로, 정답은 1번 도메인입니다.  튜플은 테이블의 한 행을, 엔티티는 테이블 자체가 나타내는 개체를, 다형성은 객체지향 프로그래밍의 개념을 의미합니다. 따라서 문제의 맥락과는 맞지 않습니다.",66,129
749,8,49,"STUDENT 테이블에 독일어과 학생 50명, 중국어과 학생 30명, 영어영문학과 학생 50명의 정보가 저장되어 있을 때, 다음 두 SQL문의 실행 결과 튜플 수는? (단, DEPT 컬럼은 학과명)",https://www.cbtbank.kr/images/iz/iz20200606/iz20200606m49.gif,"ⓐ 3, ⓑ 3","ⓐ 50, ⓑ 3","ⓐ 130, ⓑ 3","ⓐ 130, ⓑ 130",3,"문제에서 STUDENT 테이블에는 독일어과, 중국어과, 영어영문학과 학생들의 정보가 저장되어 있습니다.  SQL 문 Ⓐ `SELECT DEPT FROM STUDENT;`는 STUDENT 테이블에서 DEPT 컬럼(학과명)의 모든 데이터를 가져오는 명령어입니다.  따라서 독일어과, 중국어과, 영어영문학과 학생들의 정보가 모두 포함되므로 총 50 + 30 + 50 = 130개의 튜플(레코드)이 결과로 나옵니다.  반면, SQL 문 Ⓑ `SELECT DISTINCT DEPT FROM STUDENT;`는 STUDENT 테이블에서 DEPT 컬럼의 중복되지 않는 데이터만 가져오는 명령어입니다.  즉, 학과명이 중복되는 것을 제거하고 유일한 학과명만 출력합니다.  따라서 독일어과, 중국어과, 영어영문학과의 세 가지 학과명만 결과로 나오므로 총 3개의 튜플이 결과로 나옵니다.  그러므로 정답은 ⓐ 130, ⓑ 3 입니다.",82,127
750,8,50,관계대수 연산에서 두 릴레이션이 공통으로 가지고 있는 속성을 이용하여 두 개의 릴레이션을 하나로 합쳐서 새로운 릴레이션을 만드는 연산은?,,https://www.cbtbank.kr/images/iz/iz20200606/iz20200606m50b1.gif,https://www.cbtbank.kr/images/iz/iz20200606/iz20200606m50b2.gif,https://www.cbtbank.kr/images/iz/iz20200606/iz20200606m50b3.gif,https://www.cbtbank.kr/images/iz/iz20200606/iz20200606m50b4.gif,1,"관계대수 연산에서 두 릴레이션을 하나로 합치는 연산은 조인(Join) 연산입니다.  두 릴레이션이 공통으로 가지고 있는 속성(열)을 기준으로,  두 릴레이션의 행들을 결합하여 새로운 릴레이션을 생성합니다.  예를 들어,  학생 정보를 담은 릴레이션과 수강 정보를 담은 릴레이션이 있다면,  '학생 ID'라는 공통 속성을 이용하여 조인 연산을 수행하면 학생의 정보와 수강 정보가 하나의 릴레이션에 합쳐집니다.  이때,  공통 속성의 값이 일치하는 행들만 결합됩니다.  다른 종류의 조인 연산(내부 조인, 외부 조인 등)이 있지만, 문제의 맥락상 두 릴레이션을 하나로 합치는 기본적인 조인 연산을 의미합니다.",82,129
751,8,51,트랜잭션의 특성 중 다음 설명에 해당하는 것은?,https://www.cbtbank.kr/images/iz/iz20200606/iz20200606m51.gif,Durability,Share,Consistency,Atomicity,4,"문제에서 제시된 설명은 트랜잭션의 **원자성(Atomicity)**을 설명하고 있습니다.  트랜잭션은 데이터베이스 작업의 논리적 단위로, 여러 개의 연산으로 구성될 수 있습니다.  원자성이란 이러한 여러 연산들이 하나의 단위로 취급되어, 모든 연산이 성공적으로 완료되면 데이터베이스에 변경 사항이 반영되고, 하나라도 실패하면 모든 연산의 결과가 취소되어 데이터베이스의 상태가 변경 전으로 되돌아가는 것을 의미합니다.  즉, 데이터베이스의 일관성을 유지하기 위해 '모두 반영되거나 전혀 반영되지 않아야 한다'는 조건을 만족해야 합니다.  마치 원자처럼 나눌 수 없는 하나의 작업 단위로 동작하는 것이죠.  다른 선택지들은 트랜잭션의 다른 특성을 나타냅니다. 내구성(Durability)은 트랜잭션이 성공적으로 완료된 후 데이터베이스에 영구적으로 저장되는 것을 의미하고, 공유(Share)는 여러 트랜잭션이 동시에 데이터베이스를 접근할 수 있음을, 일관성(Consistency)은 트랜잭션이 데이터베이스의 일관성을 유지하도록 하는 것을 의미합니다.  하지만 문제에서 설명하는 '모두 반영되거나 전혀 반영되지 않아야 한다'는 특징은 원자성을 가장 잘 나타냅니다.",73,127
752,8,52,분산 데이터베이스 목표 중 “데이터베이스의 분산된 물리적 환경에서 특정 지역의 컴퓨터 시스템이나 네트워크에 장애가 발생해도 데이터 무결성이 보장된다”는 것과 관계있는 것은?,,장애 투명성,병행 투명성,위치 투명성,중복 투명성,1,"문제에서 제시된 분산 데이터베이스의 목표는 특정 지역의 시스템 장애에도 데이터 무결성을 유지하는 것입니다.  이는 시스템의 장애가 다른 지역에 있는 데이터베이스에 영향을 미치지 않도록 하는 것을 의미합니다.  즉, 장애가 발생한 사실 자체를 다른 시스템이 인지하지 못하도록 투명하게 처리하는 것을 목표로 합니다.  이러한 특성을 가장 잘 나타내는 용어가 바로 '장애 투명성'입니다.  병행 투명성은 여러 사용자가 동시에 데이터베이스를 접근해도 문제없이 동작하는 것을 의미하고, 위치 투명성은 데이터가 어디에 저장되어 있는지 사용자가 알 필요 없이 접근할 수 있는 것을 의미하며, 중복 투명성은 데이터가 여러 곳에 중복 저장되어 있어도 사용자에게 하나의 데이터베이스처럼 보이는 것을 의미합니다.  따라서, 특정 지역의 장애에도 데이터 무결성을 보장하는 목표와 가장 직접적으로 관련된 것은 장애 투명성입니다.",71,131
753,8,53,"데이터베이스 시스템에서 삽입, 갱신, 삭제 등의 이벤트가 발생할 때마다 관련 작업이 자동으로 수행되는 절차형 SQL은?",,트리거(trigger),무결성(integrity),잠금(lock),복귀(rollback),1,"데이터베이스 시스템에서 삽입, 갱신, 삭제와 같은 이벤트가 발생했을 때, 자동으로 특정 작업을 수행하도록 미리 정의해 놓은 것이 트리거(trigger)입니다.  예를 들어, 특정 테이블에 새로운 데이터가 삽입될 때마다 자동으로 다른 테이블에 관련 정보를 추가하거나, 데이터가 변경될 때마다 로그 테이블에 변경 내역을 기록하는 등의 작업을 트리거를 통해 자동화할 수 있습니다.  절차형 SQL이라고 하는 것은 트리거 내부에 작성되는 SQL 코드의 형태를 의미하며, 이벤트 발생 시 실행될 일련의 SQL 명령어들을 순차적으로 처리하는 방식입니다.  따라서 데이터베이스의 무결성을 유지하거나, 데이터 변경에 대한 감사 추적을 자동화하는 등 다양한 용도로 활용됩니다.  잠금(lock)은 데이터의 동시 접근을 제어하는 기능이고, 복귀(rollback)는 트랜잭션 처리 중 오류 발생 시 이전 상태로 되돌리는 기능이므로 문제의 상황과는 맞지 않습니다.",82,125
754,8,54,참조 무결성을 유지하기 위하여 DROP문에서 부모 테이블의 항목 값을 삭제할 경우 자동적으로 자식 테이블의 해당 레코드를 삭제하기 위한 옵션은?,,CLUSTER,CASCADE,SET-NULL,RESTRICTED,2,"참조 무결성(Referential Integrity)이란 데이터베이스에서 부모 테이블과 자식 테이블 간의 관계를 일관성 있게 유지하는 것을 의미합니다.  부모 테이블의 특정 레코드가 삭제될 때, 그 레코드를 참조하는 자식 테이블의 레코드를 어떻게 처리할 것인지에 대한 옵션을 설정하는 것이죠.  문제에서 제시된 옵션들을 살펴보면, CASCADE 옵션은 부모 테이블의 레코드가 삭제될 때, 해당 레코드를 참조하는 자식 테이블의 레코드도 자동으로 삭제하는 기능을 합니다.  즉, 부모 테이블의 데이터 삭제가 자식 테이블까지 연쇄적으로(CASCADE) 영향을 미치는 것입니다.  다른 옵션들은 각각 다른 동작을 합니다. RESTRICTED는 부모 테이블의 레코드를 삭제할 수 없도록 제한하고, SET NULL은 자식 테이블의 해당 레코드의 부모 키 값을 NULL로 변경합니다. CLUSTER는 데이터베이스의 물리적 저장 방식과 관련된 옵션으로, 이 문제와는 직접적인 관련이 없습니다. 따라서 부모 테이블의 항목 값 삭제 시 자식 테이블의 해당 레코드를 자동 삭제하는 옵션은 CASCADE입니다.",77,127
755,8,55,DML에 해당하는 SQL 명령으로만 나열된 것은?,,"DELETE, UPDATE, CREATE, ALTER","INSERT, DELETE, UPDATE, DROP","SELECT, INSERT, DELETE, UPDATE","SELECT, INSERT, DELETE, ALTER",3,"SQL(Structured Query Language)은 데이터베이스를 관리하고 조작하는 데 사용되는 표준 언어입니다.  SQL 명령어는 크게 데이터 정의어(DDL), 데이터 조작어(DML), 데이터 제어어(DCL)로 나뉩니다.  DDL은 데이터베이스의 구조를 정의하는 명령어(CREATE, ALTER, DROP 등)이고, DML은 데이터베이스의 데이터를 조작하는 명령어(SELECT, INSERT, UPDATE, DELETE 등)이며, DCL은 데이터베이스에 대한 접근 권한을 제어하는 명령어(GRANT, REVOKE 등)입니다. 문제에서 제시된 보기들은 모두 DML 명령어들 중 일부입니다.  1번과 4번은 DDL 명령어인 CREATE와 ALTER를 포함하고 있고, 2번은 DDL 명령어인 DROP을 포함하고 있으므로 정답이 될 수 없습니다.  3번은 SELECT(데이터 조회), INSERT(데이터 삽입), DELETE(데이터 삭제), UPDATE(데이터 수정) 명령어로만 구성되어 있으므로, 모두 DML에 해당하는 명령어입니다. 따라서 정답은 3번입니다.",81,126
756,8,56,데이터 제어언어(DCL)의 기능으로 옳지 않은 것은?,,데이터 보안,"논리적, 물리적 데이터 구조 정의",무결성 유지,병행수행 제어,2,"데이터 제어 언어(DCL)은 데이터베이스 시스템에서 데이터에 대한 접근 권한을 관리하고 제어하는 데 사용되는 명령어들의 집합입니다.  데이터 보안(1), 무결성 유지(3), 병행수행 제어(4)는 모두 DCL의 중요한 기능입니다. 데이터 보안은 데이터에 대한 접근을 제한하여 무단 접근을 방지하고, 무결성 유지는 데이터의 정확성과 일관성을 유지하며, 병행수행 제어는 여러 사용자가 동시에 데이터베이스를 접근할 때 데이터의 일관성을 유지하기 위해 필요한 기능입니다.  반면, 논리적, 물리적 데이터 구조 정의(2)는 데이터 정의 언어(DDL)의 기능입니다. DDL은 데이터베이스의 테이블, 뷰, 인덱스 등의 구조를 정의하는 데 사용됩니다. 따라서 DCL의 기능으로 옳지 않은 것은 논리적, 물리적 데이터 구조 정의입니다.  쉽게 말해, DCL은 ""누가 데이터에 접근할 수 있는가?""를 관리하는 것이고, DDL은 ""데이터베이스가 어떻게 구성되어 있는가?""를 정의하는 것입니다.",67,126
757,8,57,병행제어의 로킹(Locking) 단위에 대한 설명으로 옳지 않은 것은?,,"데이터베이스, 파일, 레코드 등은 로킹 단위가 될 수 있다.",로킹 단위가 작아지면 로킹 오버헤드가 감소한다.,로킹 단위가 작아지면 데이터베이스 공유도가 증가한다.,한꺼번에 로킹 할 수 있는 객체의 크기를 로킹 단위라고 한다.,2,"로킹(Locking)은 여러 사용자가 동시에 데이터베이스를 접근하여 데이터의 일관성을 유지하기 위해 사용하는 병행 제어 기법입니다.  특정 데이터에 대한 접근을 제어하기 위해,  데이터베이스, 파일, 레코드 등과 같이 특정 크기의 데이터 영역을 잠금(Lock)으로 설정하는데, 이 잠금의 단위를 로킹 단위라고 합니다.  문제에서 옳지 않은 것은 2번입니다. 로킹 단위가 작아지면, 잠가야 할 데이터 영역이 작아지므로 잠금(Lock)과 잠금 해제(Unlock) 작업이 더 자주 발생하게 됩니다. 이러한 빈번한 작업은 오히려 시스템의 오버헤드를 증가시키는 결과를 초래합니다.  즉, 로킹 단위가 작을수록 로킹 오버헤드는 증가합니다.  나머지 보기들은 로킹 단위의 개념을 정확하게 설명하고 있습니다. 1번은 로킹 단위가 될 수 있는 대상을, 3번은 로킹 단위가 작아졌을 때의 장점(데이터베이스 공유도 증가)을, 4번은 로킹 단위의 정의를 설명하고 있습니다. 따라서 2번이 옳지 않은 설명입니다.",77,131
758,8,58,E-R 모델의 표현 방법으로 옳지 않은 것은?,,개체타입: 사각형,관계타입: 마름모,속성: 오각형,연결: 선,3,"E-R 모델은 데이터베이스 설계에 사용되는 개체-관계 모델입니다.  개체(Entity)는 사물이나 개념을 나타내고, 관계(Relationship)는 개체들 간의 연관성을 표현합니다.  속성(Attribute)은 개체나 관계에 대한 특징을 나타내는 정보입니다.  E-R 다이어그램에서는 일반적으로 개체는 사각형, 관계는 마름모, 속성은 타원형(혹은 사각형 안에 속성을 나열)으로 표현합니다.  문제에서 속성을 오각형으로 표현하는 것은 E-R 모델의 표준 표현 방식과 일치하지 않으므로 옳지 않습니다. 따라서 정답은 3번입니다.",87,130
759,8,59,다음 설명의 ( )안에 들어갈 내용으로 적합한 것은?,https://www.cbtbank.kr/images/iz/iz20200606/iz20200606m59.gif,중복성,최소성,참조성,동일성,2,"후보키는 테이블(릴레이션) 내의 각 행(튜플)을 유일하게 식별하는 데 사용되는 속성(또는 속성들의 집합)입니다.  유일성이란, 후보키를 구성하는 속성값의 조합이 모든 행에서 중복되지 않아야 함을 의미합니다.  그리고 최소성이란, 후보키를 구성하는 속성 중 어떤 속성도 제거하면 유일성이 보장되지 않아야 함을 의미합니다.  즉, 후보키는 유일하게 행을 식별하는 최소한의 속성 집합이어야 합니다. 문제에서 ( ) 안에 들어갈 내용은 후보키가 만족해야 하는 두 번째 조건인 최소성을 의미합니다.  1번의 중복성은 후보키의 정의와 반대되는 개념이고, 3번의 참조성과 4번의 동일성은 후보키의 개념과 직접적인 관련이 없습니다. 따라서 정답은 2번 최소성입니다.",78,129
760,8,60,정규화 과정 중 1NF에서 2NF가 되기 위한 조건은?,,1NF를 만족하는 모든 도메인이 원자 값이어야 한다.,1NF를 만족하고 키가 아닌 모든 애트리뷰트들이 기본 키에 이행적으로 함수 종속되지 않아야 한다.,1NF를 만족하고 다치 종속이 제거되어야 한다.,1NF를 만족하고 키가 아닌 모든 속성이 기본키에 대하여 완전 함수적 종속 관계를 만족해야 한다.,4,"1NF(제1정규형)은 테이블의 각 칼럼(속성)이 원자값을 가져야 한다는 조건을 만족하는 정규화 단계입니다.  원자값이란 더 이상 나눌 수 없는 값을 의미합니다. 예를 들어, 주소 칼럼에 ""서울시 강남구 역삼동 123-45"" 와 같이 여러 값이 합쳐져 있으면 원자값이 아니고, ""서울시"", ""강남구"", ""역삼동"", ""123-45"" 와 같이 나누어야 원자값이 됩니다.",57,130
761,8,61,IPv6에 대한 설명으로 틀린 것은?,,128비트의 주소 공간을 제공한다.,인증 및 보안 기능을 포함하고 있다.,패킷 크기가 64Kbyte로 고정되어 있다.,IPv6 확장 헤더를 통해 네트워크 기능 확장이 용이하다.,3,"IPv6는 인터넷 프로토콜 버전 6으로, 기존 IPv4의 주소 부족 문제를 해결하기 위해 개발된 차세대 인터넷 프로토콜입니다.  IPv4가 32비트 주소를 사용하는 반면, IPv6는 128비트의 훨씬 넓은 주소 공간을 제공하여 엄청난 수의 장치에 고유한 IP 주소를 할당할 수 있습니다. 또한, 보안 기능을 강화하여 네트워크의 안전성을 높였습니다.  IPv6 확장 헤더는 다양한 네트워크 기능을 추가할 수 있도록 유연성을 제공합니다.  하지만 문제의 3번처럼 패킷 크기는 고정되어 있지 않고, IPv4와 마찬가지로 가변적입니다.  따라서 3번이 틀린 설명입니다.  쉽게 말해, IPv6는 더 많은 기기를 연결하고 더 안전하게 인터넷을 사용할 수 있도록 설계되었지만, 패킷 크기는 정해져 있지 않다는 점을 기억하면 됩니다.",80,145
762,8,62,C언어에서 비트 논리연산자에 해당하지 않는 것은?,,^,?,&,~,2,"C언어에서 비트 논리 연산자는 비트 단위로 연산을 수행하는 연산자입니다.  ^는 XOR(배타적 논리합), &는 AND(논리곱), ~는 NOT(논리 부정) 연산자입니다.  이 연산자들은 각 비트에 대해 논리 연산을 수행하여 결과를 반환합니다.  문제에서 제시된 2번의 '?'는 C언어의 비트 논리 연산자가 아니고, 조건 연산자(삼항 연산자)로 사용됩니다.  따라서 정답은 2번입니다.  쉽게 말해,  ^, &, ~는 컴퓨터가 숫자를 0과 1로 이루어진 비트로 처리할 때 각 비트를 개별적으로 비교하고 계산하는 연산자인데, ?는 그런 용도가 아니라는 것입니다.",69,141
763,8,63,TCP/IP 프로토콜 중 전송계층 프로토콜은?,,HTTP,SMTP,FTP,TCP,4,"TCP/IP 프로토콜은 인터넷에서 데이터를 주고받을 때 사용하는 통신 규칙의 집합입니다.  여러 계층으로 나뉘는데, 그 중 전송 계층은 데이터를 안전하고 효율적으로 전달하는 역할을 합니다.  HTTP, SMTP, FTP는 모두 응용 계층 프로토콜로,  웹 페이지 접근(HTTP), 이메일 전송(SMTP), 파일 전송(FTP)과 같은 특정 응용 서비스를 위한 규칙을 정의합니다.  반면 TCP는 전송 계층 프로토콜로,  데이터의 신뢰성 있는 전달을 보장하는 역할을 합니다.  즉,  데이터가 손실되거나 순서가 바뀌지 않도록 관리하고,  오류 발생 시 재전송을 요청하는 등의 기능을 수행합니다.  문제에서 묻는 것은 전송 계층 프로토콜이므로 정답은 TCP입니다.",71,145
764,8,64,시스템에서 모듈 사이의 결합도(Coupling)에 대한 설명으로 옳은 것은?,,한 모듈 내에 있는 처리요소들 사이의 기능적인 연관 정도를 나타낸다.,결합도가 높으면 시스템 구현 및 유지보수 작업이 쉽다.,모듈간의 결합도를 약하게 하면 모듈 독립성이 향상된다.,자료결합도는 내용결합도 보다 결합도가 높다.,3,"시스템에서 모듈이란, 특정 기능을 수행하는 독립적인 코드 단위라고 생각하면 됩니다.  결합도(Coupling)는 이러한 모듈들 간의 의존성 정도를 나타내는 척도입니다. 결합도가 높다는 것은 모듈들이 서로 긴밀하게 연결되어 있어, 한 모듈의 변경이 다른 모듈에 큰 영향을 미친다는 것을 의미합니다. 반대로 결합도가 낮으면 모듈들이 서로 독립적으로 동작하여, 한 모듈의 변경이 다른 모듈에 미치는 영향이 적습니다.  문제에서 옳은 것은 3번입니다. 모듈 간의 결합도를 약하게 하면, 각 모듈이 독립적으로 기능을 수행할 수 있게 되어, 시스템의 유지보수 및 변경이 훨씬 용이해집니다.  1번은 응집도(Cohesion)에 대한 설명이고, 2번은 결합도가 높으면 유지보수가 어렵다는 점에서 틀렸습니다. 4번은 자료 결합도가 내용 결합도보다 결합도가 낮다는 점에서 틀렸습니다.  결합도가 낮을수록 시스템의 유연성, 재사용성, 유지보수성이 향상됩니다.",69,106
765,8,65,은행가 알고리즘(Banker's Algorithm)은 교착상태의 해결 방법 중 어떤 기법에 해당하는가?,,Avoidance,Detection,Prevention,Recovery,1,"은행가 알고리즘(Banker's Algorithm)은 운영체제에서 자원 할당을 관리하여 교착 상태(Deadlock)를 사전에 예방하는 기법 중 **교착 상태 회피(Avoidance)** 기법에 속합니다.  교착 상태는 여러 프로세스가 서로 필요한 자원을 점유하고 다른 프로세스가 그 자원을 기다리는 상황으로, 시스템이 멈추는 심각한 문제를 야기합니다.  교착 상태 회피 기법은 자원 할당 요청이 들어올 때마다 시스템의 상태를 안전하게 유지할 수 있는지 확인하여 안전하다면 자원을 할당하고, 안전하지 않다면 요청을 거부하는 방식입니다. 은행가 알고리즘은 이러한 안전성 검사를 수행하는 대표적인 알고리즘입니다.  마치 은행에서 고객에게 돈을 빌려줄 때, 빌려준 돈을 모두 갚을 수 있는지 확인하는 것과 유사합니다.  즉, 미래에 자원 부족으로 인해 교착 상태가 발생할 가능성을 미리 예측하여 회피하는 전략입니다.  반면, 교착 상태 검출(Detection)은 교착 상태가 이미 발생했는지 확인하고 해결하는 방법이고, 교착 상태 예방(Prevention)은 교착 상태가 발생하지 않도록 시스템을 설계하는 방법이며, 교착 상태 복구(Recovery)는 교착 상태가 발생한 후 시스템을 복구하는 방법입니다.  은행가 알고리즘은 교착 상태를 미리 예방하는 것이 목표이므로, 회피 기법에 해당합니다.",73,121
766,8,66,UNIX의 쉘(Shell)에 관한 설명으로 옳지 않은 것은?,,명령어 해석기이다.,시스템과 사용자 간의 인터페이스를 담당한다.,여러 종류의 쉘이 있다.,"프로세스, 기억장치, 입출력 관리를 수행한다.",4,"UNIX 쉘은 사용자가 명령어를 입력하면 그 명령어를 해석하고 실행하는 프로그램입니다.  마치 번역가처럼 사용자의 명령어를 컴퓨터가 이해할 수 있는 언어로 바꿔주는 역할을 하죠.  따라서 1번과 2번 설명은 맞는 말입니다.  여러 종류의 쉘(bash, zsh, csh 등)이 존재하는 것도 사실이므로 3번도 맞습니다. 하지만 4번은 틀린 설명입니다. 프로세스, 기억장치, 입출력 관리 등은 운영체제(OS)의 커널(kernel)이 담당하는 역할입니다. 쉘은 사용자 명령어를 커널에 전달하는 역할만 할 뿐, 직접적으로 시스템 자원을 관리하지는 않습니다.  쉽게 말해 쉘은 운영체제의 커널과 사용자 사이의 중개자 역할을 하는 명령어 해석기이며, 시스템 자원 관리 자체는 하지 않습니다.",67,144
767,8,67,교착 상태 발생의 필요 충분 조건이 아닌 것은?,,상호 배제(mutual exclusion),점유와 대기(hold and wait),환형 대기(circular wait),선점(preemption),4,"교착 상태(Deadlock)란 두 개 이상의 프로세스가 서로 상대방이 갖고 있는 자원을 기다리면서 영원히 진행되지 못하는 상황을 말합니다.  교착 상태가 발생하기 위한 필요충분조건은 상호 배제, 점유와 대기, 환형 대기의 세 가지 조건이 모두 충족되어야 합니다.  문제에서 제시된 4번 선점은 교착 상태 발생 조건이 아닙니다. 선점이란 한 프로세스가 다른 프로세스가 사용 중인 자원을 강제로 빼앗는 것을 의미하는데,  만약 선점이 가능하다면,  한 프로세스가 다른 프로세스가 기다리고 있는 자원을 빼앗아 사용할 수 있으므로 교착 상태를 회피할 수 있습니다.  즉, 선점이 가능하면 환형 대기가 발생하지 않을 수 있기 때문에 교착 상태의 필요충분조건이 될 수 없습니다.  나머지 세 가지 조건은 교착 상태 발생에 필수적인 조건입니다. 상호 배제는 한 번에 하나의 프로세스만 자원을 사용할 수 있도록 제한하는 것이고, 점유와 대기는 프로세스가 적어도 하나의 자원을 점유하고 다른 자원을 기다리는 상황을 말하며, 환형 대기는 프로세스들이 원형으로 자원을 기다리는 상황을 의미합니다. 이 세 가지 조건이 동시에 만족될 때 교착 상태가 발생할 수 있습니다.",67,144
768,8,68,"OSI-7계층에서 종단간 신뢰성 있고 효율적인 데이터를 전송하기 위해 오류검출과 복구, 흐름 제어를 수행하는 계층은?",,전송 계층,세션 계층,표현 계층,응용 계층,1,"OSI 7계층은 데이터를 효율적으로 전송하기 위해 각 계층이 특정 역할을 담당하는 계층 구조입니다.  종단간 신뢰성 있는 데이터 전송을 위해서는 데이터의 오류를 검출하고 복구하며, 데이터 전송 속도를 조절하는 흐름 제어가 필수적입니다.  이러한 오류 검출 및 복구, 흐름 제어는 전송 계층(Transport Layer)에서 주로 수행됩니다.  전송 계층은 상위 계층인 응용 계층으로부터 데이터를 받아,  데이터를 분할하고 순서대로 재조립하며, 오류 검출 및 재전송, 흐름 제어 등을 통해 신뢰성 있는 데이터 전송을 보장합니다.  세션 계층은 통신 세션을 관리하고, 표현 계층은 데이터의 형식을 변환하며, 응용 계층은 사용자에게 직접적인 서비스를 제공하는 계층이므로,  종단간 신뢰성 있는 데이터 전송의 책임은 전송 계층에 있습니다. 따라서 정답은 1번 전송 계층입니다.",78,145
769,8,69,IPv6의 주소체계로 거리가 먼 것은?,,Unicast,Anycast,Broadcast,Multicast,3,"IPv6 주소 체계는 네트워크 상의 장치들을 식별하는 데 사용되는 주소 시스템입니다.  Unicast는 하나의 특정 장치에 메시지를 보내는 방식이고, Anycast는 여러 장치 중 하나에 메시지를 보내는 방식이며, Multicast는 여러 장치에 동시에 메시지를 보내는 방식입니다.  반면 Broadcast는 네트워크 상의 모든 장치에 메시지를 보내는 방식인데, IPv6에서는 효율성과 보안 문제로 인해 Broadcast 기능이 제한적으로 지원되거나 아예 지원되지 않습니다.  IPv6는 대규모 네트워크 환경에서 효율적인 주소 할당을 위해 설계되었으며, Broadcast처럼 모든 장치에 메시지를 전송하는 것은 네트워크 부하를 크게 증가시키기 때문입니다. 따라서 IPv6의 주소 체계와 거리가 먼 것은 Broadcast입니다.",74,145
770,8,70,TCP/IP 네트워크에서 IP 주소를 MAC 주소로 변환하는 프로토콜은?,,UDP,ARP,TCP,ICMP,2,"TCP/IP 네트워크에서 컴퓨터는 서로 통신하기 위해 IP 주소를 사용합니다.  IP 주소는 네트워크 상의 논리적인 주소이고, MAC 주소는 네트워크 인터페이스 카드(NIC)에 고유하게 할당된 물리적인 주소입니다.  컴퓨터가 다른 컴퓨터에게 데이터를 전송하려면, 목적지 컴퓨터의 IP 주소를 알고 있어야 하지만, 실제 데이터 전송은 MAC 주소를 사용하여 이루어집니다.  따라서 IP 주소를 MAC 주소로 변환하는 과정이 필요한데, 이를 담당하는 프로토콜이 바로 ARP(Address Resolution Protocol)입니다. ARP는 IP 주소를 알고 있을 때, 해당 IP 주소를 가지고 있는 컴퓨터의 MAC 주소를 찾아주는 역할을 합니다.  쉽게 말해,  IP 주소는 집 주소와 같고, MAC 주소는 집의 문짝에 붙어있는 고유 번호표와 같다고 생각하면 이해하기 쉽습니다.  우편 배달부(데이터)는 집 주소(IP 주소)를 보고 찾아가지만, 실제로 문을 두드릴 때는 문짝의 번호표(MAC 주소)를 확인합니다.  ARP는 바로 이 번호표를 찾아주는 역할을 하는 것입니다.",71,145
771,8,71,프로세스 상태의 종류가 아닌 것은?,,Ready,Running,Request,Exit,3,"이 문제는 운영체제에서 프로세스의 상태를 묻고 있습니다.  프로세스는 컴퓨터에서 실행 중인 프로그램을 의미하며, 여러 가지 상태를 가집니다.  'Ready' 상태는 프로세스가 실행 준비가 완료되었지만, CPU를 할당받지 못해 대기 중인 상태입니다. 'Running' 상태는 프로세스가 현재 CPU를 할당받아 실행 중인 상태입니다. 'Exit' 상태는 프로세스가 실행을 완료하고 종료된 상태입니다.  반면 'Request' 상태는 일반적인 프로세스 상태가 아닙니다. 프로세스는  '요청'을 하는 행위를 할 수 있지만,  'Request' 자체가 프로세스의 상태를 나타내는 용어는 아닙니다.  따라서 정답은 3번 Request입니다.  프로세스의 상태는 Ready, Running, Blocked(또는 Waiting), Exit 등으로 표현됩니다.",67,144
772,8,72,스레드(Thread)에 대한 설명으로 옳지 않은 것은?,,한 개의 프로세스는 여러 개의 스레드를 가질 수 없다.,커널 스레드의 경우 운영체제에 의해 스레드를 운용한다.,사용자 스레드의 경우 사용자가 만든 라이브러리를 사용하여 스레드를 운용한다.,"스레드를 사용함으로써 하드웨어, 운영체제의 성능과 응용 프로그램의 처리율을 향상시킬 수 있다.",1,"문제에서 제시된 네 가지 설명 중 옳지 않은 것을 찾는 문제입니다.  스레드(Thread)는 하나의 프로세스 내에서 동시에 실행되는 여러 개의 실행 흐름을 의미합니다.  쉽게 말해, 하나의 프로그램 안에서 여러 가지 일을 동시에 처리하는 작은 작업 단위라고 생각하면 됩니다.  예를 들어, 워드프로세서에서 문서를 작성하면서 동시에 다른 파일을 열어 참고하는 경우, 각 작업은 별도의 스레드로 처리될 수 있습니다.  따라서, 하나의 프로세스는 여러 개의 스레드를 가질 수 있습니다.  1번 선택지 ""한 개의 프로세스는 여러 개의 스레드를 가질 수 없다""는 이러한 스레드의 개념과 정반대되는 내용이므로 옳지 않은 설명입니다.  2번과 3번은 각각 커널 스레드와 사용자 스레드의 운용 방식을 설명하고 있으며, 4번은 스레드를 사용하는 이점을 설명하고 있습니다. 이들은 모두 스레드의 특징을 올바르게 설명하고 있습니다.",79,144
773,8,73,HRN(Highest Response-ratio Next) 스케줄링 방식에 대한 설명으로 옳지 않은 것은?,,대기 시간이 긴 프로세스의 경우 우선 순위가 높아진다.,SJF 기법을 보완하기 위한 방식이다.,긴 작업과 짧은 작업 간의 지나친 불평등을 해소할 수 있다.,우선 순위를 계산하여 그 수치가 가장 낮은 것부터 높은 순으로 우선 순위가 부여된다.,4,"HRN(Highest Response-ratio Next) 스케줄링은 프로세스의 우선순위를 계산하여 스케줄링하는 방식입니다.  우선순위는  (대기시간 + 서비스시간) / 서비스시간  으로 계산됩니다.  즉, 대기시간이 길거나 서비스시간이 짧은 프로세스일수록 우선순위가 높아집니다.  1번과 3번은 이러한 HRN 스케줄링의 특징을 잘 나타냅니다.  대기시간이 긴 프로세스는 우선순위가 높아져 먼저 처리되고,  긴 작업과 짧은 작업 간의 불균형을 완화하는 효과도 있습니다.  2번 또한 맞는 설명입니다. HRN은 SJF(Shortest Job First) 스케줄링의 단점인 '기아 현상'(짧은 작업만 계속 처리되어 긴 작업이 무한정 대기하는 현상)을 해결하기 위해 고안된 방식입니다.  하지만 4번은 잘못된 설명입니다. HRN은 계산된 우선순위가 가장 높은 프로세스부터 먼저 처리합니다.  가장 낮은 것부터 처리하는 것이 아니죠. 따라서 4번이 옳지 않은 설명입니다.",70,144
774,8,74,IEEE 802.11 워킹 그룹의 무선 LAN 표준화 현황 중 QoS 강화를 위해 MAC 지원 가능을 채택한 것은?,,802.11a,802.11b,802.11g,802.11e,4,"IEEE 802.11 표준은 무선랜(WLAN) 통신을 위한 표준 규격입니다.  802.11a, b, g는 초기 무선랜 표준으로 데이터 전송 속도 향상에 초점을 맞추었습니다. 하지만,  데이터 전송의 우선순위를 정하거나(예: 화상회의 중 음성 데이터 우선 전송),  실시간 서비스의 품질을 보장하는 기능(QoS, Quality of Service)은 부족했습니다.  802.11e는 이러한 문제점을 해결하기 위해 등장한 표준으로,  MAC(Media Access Control) 계층에서 QoS 기능을 지원하여  실시간 애플리케이션의 성능을 향상시키는 데 중점을 두었습니다.  따라서,  문제에서 제시된 QoS 강화를 위한 MAC 지원 채택은 802.11e에 해당합니다.  쉽게 말해,  802.11e는 데이터 전송의 '순서'와 '중요도'를 관리하여 중요한 데이터가 먼저 전달되도록 하는 기능을 추가한 업그레이드 버전이라고 생각하면 됩니다.",61,149
775,8,75,C언어에서 사용할 수 없는 변수명은?,,student2019,text-color,_korea,amount,2,"C언어에서 변수명을 지을 때는 몇 가지 규칙을 따라야 합니다.  문제에서 제시된 변수명들을 살펴보면,  `student2019`는 영문자와 숫자로만 이루어져 있으므로 C언어에서 허용되는 변수명입니다. `_korea` 역시 언더바(_)로 시작하는 변수명이지만, C언어에서는 허용됩니다. `amount`는 영문자로만 이루어진 변수명이므로 역시 허용됩니다. 하지만 `text-color`는 하이픈(-)을 포함하고 있습니다. C언어 변수명에는 영문자, 숫자, 언더바(_)만 사용할 수 있으며, 숫자로 시작할 수 없습니다. 따라서 하이픈을 포함한 `text-color`는 C언어에서 사용할 수 없는 변수명입니다.  즉, C언어 변수명은 영문자(대소문자 구분), 숫자, 언더바(_)만 사용 가능하며, 숫자로 시작할 수 없습니다.",70,141
776,8,76,스크립트 언어가 아닌 것은?,,PHP,Cobol,Basic,Python,2,"문제에서 제시된 프로그래밍 언어 중 PHP, Basic, Python은 스크립트 언어에 해당합니다. 스크립트 언어는 컴파일 과정 없이 인터프리터를 통해 바로 실행되는 언어로, 일반적으로 웹 개발이나 자동화 작업 등에 사용됩니다. 반면 COBOL은 컴파일을 거쳐 실행되는 절차적 프로그래밍 언어로, 주로 대규모 비즈니스 애플리케이션 개발에 사용되어 왔습니다. 따라서 스크립트 언어가 아닌 것은 COBOL입니다.  정보처리기사 시험에서는 다양한 프로그래밍 언어의 특징을 이해하고 있어야 하므로, 각 언어의 특징과 용도를 구분하는 연습이 필요합니다.",61,142
777,8,77,"다음의 페이지 참조 열(Page reference string)에 대해 페이지 교체 기법으로 선입선출 알고리즘을 사용할 경우 페이지 부재(Page Fault) 횟수는? (단, 할당된 페이지 프레임 수는 3이고, 처음에는 모든 프레임이 비어 있다.)",https://www.cbtbank.kr/images/iz/iz20200606/iz20200606m77.gif,13,14,15,20,2,"페이지 교체 기법 중 선입선출(FIFO) 알고리즘은 가장 먼저 들어온 페이지를 가장 먼저 교체하는 방식입니다.  문제에서 페이지 프레임은 3개이고, 참조 열은 7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0 입니다.  각 페이지 참조 시 프레임에 해당 페이지가 있는지 확인하고, 없다면 페이지 부재(Page Fault)가 발생합니다.  FIFO 알고리즘을 적용하여 페이지 부재 횟수를 계산해 보겠습니다.",56,144
778,8,78,C언어에서 배열 b[5]의 값은?,https://www.cbtbank.kr/images/iz/iz20200606/iz20200606m78.gif,0,1,2,3,1,"`static int b[9]={1,2,3};` 라는 C언어 코드에서 배열 b는 크기가 9인 정수형 배열입니다.  초기화 부분 `{1,2,3}` 에서는 배열의 처음 세 요소(b[0], b[1], b[2])에 각각 1, 2, 3의 값이 할당됩니다.  나머지 요소들(b[3]부터 b[8]까지)은 초기화되지 않으므로, C언어의 특성상 자동으로 0으로 초기화됩니다. 따라서 b[5]의 값은 0입니다. 문제의 정답 1은 잘못된 답변입니다.  문제에서 제시된 정답 1은 배열의 첫 번째 요소 b[0]의 값을 의미하는 것으로 보이나, 문제의 질문은 b[5]의 값을 묻고 있으므로 혼동을 야기합니다.  따라서 정답은 0입니다.  문제 자체에 오류가 있는 것으로 판단됩니다.",73,111
779,8,79,응집도가 가장 낮은 것은?,,기능적 응집도,시간적 응집도,절차적 응집도,우연적 응집도,4,"응집도는 모듈 내부 요소들의 관련성을 나타내는 척도입니다.  높은 응집도는 모듈 내부 요소들이 서로 밀접하게 관련되어 있어 모듈의 기능이 명확하고 이해하기 쉽다는 것을 의미합니다. 반대로 낮은 응집도는 모듈 내부 요소들이 서로 관련성이 적어 모듈의 기능이 모호하고 유지보수가 어렵다는 것을 의미합니다.  문제에서 제시된 응집도 종류 중 우연적 응집도는 모듈 내 요소들이 아무런 관련성 없이 우연히 모여 있는 경우를 말합니다.  따라서 기능적 응집도, 시간적 응집도, 절차적 응집도에 비해 우연적 응집도가 가장 낮은 응집도를 가집니다.  마치 서로 다른 종류의 과일을 한 바구니에 담아놓은 것과 같다고 생각하면 이해하기 쉽습니다.  각 과일(요소)은 서로 관련이 없고, 바구니(모듈)의 목적도 불분명합니다.",80,106
780,8,80,JAVA 언어에서 접근제한자가 아닌 것은?,,public,protected,package,private,3,"JAVA에서 접근 제한자는 클래스나 클래스 멤버(변수, 메서드)에 대한 접근 권한을 제어하는 역할을 합니다.  `public`, `protected`, `private`은 모두 JAVA에서 사용되는 접근 제한자입니다.  `public`은 모든 곳에서 접근 가능하고, `protected`는 같은 패키지 내부 또는 상속 관계에 있는 클래스에서 접근 가능하며, `private`는 같은 클래스 내부에서만 접근 가능합니다.  반면 `package`는 접근 제한자로 사용되지 않습니다.  `package`는 JAVA에서 패키지를 선언하는 키워드로, 클래스의 이름 공간을 관리하는 역할을 합니다. 따라서, 접근 제한자가 아닌 것은 `package`입니다.  쉽게 말해,  `package`는 집의 주소를 정하는 것이고,  `public`, `protected`, `private`는 집의 문을 누가 열 수 있는지 정하는 것입니다.",75,107
781,8,81,Rayleigh-Norden 곡선의 노력 분포도를 이용한 프로젝트 비용 산정기법은?,,Putnam 모형,델파이 모형,COCOMO 모형,기능점수 모형,1,"Rayleigh-Norden 곡선은 소프트웨어 개발 노력의 분포를 나타내는 곡선입니다.  초기에는 노력이 적게 투입되지만, 개발이 진행될수록 노력이 점차 증가하다가 테스트 단계에서 다시 감소하는 경향을 보입니다. Putnam 모형은 이러한 Rayleigh-Norden 곡선을 기반으로 프로젝트의 노력 분포를 예측하고, 이를 통해 프로젝트 비용을 산정하는 기법입니다.  즉,  Rayleigh-Norden 곡선의 노력 분포도를 이용하여 프로젝트의 전체 노력을 예측하고, 이를 단위 노력당 비용과 곱하여 프로젝트 비용을 추정하는 방식입니다.  다른 선택지들은 소프트웨어 비용 산정에 사용되는 다른 기법들로, Rayleigh-Norden 곡선을 직접적으로 사용하지 않습니다.  델파이 모형은 전문가들의 의견을 종합하여 비용을 추정하고, COCOMO 모형은 개발 규모와 여러 요소를 고려하여 비용을 추정하며, 기능점수 모형은 시스템의 기능 규모를 기반으로 비용을 추정합니다.",57,147
782,8,82,메모리상에서 프로그램의 복귀 주소와 변수사이에 특정 값을 저장해 두었다가 그 값이 변경되었을 경우 오버플로우 상태로 가정하여 프로그램 실행을 중단하는 기술은?,,모드체크,리커버리 통제,시스로그,스택가드,4,"프로그램이 실행될 때,  프로그램의 실행 순서와 복귀 위치 정보는 스택(Stack)이라는 메모리 영역에 저장됩니다.  스택은 후입선출(LIFO) 방식으로 동작하는데,  함수 호출 시 복귀 주소가 스택에 쌓이고, 함수 실행이 끝나면 스택에서 팝(pop)되어 원래 위치로 돌아갑니다.  변수들도 스택에 저장되는데,  만약 버퍼 오버플로우와 같은 공격으로 인해 스택에 저장된 특정 값(예: 복귀 주소)이 잘못 변경되면 프로그램은 예상치 못한 위치로 점프하게 되어  시스템이 크래시되거나 악의적인 코드가 실행될 수 있습니다.  스택가드는 이러한 위험을 방지하기 위해 복귀 주소와 변수 사이에 특정 값(가드 값)을 저장해두는 기술입니다.  만약 프로그램 실행 중 가드 값이 변경되었다면,  이는 스택 오버플로우가 발생했음을 의미하며, 프로그램 실행을 즉시 중단하여  시스템의 안정성을 확보하는 것입니다.  쉽게 말해,  경계선을 만들어 놓고 그 경계선이 침범당하면 위험을 감지하는 보안 기술이라고 생각하면 됩니다.",76,111
783,8,83,백도어 탐지 방법으로 틀린 것은?,,무결성 검사,닫힌 포트 확인,로그 분석,SetUID 파일 검사,2,"백도어는 시스템에 무단으로 접근할 수 있도록 만든 비밀 통로입니다.  백도어 탐지 방법을 묻는 문제에서 2번 '닫힌 포트 확인'이 틀린 이유는, 백도어가 항상 닫힌 포트를 통해 작동하는 것은 아니기 때문입니다. 백도어는 열린 포트나 심지어는 시스템의 정상적인 프로세스를 위장하여 작동할 수도 있습니다. 따라서 닫힌 포트만 확인하는 것은 백도어 탐지에 효과적이지 않습니다. 반면, 1번 무결성 검사는 시스템 파일의 변조 여부를 확인하여 백도어 설치 여부를 파악할 수 있고, 3번 로그 분석은 시스템 접근 기록을 분석하여 비정상적인 접근을 감지할 수 있으며, 4번 SetUID 파일 검사는 권한 상승을 이용하는 백도어를 탐지하는 데 도움이 됩니다.  결론적으로 백도어는 다양한 방법으로 숨겨질 수 있으므로, 여러 가지 탐지 방법을 종합적으로 사용하는 것이 중요합니다.",71,156
784,8,84,IP 또는 ICMP의 특성을 악용하여 특정 사이트에 집중적으로 데이터를 보내 네트워크 또는 시스템의 상태를 불능으로 만드는 공격 방법은?,,TearDrop,Smishing,Qshing,Smurfing,4,"Smurfing 공격은 ICMP(Internet Control Message Protocol)의 특성을 악용한 대표적인 DDoS(Distributed Denial of Service) 공격 방식입니다.  ICMP는 네트워크 장비의 상태를 확인하거나 오류를 알리는 데 사용되는 프로토콜인데, Smurfing 공격은 이 프로토콜의 브로드캐스트 기능을 악용합니다. 공격자는 특정 대상 사이트의 IP 주소를 포함한 ICMP 에코 요청(ping) 패킷을 네트워크의 브로드캐스트 주소로 보냅니다. 브로드캐스트 주소는 네트워크 상의 모든 장비에 패킷을 전달하도록 설계되어 있기 때문에,  수많은 장비가 대상 사이트로 ICMP 에코 응답 패킷을 보내게 되어 대상 사이트의 네트워크 대역폭을 초과하고 시스템을 마비시키는 것입니다. 마치 작은 돌멩이(Smurf)를 연못에 던져 큰 파장을 일으키는 것과 같다고 생각하면 이해하기 쉽습니다.  결과적으로 대상 사이트는 정상적인 서비스를 제공할 수 없게 되는 것입니다.  IP 주소를 악용하는 경우는 대상 IP 주소를 스푸핑(가짜 IP 주소를 사용)하여 추적을 어렵게 만드는 방식으로 사용될 수 있습니다.",67,155
785,8,85,CMM(Capability Maturity Model) 모델의 레벨로 옳지 않은 것은?,,최적단계,관리단계,정의단계,계획단계,4,"CMM(Capability Maturity Model)은 소프트웨어 개발 조직의 성숙도를 5단계로 평가하는 모델입니다.  각 단계는 소프트웨어 개발 프로세스의 안정성과 예측 가능성을 나타냅니다.  1단계는 초기 단계(Initial), 2단계는 관리 단계(Managed), 3단계는 정의 단계(Defined), 4단계는 관리 단계(Managed), 5단계는 최적 단계(Optimizing)입니다. 문제에서 제시된 4번 선택지 ""계획 단계""는 CMM의 공식적인 레벨 명칭이 아니므로 옳지 않은 것입니다. CMM은 계획 단계를 별도로 구분하지 않고, 각 레벨 내에서 계획 수립 및 관리를 다룹니다.  즉,  계획은 각 레벨의 활동 중 하나일 뿐, 레벨 자체를 나타내는 용어는 아닙니다.",52,147
786,8,86,웹과 컴퓨터 프로그램에서 용량이 적은 데이터를 교환하기 위해 데이터 객체를 속성·값의 쌍 형태로 표현하는 형식으로 자바스크립트(JavaScript)를 토대로 개발되어진 형식은?,,Python,XML,JSON,WEB SEVER,3,"웹이나 컴퓨터 프로그램에서 데이터를 주고받을 때, 용량이 큰 데이터를 전송하는 것은 비효율적입니다.  그래서 용량이 작은 데이터를 효율적으로 주고받기 위해 속성(key)과 값(value)의 쌍으로 데이터를 표현하는 방법이 필요한데,  JSON(JavaScript Object Notation)이 바로 그러한 형식입니다.  JSON은 자바스크립트 기반으로 만들어졌지만,  다양한 프로그래밍 언어에서 쉽게 사용할 수 있도록 설계되어  웹 서비스에서 데이터를 교환하는 데 널리 활용됩니다.  예를 들어, 웹 서버가 사용자에게 데이터를 보낼 때,  복잡한 XML 대신 간결한 JSON 형식으로 데이터를 전송하면 데이터 전송 속도가 빨라지고,  프로그램에서 데이터를 처리하기도 쉬워집니다.  문제에서 제시된 다른 선택지들은 JSON과는 다른 데이터 표현 방식 또는 관련 없는 개념입니다. Python은 프로그래밍 언어이고, XML은 데이터 표현 방식이지만 JSON보다 복잡하며, 웹 서버는 데이터를 제공하는 시스템의 일부입니다. 따라서 정답은 JSON입니다.",79,142
787,8,87,"크래커가 침입하여 백도어를 만들어 놓거나, 설정 파일을 변경했을 때 분석하는 도구는?",,trace,tripwire,udpdump,cron,2,"문제에서 제시된 상황은 크래커가 시스템에 침입하여 백도어를 생성하거나 설정 파일을 변경하는 등의 악의적인 행위를 했을 때 이를 감지하고 분석하는 도구를 묻고 있습니다.  trace는 시스템 호출이나 네트워크 패킷을 추적하는 도구이고, udpdump는 UDP 패킷을 캡처하는 도구이며, cron은 시스템에서 주기적으로 작업을 실행하는 스케줄러입니다. 이들은 시스템의 변화를 감지하는 데 직접적으로 사용되지 않습니다. 반면, tripwire는 시스템 파일의 무결성을 감시하는 도구입니다.  크래커가 파일을 변경하면 tripwire가 이를 감지하여 시스템 관리자에게 알려줍니다. 따라서 시스템의 무단 변경을 감지하는 데 가장 적합한 도구는 tripwire입니다.  정보처리기사 시험에서는 시스템 보안과 관련된 지식을 묻는 문제가 자주 출제되며, tripwire와 같은 시스템 무결성 감시 도구에 대한 이해가 필수적입니다.",73,156
788,8,88,소프트웨어 개발 프레임워크를 적용할 경우 기대효과로 거리가 먼 것은?,,품질보증,시스템 복잡도 증가,개발 용이성,변경 용이성,2,"소프트웨어 개발 프레임워크는 소프트웨어 개발 과정을 체계화하고 효율성을 높이기 위한 일종의 틀이나 규칙입니다.  프레임워크를 사용하면 반복적인 작업을 줄이고, 코드의 재사용성을 높이며, 개발팀 간의 협업을 원활하게 할 수 있습니다.  따라서 품질 보증 향상, 개발 용이성 증대, 변경 용이성 개선 등의 효과를 기대할 수 있습니다. 하지만 프레임워크 자체가 복잡할 수 있고,  프레임워크에 맞춰 개발해야 하므로 오히려 시스템의 복잡도가 증가할 수 있다는 것은 거리가 먼 주장입니다.  프레임워크는 개발을 돕는 도구이지, 시스템 자체의 복잡성을 증가시키는 원인이 되지는 않습니다.  시스템의 복잡성은 시스템의 기능과 구조에 따라 결정되며, 프레임워크는 이를 관리하고 효율적으로 구축하는 데 도움을 줄 뿐입니다.",87,148
789,8,89,"COCOMO model 중 기관 내부에서 개발된 중소 규모의 소프트웨어로 일괄 자료 처리나 과학기술 계산용, 비즈니스 자료 처리용으로 5만 라인 이하의 소프트웨어를 개발하는 유형은?",,embeded,organic,semi-detached,semi-embeded,2,"COCOMO(Constructive Cost Model) 모델은 소프트웨어 개발에 필요한 비용과 기간을 예측하는 모델입니다.  여러 유형으로 나뉘는데, 문제에서 제시된 조건(기관 내부 개발, 중소 규모, 5만 라인 이하, 일괄 자료 처리나 과학기술 계산, 비즈니스 자료 처리)에 가장 적합한 유형은 'Organic'입니다.  Organic 유형은 소규모 팀이 개발하며, 개발 과정이 상대적으로 단순하고 잘 정의되어 있어 예측이 용이한 프로젝트에 적용됩니다.  문제에서 제시된 소프트웨어 규모(5만 라인 이하)와 개발 환경(기관 내부)은 Organic 유형의 특징과 일치합니다.  반면, Embedded, Semi-detached, Semi-embedded 유형은  실시간 시스템, 복잡한 시스템, 하드웨어와의 상호작용이 많은 시스템 등에 적용되는데, 문제의 조건과는 부합하지 않습니다. 따라서 정답은 2번 Organic입니다.",71,147
790,8,90,여러 개의 독립된 통신장치가 UWB(Ultra Wideband)기술 또는 블루투스 기술을 사용하여 통신망을 형성하는 무선 네트워크 기술은?,,PICONET,SCRUM,NFC,WI-SUN,1,"여러 개의 독립된 통신 장치가 UWB(Ultra Wideband) 기술 또는 블루투스 기술을 사용하여 통신망을 형성하는 무선 네트워크 기술을 묻는 문제입니다.  정답은 PICONET입니다.  PICONET은 블루투스 기술에서 사용되는 네트워크 토폴로지의 한 종류로, 하나의 마스터 장치와 여러 개의 슬레이브 장치로 구성됩니다. 마스터 장치는 슬레이브 장치들과 통신을 제어하며, 슬레이브 장치들은 마스터 장치와만 직접 통신할 수 있습니다.  UWB 기술 또한 근거리 무선 통신 기술로, PICONET과 유사한 방식으로 여러 장치 간의 통신을 지원할 수 있습니다.  반면, SCRUM은 소프트웨어 개발 프로세스, NFC는 근거리 무선 통신 기술이지만 PICONET처럼 네트워크를 형성하는 방식은 아니며, WI-SUN은 저전력 광대역 무선 통신 기술로,  문제에서 제시된 조건과는 다릅니다. 따라서 여러 개의 독립된 장치가 UWB 또는 블루투스를 이용해 네트워크를 구성하는 기술은 PICONET이 가장 적절한 답입니다.",55,149
791,8,91,프로토타입을 지속적으로 발전시켜 최종 소프트웨어 개발까지 이르는 개발방법으로 위험관리가 중심인 소프트웨어 생명주기 모형은?,,나선형 모형,델파이 모형,폭포수 모형,기능점수 모형,1,"이 문제는 소프트웨어 개발 방법론 중 프로토타입을 지속적으로 발전시켜 최종 소프트웨어 개발까지 이르는, 위험 관리에 중점을 둔 모형을 묻고 있습니다.  폭포수 모형은 단계별로 순차적으로 진행하는 방식이므로 프로토타입 개념과는 거리가 멀고, 델파이 모형은 전문가 의견을 종합하여 예측하는 기법이므로 소프트웨어 개발 방법론과는 다릅니다. 기능점수 모형은 소프트웨어의 규모를 측정하는 기법입니다.  나선형 모형은 각 단계마다 프로토타입을 만들어 위험을 평가하고 다음 단계로 진행하는 반복적인 개발 방식으로, 위험 관리에 초점을 맞추고 있습니다.  따라서 프로토타입을 지속적으로 발전시켜 최종 소프트웨어 개발까지 이르는 개발 방법으로 위험 관리가 중심인 소프트웨어 생명주기 모형은 나선형 모형입니다.  정보처리기사 공식 교재에서는 나선형 모형의 특징으로 반복적인 개발 과정, 위험 관리의 중요성, 프로토타입 기반 개발 등을 설명하고 있을 것입니다.",74,147
792,8,92,다음이 설명하는 용어로 옳은 것은?,https://www.cbtbank.kr/images/iz/iz20200606/iz20200606m92.gif,하둡(Hadoop),비컨(Beacon),포스퀘어(Foursquare),맴리스터(Memristor),1,"문제에서 제시된 설명은 오픈소스 기반의 분산 컴퓨팅 플랫폼으로, 일반 PC들을 활용하여 대용량 스토리지를 구축하고 빅데이터를 효율적으로 처리하는 시스템을 묘사하고 있습니다. 이러한 특징은 바로 하둡(Hadoop)의 핵심 기능을 정확하게 나타냅니다. 하둡은 수많은 컴퓨터들을 하나의 거대한 시스템처럼 연결하여 데이터를 저장하고 처리하는 분산 처리 시스템입니다.  비컨, 포스퀘어, 맴리스터는 각각 근거리 통신 기술, 위치 기반 서비스, 새로운 종류의 메모리 기술을 의미하며 문제의 설명과는 관련이 없습니다. 따라서 정답은 1번 하둡(Hadoop)입니다.",76,131
793,8,93,소인수 분해 문제를 이용한 공개키 암호화 기법에 널리 사용되는 암호 알고리즘 기법은?,,RSA,ECC,PKI,PEM,1,"소인수분해 문제를 이용한 공개키 암호화 기법은 매우 중요한 개념입니다.  간단히 설명하면, 아주 큰 수를 소수(1과 자기 자신만으로 나누어지는 수) 두 개의 곱으로 분해하는 것은 쉽지 않지만, 그 두 소수를 알고 있다면 곱셈은 쉽다는 점을 이용한 것입니다.  RSA 알고리즘은 이러한 소인수분해의 어려움을 기반으로 공개키와 개인키를 생성합니다. 공개키는 누구에게나 공개되어 암호화에 사용되고, 개인키는 소수 두 개를 알고 있는 사람만 가지고 있어 복호화에 사용됩니다.  따라서, 아무나 암호화할 수 있지만, 개인키를 가지고 있는 사람만이 복호화하여 원래 메시지를 읽을 수 있습니다.  문제에서 제시된 다른 옵션들은 암호화 기법과 관련은 있지만, 소인수분해를 직접적으로 이용하는 암호 알고리즘은 RSA입니다. ECC는 타원곡선 암호기술이고, PKI는 공개키 기반구조, PEM은 Privacy Enhanced Mail을 의미하며, 모두 RSA와는 다른 암호화 관련 기술입니다.",79,154
794,8,94,"LOC 기법에 의하여 예측된 총 라인수가 50000라인, 프로그래머의 월 평균 생산성이 200라인, 개발에 참여할 프로그래머가 10인 일 때, 개발 소요 기간은?",,25개월,50개월,200개월,2000개월,1,"이 문제는 소프트웨어 개발에 필요한 시간을 계산하는 문제입니다.  LOC 기법은 Lines Of Code의 약자로, 소프트웨어의 크기를 코드 라인 수로 측정하는 방법입니다. 문제에서 예측된 총 라인 수는 50,000라인이고, 한 프로그래머의 월 평균 생산성은 200라인입니다.  10명의 프로그래머가 함께 개발한다면, 한 달에 생산할 수 있는 라인 수는 200라인/명 * 10명 = 2000라인이 됩니다. 따라서 총 50,000라인을 개발하는 데 필요한 기간은 50,000라인 / 2,000라인/월 = 25개월이 됩니다.  따라서 정답은 1번입니다.",86,147
795,8,95,최대 홉수를 15로 제한한 라우팅 프로토콜은?,,RIP,OSPF,Static,EIGRP,1,"라우팅 프로토콜은 네트워크 내에서 데이터 패킷이 목적지까지 최적의 경로를 찾아 이동하도록 하는 프로토콜입니다.  RIP(Routing Information Protocol)는 거리 벡터 라우팅 프로토콜의 한 종류로, 각 라우터는 이웃 라우터로부터 목적지까지의 거리(홉 수) 정보를 받아 최단 경로를 계산합니다.  RIP의 특징 중 하나는 최대 홉 수를 15로 제한한다는 점입니다.  홉 수가 15를 초과하는 경우, 목적지까지 도달할 수 없다고 판단합니다.  따라서 최대 홉수를 15로 제한한 라우팅 프로토콜은 RIP입니다. OSPF(Open Shortest Path First)는 링크 상태 라우팅 프로토콜로, 네트워크 전체의 토폴로지를 파악하여 최단 경로를 계산하며, 홉 수 제한이 없습니다. Static 라우팅은 관리자가 수동으로 경로를 설정하는 방식이며, EIGRP(Enhanced Interior Gateway Routing Protocol)는 Cisco 사의 고급 라우팅 프로토콜로, 역시 홉 수 제한이 없습니다.  문제에서 최대 홉 수를 15로 제한한다는 조건이 주어졌으므로, 정답은 RIP입니다.",72,149
796,8,96,"컴퓨터 사용자의 키보드 움직임을 탐지해 ID, 패스워드 등 개인의 중요한 정보를 몰래 빼가는 해킹 공격은?",,Key Logger Attack,Worm,Rollback,Zombie Worm,1,"키로거 공격(Key Logger Attack)은 사용자의 키보드 입력을 몰래 기록하는 악성 프로그램을 이용한 해킹 기법입니다.  사용자가 키보드를 통해 입력하는 모든 정보, 예를 들어 ID, 비밀번호, 신용카드 번호, 주소 등 개인 정보가 키로거에 의해 감지되어 해커에게 전송됩니다.  키로거는 사용자의 컴퓨터에 설치되거나, 악성 웹사이트를 통해 실행될 수 있으며,  눈에 보이지 않게 작동하여 사용자는 자신의 정보가 탈취당하고 있는 사실을 인지하지 못하는 경우가 많습니다.  따라서 키보드 입력을 통해 중요한 정보를 입력할 때는 키로거 감염 여부를 주의 깊게 확인하고 안전한 환경에서 작업하는 것이 중요합니다.  정보처리기사 시험에서는 이러한 해킹 기법에 대한 이해를 묻는 문제가 자주 출제됩니다.",87,156
797,8,97,테일러링(Tailoring) 개발 방법론의 내부 기준에 해당하지 않는 것은?,,납기/비용,기술환경,구성원 능력,국제표준 품질기준,4,"테일러링(Tailoring) 개발 방법론은 표준적인 소프트웨어 개발 방법론을 특정 프로젝트의 상황에 맞게 조정하는 것을 의미합니다.  프로젝트의 성공적인 수행을 위해서는 프로젝트의 특성을 고려하여 방법론을 조정해야 하는데, 이때 고려하는 내부 기준에는 프로젝트의 납기, 비용, 기술 환경, 구성원의 능력 등이 포함됩니다.  하지만 국제표준 품질기준은 프로젝트의 특성보다는 외부에서 정의된 객관적인 기준이므로, 테일러링의 내부 기준으로 보기 어렵습니다.  즉, 테일러링은 프로젝트의 고유한 상황에 맞춰 방법론을 조정하는 것이므로,  외부의 객관적인 기준인 국제표준 품질기준은  프로젝트의 상황에 맞춰 조정할 대상이 아니기 때문입니다. 따라서 국제표준 품질기준은 테일러링 개발 방법론의 내부 기준에 해당하지 않습니다.",60,148
798,8,98,폭포수 모형의 특징으로 거리가 먼 것은,,개발 중 발생한 요구사항을 쉽게 반영할 수 있다.,순차적인 접근방법을 이용한다.,단계적 정의와 산출물이 명확하다.,모형의 적용 경험과 성공사례가 많다.,1,"폭포수 모형은 소프트웨어 개발 과정을 여러 단계로 나누어 순차적으로 진행하는 방법입니다.  각 단계는 명확하게 정의되고, 이전 단계가 완료되어야만 다음 단계로 진행할 수 있습니다.  따라서 단계적 정의와 산출물이 명확하고,  오랜 기간 사용되어 많은 적용 경험과 성공사례가 존재합니다. 하지만 개발 중에 요구사항이 변경되면 이전 단계로 돌아가 수정해야 하므로,  요구사항 변경에 유연하게 대처하기 어렵습니다.  문제에서 1번은 개발 중 발생한 요구사항을 쉽게 반영할 수 있다고 했는데, 이는 폭포수 모형의 특징과는 거리가 멉니다. 폭포수 모형은 한번 진행된 단계를 되돌리기 어렵기 때문입니다.  따라서 정답은 1번입니다.",84,147
799,8,99,다음 설명의 정보보안 침해 공격 관련 용어는?,https://www.cbtbank.kr/images/iz/iz20200606/iz20200606m99.gif,Smishing,C-brain,Trojan Horse,Ransomware,4,"문제에서 설명하는 공격은 인터넷 사용자의 컴퓨터에 침입하여 중요한 파일들을 암호화하고, 암호를 풀어주는 대가로 돈을 요구하는 악성 프로그램의 공격입니다.  이러한 공격 방식을 '랜섬웨어(Ransomware)'라고 합니다.  랜섬웨어는 사용자의 파일을 인질로 잡고(ransom:몸값) 금전을 요구하는 특징을 가지고 있습니다.  Smishing은 문자 메시지를 이용한 피싱, C-brain은 특정 용어가 아니며, Trojan Horse는 트로이 목마 바이러스로 랜섬웨어와는 공격 방식이 다릅니다. 따라서 정답은 랜섬웨어를 의미하는 4번입니다.",83,156
800,8,100,시스템 내의 정보는 오직 인가된 사용자만 수정할 수 있는 보안 요소는?,,기밀성,부인방지,가용성,무결성,4,"시스템 내의 정보를 오직 인가된 사용자만 수정할 수 있도록 하는 보안 요소는 무결성입니다.  무결성은 데이터의 정확성, 완전성, 일관성을 유지하는 것을 의미합니다.  인가되지 않은 사용자가 데이터를 변경하거나 삭제하는 것을 막아 데이터의 신뢰성을 보장하는 것이죠.  예를 들어, 은행 계좌 정보를 생각해보세요.  인가되지 않은 접근으로 인해 잔액이 변경되면 안 되겠죠? 이처럼 데이터의 정확성과 신뢰성을 유지하는 것이 무결성의 핵심입니다.  반면 기밀성은 정보를 보호하여  허가받지 않은 사람이 접근하지 못하도록 하는 것이고, 가용성은 필요한 사람이 언제든지 정보에 접근할 수 있도록 하는 것을, 부인방지는 특정 행위를 한 사람이 그 사실을 부인하지 못하도록 하는 것을 의미합니다.  문제에서 요구하는 것은 인가되지 않은 수정을 막는 것이므로 무결성이 가장 적절한 답입니다.",45,153
